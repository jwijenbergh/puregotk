// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type FlapClass struct {
	ParentClass uintptr
}

func (x *FlapClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Describes the possible folding behavior of a [class@Flap] widget.
type FlapFoldPolicy int

const (

	// Disable folding, the flap cannot reach narrow
	//   sizes.
	FlapFoldPolicyNeverValue FlapFoldPolicy = 0
	// Keep the flap always folded.
	FlapFoldPolicyAlwaysValue FlapFoldPolicy = 1
	// Fold and unfold the flap based on available
	//   space.
	FlapFoldPolicyAutoValue FlapFoldPolicy = 2
)

// Describes transitions types of a [class@Flap] widget.
//
// It determines the type of animation when transitioning between children in a
// [class@Flap] widget, as well as which areas can be swiped via
// [property@Flap:swipe-to-open] and [property@Flap:swipe-to-close].
//
// New values may be added to this enum over time.
type FlapTransitionType int

const (

	// The flap slides over the content, which is
	//   dimmed. When folded, only the flap can be swiped.
	FlapTransitionTypeOverValue FlapTransitionType = 0
	// The content slides over the flap. Only the
	//   content can be swiped.
	FlapTransitionTypeUnderValue FlapTransitionType = 1
	// The flap slides offscreen when hidden,
	//   neither the flap nor content overlap each other. Both widgets can be
	//   swiped.
	FlapTransitionTypeSlideValue FlapTransitionType = 2
)

// An adaptive container acting like a box or an overlay.
//
// &lt;picture&gt;
//
//	&lt;source srcset="flap-wide-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="flap-wide.png" alt="flap-wide"&gt;
//
// &lt;/picture&gt;
// &lt;picture&gt;
//
//	&lt;source srcset="flap-narrow-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="flap-narrow.png" alt="flap-narrow"&gt;
//
// &lt;/picture&gt;
//
// The `AdwFlap` widget can display its children like a [class@Gtk.Box] does or
// like a [class@Gtk.Overlay] does, according to the
// [property@Flap:fold-policy] value.
//
// `AdwFlap` has at most three children: [property@Flap:content],
// [property@Flap:flap] and [property@Flap:separator]. Content is the primary
// child, flap is displayed next to it when unfolded, or overlays it when
// folded. Flap can be shown or hidden by changing the
// [property@Flap:reveal-flap] value, as well as via swipe gestures if
// [property@Flap:swipe-to-open] and/or [property@Flap:swipe-to-close] are set
// to `TRUE`.
//
// Optionally, a separator can be provided, which would be displayed between
// the content and the flap when there's no shadow to separate them, depending
// on the transition type.
//
// [property@Flap:flap] is transparent by default; add the
// [`.background`](style-classes.html#background) style class to it if this is
// unwanted.
//
// If [property@Flap:modal] is set to `TRUE`, content becomes completely
// inaccessible when the flap is revealed while folded.
//
// The position of the flap and separator children relative to the content is
// determined by orientation, as well as the [property@Flap:flap-position]
// value.
//
// Folding the flap will automatically hide the flap widget, and unfolding it
// will automatically reveal it. If this behavior is not desired, the
// [property@Flap:locked] property can be used to override it.
//
// Common use cases include sidebars, header bars that need to be able to
// overlap the window content (for example, in fullscreen mode) and bottom
// sheets.
//
// ## AdwFlap as GtkBuildable
//
// The `AdwFlap` implementation of the [iface@Gtk.Buildable] interface supports
// setting the flap child by specifying “flap” as the “type” attribute of a
// `&lt;child&gt;` element, and separator by specifying “separator”. Specifying
// “content” child type or omitting it results in setting the content child.
//
// ## CSS nodes
//
// `AdwFlap` has a single CSS node with name `flap`. The node will get the style
// classes `.folded` when it is folded, and `.unfolded` when it's not.
type Flap struct {
	gtk.Widget
}

func FlapNewFromInternalPtr(ptr uintptr) *Flap {
	cls := &Flap{}
	cls.Ptr = ptr
	return cls
}

var xNewFlap func() uintptr

// Creates a new `AdwFlap`.
func NewFlap() *Flap {
	var cls *Flap

	cret := xNewFlap()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Flap{}
	cls.Ptr = cret
	return cls
}

var xFlapGetContent func(uintptr) uintptr

// Gets the content widget for @self.
func (x *Flap) GetContent() *gtk.Widget {
	var cls *gtk.Widget

	cret := xFlapGetContent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xFlapGetFlap func(uintptr) uintptr

// Gets the flap widget for @self.
func (x *Flap) GetFlap() *gtk.Widget {
	var cls *gtk.Widget

	cret := xFlapGetFlap(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xFlapGetFlapPosition func(uintptr) gtk.PackType

// Gets the flap position for @self.
func (x *Flap) GetFlapPosition() gtk.PackType {

	cret := xFlapGetFlapPosition(x.GoPointer())
	return cret
}

var xFlapGetFoldDuration func(uintptr) uint

// Gets the fold transition animation duration for @self, in milliseconds.
func (x *Flap) GetFoldDuration() uint {

	cret := xFlapGetFoldDuration(x.GoPointer())
	return cret
}

var xFlapGetFoldPolicy func(uintptr) FlapFoldPolicy

// Gets the fold policy for @self.
func (x *Flap) GetFoldPolicy() FlapFoldPolicy {

	cret := xFlapGetFoldPolicy(x.GoPointer())
	return cret
}

var xFlapGetFoldThresholdPolicy func(uintptr) FoldThresholdPolicy

// Gets the fold threshold policy for @self.
func (x *Flap) GetFoldThresholdPolicy() FoldThresholdPolicy {

	cret := xFlapGetFoldThresholdPolicy(x.GoPointer())
	return cret
}

var xFlapGetFolded func(uintptr) bool

// Gets whether @self is currently folded.
//
// See [property@Flap:fold-policy].
func (x *Flap) GetFolded() bool {

	cret := xFlapGetFolded(x.GoPointer())
	return cret
}

var xFlapGetLocked func(uintptr) bool

// Gets whether @self is locked.
func (x *Flap) GetLocked() bool {

	cret := xFlapGetLocked(x.GoPointer())
	return cret
}

var xFlapGetModal func(uintptr) bool

// Gets whether @self is modal.
func (x *Flap) GetModal() bool {

	cret := xFlapGetModal(x.GoPointer())
	return cret
}

var xFlapGetRevealFlap func(uintptr) bool

// Gets whether the flap widget is revealed for @self.
func (x *Flap) GetRevealFlap() bool {

	cret := xFlapGetRevealFlap(x.GoPointer())
	return cret
}

var xFlapGetRevealParams func(uintptr) *SpringParams

// Gets the reveal animation spring parameters for @self.
func (x *Flap) GetRevealParams() *SpringParams {

	cret := xFlapGetRevealParams(x.GoPointer())
	return cret
}

var xFlapGetRevealProgress func(uintptr) float64

// Gets the current reveal progress for @self.
//
// 0 means fully hidden, 1 means fully revealed.
//
// See [property@Flap:reveal-flap].
func (x *Flap) GetRevealProgress() float64 {

	cret := xFlapGetRevealProgress(x.GoPointer())
	return cret
}

var xFlapGetSeparator func(uintptr) uintptr

// Gets the separator widget for @self.
func (x *Flap) GetSeparator() *gtk.Widget {
	var cls *gtk.Widget

	cret := xFlapGetSeparator(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xFlapGetSwipeToClose func(uintptr) bool

// Gets whether @self can be closed with a swipe gesture.
func (x *Flap) GetSwipeToClose() bool {

	cret := xFlapGetSwipeToClose(x.GoPointer())
	return cret
}

var xFlapGetSwipeToOpen func(uintptr) bool

// Gets whether @self can be opened with a swipe gesture.
func (x *Flap) GetSwipeToOpen() bool {

	cret := xFlapGetSwipeToOpen(x.GoPointer())
	return cret
}

var xFlapGetTransitionType func(uintptr) FlapTransitionType

// Gets the type of animation used for reveal and fold transitions in @self.
func (x *Flap) GetTransitionType() FlapTransitionType {

	cret := xFlapGetTransitionType(x.GoPointer())
	return cret
}

var xFlapSetContent func(uintptr, uintptr)

// Sets the content widget for @self.
//
// It's always displayed when unfolded, and partially visible when folded.
func (x *Flap) SetContent(ContentVar *gtk.Widget) {

	xFlapSetContent(x.GoPointer(), ContentVar.GoPointer())

}

var xFlapSetFlap func(uintptr, uintptr)

// Sets the flap widget for @self.
//
// It's only visible when [property@Flap:reveal-progress] is greater than 0.
func (x *Flap) SetFlap(FlapVar *gtk.Widget) {

	xFlapSetFlap(x.GoPointer(), FlapVar.GoPointer())

}

var xFlapSetFlapPosition func(uintptr, gtk.PackType)

// Sets the flap position for @self.
//
// If it's set to `GTK_PACK_START`, the flap is displayed before the content,
// if `GTK_PACK_END`, it's displayed after the content.
func (x *Flap) SetFlapPosition(PositionVar gtk.PackType) {

	xFlapSetFlapPosition(x.GoPointer(), PositionVar)

}

var xFlapSetFoldDuration func(uintptr, uint)

// Sets the fold transition animation duration for @self, in milliseconds.
func (x *Flap) SetFoldDuration(DurationVar uint) {

	xFlapSetFoldDuration(x.GoPointer(), DurationVar)

}

var xFlapSetFoldPolicy func(uintptr, FlapFoldPolicy)

// Sets the fold policy for @self.
func (x *Flap) SetFoldPolicy(PolicyVar FlapFoldPolicy) {

	xFlapSetFoldPolicy(x.GoPointer(), PolicyVar)

}

var xFlapSetFoldThresholdPolicy func(uintptr, FoldThresholdPolicy)

// Sets the fold threshold policy for @self.
//
// If set to `ADW_FOLD_THRESHOLD_POLICY_MINIMUM`, flap will only fold when the
// children cannot fit anymore. With `ADW_FOLD_THRESHOLD_POLICY_NATURAL`, it
// will fold as soon as children don't get their natural size.
//
// This can be useful if you have a long ellipsizing label and want to let it
// ellipsize instead of immediately folding.
func (x *Flap) SetFoldThresholdPolicy(PolicyVar FoldThresholdPolicy) {

	xFlapSetFoldThresholdPolicy(x.GoPointer(), PolicyVar)

}

var xFlapSetLocked func(uintptr, bool)

// Sets whether @self is locked.
//
// If `FALSE`, folding when the flap is revealed automatically closes it, and
// unfolding it when the flap is not revealed opens it. If `TRUE`,
// [property@Flap:reveal-flap] value never changes on its own.
func (x *Flap) SetLocked(LockedVar bool) {

	xFlapSetLocked(x.GoPointer(), LockedVar)

}

var xFlapSetModal func(uintptr, bool)

// Sets whether @self is modal.
//
// If `TRUE`, clicking the content widget while flap is revealed, as well as
// pressing the &lt;kbd&gt;Esc&lt;/kbd&gt; key, will close the flap. If `FALSE`, clicks are
// passed through to the content widget.
func (x *Flap) SetModal(ModalVar bool) {

	xFlapSetModal(x.GoPointer(), ModalVar)

}

var xFlapSetRevealFlap func(uintptr, bool)

// Sets whether the flap widget is revealed for @self.
func (x *Flap) SetRevealFlap(RevealFlapVar bool) {

	xFlapSetRevealFlap(x.GoPointer(), RevealFlapVar)

}

var xFlapSetRevealParams func(uintptr, *SpringParams)

// Sets the reveal animation spring parameters for @self.
//
// The default value is equivalent to:
//
// ```c
// adw_spring_params_new (1, 0.5, 500)
// ```
func (x *Flap) SetRevealParams(ParamsVar *SpringParams) {

	xFlapSetRevealParams(x.GoPointer(), ParamsVar)

}

var xFlapSetSeparator func(uintptr, uintptr)

// Sets the separator widget for @self.
//
// It's displayed between content and flap when there's no shadow to display.
// When exactly it's visible depends on the [property@Flap:transition-type]
// value.
func (x *Flap) SetSeparator(SeparatorVar *gtk.Widget) {

	xFlapSetSeparator(x.GoPointer(), SeparatorVar.GoPointer())

}

var xFlapSetSwipeToClose func(uintptr, bool)

// Sets whether @self can be closed with a swipe gesture.
//
// The area that can be swiped depends on the [property@Flap:transition-type]
// value.
func (x *Flap) SetSwipeToClose(SwipeToCloseVar bool) {

	xFlapSetSwipeToClose(x.GoPointer(), SwipeToCloseVar)

}

var xFlapSetSwipeToOpen func(uintptr, bool)

// Sets whether @self can be opened with a swipe gesture.
//
// The area that can be swiped depends on the [property@Flap:transition-type]
// value.
func (x *Flap) SetSwipeToOpen(SwipeToOpenVar bool) {

	xFlapSetSwipeToOpen(x.GoPointer(), SwipeToOpenVar)

}

var xFlapSetTransitionType func(uintptr, FlapTransitionType)

// Sets the type of animation used for reveal and fold transitions in @self.
//
// [property@Flap:flap] is transparent by default, which means the content will
// be seen through it with `ADW_FLAP_TRANSITION_TYPE_OVER` transitions; add the
// [`.background`](style-classes.html#background) style class to it if this is
// unwanted.
func (x *Flap) SetTransitionType(TransitionTypeVar FlapTransitionType) {

	xFlapSetTransitionType(x.GoPointer(), TransitionTypeVar)

}

func (c *Flap) GoPointer() uintptr {
	return c.Ptr
}

func (c *Flap) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Gets the progress @self will snap back to after the gesture is canceled.
func (x *Flap) GetCancelProgress() float64 {

	cret := XAdwSwipeableGetCancelProgress(x.GoPointer())
	return cret
}

// Gets the swipe distance of @self.
//
// This corresponds to how many pixels 1 unit represents.
func (x *Flap) GetDistance() float64 {

	cret := XAdwSwipeableGetDistance(x.GoPointer())
	return cret
}

// Gets the current progress of @self.
func (x *Flap) GetProgress() float64 {

	cret := XAdwSwipeableGetProgress(x.GoPointer())
	return cret
}

// Gets the snap points of @self.
//
// Each snap point represents a progress value that is considered acceptable to
// end the swipe on.
func (x *Flap) GetSnapPoints(NSnapPointsVar int) []float64 {

	cret := XAdwSwipeableGetSnapPoints(x.GoPointer(), NSnapPointsVar)
	return cret
}

// Gets the area @self can start a swipe from for the given direction and
// gesture type.
//
// This can be used to restrict swipes to only be possible from a certain area,
// for example, to only allow edge swipes, or to have a draggable element and
// ignore swipes elsewhere.
//
// If not implemented, the default implementation returns the allocation of
// @self, allowing swipes from anywhere.
func (x *Flap) GetSwipeArea(NavigationDirectionVar NavigationDirection, IsDragVar bool, RectVar *gdk.Rectangle) {

	XAdwSwipeableGetSwipeArea(x.GoPointer(), NavigationDirectionVar, IsDragVar, RectVar)

}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *Flap) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *Flap) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *Flap) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *Flap) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Flap) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Flap) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Flap) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Flap) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Flap) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Flap) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *Flap) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Retrieves the orientation of the @orientable.
func (x *Flap) GetOrientation() gtk.Orientation {

	cret := gtk.XGtkOrientableGetOrientation(x.GoPointer())
	return cret
}

// Sets the orientation of the @orientable.
func (x *Flap) SetOrientation(OrientationVar gtk.Orientation) {

	gtk.XGtkOrientableSetOrientation(x.GoPointer(), OrientationVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("ADW"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewFlap, lib, "adw_flap_new")

	core.PuregoSafeRegister(&xFlapGetContent, lib, "adw_flap_get_content")
	core.PuregoSafeRegister(&xFlapGetFlap, lib, "adw_flap_get_flap")
	core.PuregoSafeRegister(&xFlapGetFlapPosition, lib, "adw_flap_get_flap_position")
	core.PuregoSafeRegister(&xFlapGetFoldDuration, lib, "adw_flap_get_fold_duration")
	core.PuregoSafeRegister(&xFlapGetFoldPolicy, lib, "adw_flap_get_fold_policy")
	core.PuregoSafeRegister(&xFlapGetFoldThresholdPolicy, lib, "adw_flap_get_fold_threshold_policy")
	core.PuregoSafeRegister(&xFlapGetFolded, lib, "adw_flap_get_folded")
	core.PuregoSafeRegister(&xFlapGetLocked, lib, "adw_flap_get_locked")
	core.PuregoSafeRegister(&xFlapGetModal, lib, "adw_flap_get_modal")
	core.PuregoSafeRegister(&xFlapGetRevealFlap, lib, "adw_flap_get_reveal_flap")
	core.PuregoSafeRegister(&xFlapGetRevealParams, lib, "adw_flap_get_reveal_params")
	core.PuregoSafeRegister(&xFlapGetRevealProgress, lib, "adw_flap_get_reveal_progress")
	core.PuregoSafeRegister(&xFlapGetSeparator, lib, "adw_flap_get_separator")
	core.PuregoSafeRegister(&xFlapGetSwipeToClose, lib, "adw_flap_get_swipe_to_close")
	core.PuregoSafeRegister(&xFlapGetSwipeToOpen, lib, "adw_flap_get_swipe_to_open")
	core.PuregoSafeRegister(&xFlapGetTransitionType, lib, "adw_flap_get_transition_type")
	core.PuregoSafeRegister(&xFlapSetContent, lib, "adw_flap_set_content")
	core.PuregoSafeRegister(&xFlapSetFlap, lib, "adw_flap_set_flap")
	core.PuregoSafeRegister(&xFlapSetFlapPosition, lib, "adw_flap_set_flap_position")
	core.PuregoSafeRegister(&xFlapSetFoldDuration, lib, "adw_flap_set_fold_duration")
	core.PuregoSafeRegister(&xFlapSetFoldPolicy, lib, "adw_flap_set_fold_policy")
	core.PuregoSafeRegister(&xFlapSetFoldThresholdPolicy, lib, "adw_flap_set_fold_threshold_policy")
	core.PuregoSafeRegister(&xFlapSetLocked, lib, "adw_flap_set_locked")
	core.PuregoSafeRegister(&xFlapSetModal, lib, "adw_flap_set_modal")
	core.PuregoSafeRegister(&xFlapSetRevealFlap, lib, "adw_flap_set_reveal_flap")
	core.PuregoSafeRegister(&xFlapSetRevealParams, lib, "adw_flap_set_reveal_params")
	core.PuregoSafeRegister(&xFlapSetSeparator, lib, "adw_flap_set_separator")
	core.PuregoSafeRegister(&xFlapSetSwipeToClose, lib, "adw_flap_set_swipe_to_close")
	core.PuregoSafeRegister(&xFlapSetSwipeToOpen, lib, "adw_flap_set_swipe_to_open")
	core.PuregoSafeRegister(&xFlapSetTransitionType, lib, "adw_flap_set_transition_type")

}
