// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type LeafletClass struct {
	ParentClass uintptr
}

func (x *LeafletClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type LeafletPageClass struct {
	ParentClass uintptr
}

func (x *LeafletPageClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Describes the possible transitions in a [class@Leaflet] widget.
//
// New values may be added to this enumeration over time.
type LeafletTransitionType int

const (

	// Cover the old page or uncover the new page, sliding from or towards the end according to orientation, text direction and children order
	LeafletTransitionTypeOverValue LeafletTransitionType = 0
	// Uncover the new page or cover the old page, sliding from or towards the start according to orientation, text direction and children order
	LeafletTransitionTypeUnderValue LeafletTransitionType = 1
	// Slide from left, right, up or down according to the orientation, text direction and the children order
	LeafletTransitionTypeSlideValue LeafletTransitionType = 2
)

// An adaptive container acting like a box or a stack.
//
// &lt;picture&gt;
//
//	&lt;source srcset="leaflet-wide-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="leaflet-wide.png" alt="leaflet-wide"&gt;
//
// &lt;/picture&gt;
// &lt;picture&gt;
//
//	&lt;source srcset="leaflet-narrow-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="leaflet-narrow.png" alt="leaflet-narrow"&gt;
//
// &lt;/picture&gt;
//
// The `AdwLeaflet` widget can display its children like a [class@Gtk.Box] does
// or like a [class@Gtk.Stack] does, adapting to size changes by switching
// between the two modes.
//
// When there is enough space the children are displayed side by side, otherwise
// only one is displayed and the leaflet is said to be “folded”.
// The threshold is dictated by the preferred minimum sizes of the children.
// When a leaflet is folded, the children can be navigated using swipe gestures.
//
// The “over” and “under” transition types stack the children one on top of the
// other, while the “slide” transition puts the children side by side. While
// navigating to a child on the side or below can be performed by swiping the
// current child away, navigating to an upper child requires dragging it from
// the edge where it resides. This doesn't affect non-dragging swipes.
//
// ## CSS nodes
//
// `AdwLeaflet` has a single CSS node with name `leaflet`. The node will get the
// style classes `.folded` when it is folded, `.unfolded` when it's not, or none
// if it hasn't computed its fold yet.
type Leaflet struct {
	gtk.Widget
}

func LeafletNewFromInternalPtr(ptr uintptr) *Leaflet {
	cls := &Leaflet{}
	cls.Ptr = ptr
	return cls
}

var xNewLeaflet func() uintptr

// Creates a new `AdwLeaflet`.
func NewLeaflet() *Leaflet {
	var cls *Leaflet

	cret := xNewLeaflet()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Leaflet{}
	cls.Ptr = cret
	return cls
}

var xLeafletAppend func(uintptr, uintptr) uintptr

// Adds a child to @self.
func (x *Leaflet) Append(ChildVar *gtk.Widget) *LeafletPage {
	var cls *LeafletPage

	cret := xLeafletAppend(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &LeafletPage{}
	cls.Ptr = cret
	return cls
}

var xLeafletGetAdjacentChild func(uintptr, NavigationDirection) uintptr

// Finds the previous or next navigatable child.
//
// This will be the same child [method@Leaflet.navigate] or swipe gestures will
// navigate to.
//
// If there's no child to navigate to, `NULL` will be returned instead.
//
// See [property@LeafletPage:navigatable].
func (x *Leaflet) GetAdjacentChild(DirectionVar NavigationDirection) *gtk.Widget {
	var cls *gtk.Widget

	cret := xLeafletGetAdjacentChild(x.GoPointer(), DirectionVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xLeafletGetCanNavigateBack func(uintptr) bool

// Gets whether gestures and shortcuts for navigating backward are enabled.
func (x *Leaflet) GetCanNavigateBack() bool {

	cret := xLeafletGetCanNavigateBack(x.GoPointer())
	return cret
}

var xLeafletGetCanNavigateForward func(uintptr) bool

// Gets whether gestures and shortcuts for navigating forward are enabled.
func (x *Leaflet) GetCanNavigateForward() bool {

	cret := xLeafletGetCanNavigateForward(x.GoPointer())
	return cret
}

var xLeafletGetCanUnfold func(uintptr) bool

// Gets whether @self can unfold.
func (x *Leaflet) GetCanUnfold() bool {

	cret := xLeafletGetCanUnfold(x.GoPointer())
	return cret
}

var xLeafletGetChildByName func(uintptr, string) uintptr

// Finds the child of @self with @name.
//
// Returns `NULL` if there is no child with this name.
//
// See [property@LeafletPage:name].
func (x *Leaflet) GetChildByName(NameVar string) *gtk.Widget {
	var cls *gtk.Widget

	cret := xLeafletGetChildByName(x.GoPointer(), NameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xLeafletGetChildTransitionParams func(uintptr) *SpringParams

// Gets the child transition spring parameters for @self.
func (x *Leaflet) GetChildTransitionParams() *SpringParams {

	cret := xLeafletGetChildTransitionParams(x.GoPointer())
	return cret
}

var xLeafletGetChildTransitionRunning func(uintptr) bool

// Gets whether a child transition is currently running for @self.
func (x *Leaflet) GetChildTransitionRunning() bool {

	cret := xLeafletGetChildTransitionRunning(x.GoPointer())
	return cret
}

var xLeafletGetFoldThresholdPolicy func(uintptr) FoldThresholdPolicy

// Gets the fold threshold policy for @self.
func (x *Leaflet) GetFoldThresholdPolicy() FoldThresholdPolicy {

	cret := xLeafletGetFoldThresholdPolicy(x.GoPointer())
	return cret
}

var xLeafletGetFolded func(uintptr) bool

// Gets whether @self is folded.
//
// The leaflet will be folded if the size allocated to it is smaller than the
// sum of the minimum or natural sizes of the children (see
// [property@Leaflet:fold-threshold-policy]), it will be unfolded otherwise.
func (x *Leaflet) GetFolded() bool {

	cret := xLeafletGetFolded(x.GoPointer())
	return cret
}

var xLeafletGetHomogeneous func(uintptr) bool

// Gets whether @self is homogeneous.
func (x *Leaflet) GetHomogeneous() bool {

	cret := xLeafletGetHomogeneous(x.GoPointer())
	return cret
}

var xLeafletGetModeTransitionDuration func(uintptr) uint

// Gets the mode transition animation duration for @self.
func (x *Leaflet) GetModeTransitionDuration() uint {

	cret := xLeafletGetModeTransitionDuration(x.GoPointer())
	return cret
}

var xLeafletGetPage func(uintptr, uintptr) uintptr

// Returns the [class@LeafletPage] object for @child.
func (x *Leaflet) GetPage(ChildVar *gtk.Widget) *LeafletPage {
	var cls *LeafletPage

	cret := xLeafletGetPage(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &LeafletPage{}
	cls.Ptr = cret
	return cls
}

var xLeafletGetPages func(uintptr) uintptr

// Returns a [iface@Gio.ListModel] that contains the pages of the leaflet.
//
// This can be used to keep an up-to-date view. The model also implements
// [iface@Gtk.SelectionModel] and can be used to track and change the visible
// page.
func (x *Leaflet) GetPages() *gtk.SelectionModelBase {
	var cls *gtk.SelectionModelBase

	cret := xLeafletGetPages(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.SelectionModelBase{}
	cls.Ptr = cret
	return cls
}

var xLeafletGetTransitionType func(uintptr) LeafletTransitionType

// Gets the type of animation used for transitions between modes and children.
func (x *Leaflet) GetTransitionType() LeafletTransitionType {

	cret := xLeafletGetTransitionType(x.GoPointer())
	return cret
}

var xLeafletGetVisibleChild func(uintptr) uintptr

// Gets the widget currently visible when the leaflet is folded.
func (x *Leaflet) GetVisibleChild() *gtk.Widget {
	var cls *gtk.Widget

	cret := xLeafletGetVisibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xLeafletGetVisibleChildName func(uintptr) string

// Gets the name of the currently visible child widget.
func (x *Leaflet) GetVisibleChildName() string {

	cret := xLeafletGetVisibleChildName(x.GoPointer())
	return cret
}

var xLeafletInsertChildAfter func(uintptr, uintptr, uintptr) uintptr

// Inserts @child in the position after @sibling in the list of children.
//
// If @sibling is `NULL`, inserts @child at the first position.
func (x *Leaflet) InsertChildAfter(ChildVar *gtk.Widget, SiblingVar *gtk.Widget) *LeafletPage {
	var cls *LeafletPage

	cret := xLeafletInsertChildAfter(x.GoPointer(), ChildVar.GoPointer(), SiblingVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &LeafletPage{}
	cls.Ptr = cret
	return cls
}

var xLeafletNavigate func(uintptr, NavigationDirection) bool

// Navigates to the previous or next child.
//
// The child must have the [property@LeafletPage:navigatable] property set to
// `TRUE`, otherwise it will be skipped.
//
// This will be the same child as returned by
// [method@Leaflet.get_adjacent_child] or navigated to via swipe gestures.
func (x *Leaflet) Navigate(DirectionVar NavigationDirection) bool {

	cret := xLeafletNavigate(x.GoPointer(), DirectionVar)
	return cret
}

var xLeafletPrepend func(uintptr, uintptr) uintptr

// Inserts @child at the first position in @self.
func (x *Leaflet) Prepend(ChildVar *gtk.Widget) *LeafletPage {
	var cls *LeafletPage

	cret := xLeafletPrepend(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &LeafletPage{}
	cls.Ptr = cret
	return cls
}

var xLeafletRemove func(uintptr, uintptr)

// Removes a child widget from @self.
func (x *Leaflet) Remove(ChildVar *gtk.Widget) {

	xLeafletRemove(x.GoPointer(), ChildVar.GoPointer())

}

var xLeafletReorderChildAfter func(uintptr, uintptr, uintptr)

// Moves @child to the position after @sibling in the list of children.
//
// If @sibling is `NULL`, moves @child to the first position.
func (x *Leaflet) ReorderChildAfter(ChildVar *gtk.Widget, SiblingVar *gtk.Widget) {

	xLeafletReorderChildAfter(x.GoPointer(), ChildVar.GoPointer(), SiblingVar.GoPointer())

}

var xLeafletSetCanNavigateBack func(uintptr, bool)

// Sets whether gestures and shortcuts for navigating backward are enabled.
//
// The supported gestures are:
//
// - One-finger swipe on touchscreens
// - Horizontal scrolling on touchpads (usually two-finger swipe)
// - Back/forward mouse buttons
//
// The keyboard back/forward keys are also supported, as well as the
// &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;←&lt;/kbd&gt; shortcut for horizontal orientation, or
// &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;↑&lt;/kbd&gt; for vertical orientation.
//
// If the orientation is horizontal, for right-to-left locales, gestures and
// shortcuts are reversed.
//
// Only children that have [property@LeafletPage:navigatable] set to `TRUE` can
// be navigated to.
func (x *Leaflet) SetCanNavigateBack(CanNavigateBackVar bool) {

	xLeafletSetCanNavigateBack(x.GoPointer(), CanNavigateBackVar)

}

var xLeafletSetCanNavigateForward func(uintptr, bool)

// Sets whether gestures and shortcuts for navigating forward are enabled.
//
// The supported gestures are:
//
// - One-finger swipe on touchscreens
// - Horizontal scrolling on touchpads (usually two-finger swipe)
// - Back/forward mouse buttons
//
// The keyboard back/forward keys are also supported, as well as the
// &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;→&lt;/kbd&gt; shortcut for horizontal orientation, or
// &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;↓&lt;/kbd&gt; for vertical orientation.
//
// If the orientation is horizontal, for right-to-left locales, gestures and
// shortcuts are reversed.
//
// Only children that have [property@LeafletPage:navigatable] set to `TRUE` can
// be navigated to.
func (x *Leaflet) SetCanNavigateForward(CanNavigateForwardVar bool) {

	xLeafletSetCanNavigateForward(x.GoPointer(), CanNavigateForwardVar)

}

var xLeafletSetCanUnfold func(uintptr, bool)

// Sets whether @self can unfold.
func (x *Leaflet) SetCanUnfold(CanUnfoldVar bool) {

	xLeafletSetCanUnfold(x.GoPointer(), CanUnfoldVar)

}

var xLeafletSetChildTransitionParams func(uintptr, *SpringParams)

// Sets the child transition spring parameters for @self.
//
// The default value is equivalent to:
//
// ```c
// adw_spring_params_new (1, 0.5, 500)
// ```
func (x *Leaflet) SetChildTransitionParams(ParamsVar *SpringParams) {

	xLeafletSetChildTransitionParams(x.GoPointer(), ParamsVar)

}

var xLeafletSetFoldThresholdPolicy func(uintptr, FoldThresholdPolicy)

// Sets the fold threshold policy for @self.
//
// If set to `ADW_FOLD_THRESHOLD_POLICY_MINIMUM`, it will only fold when the
// children cannot fit anymore. With `ADW_FOLD_THRESHOLD_POLICY_NATURAL`, it
// will fold as soon as children don't get their natural size.
//
// This can be useful if you have a long ellipsizing label and want to let it
// ellipsize instead of immediately folding.
func (x *Leaflet) SetFoldThresholdPolicy(PolicyVar FoldThresholdPolicy) {

	xLeafletSetFoldThresholdPolicy(x.GoPointer(), PolicyVar)

}

var xLeafletSetHomogeneous func(uintptr, bool)

// Sets @self to be homogeneous or not.
//
// If set to `FALSE`, different children can have different size along the
// opposite orientation.
func (x *Leaflet) SetHomogeneous(HomogeneousVar bool) {

	xLeafletSetHomogeneous(x.GoPointer(), HomogeneousVar)

}

var xLeafletSetModeTransitionDuration func(uintptr, uint)

// Sets the mode transition animation duration for @self.
func (x *Leaflet) SetModeTransitionDuration(DurationVar uint) {

	xLeafletSetModeTransitionDuration(x.GoPointer(), DurationVar)

}

var xLeafletSetTransitionType func(uintptr, LeafletTransitionType)

// Sets the type of animation used for transitions between modes and children.
//
// The transition type can be changed without problems at runtime, so it is
// possible to change the animation based on the mode or child that is about to
// become current.
func (x *Leaflet) SetTransitionType(TransitionVar LeafletTransitionType) {

	xLeafletSetTransitionType(x.GoPointer(), TransitionVar)

}

var xLeafletSetVisibleChild func(uintptr, uintptr)

// Sets the widget currently visible when the leaflet is folded.
//
// The transition is determined by [property@Leaflet:transition-type] and
// [property@Leaflet:child-transition-params]. The transition can be cancelled
// by the user, in which case visible child will change back to the previously
// visible child.
func (x *Leaflet) SetVisibleChild(VisibleChildVar *gtk.Widget) {

	xLeafletSetVisibleChild(x.GoPointer(), VisibleChildVar.GoPointer())

}

var xLeafletSetVisibleChildName func(uintptr, string)

// Makes the child with the name @name visible.
//
// See [property@Leaflet:visible-child].
func (x *Leaflet) SetVisibleChildName(NameVar string) {

	xLeafletSetVisibleChildName(x.GoPointer(), NameVar)

}

func (c *Leaflet) GoPointer() uintptr {
	return c.Ptr
}

func (c *Leaflet) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Gets the progress @self will snap back to after the gesture is canceled.
func (x *Leaflet) GetCancelProgress() float64 {

	cret := XAdwSwipeableGetCancelProgress(x.GoPointer())
	return cret
}

// Gets the swipe distance of @self.
//
// This corresponds to how many pixels 1 unit represents.
func (x *Leaflet) GetDistance() float64 {

	cret := XAdwSwipeableGetDistance(x.GoPointer())
	return cret
}

// Gets the current progress of @self.
func (x *Leaflet) GetProgress() float64 {

	cret := XAdwSwipeableGetProgress(x.GoPointer())
	return cret
}

// Gets the snap points of @self.
//
// Each snap point represents a progress value that is considered acceptable to
// end the swipe on.
func (x *Leaflet) GetSnapPoints(NSnapPointsVar int) uintptr {

	cret := XAdwSwipeableGetSnapPoints(x.GoPointer(), NSnapPointsVar)
	return cret
}

// Gets the area @self can start a swipe from for the given direction and
// gesture type.
//
// This can be used to restrict swipes to only be possible from a certain area,
// for example, to only allow edge swipes, or to have a draggable element and
// ignore swipes elsewhere.
//
// If not implemented, the default implementation returns the allocation of
// @self, allowing swipes from anywhere.
func (x *Leaflet) GetSwipeArea(NavigationDirectionVar NavigationDirection, IsDragVar bool, RectVar *gdk.Rectangle) {

	XAdwSwipeableGetSwipeArea(x.GoPointer(), NavigationDirectionVar, IsDragVar, RectVar)

}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *Leaflet) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *Leaflet) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *Leaflet) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *Leaflet) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Leaflet) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Leaflet) UpdatePropertyValue(NPropertiesVar int, PropertiesVar uintptr, ValuesVar uintptr) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Leaflet) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Leaflet) UpdateRelationValue(NRelationsVar int, RelationsVar uintptr, ValuesVar uintptr) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Leaflet) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Leaflet) UpdateStateValue(NStatesVar int, StatesVar uintptr, ValuesVar uintptr) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *Leaflet) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Retrieves the orientation of the @orientable.
func (x *Leaflet) GetOrientation() gtk.Orientation {

	cret := gtk.XGtkOrientableGetOrientation(x.GoPointer())
	return cret
}

// Sets the orientation of the @orientable.
func (x *Leaflet) SetOrientation(OrientationVar gtk.Orientation) {

	gtk.XGtkOrientableSetOrientation(x.GoPointer(), OrientationVar)

}

// An auxiliary class used by [class@Leaflet].
type LeafletPage struct {
	gobject.Object
}

func LeafletPageNewFromInternalPtr(ptr uintptr) *LeafletPage {
	cls := &LeafletPage{}
	cls.Ptr = ptr
	return cls
}

var xLeafletPageGetChild func(uintptr) uintptr

// Gets the leaflet child to which @self belongs.
func (x *LeafletPage) GetChild() *gtk.Widget {
	var cls *gtk.Widget

	cret := xLeafletPageGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xLeafletPageGetName func(uintptr) string

// Gets the name of @self.
func (x *LeafletPage) GetName() string {

	cret := xLeafletPageGetName(x.GoPointer())
	return cret
}

var xLeafletPageGetNavigatable func(uintptr) bool

// Gets whether the child can be navigated to when folded.
func (x *LeafletPage) GetNavigatable() bool {

	cret := xLeafletPageGetNavigatable(x.GoPointer())
	return cret
}

var xLeafletPageSetName func(uintptr, string)

// Sets the name of the @self.
func (x *LeafletPage) SetName(NameVar string) {

	xLeafletPageSetName(x.GoPointer(), NameVar)

}

var xLeafletPageSetNavigatable func(uintptr, bool)

// Sets whether @self can be navigated to when folded.
//
// If `FALSE`, the child will be ignored by [method@Leaflet.get_adjacent_child],
// [method@Leaflet.navigate], and swipe gestures.
//
// This can be used used to prevent switching to widgets like separators.
func (x *LeafletPage) SetNavigatable(NavigatableVar bool) {

	xLeafletPageSetNavigatable(x.GoPointer(), NavigatableVar)

}

func (c *LeafletPage) GoPointer() uintptr {
	return c.Ptr
}

func (c *LeafletPage) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("ADW"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewLeaflet, lib, "adw_leaflet_new")

	core.PuregoSafeRegister(&xLeafletAppend, lib, "adw_leaflet_append")
	core.PuregoSafeRegister(&xLeafletGetAdjacentChild, lib, "adw_leaflet_get_adjacent_child")
	core.PuregoSafeRegister(&xLeafletGetCanNavigateBack, lib, "adw_leaflet_get_can_navigate_back")
	core.PuregoSafeRegister(&xLeafletGetCanNavigateForward, lib, "adw_leaflet_get_can_navigate_forward")
	core.PuregoSafeRegister(&xLeafletGetCanUnfold, lib, "adw_leaflet_get_can_unfold")
	core.PuregoSafeRegister(&xLeafletGetChildByName, lib, "adw_leaflet_get_child_by_name")
	core.PuregoSafeRegister(&xLeafletGetChildTransitionParams, lib, "adw_leaflet_get_child_transition_params")
	core.PuregoSafeRegister(&xLeafletGetChildTransitionRunning, lib, "adw_leaflet_get_child_transition_running")
	core.PuregoSafeRegister(&xLeafletGetFoldThresholdPolicy, lib, "adw_leaflet_get_fold_threshold_policy")
	core.PuregoSafeRegister(&xLeafletGetFolded, lib, "adw_leaflet_get_folded")
	core.PuregoSafeRegister(&xLeafletGetHomogeneous, lib, "adw_leaflet_get_homogeneous")
	core.PuregoSafeRegister(&xLeafletGetModeTransitionDuration, lib, "adw_leaflet_get_mode_transition_duration")
	core.PuregoSafeRegister(&xLeafletGetPage, lib, "adw_leaflet_get_page")
	core.PuregoSafeRegister(&xLeafletGetPages, lib, "adw_leaflet_get_pages")
	core.PuregoSafeRegister(&xLeafletGetTransitionType, lib, "adw_leaflet_get_transition_type")
	core.PuregoSafeRegister(&xLeafletGetVisibleChild, lib, "adw_leaflet_get_visible_child")
	core.PuregoSafeRegister(&xLeafletGetVisibleChildName, lib, "adw_leaflet_get_visible_child_name")
	core.PuregoSafeRegister(&xLeafletInsertChildAfter, lib, "adw_leaflet_insert_child_after")
	core.PuregoSafeRegister(&xLeafletNavigate, lib, "adw_leaflet_navigate")
	core.PuregoSafeRegister(&xLeafletPrepend, lib, "adw_leaflet_prepend")
	core.PuregoSafeRegister(&xLeafletRemove, lib, "adw_leaflet_remove")
	core.PuregoSafeRegister(&xLeafletReorderChildAfter, lib, "adw_leaflet_reorder_child_after")
	core.PuregoSafeRegister(&xLeafletSetCanNavigateBack, lib, "adw_leaflet_set_can_navigate_back")
	core.PuregoSafeRegister(&xLeafletSetCanNavigateForward, lib, "adw_leaflet_set_can_navigate_forward")
	core.PuregoSafeRegister(&xLeafletSetCanUnfold, lib, "adw_leaflet_set_can_unfold")
	core.PuregoSafeRegister(&xLeafletSetChildTransitionParams, lib, "adw_leaflet_set_child_transition_params")
	core.PuregoSafeRegister(&xLeafletSetFoldThresholdPolicy, lib, "adw_leaflet_set_fold_threshold_policy")
	core.PuregoSafeRegister(&xLeafletSetHomogeneous, lib, "adw_leaflet_set_homogeneous")
	core.PuregoSafeRegister(&xLeafletSetModeTransitionDuration, lib, "adw_leaflet_set_mode_transition_duration")
	core.PuregoSafeRegister(&xLeafletSetTransitionType, lib, "adw_leaflet_set_transition_type")
	core.PuregoSafeRegister(&xLeafletSetVisibleChild, lib, "adw_leaflet_set_visible_child")
	core.PuregoSafeRegister(&xLeafletSetVisibleChildName, lib, "adw_leaflet_set_visible_child_name")

	core.PuregoSafeRegister(&xLeafletPageGetChild, lib, "adw_leaflet_page_get_child")
	core.PuregoSafeRegister(&xLeafletPageGetName, lib, "adw_leaflet_page_get_name")
	core.PuregoSafeRegister(&xLeafletPageGetNavigatable, lib, "adw_leaflet_page_get_navigatable")
	core.PuregoSafeRegister(&xLeafletPageSetName, lib, "adw_leaflet_page_set_name")
	core.PuregoSafeRegister(&xLeafletPageSetNavigatable, lib, "adw_leaflet_page_set_navigatable")

}
