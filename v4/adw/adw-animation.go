// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type AnimationClass struct {
}

func (x *AnimationClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

const (
	// Indicates an [class@Animation] with an infinite duration.
	//
	// This value is mostly used internally.
	DURATION_INFINITE uint = 4294967295
)

// Describes the possible states of an [class@Animation].
//
// The state can be controlled with [method@Animation.play],
// [method@Animation.pause], [method@Animation.resume],
// [method@Animation.reset] and [method@Animation.skip].
type AnimationState int

var xAnimationStateGLibType func() types.GType

func AnimationStateGLibType() types.GType {
	return xAnimationStateGLibType()
}

const (

	// The animation hasn't started yet.
	AnimationIdleValue AnimationState = 0
	// The animation has been paused.
	AnimationPausedValue AnimationState = 1
	// The animation is currently playing.
	AnimationPlayingValue AnimationState = 2
	// The animation has finished.
	AnimationFinishedValue AnimationState = 3
)

// A base class for animations.
//
// `AdwAnimation` represents an animation on a widget. It has a target that
// provides a value to animate, and a state indicating whether the
// animation hasn't been started yet, is playing, paused or finished.
//
// Currently there are two concrete animation types:
// [class@TimedAnimation] and [class@SpringAnimation].
//
// `AdwAnimation` will automatically skip the animation if
// [property@Animation:widget] is unmapped, or if
// [property@Gtk.Settings:gtk-enable-animations] is `FALSE`.
//
// The [signal@Animation::done] signal can be used to perform an action after
// the animation ends, for example hiding a widget after animating its
// [property@Gtk.Widget:opacity] to 0.
//
// `AdwAnimation` will be kept alive while the animation is playing. As such,
// it's safe to create an animation, start it and immediately unref it:
// A fire-and-forget animation:
//
// ```c
// static void
// animation_cb (double    value,
//
//	MyObject *self)
//
//	{
//	  // Do something with @value
//	}
//
// static void
// my_object_animate (MyObject *self)
//
//	{
//	  AdwAnimationTarget *target =
//	    adw_callback_animation_target_new ((AdwAnimationTargetFunc) animation_cb,
//	                                       self, NULL);
//	  g_autoptr (AdwAnimation) animation =
//	    adw_timed_animation_new (widget, 0, 1, 250, target);
//
//	  adw_animation_play (animation);
//	}
//
// ```
//
// If there's a chance the previous animation for the same target hasn't yet
// finished, the previous animation should be stopped first, or the existing
// `AdwAnimation` object can be reused.
type Animation struct {
	gobject.Object
}

var xAnimationGLibType func() types.GType

func AnimationGLibType() types.GType {
	return xAnimationGLibType()
}

func AnimationNewFromInternalPtr(ptr uintptr) *Animation {
	cls := &Animation{}
	cls.Ptr = ptr
	return cls
}

var xAnimationGetFollowEnableAnimationsSetting func(uintptr) bool

// Gets whether @self should be skipped when animations are globally disabled.
func (x *Animation) GetFollowEnableAnimationsSetting() bool {

	cret := xAnimationGetFollowEnableAnimationsSetting(x.GoPointer())
	return cret
}

var xAnimationGetState func(uintptr) AnimationState

// Gets the current value of @self.
//
// The state indicates whether @self is currently playing, paused, finished or
// hasn't been started yet.
func (x *Animation) GetState() AnimationState {

	cret := xAnimationGetState(x.GoPointer())
	return cret
}

var xAnimationGetTarget func(uintptr) uintptr

// Gets the target @self animates.
func (x *Animation) GetTarget() *AnimationTarget {
	var cls *AnimationTarget

	cret := xAnimationGetTarget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &AnimationTarget{}
	cls.Ptr = cret
	return cls
}

var xAnimationGetValue func(uintptr) float64

// Gets the current value of @self.
func (x *Animation) GetValue() float64 {

	cret := xAnimationGetValue(x.GoPointer())
	return cret
}

var xAnimationGetWidget func(uintptr) uintptr

// Gets the widget @self was created for.
//
// It provides the frame clock for the animation. It's not strictly necessary
// for this widget to be same as the one being animated.
//
// The widget must be mapped in order for the animation to work. If it's not
// mapped, or if it gets unmapped during an ongoing animation, the animation
// will be automatically skipped.
func (x *Animation) GetWidget() *gtk.Widget {
	var cls *gtk.Widget

	cret := xAnimationGetWidget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xAnimationPause func(uintptr)

// Pauses a playing animation for @self.
//
// Does nothing if the current state of @self isn't `ADW_ANIMATION_PLAYING`.
//
// Sets [property@Animation:state] to `ADW_ANIMATION_PAUSED`.
func (x *Animation) Pause() {

	xAnimationPause(x.GoPointer())

}

var xAnimationPlay func(uintptr)

// Starts the animation for @self.
//
// If the animation is playing, paused or has been completed, restarts it from
// the beginning. This allows to easily play an animation regardless of whether
// it's already playing or not.
//
// Sets [property@Animation:state] to `ADW_ANIMATION_PLAYING`.
//
// The animation will be automatically skipped if [property@Animation:widget] is
// unmapped, or if [property@Gtk.Settings:gtk-enable-animations] is `FALSE`.
//
// As such, it's not guaranteed that the animation will actually run. For
// example, when using [func@GLib.idle_add] and starting an animation
// immediately afterwards, it's entirely possible that the idle callback will
// run after the animation has already finished, and not while it's playing.
func (x *Animation) Play() {

	xAnimationPlay(x.GoPointer())

}

var xAnimationReset func(uintptr)

// Resets the animation for @self.
//
// Sets [property@Animation:state] to `ADW_ANIMATION_IDLE`.
func (x *Animation) Reset() {

	xAnimationReset(x.GoPointer())

}

var xAnimationResume func(uintptr)

// Resumes a paused animation for @self.
//
// This function must only be used if the animation has been paused with
// [method@Animation.pause].
//
// Sets [property@Animation:state] to `ADW_ANIMATION_PLAYING`.
func (x *Animation) Resume() {

	xAnimationResume(x.GoPointer())

}

var xAnimationSetFollowEnableAnimationsSetting func(uintptr, bool)

// Sets whether to skip @self when animations are globally disabled.
//
// The default behavior is to skip the animation. Set to `FALSE` to disable this
// behavior.
//
// This can be useful for cases where animation is essential, like spinners, or
// in demo applications. Most other animations should keep it enabled.
//
// See [property@Gtk.Settings:gtk-enable-animations].
func (x *Animation) SetFollowEnableAnimationsSetting(SettingVar bool) {

	xAnimationSetFollowEnableAnimationsSetting(x.GoPointer(), SettingVar)

}

var xAnimationSetTarget func(uintptr, uintptr)

// Sets the target @self animates to @target.
func (x *Animation) SetTarget(TargetVar *AnimationTarget) {

	xAnimationSetTarget(x.GoPointer(), TargetVar.GoPointer())

}

var xAnimationSkip func(uintptr)

// Skips the animation for @self.
//
// If the animation hasn't been started yet, is playing, or is paused, instantly
// skips the animation to the end and causes [signal@Animation::done] to be
// emitted.
//
// Sets [property@Animation:state] to `ADW_ANIMATION_FINISHED`.
func (x *Animation) Skip() {

	xAnimationSkip(x.GoPointer())

}

func (c *Animation) GoPointer() uintptr {
	return c.Ptr
}

func (c *Animation) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// This signal is emitted when the animation has been completed, either on its
// own or via calling [method@Animation.skip].
func (x *Animation) ConnectDone(cb *func(Animation)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "done", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Animation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "done", cbRefPtr)
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("ADW"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xAnimationStateGLibType, lib, "adw_animation_state_get_type")

	core.PuregoSafeRegister(&xAnimationGLibType, lib, "adw_animation_get_type")

	core.PuregoSafeRegister(&xAnimationGetFollowEnableAnimationsSetting, lib, "adw_animation_get_follow_enable_animations_setting")
	core.PuregoSafeRegister(&xAnimationGetState, lib, "adw_animation_get_state")
	core.PuregoSafeRegister(&xAnimationGetTarget, lib, "adw_animation_get_target")
	core.PuregoSafeRegister(&xAnimationGetValue, lib, "adw_animation_get_value")
	core.PuregoSafeRegister(&xAnimationGetWidget, lib, "adw_animation_get_widget")
	core.PuregoSafeRegister(&xAnimationPause, lib, "adw_animation_pause")
	core.PuregoSafeRegister(&xAnimationPlay, lib, "adw_animation_play")
	core.PuregoSafeRegister(&xAnimationReset, lib, "adw_animation_reset")
	core.PuregoSafeRegister(&xAnimationResume, lib, "adw_animation_resume")
	core.PuregoSafeRegister(&xAnimationSetFollowEnableAnimationsSetting, lib, "adw_animation_set_follow_enable_animations_setting")
	core.PuregoSafeRegister(&xAnimationSetTarget, lib, "adw_animation_set_target")
	core.PuregoSafeRegister(&xAnimationSkip, lib, "adw_animation_skip")

}
