// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type NavigationPageClass struct {
	_ structs.HostLayout

	ParentClass uintptr

	Padding [8]uintptr
}

func (x *NavigationPageClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type NavigationViewClass struct {
	_ structs.HostLayout

	ParentClass uintptr
}

func (x *NavigationViewClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A page within [class@NavigationView] or [class@NavigationSplitView].
//
// Each page has a child widget, a title and optionally a tag.
//
// The [signal@NavigationPage::showing], [signal@NavigationPage::shown],
// [signal@NavigationPage::hiding] and [signal@NavigationPage::hidden] signals
// can be used to track the page's visibility within its `AdwNavigationView`.
//
// ## Header Bar Integration
//
// When placed inside `AdwNavigationPage`, [class@HeaderBar] will display the
// page title instead of window title.
//
// When used together with [class@NavigationView], it will also display a back
// button that can be used to go back to the previous page. Set
// [property@HeaderBar:show-back-button] to `FALSE` to disable that behavior if
// it's unwanted.
//
// ## CSS Nodes
//
// `AdwNavigationPage` has a single CSS node with name
// `navigation-view-page`.
//
// ## Accessibility
//
// `AdwNavigationPage` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
type NavigationPage struct {
	gtk.Widget
}

var xNavigationPageGLibType func() types.GType

func NavigationPageGLibType() types.GType {
	return xNavigationPageGLibType()
}

func NavigationPageNewFromInternalPtr(ptr uintptr) *NavigationPage {
	cls := &NavigationPage{}
	cls.Ptr = ptr
	return cls
}

var xNewNavigationPage func(uintptr, string) uintptr

// Creates a new `AdwNavigationPage`.
func NewNavigationPage(ChildVar *gtk.Widget, TitleVar string) *NavigationPage {
	var cls *NavigationPage

	cret := xNewNavigationPage(ChildVar.GoPointer(), TitleVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NavigationPage{}
	cls.Ptr = cret
	return cls
}

var xNewNavigationPageWithTag func(uintptr, string, string) uintptr

// Creates a new `AdwNavigationPage` with provided tag.
func NewNavigationPageWithTag(ChildVar *gtk.Widget, TitleVar string, TagVar string) *NavigationPage {
	var cls *NavigationPage

	cret := xNewNavigationPageWithTag(ChildVar.GoPointer(), TitleVar, TagVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NavigationPage{}
	cls.Ptr = cret
	return cls
}

var xNavigationPageGetCanPop func(uintptr) bool

// Gets whether @self can be popped from navigation stack.
func (x *NavigationPage) GetCanPop() bool {

	cret := xNavigationPageGetCanPop(x.GoPointer())
	return cret
}

var xNavigationPageGetChild func(uintptr) uintptr

// Gets the child widget of @self.
func (x *NavigationPage) GetChild() *gtk.Widget {
	var cls *gtk.Widget

	cret := xNavigationPageGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xNavigationPageGetTag func(uintptr) string

// Gets the tag of @self.
func (x *NavigationPage) GetTag() string {

	cret := xNavigationPageGetTag(x.GoPointer())
	return cret
}

var xNavigationPageGetTitle func(uintptr) string

// Gets the title of @self.
func (x *NavigationPage) GetTitle() string {

	cret := xNavigationPageGetTitle(x.GoPointer())
	return cret
}

var xNavigationPageSetCanPop func(uintptr, bool)

// Sets whether @self can be popped from navigation stack.
//
// Set it to `FALSE` to disable shortcuts and gestures, as well as remove the
// back button from [class@HeaderBar].
//
// Manually calling [method@NavigationView.pop] or using the `navigation.pop`
// action will still work.
//
// See [property@HeaderBar:show-back-button] for removing only the back button,
// but not shortcuts.
func (x *NavigationPage) SetCanPop(CanPopVar bool) {

	xNavigationPageSetCanPop(x.GoPointer(), CanPopVar)

}

var xNavigationPageSetChild func(uintptr, uintptr)

// Sets the child widget of @self.
func (x *NavigationPage) SetChild(ChildVar *gtk.Widget) {

	xNavigationPageSetChild(x.GoPointer(), ChildVar.GoPointer())

}

var xNavigationPageSetTag func(uintptr, string)

// Sets the tag for @self.
//
// The tag can be used to retrieve the page with
// [method@NavigationView.find_page], as well as with
// [method@NavigationView.push_by_tag], [method@NavigationView.pop_to_tag] or
// [method@NavigationView.replace_with_tags].
//
// Tags must be unique within each [class@NavigationView].
//
// The tag also must be set to use the `navigation.push` action.
func (x *NavigationPage) SetTag(TagVar string) {

	xNavigationPageSetTag(x.GoPointer(), TagVar)

}

var xNavigationPageSetTitle func(uintptr, string)

// Sets the title of @self.
//
// It's displayed in [class@HeaderBar] instead of the window title, and used as
// the tooltip on the next page's back button, as well as by screen reader.
func (x *NavigationPage) SetTitle(TitleVar string) {

	xNavigationPageSetTitle(x.GoPointer(), TitleVar)

}

func (c *NavigationPage) GoPointer() uintptr {
	return c.Ptr
}

func (c *NavigationPage) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the navigation view transition has been completed and the page
// is fully hidden.
//
// It will always be preceded by [signal@NavigationPage::hiding] or
// [signal@NavigationPage::showing].
func (x *NavigationPage) ConnectHidden(cb *func(NavigationPage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "hidden", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := NavigationPage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "hidden", cbRefPtr)
}

// Emitted when the page starts hiding at the beginning of the navigation view
// transition.
//
// It will always be followed by [signal@NavigationPage::hidden] or
// [signal@NavigationPage::shown].
func (x *NavigationPage) ConnectHiding(cb *func(NavigationPage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "hiding", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := NavigationPage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "hiding", cbRefPtr)
}

// Emitted when the page shows at the beginning of the navigation view
// transition.
//
// It will always be followed by [signal@NavigationPage::shown] or
// [signal@NavigationPage::hidden].
func (x *NavigationPage) ConnectShowing(cb *func(NavigationPage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "showing", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := NavigationPage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "showing", cbRefPtr)
}

// Emitted when the navigation view transition has been completed and the page
// is fully shown.
//
// It will always be preceded by [signal@NavigationPage::showing] or
// [signal@NavigationPage::hiding].
func (x *NavigationPage) ConnectShown(cb *func(NavigationPage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "shown", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := NavigationPage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "shown", cbRefPtr)
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *NavigationPage) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *NavigationPage) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *NavigationPage) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *NavigationPage) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *NavigationPage) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *NavigationPage) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *NavigationPage) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *NavigationPage) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *NavigationPage) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *NavigationPage) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *NavigationPage) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// A page-based navigation container.
//
// &lt;picture&gt;
//
//	&lt;source srcset="navigation-view-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="navigation-view.png" alt="navigation-view"&gt;
//
// &lt;/picture&gt;
//
// `AdwNavigationView` presents one child at a time, similar to
// [class@Gtk.Stack].
//
// `AdwNavigationView` can only contain [class@NavigationPage] children.
//
// It maintains a navigation stack that can be controlled with
// [method@NavigationView.push] and [method@NavigationView.pop]. The whole
// navigation stack can also be replaced using [method@NavigationView.replace].
//
// `AdwNavigationView` allows to manage pages statically or dynamically.
//
// Static pages can be added using the [method@NavigationView.add] method. The
// `AdwNavigationView` will keep a reference to these pages, but they aren't
// accessible to the user until [method@NavigationView.push] is called (except
// for the first page, which is pushed automatically). Use the
// [method@NavigationView.remove] method to remove them. This is useful for
// applications that have a small number of unique pages and just need
// navigation between them.
//
// Dynamic pages are automatically destroyed once they are popped off the
// navigation stack. To add a page like this, push it using the
// [method@NavigationView.push] method without calling
// [method@NavigationView.add] first.
//
// ## Tags
//
// Static pages, as well as any pages in the navigation stack, can be accessed
// by their [property@NavigationPage:tag]. For example,
// [method@NavigationView.push_by_tag] can be used to push a static page that's
// not in the navigation stack without having to keep a reference to it manually.
//
// ## Header Bar Integration
//
// When used inside `AdwNavigationView`, [class@HeaderBar] will automatically
// display a back button that can be used to go back to the previous page when
// possible. The button also has a context menu, allowing to pop multiple pages
// at once, potentially across multiple navigation views.
//
// Set [property@HeaderBar:show-back-button] to `FALSE` to disable this behavior
// in rare scenarios where it's unwanted.
//
// `AdwHeaderBar` will also display the title of the `AdwNavigationPage` it's
// placed into, so most applications shouldn't need to customize it at all.
//
// ## Shortcuts and Gestures
//
// `AdwNavigationView` supports the following shortcuts for going to the
// previous page:
//
//   - &lt;kbd&gt;Escape&lt;/kbd&gt; (unless [property@NavigationView:pop-on-escape] is set to
//     `FALSE`)
//   - &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;←&lt;/kbd&gt;
//   - Back mouse button
//
// Additionally, it supports interactive gestures:
//
// - One-finger swipe towards the right on touchscreens
// - Scrolling towards the right on touchpads (usually two-finger swipe)
//
// These gestures have transitions enabled regardless of the
// [property@NavigationView:animate-transitions] value.
//
// Applications can also enable shortcuts for pushing another page onto the
// navigation stack via connecting to the [signal@NavigationView::get-next-page]
// signal, in that case the following shortcuts are supported:
//
// - &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;→&lt;/kbd&gt;
// - Forward mouse button
// - Swipe/scrolling towards the left
//
// For right-to-left locales, the gestures and shortcuts are reversed.
//
// [property@NavigationPage:can-pop] can be used to disable them, along with the
// header bar back buttons.
//
// ## Actions
//
// `AdwNavigationView` defines actions for controlling the navigation stack.
// actions for controlling the navigation stack:
//
// - `navigation.push` takes a string parameter specifying the tag of the page to
// push, and is equivalent to calling [method@NavigationView.push_by_tag].
//
// - `navigation.pop` doesn't take any parameters and pops the current page from
// the navigation stack, equivalent to calling [method@NavigationView.pop].
//
// ## `AdwNavigationView` as `GtkBuildable`
//
// `AdwNavigationView` allows to add pages as children, equivalent to using the
// [method@NavigationView.add] method.
//
// Example of an `AdwNavigationView` UI definition:
//
// ```xml
// &lt;object class="AdwNavigationView"&gt;
//
//	&lt;child&gt;
//	  &lt;object class="AdwNavigationPage"&gt;
//	    &lt;property name="title" translatable="yes"&gt;Page 1&lt;/property&gt;
//	    &lt;property name="child"&gt;
//	      &lt;object class="AdwToolbarView"&gt;
//	        &lt;child type="top"&gt;
//	          &lt;object class="AdwHeaderBar"/&gt;
//	        &lt;/child&gt;
//	        &lt;property name="content"&gt;
//	          &lt;object class="GtkButton"&gt;
//	            &lt;property name="label" translatable="yes"&gt;Open Page 2&lt;/property&gt;
//	            &lt;property name="halign"&gt;center&lt;/property&gt;
//	            &lt;property name="valign"&gt;center&lt;/property&gt;
//	            &lt;property name="action-name"&gt;navigation.push&lt;/property&gt;
//	            &lt;property name="action-target"&gt;'page-2'&lt;/property&gt;
//	            &lt;style&gt;
//	              &lt;class name="pill"/&gt;
//	             &lt;/style&gt;
//	          &lt;/object&gt;
//	        &lt;/property&gt;
//	      &lt;/object&gt;
//	    &lt;/property&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//	&lt;child&gt;
//	  &lt;object class="AdwNavigationPage"&gt;
//	    &lt;property name="title" translatable="yes"&gt;Page 2&lt;/property&gt;
//	    &lt;property name="tag"&gt;page-2&lt;/property&gt;
//	    &lt;property name="child"&gt;
//	      &lt;object class="AdwToolbarView"&gt;
//	        &lt;child type="top"&gt;
//	          &lt;object class="AdwHeaderBar"/&gt;
//	        &lt;/child&gt;
//	        &lt;property name="content"&gt;
//	          &lt;!-- ... --&gt;
//	        &lt;/property&gt;
//	      &lt;/object&gt;
//	    &lt;/property&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//
// &lt;/object&gt;
// ```
//
// &lt;picture&gt;
//
//	&lt;source srcset="navigation-view-example-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img src="navigation-view-example.png" alt="navigation-view-example"&gt;
//
// &lt;/picture&gt;
//
// ## CSS nodes
//
// `AdwNavigationView` has a single CSS node with the name `navigation-view`.
//
// ## Accessibility
//
// `AdwNavigationView` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
type NavigationView struct {
	gtk.Widget
}

var xNavigationViewGLibType func() types.GType

func NavigationViewGLibType() types.GType {
	return xNavigationViewGLibType()
}

func NavigationViewNewFromInternalPtr(ptr uintptr) *NavigationView {
	cls := &NavigationView{}
	cls.Ptr = ptr
	return cls
}

var xNewNavigationView func() uintptr

// Creates a new `AdwNavigationView`.
func NewNavigationView() *NavigationView {
	var cls *NavigationView

	cret := xNewNavigationView()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NavigationView{}
	cls.Ptr = cret
	return cls
}

var xNavigationViewAdd func(uintptr, uintptr)

// Permanently adds @page to @self.
//
// Any page that has been added will stay in @self even after being popped from
// the navigation stack.
//
// Adding a page while no page is visible will automatically push it to the
// navigation stack.
//
// See [method@NavigationView.remove].
func (x *NavigationView) Add(PageVar *NavigationPage) {

	xNavigationViewAdd(x.GoPointer(), PageVar.GoPointer())

}

var xNavigationViewFindPage func(uintptr, string) uintptr

// Finds a page in @self by its tag.
//
// See [property@NavigationPage:tag].
func (x *NavigationView) FindPage(TagVar string) *NavigationPage {
	var cls *NavigationPage

	cret := xNavigationViewFindPage(x.GoPointer(), TagVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NavigationPage{}
	cls.Ptr = cret
	return cls
}

var xNavigationViewGetAnimateTransitions func(uintptr) bool

// Gets whether @self animates page transitions.
func (x *NavigationView) GetAnimateTransitions() bool {

	cret := xNavigationViewGetAnimateTransitions(x.GoPointer())
	return cret
}

var xNavigationViewGetNavigationStack func(uintptr) uintptr

// Returns a [iface@Gio.ListModel] that contains the pages in navigation stack.
//
// The pages are sorted from root page to visible page.
//
// This can be used to keep an up-to-date view.
func (x *NavigationView) GetNavigationStack() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xNavigationViewGetNavigationStack(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xNavigationViewGetPopOnEscape func(uintptr) bool

// Gets whether pressing Escape pops the current page on @self.
func (x *NavigationView) GetPopOnEscape() bool {

	cret := xNavigationViewGetPopOnEscape(x.GoPointer())
	return cret
}

var xNavigationViewGetPreviousPage func(uintptr, uintptr) uintptr

// Gets the previous page for @page.
//
// If @page is in the navigation stack, returns the page popping @page will
// reveal.
//
// If @page is the root page or is not in the navigation stack, returns `NULL`.
func (x *NavigationView) GetPreviousPage(PageVar *NavigationPage) *NavigationPage {
	var cls *NavigationPage

	cret := xNavigationViewGetPreviousPage(x.GoPointer(), PageVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NavigationPage{}
	cls.Ptr = cret
	return cls
}

var xNavigationViewGetVisiblePage func(uintptr) uintptr

// Gets the currently visible page in @self.
func (x *NavigationView) GetVisiblePage() *NavigationPage {
	var cls *NavigationPage

	cret := xNavigationViewGetVisiblePage(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NavigationPage{}
	cls.Ptr = cret
	return cls
}

var xNavigationViewPop func(uintptr) bool

// Pops the visible page from the navigation stack.
//
// Does nothing if the navigation stack contains less than two pages.
//
// If [method@NavigationView.add] hasn't been called, the page is automatically
// removed.
//
// [signal@NavigationView::popped] will be emitted for the current visible page.
//
// See [method@NavigationView.pop_to_page] and
// [method@NavigationView.pop_to_tag].
func (x *NavigationView) Pop() bool {

	cret := xNavigationViewPop(x.GoPointer())
	return cret
}

var xNavigationViewPopToPage func(uintptr, uintptr) bool

// Pops pages from the navigation stack until @page is visible.
//
// @page must be in the navigation stack.
//
// If [method@NavigationView.add] hasn't been called for any of the popped pages,
// they are automatically removed.
//
// [signal@NavigationView::popped] will be be emitted for each of the popped
// pages.
//
// See [method@NavigationView.pop] and [method@NavigationView.pop_to_tag].
func (x *NavigationView) PopToPage(PageVar *NavigationPage) bool {

	cret := xNavigationViewPopToPage(x.GoPointer(), PageVar.GoPointer())
	return cret
}

var xNavigationViewPopToTag func(uintptr, string) bool

// Pops pages from the navigation stack until page with the tag @tag is visible.
//
// The page must be in the navigation stack.
//
// If [method@NavigationView.add] hasn't been called for any of the popped pages,
// they are automatically removed.
//
// [signal@NavigationView::popped] will be emitted for each of the popped pages.
//
// See [method@NavigationView.pop_to_page] and [property@NavigationPage:tag].
func (x *NavigationView) PopToTag(TagVar string) bool {

	cret := xNavigationViewPopToTag(x.GoPointer(), TagVar)
	return cret
}

var xNavigationViewPush func(uintptr, uintptr)

// Pushes @page onto the navigation stack.
//
// If [method@NavigationView.add] hasn't been called, the page is automatically
// removed once it's popped.
//
// [signal@NavigationView::pushed] will be emitted for @page.
//
// See [method@NavigationView.push_by_tag].
func (x *NavigationView) Push(PageVar *NavigationPage) {

	xNavigationViewPush(x.GoPointer(), PageVar.GoPointer())

}

var xNavigationViewPushByTag func(uintptr, string)

// Pushes the page with the tag @tag onto the navigation stack.
//
// If [method@NavigationView.add] hasn't been called, the page is automatically
// removed once it's popped.
//
// [signal@NavigationView::pushed] will be emitted for the page.
//
// See [method@NavigationView.push] and [property@NavigationPage:tag].
func (x *NavigationView) PushByTag(TagVar string) {

	xNavigationViewPushByTag(x.GoPointer(), TagVar)

}

var xNavigationViewRemove func(uintptr, uintptr)

// Removes @page from @self.
//
// If @page is currently in the navigation stack, it will be removed once it's
// popped. Otherwise, it's removed immediately.
//
// See [method@NavigationView.add].
func (x *NavigationView) Remove(PageVar *NavigationPage) {

	xNavigationViewRemove(x.GoPointer(), PageVar.GoPointer())

}

var xNavigationViewReplace func(uintptr, uintptr, int)

// Replaces the current navigation stack with @pages.
//
// The last page becomes the visible page.
//
// Replacing the navigation stack has no animation.
//
// If [method@NavigationView.add] hasn't been called for any pages that are no
// longer in the navigation stack, they are automatically removed.
//
// @n_pages can be 0, in that case no page will be visible after calling this
// method. This can be useful for removing all pages from @self.
//
// The [signal@NavigationView::replaced] signal will be emitted.
//
// See [method@NavigationView.replace_with_tags].
func (x *NavigationView) Replace(PagesVar uintptr, NPagesVar int) {

	xNavigationViewReplace(x.GoPointer(), PagesVar, NPagesVar)

}

var xNavigationViewReplaceWithTags func(uintptr, []string, int)

// Replaces the current navigation stack with pages with the tags @tags.
//
// The last page becomes the visible page.
//
// Replacing the navigation stack has no animation.
//
// If [method@NavigationView.add] hasn't been called for any pages that are no
// longer in the navigation stack, they are automatically removed.
//
// @n_tags can be 0, in that case no page will be visible after calling this
// method. This can be useful for removing all pages from @self.
//
// The [signal@NavigationView::replaced] signal will be emitted.
//
// See [method@NavigationView.replace] and [property@NavigationPage:tag].
func (x *NavigationView) ReplaceWithTags(TagsVar []string, NTagsVar int) {

	xNavigationViewReplaceWithTags(x.GoPointer(), TagsVar, NTagsVar)

}

var xNavigationViewSetAnimateTransitions func(uintptr, bool)

// Sets whether @self should animate page transitions.
//
// Gesture-based transitions are always animated.
func (x *NavigationView) SetAnimateTransitions(AnimateTransitionsVar bool) {

	xNavigationViewSetAnimateTransitions(x.GoPointer(), AnimateTransitionsVar)

}

var xNavigationViewSetPopOnEscape func(uintptr, bool)

// Sets whether pressing Escape pops the current page on @self.
//
// Applications using `AdwNavigationView` to implement a browser may want to
// disable it.
func (x *NavigationView) SetPopOnEscape(PopOnEscapeVar bool) {

	xNavigationViewSetPopOnEscape(x.GoPointer(), PopOnEscapeVar)

}

func (c *NavigationView) GoPointer() uintptr {
	return c.Ptr
}

func (c *NavigationView) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when a push shortcut or a gesture is triggered.
//
// To support the push shortcuts and gestures, the application is expected to
// return the page to push in the handler.
//
// This signal can be emitted multiple times for the gestures, for example
// when the gesture is cancelled by the user. As such, the application must
// not make any irreversible changes in the handler, such as removing the page
// from a forward stack.
//
// Instead, it should be done in the [signal@NavigationView::pushed] handler.
func (x *NavigationView) ConnectGetNextPage(cb *func(NavigationView) NavigationPage) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "get-next-page", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) uintptr {
		fa := NavigationView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		GetNextPageCls := cbFn(fa)
		return GetNextPageCls.Ptr

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "get-next-page", cbRefPtr)
}

// Emitted after @page has been popped from the navigation stack.
//
// See [method@NavigationView.pop].
//
// When using [method@NavigationView.pop_to_page] or
// [method@NavigationView.pop_to_tag], this signal is emitted for each of the
// popped pages.
func (x *NavigationView) ConnectPopped(cb *func(NavigationView, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "popped", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PageVarp uintptr) {
		fa := NavigationView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "popped", cbRefPtr)
}

// Emitted after a page has been pushed to the navigation stack.
//
// See [method@NavigationView.push].
func (x *NavigationView) ConnectPushed(cb *func(NavigationView)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "pushed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := NavigationView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "pushed", cbRefPtr)
}

// Emitted after the navigation stack has been replaced.
//
// See [method@NavigationView.replace].
func (x *NavigationView) ConnectReplaced(cb *func(NavigationView)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "replaced", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := NavigationView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "replaced", cbRefPtr)
}

// Gets the progress @self will snap back to after the gesture is canceled.
func (x *NavigationView) GetCancelProgress() float64 {

	cret := XAdwSwipeableGetCancelProgress(x.GoPointer())
	return cret
}

// Gets the swipe distance of @self.
//
// This corresponds to how many pixels 1 unit represents.
func (x *NavigationView) GetDistance() float64 {

	cret := XAdwSwipeableGetDistance(x.GoPointer())
	return cret
}

// Gets the current progress of @self.
func (x *NavigationView) GetProgress() float64 {

	cret := XAdwSwipeableGetProgress(x.GoPointer())
	return cret
}

// Gets the snap points of @self.
//
// Each snap point represents a progress value that is considered acceptable to
// end the swipe on.
func (x *NavigationView) GetSnapPoints(NSnapPointsVar int) []float64 {

	cret := XAdwSwipeableGetSnapPoints(x.GoPointer(), NSnapPointsVar)
	return cret
}

// Gets the area @self can start a swipe from for the given direction and
// gesture type.
//
// This can be used to restrict swipes to only be possible from a certain area,
// for example, to only allow edge swipes, or to have a draggable element and
// ignore swipes elsewhere.
//
// If not implemented, the default implementation returns the allocation of
// @self, allowing swipes from anywhere.
func (x *NavigationView) GetSwipeArea(NavigationDirectionVar NavigationDirection, IsDragVar bool, RectVar *gdk.Rectangle) {

	XAdwSwipeableGetSwipeArea(x.GoPointer(), NavigationDirectionVar, IsDragVar, RectVar)

}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *NavigationView) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *NavigationView) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *NavigationView) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *NavigationView) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *NavigationView) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *NavigationView) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *NavigationView) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *NavigationView) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *NavigationView) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *NavigationView) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *NavigationView) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("ADW"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNavigationPageGLibType, lib, "adw_navigation_page_get_type")

	core.PuregoSafeRegister(&xNewNavigationPage, lib, "adw_navigation_page_new")
	core.PuregoSafeRegister(&xNewNavigationPageWithTag, lib, "adw_navigation_page_new_with_tag")

	core.PuregoSafeRegister(&xNavigationPageGetCanPop, lib, "adw_navigation_page_get_can_pop")
	core.PuregoSafeRegister(&xNavigationPageGetChild, lib, "adw_navigation_page_get_child")
	core.PuregoSafeRegister(&xNavigationPageGetTag, lib, "adw_navigation_page_get_tag")
	core.PuregoSafeRegister(&xNavigationPageGetTitle, lib, "adw_navigation_page_get_title")
	core.PuregoSafeRegister(&xNavigationPageSetCanPop, lib, "adw_navigation_page_set_can_pop")
	core.PuregoSafeRegister(&xNavigationPageSetChild, lib, "adw_navigation_page_set_child")
	core.PuregoSafeRegister(&xNavigationPageSetTag, lib, "adw_navigation_page_set_tag")
	core.PuregoSafeRegister(&xNavigationPageSetTitle, lib, "adw_navigation_page_set_title")

	core.PuregoSafeRegister(&xNavigationViewGLibType, lib, "adw_navigation_view_get_type")

	core.PuregoSafeRegister(&xNewNavigationView, lib, "adw_navigation_view_new")

	core.PuregoSafeRegister(&xNavigationViewAdd, lib, "adw_navigation_view_add")
	core.PuregoSafeRegister(&xNavigationViewFindPage, lib, "adw_navigation_view_find_page")
	core.PuregoSafeRegister(&xNavigationViewGetAnimateTransitions, lib, "adw_navigation_view_get_animate_transitions")
	core.PuregoSafeRegister(&xNavigationViewGetNavigationStack, lib, "adw_navigation_view_get_navigation_stack")
	core.PuregoSafeRegister(&xNavigationViewGetPopOnEscape, lib, "adw_navigation_view_get_pop_on_escape")
	core.PuregoSafeRegister(&xNavigationViewGetPreviousPage, lib, "adw_navigation_view_get_previous_page")
	core.PuregoSafeRegister(&xNavigationViewGetVisiblePage, lib, "adw_navigation_view_get_visible_page")
	core.PuregoSafeRegister(&xNavigationViewPop, lib, "adw_navigation_view_pop")
	core.PuregoSafeRegister(&xNavigationViewPopToPage, lib, "adw_navigation_view_pop_to_page")
	core.PuregoSafeRegister(&xNavigationViewPopToTag, lib, "adw_navigation_view_pop_to_tag")
	core.PuregoSafeRegister(&xNavigationViewPush, lib, "adw_navigation_view_push")
	core.PuregoSafeRegister(&xNavigationViewPushByTag, lib, "adw_navigation_view_push_by_tag")
	core.PuregoSafeRegister(&xNavigationViewRemove, lib, "adw_navigation_view_remove")
	core.PuregoSafeRegister(&xNavigationViewReplace, lib, "adw_navigation_view_replace")
	core.PuregoSafeRegister(&xNavigationViewReplaceWithTags, lib, "adw_navigation_view_replace_with_tags")
	core.PuregoSafeRegister(&xNavigationViewSetAnimateTransitions, lib, "adw_navigation_view_set_animate_transitions")
	core.PuregoSafeRegister(&xNavigationViewSetPopOnEscape, lib, "adw_navigation_view_set_pop_on_escape")

}
