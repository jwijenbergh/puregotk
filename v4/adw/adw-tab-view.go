// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type TabPageClass struct {
	ParentClass uintptr
}

func (x *TabPageClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type TabViewClass struct {
	ParentClass uintptr
}

func (x *TabViewClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Describes available shortcuts in an [class@TabView].
//
// Shortcuts can be set with [property@TabView:shortcuts], or added/removed
// individually with [method@TabView.add_shortcuts] and
// [method@TabView.remove_shortcuts].
//
// New values may be added to this enumeration over time.
type TabViewShortcuts int

const (

	// No shortcuts
	TabViewShortcutNoneValue TabViewShortcuts = 0
	// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Tab&lt;/kbd&gt; - switch to the next page, with looping
	TabViewShortcutControlTabValue TabViewShortcuts = 1
	// &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Tab&lt;/kbd&gt; - switch to the previous
	//   page, with looping
	TabViewShortcutControlShiftTabValue TabViewShortcuts = 2
	// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Page Up&lt;/kbd&gt; - switch to the previous page
	TabViewShortcutControlPageUpValue TabViewShortcuts = 4
	// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Page Down&lt;/kbd&gt; - switch to the next page
	TabViewShortcutControlPageDownValue TabViewShortcuts = 8
	// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Home&lt;/kbd&gt; - switch to the first page
	TabViewShortcutControlHomeValue TabViewShortcuts = 16
	// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;End&lt;/kbd&gt; - switch to the last page
	TabViewShortcutControlEndValue TabViewShortcuts = 32
	// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Page Up&lt;/kbd&gt; - move the selected
	//   page backward
	TabViewShortcutControlShiftPageUpValue TabViewShortcuts = 64
	// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Page Down&lt;/kbd&gt; - move the selected
	//   page forward
	TabViewShortcutControlShiftPageDownValue TabViewShortcuts = 128
	// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Home&lt;/kbd&gt; - move the selected page
	//   at the start
	TabViewShortcutControlShiftHomeValue TabViewShortcuts = 256
	// &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;End&lt;/kbd&gt; - move the current page at
	//   the end
	TabViewShortcutControlShiftEndValue TabViewShortcuts = 512
	// &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;1&lt;/kbd&gt;â‹¯&lt;kbd&gt;9&lt;/kbd&gt; - switch to pages 1-9
	TabViewShortcutAltDigitsValue TabViewShortcuts = 1024
	// &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;0&lt;/kbd&gt; - switch to page 10
	TabViewShortcutAltZeroValue TabViewShortcuts = 2048
	// All of the shortcuts
	TabViewShortcutAllShortcutsValue TabViewShortcuts = 4095
)

// An auxiliary class used by [class@TabView].
type TabPage struct {
	gobject.Object
}

func TabPageNewFromInternalPtr(ptr uintptr) *TabPage {
	cls := &TabPage{}
	cls.Ptr = ptr
	return cls
}

var xTabPageGetChild func(uintptr) uintptr

// Gets the child of @self.
func (x *TabPage) GetChild() *gtk.Widget {
	var cls *gtk.Widget

	cret := xTabPageGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

var xTabPageGetIcon func(uintptr) uintptr

// Gets the icon of @self.
func (x *TabPage) GetIcon() *gio.IconBase {
	var cls *gio.IconBase

	cret := xTabPageGetIcon(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.IconBase{}
	cls.Ptr = cret
	return cls
}

var xTabPageGetIndicatorActivatable func(uintptr) bool

// Gets whether the indicator of @self is activatable.
func (x *TabPage) GetIndicatorActivatable() bool {

	cret := xTabPageGetIndicatorActivatable(x.GoPointer())
	return cret
}

var xTabPageGetIndicatorIcon func(uintptr) uintptr

// Gets the indicator icon of @self.
func (x *TabPage) GetIndicatorIcon() *gio.IconBase {
	var cls *gio.IconBase

	cret := xTabPageGetIndicatorIcon(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.IconBase{}
	cls.Ptr = cret
	return cls
}

var xTabPageGetIndicatorTooltip func(uintptr) string

// Gets the tooltip of the indicator icon of @self.
func (x *TabPage) GetIndicatorTooltip() string {

	cret := xTabPageGetIndicatorTooltip(x.GoPointer())
	return cret
}

var xTabPageGetKeyword func(uintptr) string

// Gets the search keyword of @self.
func (x *TabPage) GetKeyword() string {

	cret := xTabPageGetKeyword(x.GoPointer())
	return cret
}

var xTabPageGetLiveThumbnail func(uintptr) bool

// Gets whether to live thumbnail is enabled @self.
func (x *TabPage) GetLiveThumbnail() bool {

	cret := xTabPageGetLiveThumbnail(x.GoPointer())
	return cret
}

var xTabPageGetLoading func(uintptr) bool

// Gets whether @self is loading.
func (x *TabPage) GetLoading() bool {

	cret := xTabPageGetLoading(x.GoPointer())
	return cret
}

var xTabPageGetNeedsAttention func(uintptr) bool

// Gets whether @self needs attention.
func (x *TabPage) GetNeedsAttention() bool {

	cret := xTabPageGetNeedsAttention(x.GoPointer())
	return cret
}

var xTabPageGetParent func(uintptr) uintptr

// Gets the parent page of @self.
//
// See [method@TabView.add_page] and [method@TabView.close_page].
func (x *TabPage) GetParent() *TabPage {
	var cls *TabPage

	cret := xTabPageGetParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TabPage{}
	cls.Ptr = cret
	return cls
}

var xTabPageGetPinned func(uintptr) bool

// Gets whether @self is pinned.
//
// See [method@TabView.set_page_pinned].
func (x *TabPage) GetPinned() bool {

	cret := xTabPageGetPinned(x.GoPointer())
	return cret
}

var xTabPageGetSelected func(uintptr) bool

// Gets whether @self is selected.
func (x *TabPage) GetSelected() bool {

	cret := xTabPageGetSelected(x.GoPointer())
	return cret
}

var xTabPageGetThumbnailXalign func(uintptr) float32

// Gets the horizontal alignment of the thumbnail for @self.
func (x *TabPage) GetThumbnailXalign() float32 {

	cret := xTabPageGetThumbnailXalign(x.GoPointer())
	return cret
}

var xTabPageGetThumbnailYalign func(uintptr) float32

// Gets the vertical alignment of the thumbnail for @self.
func (x *TabPage) GetThumbnailYalign() float32 {

	cret := xTabPageGetThumbnailYalign(x.GoPointer())
	return cret
}

var xTabPageGetTitle func(uintptr) string

// Gets the title of @self.
func (x *TabPage) GetTitle() string {

	cret := xTabPageGetTitle(x.GoPointer())
	return cret
}

var xTabPageGetTooltip func(uintptr) string

// Gets the tooltip of @self.
func (x *TabPage) GetTooltip() string {

	cret := xTabPageGetTooltip(x.GoPointer())
	return cret
}

var xTabPageInvalidateThumbnail func(uintptr)

// Invalidates thumbnail for @self.
//
// If an [class@TabOverview] is open, the thumbnail representing @self will be
// immediately updated. Otherwise it will be update when opening the overview.
//
// Does nothing if [property@TabPage:live-thumbnail] is set to `TRUE`.
//
// See also [method@TabView.invalidate_thumbnails].
func (x *TabPage) InvalidateThumbnail() {

	xTabPageInvalidateThumbnail(x.GoPointer())

}

var xTabPageSetIcon func(uintptr, uintptr)

// Sets the icon of @self.
//
// [class@TabBar] and [class@TabOverview] display the icon next to the title,
// unless [property@TabPage:loading] is set to `TRUE`.
//
// `AdwTabBar` also won't show the icon if the page is pinned and
// [propertyTabPage:indicator-icon] is set.
func (x *TabPage) SetIcon(IconVar gio.Icon) {

	xTabPageSetIcon(x.GoPointer(), IconVar.GoPointer())

}

var xTabPageSetIndicatorActivatable func(uintptr, bool)

// Sets whether the indicator of @self is activatable.
//
// If set to `TRUE`, [signal@TabView::indicator-activated] will be emitted
// when the indicator icon is clicked.
//
// If [property@TabPage:indicator-icon] is not set, does nothing.
func (x *TabPage) SetIndicatorActivatable(ActivatableVar bool) {

	xTabPageSetIndicatorActivatable(x.GoPointer(), ActivatableVar)

}

var xTabPageSetIndicatorIcon func(uintptr, uintptr)

// Sets the indicator icon of @self.
//
// A common use case is an audio or camera indicator in a web browser.
//
// [class@TabBar] will show it at the beginning of the tab, alongside icon
// representing [property@TabPage:icon] or loading spinner.
//
// If the page is pinned, the indicator will be shown instead of icon or
// spinner.
//
// [class@TabOverview] will show it at the at the top part of the thumbnail.
//
// [property@TabPage:indicator-tooltip] can be used to set the tooltip on the
// indicator icon.
//
// If [property@TabPage:indicator-activatable] is set to `TRUE`, the
// indicator icon can act as a button.
func (x *TabPage) SetIndicatorIcon(IndicatorIconVar gio.Icon) {

	xTabPageSetIndicatorIcon(x.GoPointer(), IndicatorIconVar.GoPointer())

}

var xTabPageSetIndicatorTooltip func(uintptr, string)

// Sets the tooltip of the indicator icon of @self.
//
// The tooltip can be marked up with the Pango text markup language.
//
// See [property@TabPage:indicator-icon].
func (x *TabPage) SetIndicatorTooltip(TooltipVar string) {

	xTabPageSetIndicatorTooltip(x.GoPointer(), TooltipVar)

}

var xTabPageSetKeyword func(uintptr, string)

// Sets the search keyword for @self.
//
// [class@TabOverview] can search pages by their keywords in addition to their
// titles and tooltips.
//
// Keywords allow to include e.g. page URLs into tab search in a web browser.
func (x *TabPage) SetKeyword(KeywordVar string) {

	xTabPageSetKeyword(x.GoPointer(), KeywordVar)

}

var xTabPageSetLiveThumbnail func(uintptr, bool)

// Sets whether to enable live thumbnail for @self.
//
// When set to `TRUE`, @self's thumbnail in [class@TabOverview] will update
// immediately when @self is redrawn or resized.
//
// If it's set to `FALSE`, the thumbnail will only be live when the @self is
// selected, and otherwise it will be static and will only update when
// [method@TabPage.invalidate_thumbnail] or
// [method@TabView.invalidate_thumbnails] is called.
func (x *TabPage) SetLiveThumbnail(LiveThumbnailVar bool) {

	xTabPageSetLiveThumbnail(x.GoPointer(), LiveThumbnailVar)

}

var xTabPageSetLoading func(uintptr, bool)

// Sets whether @self is loading.
//
// If set to `TRUE`, [class@TabBar] and [class@TabOverview] will display a
// spinner in place of icon.
//
// If the page is pinned and [property@TabPage:indicator-icon] is set, loading
// status will not be visible with `AdwTabBar`.
func (x *TabPage) SetLoading(LoadingVar bool) {

	xTabPageSetLoading(x.GoPointer(), LoadingVar)

}

var xTabPageSetNeedsAttention func(uintptr, bool)

// Sets whether @self needs attention.
//
// [class@TabBar] will display a line under the tab representing the page if
// set to `TRUE`. If the tab is not visible, the corresponding edge of the tab
// bar will be highlighted.
//
// [class@TabOverview] will display a dot in the corner of the thumbnail if set
// to `TRUE`.
//
// [class@TabButton] will display a dot if any of the pages that aren't
// selected have [property@TabPage:needs-attention] set to `TRUE`.
func (x *TabPage) SetNeedsAttention(NeedsAttentionVar bool) {

	xTabPageSetNeedsAttention(x.GoPointer(), NeedsAttentionVar)

}

var xTabPageSetThumbnailXalign func(uintptr, float32)

// Sets the horizontal alignment of the thumbnail for @self.
//
// If the page is so wide that [class@TabOverview] can't display it completely
// and has to crop it, horizontal alignment will determine which part of the
// page will be visible.
//
// For example, 0.5 means the center of the page will be visible, 0 means the
// start edge will be visible and 1 means the end edge will be visible.
//
// The default horizontal alignment is 0.
func (x *TabPage) SetThumbnailXalign(XalignVar float32) {

	xTabPageSetThumbnailXalign(x.GoPointer(), XalignVar)

}

var xTabPageSetThumbnailYalign func(uintptr, float32)

// Sets the vertical alignment of the thumbnail for @self.
//
// If the page is so tall that [class@TabOverview] can't display it completely
// and has to crop it, vertical alignment will determine which part of the page
// will be visible.
//
// For example, 0.5 means the center of the page will be visible, 0 means the
// top edge will be visible and 1 means the bottom edge will be visible.
//
// The default vertical alignment is 0.
func (x *TabPage) SetThumbnailYalign(YalignVar float32) {

	xTabPageSetThumbnailYalign(x.GoPointer(), YalignVar)

}

var xTabPageSetTitle func(uintptr, string)

// [class@TabBar] will display it in the center of the tab unless it's pinned,
// and will use it as a tooltip unless [property@TabPage:tooltip] is set.
//
// [class@TabOverview] will display it below the thumbnail unless it's pinned,
// or inside the card otherwise, and will use it as a tooltip unless
// [property@TabPage:tooltip] is set.
//
// Sets the title of @self.
func (x *TabPage) SetTitle(TitleVar string) {

	xTabPageSetTitle(x.GoPointer(), TitleVar)

}

var xTabPageSetTooltip func(uintptr, string)

// Sets the tooltip of @self.
//
// The tooltip can be marked up with the Pango text markup language.
//
// If not set, [class@TabBar] and [class@TabOverview] will use
// [property@TabPage:title] as a tooltip instead.
func (x *TabPage) SetTooltip(TooltipVar string) {

	xTabPageSetTooltip(x.GoPointer(), TooltipVar)

}

func (c *TabPage) GoPointer() uintptr {
	return c.Ptr
}

func (c *TabPage) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *TabPage) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *TabPage) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *TabPage) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *TabPage) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *TabPage) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TabPage) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *TabPage) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TabPage) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *TabPage) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TabPage) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// A dynamic tabbed container.
//
// `AdwTabView` is a container which shows one child at a time. While it
// provides keyboard shortcuts for switching between pages, it does not provide
// a visible tab switcher and relies on external widgets for that, such as
// [class@TabBar], [class@TabOverview] and [class@TabButton].
//
// `AdwTabView` maintains a [class@TabPage] object for each page, which holds
// additional per-page properties. You can obtain the `AdwTabPage` for a page
// with [method@TabView.get_page], and as the return value for
// [method@TabView.append] and other functions for adding children.
//
// `AdwTabView` only aims to be useful for dynamic tabs in multi-window
// document-based applications, such as web browsers, file managers, text
// editors or terminals. It does not aim to replace [class@Gtk.Notebook] for use
// cases such as tabbed dialogs.
//
// As such, it does not support disabling page reordering or detaching.
//
// `AdwTabView` adds a number of global page switching and reordering shortcuts.
// The [property@TabView:shortcuts] property can be used to manage them.
//
// See [flags@TabViewShortcuts] for the list of the available shortcuts. All of
// the shortcuts are enabled by default.
//
// [method@TabView.add_shortcuts] and [method@TabView.remove_shortcuts] can be
// used to manage shortcuts in a convenient way, for example:
//
// ```c
// adw_tab_view_remove_shortcuts (view, ADW_TAB_VIEW_SHORTCUT_CONTROL_HOME |
//
//	ADW_TAB_VIEW_SHORTCUT_CONTROL_END);
//
// ```
//
// ## CSS nodes
//
// `AdwTabView` has a main CSS node with the name `tabview`.
//
// ## Accessibility
//
// `AdwTabView` uses the `GTK_ACCESSIBLE_ROLE_TAB_PANEL` for the tab pages which
// are the accessible parent objects of the child widgets.
type TabView struct {
	gtk.Widget
}

func TabViewNewFromInternalPtr(ptr uintptr) *TabView {
	cls := &TabView{}
	cls.Ptr = ptr
	return cls
}

var xNewTabView func() uintptr

// Creates a new `AdwTabView`.
func NewTabView() *TabView {
	var cls *TabView

	cret := xNewTabView()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TabView{}
	cls.Ptr = cret
	return cls
}

var xTabViewAddPage func(uintptr, uintptr, uintptr) uintptr

// Adds @child to @self with @parent as the parent.
//
// This function can be used to automatically position new pages, and to select
// the correct page when this page is closed while being selected (see
// [method@TabView.close_page]).
//
// If @parent is `NULL`, this function is equivalent to [method@TabView.append].
func (x *TabView) AddPage(ChildVar *gtk.Widget, ParentVar *TabPage) *TabPage {
	var cls *TabPage

	cret := xTabViewAddPage(x.GoPointer(), ChildVar.GoPointer(), ParentVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TabPage{}
	cls.Ptr = cret
	return cls
}

var xTabViewAddShortcuts func(uintptr, TabViewShortcuts)

// Adds @shortcuts for @self.
//
// See [property@TabView:shortcuts] for details.
func (x *TabView) AddShortcuts(ShortcutsVar TabViewShortcuts) {

	xTabViewAddShortcuts(x.GoPointer(), ShortcutsVar)

}

var xTabViewAppend func(uintptr, uintptr) uintptr

// Inserts @child as the last non-pinned page.
func (x *TabView) Append(ChildVar *gtk.Widget) *TabPage {
	var cls *TabPage

	cret := xTabViewAppend(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TabPage{}
	cls.Ptr = cret
	return cls
}

var xTabViewAppendPinned func(uintptr, uintptr) uintptr

// Inserts @child as the last pinned page.
func (x *TabView) AppendPinned(ChildVar *gtk.Widget) *TabPage {
	var cls *TabPage

	cret := xTabViewAppendPinned(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TabPage{}
	cls.Ptr = cret
	return cls
}

var xTabViewCloseOtherPages func(uintptr, uintptr)

// Requests to close all pages other than @page.
func (x *TabView) CloseOtherPages(PageVar *TabPage) {

	xTabViewCloseOtherPages(x.GoPointer(), PageVar.GoPointer())

}

var xTabViewClosePage func(uintptr, uintptr)

// Requests to close @page.
//
// Calling this function will result in the [signal@TabView::close-page] signal
// being emitted for @page. Closing the page can then be confirmed or
// denied via [method@TabView.close_page_finish].
//
// If the page is waiting for a [method@TabView.close_page_finish] call, this
// function will do nothing.
//
// The default handler for [signal@TabView::close-page] will immediately confirm
// closing the page if it's non-pinned, or reject it if it's pinned. This
// behavior can be changed by registering your own handler for that signal.
//
// If @page was selected, another page will be selected instead:
//
// If the [property@TabPage:parent] value is `NULL`, the next page will be
// selected when possible, or if the page was already last, the previous page
// will be selected instead.
//
// If it's not `NULL`, the previous page will be selected if it's a descendant
// (possibly indirect) of the parent. If both the previous page and the parent
// are pinned, the parent will be selected instead.
func (x *TabView) ClosePage(PageVar *TabPage) {

	xTabViewClosePage(x.GoPointer(), PageVar.GoPointer())

}

var xTabViewClosePageFinish func(uintptr, uintptr, bool)

// Completes a [method@TabView.close_page] call for @page.
//
// If @confirm is `TRUE`, @page will be closed. If it's `FALSE`, it will be
// reverted to its previous state and [method@TabView.close_page] can be called
// for it again.
//
// This function should not be called unless a custom handler for
// [signal@TabView::close-page] is used.
func (x *TabView) ClosePageFinish(PageVar *TabPage, ConfirmVar bool) {

	xTabViewClosePageFinish(x.GoPointer(), PageVar.GoPointer(), ConfirmVar)

}

var xTabViewClosePagesAfter func(uintptr, uintptr)

// Requests to close all pages after @page.
func (x *TabView) ClosePagesAfter(PageVar *TabPage) {

	xTabViewClosePagesAfter(x.GoPointer(), PageVar.GoPointer())

}

var xTabViewClosePagesBefore func(uintptr, uintptr)

// Requests to close all pages before @page.
func (x *TabView) ClosePagesBefore(PageVar *TabPage) {

	xTabViewClosePagesBefore(x.GoPointer(), PageVar.GoPointer())

}

var xTabViewGetDefaultIcon func(uintptr) uintptr

// Gets the default icon of @self.
func (x *TabView) GetDefaultIcon() *gio.IconBase {
	var cls *gio.IconBase

	cret := xTabViewGetDefaultIcon(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.IconBase{}
	cls.Ptr = cret
	return cls
}

var xTabViewGetIsTransferringPage func(uintptr) bool

// Whether a page is being transferred.
//
// The corresponding property will be set to `TRUE` when a drag-n-drop tab
// transfer starts on any `AdwTabView`, and to `FALSE` after it ends.
//
// During the transfer, children cannot receive pointer input and a tab can
// be safely dropped on the tab view.
func (x *TabView) GetIsTransferringPage() bool {

	cret := xTabViewGetIsTransferringPage(x.GoPointer())
	return cret
}

var xTabViewGetMenuModel func(uintptr) uintptr

// Gets the tab context menu model for @self.
func (x *TabView) GetMenuModel() *gio.MenuModel {
	var cls *gio.MenuModel

	cret := xTabViewGetMenuModel(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.MenuModel{}
	cls.Ptr = cret
	return cls
}

var xTabViewGetNPages func(uintptr) int

// Gets the number of pages in @self.
func (x *TabView) GetNPages() int {

	cret := xTabViewGetNPages(x.GoPointer())
	return cret
}

var xTabViewGetNPinnedPages func(uintptr) int

// Gets the number of pinned pages in @self.
//
// See [method@TabView.set_page_pinned].
func (x *TabView) GetNPinnedPages() int {

	cret := xTabViewGetNPinnedPages(x.GoPointer())
	return cret
}

var xTabViewGetNthPage func(uintptr, int) uintptr

// Gets the [class@TabPage] representing the child at @position.
func (x *TabView) GetNthPage(PositionVar int) *TabPage {
	var cls *TabPage

	cret := xTabViewGetNthPage(x.GoPointer(), PositionVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TabPage{}
	cls.Ptr = cret
	return cls
}

var xTabViewGetPage func(uintptr, uintptr) uintptr

// Gets the [class@TabPage] object representing @child.
func (x *TabView) GetPage(ChildVar *gtk.Widget) *TabPage {
	var cls *TabPage

	cret := xTabViewGetPage(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TabPage{}
	cls.Ptr = cret
	return cls
}

var xTabViewGetPagePosition func(uintptr, uintptr) int

// Finds the position of @page in @self, starting from 0.
func (x *TabView) GetPagePosition(PageVar *TabPage) int {

	cret := xTabViewGetPagePosition(x.GoPointer(), PageVar.GoPointer())
	return cret
}

var xTabViewGetPages func(uintptr) uintptr

// Returns a [iface@Gio.ListModel] that contains the pages of @self.
//
// This can be used to keep an up-to-date view. The model also implements
// [iface@Gtk.SelectionModel] and can be used to track and change the selected
// page.
func (x *TabView) GetPages() *gtk.SelectionModelBase {
	var cls *gtk.SelectionModelBase

	cret := xTabViewGetPages(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.SelectionModelBase{}
	cls.Ptr = cret
	return cls
}

var xTabViewGetSelectedPage func(uintptr) uintptr

// Gets the currently selected page in @self.
func (x *TabView) GetSelectedPage() *TabPage {
	var cls *TabPage

	cret := xTabViewGetSelectedPage(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TabPage{}
	cls.Ptr = cret
	return cls
}

var xTabViewGetShortcuts func(uintptr) TabViewShortcuts

// Gets the enabled shortcuts for @self.
func (x *TabView) GetShortcuts() TabViewShortcuts {

	cret := xTabViewGetShortcuts(x.GoPointer())
	return cret
}

var xTabViewInsert func(uintptr, uintptr, int) uintptr

// Inserts a non-pinned page at @position.
//
// It's an error to try to insert a page before a pinned page, in that case
// [method@TabView.insert_pinned] should be used instead.
func (x *TabView) Insert(ChildVar *gtk.Widget, PositionVar int) *TabPage {
	var cls *TabPage

	cret := xTabViewInsert(x.GoPointer(), ChildVar.GoPointer(), PositionVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TabPage{}
	cls.Ptr = cret
	return cls
}

var xTabViewInsertPinned func(uintptr, uintptr, int) uintptr

// Inserts a pinned page at @position.
//
// It's an error to try to insert a pinned page after a non-pinned page, in
// that case [method@TabView.insert] should be used instead.
func (x *TabView) InsertPinned(ChildVar *gtk.Widget, PositionVar int) *TabPage {
	var cls *TabPage

	cret := xTabViewInsertPinned(x.GoPointer(), ChildVar.GoPointer(), PositionVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TabPage{}
	cls.Ptr = cret
	return cls
}

var xTabViewInvalidateThumbnails func(uintptr)

// Invalidates thumbnails for all pages in @self.
//
// This is a convenience method, equivalent to calling
// [method@TabPage.invalidate_thumbnail] on each page.
func (x *TabView) InvalidateThumbnails() {

	xTabViewInvalidateThumbnails(x.GoPointer())

}

var xTabViewPrepend func(uintptr, uintptr) uintptr

// Inserts @child as the first non-pinned page.
func (x *TabView) Prepend(ChildVar *gtk.Widget) *TabPage {
	var cls *TabPage

	cret := xTabViewPrepend(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TabPage{}
	cls.Ptr = cret
	return cls
}

var xTabViewPrependPinned func(uintptr, uintptr) uintptr

// Inserts @child as the first pinned page.
func (x *TabView) PrependPinned(ChildVar *gtk.Widget) *TabPage {
	var cls *TabPage

	cret := xTabViewPrependPinned(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TabPage{}
	cls.Ptr = cret
	return cls
}

var xTabViewRemoveShortcuts func(uintptr, TabViewShortcuts)

// Removes @shortcuts from @self.
//
// See [property@TabView:shortcuts] for details.
func (x *TabView) RemoveShortcuts(ShortcutsVar TabViewShortcuts) {

	xTabViewRemoveShortcuts(x.GoPointer(), ShortcutsVar)

}

var xTabViewReorderBackward func(uintptr, uintptr) bool

// Reorders @page to before its previous page if possible.
func (x *TabView) ReorderBackward(PageVar *TabPage) bool {

	cret := xTabViewReorderBackward(x.GoPointer(), PageVar.GoPointer())
	return cret
}

var xTabViewReorderFirst func(uintptr, uintptr) bool

// Reorders @page to the first possible position.
func (x *TabView) ReorderFirst(PageVar *TabPage) bool {

	cret := xTabViewReorderFirst(x.GoPointer(), PageVar.GoPointer())
	return cret
}

var xTabViewReorderForward func(uintptr, uintptr) bool

// Reorders @page to after its next page if possible.
func (x *TabView) ReorderForward(PageVar *TabPage) bool {

	cret := xTabViewReorderForward(x.GoPointer(), PageVar.GoPointer())
	return cret
}

var xTabViewReorderLast func(uintptr, uintptr) bool

// Reorders @page to the last possible position.
func (x *TabView) ReorderLast(PageVar *TabPage) bool {

	cret := xTabViewReorderLast(x.GoPointer(), PageVar.GoPointer())
	return cret
}

var xTabViewReorderPage func(uintptr, uintptr, int) bool

// Reorders @page to @position.
//
// It's a programmer error to try to reorder a pinned page after a non-pinned
// one, or a non-pinned page before a pinned one.
func (x *TabView) ReorderPage(PageVar *TabPage, PositionVar int) bool {

	cret := xTabViewReorderPage(x.GoPointer(), PageVar.GoPointer(), PositionVar)
	return cret
}

var xTabViewSelectNextPage func(uintptr) bool

// Selects the page after the currently selected page.
//
// If the last page was already selected, this function does nothing.
func (x *TabView) SelectNextPage() bool {

	cret := xTabViewSelectNextPage(x.GoPointer())
	return cret
}

var xTabViewSelectPreviousPage func(uintptr) bool

// Selects the page before the currently selected page.
//
// If the first page was already selected, this function does nothing.
func (x *TabView) SelectPreviousPage() bool {

	cret := xTabViewSelectPreviousPage(x.GoPointer())
	return cret
}

var xTabViewSetDefaultIcon func(uintptr, uintptr)

// Sets the default page icon for @self.
//
// If a page doesn't provide its own icon via [property@TabPage:icon], a default
// icon may be used instead for contexts where having an icon is necessary.
//
// [class@TabBar] will use default icon for pinned tabs in case the page is not
// loading, doesn't have an icon and an indicator. Default icon is never used
// for tabs that aren't pinned.
//
// [class@TabOverview] will use default icon for pages with missing thumbnails.
//
// By default, the `adw-tab-icon-missing-symbolic` icon is used.
func (x *TabView) SetDefaultIcon(DefaultIconVar gio.Icon) {

	xTabViewSetDefaultIcon(x.GoPointer(), DefaultIconVar.GoPointer())

}

var xTabViewSetMenuModel func(uintptr, uintptr)

// Sets the tab context menu model for @self.
//
// When a context menu is shown for a tab, it will be constructed from the
// provided menu model. Use the [signal@TabView::setup-menu] signal to set up
// the menu actions for the particular tab.
func (x *TabView) SetMenuModel(MenuModelVar *gio.MenuModel) {

	xTabViewSetMenuModel(x.GoPointer(), MenuModelVar.GoPointer())

}

var xTabViewSetPagePinned func(uintptr, uintptr, bool)

// Pins or unpins @page.
//
// Pinned pages are guaranteed to be placed before all non-pinned pages; at any
// given moment the first [property@TabView:n-pinned-pages] pages in @self are
// guaranteed to be pinned.
//
// When a page is pinned or unpinned, it's automatically reordered: pinning a
// page moves it after other pinned pages; unpinning a page moves it before
// other non-pinned pages.
//
// Pinned pages can still be reordered between each other.
//
// [class@TabBar] will display pinned pages in a compact form, never showing the
// title or close button, and only showing a single icon, selected in the
// following order:
//
// 1. [property@TabPage:indicator-icon]
// 2. A spinner if [property@TabPage:loading] is `TRUE`
// 3. [property@TabPage:icon]
// 4. [property@TabView:default-icon]
//
// [class@TabOverview] will not show a thumbnail for pinned pages, and replace
// the close button with an unpin button. Unlike `AdwTabBar`, it will still
// display the page's title, icon and indicator separately.
//
// Pinned pages cannot be closed by default, see [signal@TabView::close-page]
// for how to override that behavior.
//
// Changes the value of the [property@TabPage:pinned] property.
func (x *TabView) SetPagePinned(PageVar *TabPage, PinnedVar bool) {

	xTabViewSetPagePinned(x.GoPointer(), PageVar.GoPointer(), PinnedVar)

}

var xTabViewSetSelectedPage func(uintptr, uintptr)

// Sets the currently selected page in @self.
func (x *TabView) SetSelectedPage(SelectedPageVar *TabPage) {

	xTabViewSetSelectedPage(x.GoPointer(), SelectedPageVar.GoPointer())

}

var xTabViewSetShortcuts func(uintptr, TabViewShortcuts)

// Sets the enabled shortcuts for @self.
//
// See [flags@TabViewShortcuts] for the list of the available shortcuts. All of
// the shortcuts are enabled by default.
//
// [method@TabView.add_shortcuts] and [method@TabView.remove_shortcuts] provide
// a convenient way to manage individual shortcuts.
func (x *TabView) SetShortcuts(ShortcutsVar TabViewShortcuts) {

	xTabViewSetShortcuts(x.GoPointer(), ShortcutsVar)

}

var xTabViewTransferPage func(uintptr, uintptr, uintptr, int)

// Transfers @page from @self to @other_view.
//
// The @page object will be reused.
//
// It's a programmer error to try to insert a pinned page after a non-pinned
// one, or a non-pinned page before a pinned one.
func (x *TabView) TransferPage(PageVar *TabPage, OtherViewVar *TabView, PositionVar int) {

	xTabViewTransferPage(x.GoPointer(), PageVar.GoPointer(), OtherViewVar.GoPointer(), PositionVar)

}

func (c *TabView) GoPointer() uintptr {
	return c.Ptr
}

func (c *TabView) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted after [method@TabView.close_page] has been called for @page.
//
// The handler is expected to call [method@TabView.close_page_finish] to
// confirm or reject the closing.
//
// The default handler will immediately confirm closing for non-pinned pages,
// or reject it for pinned pages, equivalent to the following example:
//
// ```c
// static gboolean
// close_page_cb (AdwTabView *view,
//
//	AdwTabPage *page,
//	gpointer    user_data)
//
//	{
//	  adw_tab_view_close_page_finish (view, page, !adw_tab_page_get_pinned (page));
//
//	  return GDK_EVENT_STOP;
//	}
//
// ```
//
// The [method@TabView.close_page_finish] call doesn't have to happen inside
// the handler, so can be used to do asynchronous checks before confirming the
// closing.
//
// A typical reason to connect to this signal is to show a confirmation dialog
// for closing a tab.
func (x *TabView) ConnectClosePage(cb *func(TabView, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "close-page", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PageVarp uintptr) bool {
		fa := TabView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, PageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "close-page", cbRefPtr)
}

// Emitted when a tab should be transferred into a new window.
//
// This can happen after a tab has been dropped on desktop.
//
// The signal handler is expected to create a new window, position it as
// needed and return its `AdwTabView` that the page will be transferred into.
func (x *TabView) ConnectCreateWindow(cb *func(TabView) TabView) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "create-window", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) uintptr {
		fa := TabView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		CreateWindowCls := cbFn(fa)
		return CreateWindowCls.Ptr

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "create-window", cbRefPtr)
}

// Emitted after the indicator icon on @page has been activated.
//
// See [property@TabPage:indicator-icon] and
// [property@TabPage:indicator-activatable].
func (x *TabView) ConnectIndicatorActivated(cb *func(TabView, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "indicator-activated", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PageVarp uintptr) {
		fa := TabView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "indicator-activated", cbRefPtr)
}

// Emitted when a page has been created or transferred to @self.
//
// A typical reason to connect to this signal would be to connect to page
// signals for things such as updating window title.
func (x *TabView) ConnectPageAttached(cb *func(TabView, uintptr, int)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "page-attached", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PageVarp uintptr, PositionVarp int) {
		fa := TabView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PageVarp, PositionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "page-attached", cbRefPtr)
}

// Emitted when a page has been removed or transferred to another view.
//
// A typical reason to connect to this signal would be to disconnect signal
// handlers connected in the [signal@TabView::page-attached] handler.
//
// It is important not to try and destroy the page child in the handler of
// this function as the child might merely be moved to another window; use
// child dispose handler for that or do it in sync with your
// [method@TabView.close_page_finish] calls.
func (x *TabView) ConnectPageDetached(cb *func(TabView, uintptr, int)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "page-detached", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PageVarp uintptr, PositionVarp int) {
		fa := TabView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PageVarp, PositionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "page-detached", cbRefPtr)
}

// Emitted after @page has been reordered to @position.
func (x *TabView) ConnectPageReordered(cb *func(TabView, uintptr, int)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "page-reordered", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PageVarp uintptr, PositionVarp int) {
		fa := TabView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PageVarp, PositionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "page-reordered", cbRefPtr)
}

// Emitted when a context menu is opened or closed for @page.
//
// If the menu has been closed, @page will be set to `NULL`.
//
// It can be used to set up menu actions before showing the menu, for example
// disable actions not applicable to @page.
func (x *TabView) ConnectSetupMenu(cb *func(TabView, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "setup-menu", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PageVarp uintptr) {
		fa := TabView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "setup-menu", cbRefPtr)
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *TabView) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *TabView) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *TabView) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *TabView) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *TabView) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TabView) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *TabView) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TabView) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *TabView) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TabView) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *TabView) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("ADW"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xTabPageGetChild, lib, "adw_tab_page_get_child")
	core.PuregoSafeRegister(&xTabPageGetIcon, lib, "adw_tab_page_get_icon")
	core.PuregoSafeRegister(&xTabPageGetIndicatorActivatable, lib, "adw_tab_page_get_indicator_activatable")
	core.PuregoSafeRegister(&xTabPageGetIndicatorIcon, lib, "adw_tab_page_get_indicator_icon")
	core.PuregoSafeRegister(&xTabPageGetIndicatorTooltip, lib, "adw_tab_page_get_indicator_tooltip")
	core.PuregoSafeRegister(&xTabPageGetKeyword, lib, "adw_tab_page_get_keyword")
	core.PuregoSafeRegister(&xTabPageGetLiveThumbnail, lib, "adw_tab_page_get_live_thumbnail")
	core.PuregoSafeRegister(&xTabPageGetLoading, lib, "adw_tab_page_get_loading")
	core.PuregoSafeRegister(&xTabPageGetNeedsAttention, lib, "adw_tab_page_get_needs_attention")
	core.PuregoSafeRegister(&xTabPageGetParent, lib, "adw_tab_page_get_parent")
	core.PuregoSafeRegister(&xTabPageGetPinned, lib, "adw_tab_page_get_pinned")
	core.PuregoSafeRegister(&xTabPageGetSelected, lib, "adw_tab_page_get_selected")
	core.PuregoSafeRegister(&xTabPageGetThumbnailXalign, lib, "adw_tab_page_get_thumbnail_xalign")
	core.PuregoSafeRegister(&xTabPageGetThumbnailYalign, lib, "adw_tab_page_get_thumbnail_yalign")
	core.PuregoSafeRegister(&xTabPageGetTitle, lib, "adw_tab_page_get_title")
	core.PuregoSafeRegister(&xTabPageGetTooltip, lib, "adw_tab_page_get_tooltip")
	core.PuregoSafeRegister(&xTabPageInvalidateThumbnail, lib, "adw_tab_page_invalidate_thumbnail")
	core.PuregoSafeRegister(&xTabPageSetIcon, lib, "adw_tab_page_set_icon")
	core.PuregoSafeRegister(&xTabPageSetIndicatorActivatable, lib, "adw_tab_page_set_indicator_activatable")
	core.PuregoSafeRegister(&xTabPageSetIndicatorIcon, lib, "adw_tab_page_set_indicator_icon")
	core.PuregoSafeRegister(&xTabPageSetIndicatorTooltip, lib, "adw_tab_page_set_indicator_tooltip")
	core.PuregoSafeRegister(&xTabPageSetKeyword, lib, "adw_tab_page_set_keyword")
	core.PuregoSafeRegister(&xTabPageSetLiveThumbnail, lib, "adw_tab_page_set_live_thumbnail")
	core.PuregoSafeRegister(&xTabPageSetLoading, lib, "adw_tab_page_set_loading")
	core.PuregoSafeRegister(&xTabPageSetNeedsAttention, lib, "adw_tab_page_set_needs_attention")
	core.PuregoSafeRegister(&xTabPageSetThumbnailXalign, lib, "adw_tab_page_set_thumbnail_xalign")
	core.PuregoSafeRegister(&xTabPageSetThumbnailYalign, lib, "adw_tab_page_set_thumbnail_yalign")
	core.PuregoSafeRegister(&xTabPageSetTitle, lib, "adw_tab_page_set_title")
	core.PuregoSafeRegister(&xTabPageSetTooltip, lib, "adw_tab_page_set_tooltip")

	core.PuregoSafeRegister(&xNewTabView, lib, "adw_tab_view_new")

	core.PuregoSafeRegister(&xTabViewAddPage, lib, "adw_tab_view_add_page")
	core.PuregoSafeRegister(&xTabViewAddShortcuts, lib, "adw_tab_view_add_shortcuts")
	core.PuregoSafeRegister(&xTabViewAppend, lib, "adw_tab_view_append")
	core.PuregoSafeRegister(&xTabViewAppendPinned, lib, "adw_tab_view_append_pinned")
	core.PuregoSafeRegister(&xTabViewCloseOtherPages, lib, "adw_tab_view_close_other_pages")
	core.PuregoSafeRegister(&xTabViewClosePage, lib, "adw_tab_view_close_page")
	core.PuregoSafeRegister(&xTabViewClosePageFinish, lib, "adw_tab_view_close_page_finish")
	core.PuregoSafeRegister(&xTabViewClosePagesAfter, lib, "adw_tab_view_close_pages_after")
	core.PuregoSafeRegister(&xTabViewClosePagesBefore, lib, "adw_tab_view_close_pages_before")
	core.PuregoSafeRegister(&xTabViewGetDefaultIcon, lib, "adw_tab_view_get_default_icon")
	core.PuregoSafeRegister(&xTabViewGetIsTransferringPage, lib, "adw_tab_view_get_is_transferring_page")
	core.PuregoSafeRegister(&xTabViewGetMenuModel, lib, "adw_tab_view_get_menu_model")
	core.PuregoSafeRegister(&xTabViewGetNPages, lib, "adw_tab_view_get_n_pages")
	core.PuregoSafeRegister(&xTabViewGetNPinnedPages, lib, "adw_tab_view_get_n_pinned_pages")
	core.PuregoSafeRegister(&xTabViewGetNthPage, lib, "adw_tab_view_get_nth_page")
	core.PuregoSafeRegister(&xTabViewGetPage, lib, "adw_tab_view_get_page")
	core.PuregoSafeRegister(&xTabViewGetPagePosition, lib, "adw_tab_view_get_page_position")
	core.PuregoSafeRegister(&xTabViewGetPages, lib, "adw_tab_view_get_pages")
	core.PuregoSafeRegister(&xTabViewGetSelectedPage, lib, "adw_tab_view_get_selected_page")
	core.PuregoSafeRegister(&xTabViewGetShortcuts, lib, "adw_tab_view_get_shortcuts")
	core.PuregoSafeRegister(&xTabViewInsert, lib, "adw_tab_view_insert")
	core.PuregoSafeRegister(&xTabViewInsertPinned, lib, "adw_tab_view_insert_pinned")
	core.PuregoSafeRegister(&xTabViewInvalidateThumbnails, lib, "adw_tab_view_invalidate_thumbnails")
	core.PuregoSafeRegister(&xTabViewPrepend, lib, "adw_tab_view_prepend")
	core.PuregoSafeRegister(&xTabViewPrependPinned, lib, "adw_tab_view_prepend_pinned")
	core.PuregoSafeRegister(&xTabViewRemoveShortcuts, lib, "adw_tab_view_remove_shortcuts")
	core.PuregoSafeRegister(&xTabViewReorderBackward, lib, "adw_tab_view_reorder_backward")
	core.PuregoSafeRegister(&xTabViewReorderFirst, lib, "adw_tab_view_reorder_first")
	core.PuregoSafeRegister(&xTabViewReorderForward, lib, "adw_tab_view_reorder_forward")
	core.PuregoSafeRegister(&xTabViewReorderLast, lib, "adw_tab_view_reorder_last")
	core.PuregoSafeRegister(&xTabViewReorderPage, lib, "adw_tab_view_reorder_page")
	core.PuregoSafeRegister(&xTabViewSelectNextPage, lib, "adw_tab_view_select_next_page")
	core.PuregoSafeRegister(&xTabViewSelectPreviousPage, lib, "adw_tab_view_select_previous_page")
	core.PuregoSafeRegister(&xTabViewSetDefaultIcon, lib, "adw_tab_view_set_default_icon")
	core.PuregoSafeRegister(&xTabViewSetMenuModel, lib, "adw_tab_view_set_menu_model")
	core.PuregoSafeRegister(&xTabViewSetPagePinned, lib, "adw_tab_view_set_page_pinned")
	core.PuregoSafeRegister(&xTabViewSetSelectedPage, lib, "adw_tab_view_set_selected_page")
	core.PuregoSafeRegister(&xTabViewSetShortcuts, lib, "adw_tab_view_set_shortcuts")
	core.PuregoSafeRegister(&xTabViewTransferPage, lib, "adw_tab_view_transfer_page")

}
