// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type BreakpointClass struct {
	_ structs.HostLayout

	ParentClass uintptr
}

func (x *BreakpointClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Describes condition for an [class@Breakpoint].
type BreakpointCondition struct {
	_ structs.HostLayout
}

var xBreakpointConditionGLibType func() types.GType

func BreakpointConditionGLibType() types.GType {
	return xBreakpointConditionGLibType()
}

func (x *BreakpointCondition) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewBreakpointConditionAnd func(*BreakpointCondition, *BreakpointCondition) *BreakpointCondition

// Creates a condition that triggers when @condition_1 and @condition_2 are both
// true.
func NewBreakpointConditionAnd(Condition1Var *BreakpointCondition, Condition2Var *BreakpointCondition) *BreakpointCondition {

	cret := xNewBreakpointConditionAnd(Condition1Var, Condition2Var)
	return cret
}

var xNewBreakpointConditionLength func(BreakpointConditionLengthType, float64, LengthUnit) *BreakpointCondition

// Creates a condition that triggers on length changes.
func NewBreakpointConditionLength(TypeVar BreakpointConditionLengthType, ValueVar float64, UnitVar LengthUnit) *BreakpointCondition {

	cret := xNewBreakpointConditionLength(TypeVar, ValueVar, UnitVar)
	return cret
}

var xNewBreakpointConditionOr func(*BreakpointCondition, *BreakpointCondition) *BreakpointCondition

// Creates a condition that triggers when either @condition_1 or @condition_2 is
// true.
func NewBreakpointConditionOr(Condition1Var *BreakpointCondition, Condition2Var *BreakpointCondition) *BreakpointCondition {

	cret := xNewBreakpointConditionOr(Condition1Var, Condition2Var)
	return cret
}

var xNewBreakpointConditionRatio func(BreakpointConditionRatioType, int, int) *BreakpointCondition

// Creates a condition that triggers on ratio changes.
//
// The ratio is represented as @width divided by @height.
func NewBreakpointConditionRatio(TypeVar BreakpointConditionRatioType, WidthVar int, HeightVar int) *BreakpointCondition {

	cret := xNewBreakpointConditionRatio(TypeVar, WidthVar, HeightVar)
	return cret
}

var xBreakpointConditionCopy func(uintptr) *BreakpointCondition

// Copies @self.
func (x *BreakpointCondition) Copy() *BreakpointCondition {

	cret := xBreakpointConditionCopy(x.GoPointer())
	return cret
}

var xBreakpointConditionFree func(uintptr)

// Frees @self.
func (x *BreakpointCondition) Free() {

	xBreakpointConditionFree(x.GoPointer())

}

var xBreakpointConditionToString func(uintptr) string

// Returns a textual representation of @self.
//
// The returned string can be parsed by [func@BreakpointCondition.parse].
func (x *BreakpointCondition) ToString() string {

	cret := xBreakpointConditionToString(x.GoPointer())
	return cret
}

// Describes length types for [struct@BreakpointCondition].
//
// See [ctor@BreakpointCondition.new_length].
//
// New values may be added to this enumeration over time.
type BreakpointConditionLengthType int

var xBreakpointConditionLengthTypeGLibType func() types.GType

func BreakpointConditionLengthTypeGLibType() types.GType {
	return xBreakpointConditionLengthTypeGLibType()
}

const (

	// true if the width is greater than or
	//   equal to the condition value
	BreakpointConditionMinWidthValue BreakpointConditionLengthType = 0
	// true if the width is less than or
	//   equal to the condition value
	BreakpointConditionMaxWidthValue BreakpointConditionLengthType = 1
	// true if the height is greater than or
	//   equal to the condition value
	BreakpointConditionMinHeightValue BreakpointConditionLengthType = 2
	// true if the height is less than or
	//   equal to the condition value
	BreakpointConditionMaxHeightValue BreakpointConditionLengthType = 3
)

// Describes ratio types for [struct@BreakpointCondition].
//
// See [ctor@BreakpointCondition.new_ratio].
//
// New values may be added to this enumeration over time.
type BreakpointConditionRatioType int

var xBreakpointConditionRatioTypeGLibType func() types.GType

func BreakpointConditionRatioTypeGLibType() types.GType {
	return xBreakpointConditionRatioTypeGLibType()
}

const (

	// true if the aspect ratio is
	//   greater than or equal to the condition value
	BreakpointConditionMinAspectRatioValue BreakpointConditionRatioType = 0
	// true if the aspect ratio is
	//   less than or equal to the condition value
	BreakpointConditionMaxAspectRatioValue BreakpointConditionRatioType = 1
)

var xBreakpointConditionParse func(string) *BreakpointCondition

// Parses a condition from a string.
//
// Length conditions are specified as `&lt;type&gt;: &lt;value&gt;[&lt;unit&gt;]`, where:
//
// - `&lt;type&gt;` can be `min-width`, `max-width`, `min-height` or `max-height`
// - `&lt;value&gt;` is a fractional number
// - `&lt;unit&gt;` can be `px`, `pt` or `sp`
//
// If the unit is omitted, `px` is assumed.
//
// See [ctor@BreakpointCondition.new_length].
//
// Examples:
//
// - `min-width: 500px`
// - `min-height: 400pt`
// - `max-width: 100sp`
// - `max-height: 500`
//
// Ratio conditions are specified as `&lt;type&gt;: &lt;width&gt;[/&lt;height&gt;]`, where:
//
// - `&lt;type&gt;` can be `min-aspect-ratio` or `max-aspect-ratio`
// - `&lt;width&gt;` and `&lt;height&gt;` are integer numbers
//
// See [ctor@BreakpointCondition.new_ratio].
//
// The ratio is represented as `&lt;width&gt;` divided by `&lt;height&gt;`.
//
// If `&lt;height&gt;` is omitted, it's assumed to be 1.
//
// Examples:
//
// - `min-aspect-ratio: 4/3`
// - `max-aspect-ratio: 1`
//
// The logical operators `and`, `or` can be used to compose a complex condition
// as follows:
//
//   - `&lt;condition&gt; and &lt;condition&gt;`: the condition is true when both
//     `&lt;condition&gt;`s are true, same as when using
//     [ctor@BreakpointCondition.new_and]
//   - `&lt;condition&gt; or &lt;condition&gt;`: the condition is true when either of the
//     `&lt;condition&gt;`s is true, same as when using
//     [ctor@BreakpointCondition.new_or]
//
// Examples:
//
// - `min-width: 400px and max-aspect-ratio: 4/3`
// - `max-width: 360sp or max-width: 360px`
//
// Conditions can be further nested using parentheses, for example:
//
// - `min-width: 400px and (max-aspect-ratio: 4/3 or max-height: 400px)`
//
// If parentheses are omitted, the first operator takes priority.
func BreakpointConditionParse(StrVar string) *BreakpointCondition {

	cret := xBreakpointConditionParse(StrVar)
	return cret
}

// Describes a breakpoint for [class@Window] or [class@Dialog].
//
// Breakpoints are used to create adaptive UI, allowing to change the layout
// depending on available size.
//
// Breakpoint is a size threshold, specified by its condition, as well as one or
// more setters.
//
// Each setter has a target object, a property and a value. When a breakpoint
// is applied, each setter sets the target property on their target object to
// the specified value, and reset it back to the original value when it's
// unapplied.
//
// For more complicated scenarios, [signal@Breakpoint::apply] and
// [signal@Breakpoint::unapply] can be used instead.
//
// Breakpoints can be used within [class@Window], [class@ApplicationWindow],
// [class@Dialog] or [class@BreakpointBin].
//
// ## `AdwBreakpoint` as `GtkBuildable`:
//
// `AdwBreakpoint` supports specifying its condition via the `&lt;condition&gt;`
// element. The contents of the element must be a string in a format accepted by
// [func@BreakpointCondition.parse].
//
// It also supports adding setters via the `&lt;setter&gt;` element. Each `&lt;setter&gt;`
// element must have the `object` attribute specifying the target object, and
// the `property` attribute specifying the property name. The contents of the
// element are used as the setter value.
//
// For `G_TYPE_OBJECT` and `G_TYPE_BOXED` derived properties, empty contents are
// treated as `NULL`.
//
// Setter values can be translated with the usual `translatable`, `context` and
// `comments` attributes.
//
// Example of an `AdwBreakpoint` UI definition:
//
// ```xml
// &lt;object class="AdwBreakpoint"&gt;
//
//	&lt;condition&gt;max-width: 400px&lt;/condition&gt;
//	&lt;setter object="button" property="visible"&gt;True&lt;/setter&gt;
//	&lt;setter object="box" property="orientation"&gt;vertical&lt;/setter&gt;
//	&lt;setter object="page" property="title" translatable="yes"&gt;Example&lt;/setter&gt;
//
// &lt;/object&gt;
// ```
type Breakpoint struct {
	gobject.Object
}

var xBreakpointGLibType func() types.GType

func BreakpointGLibType() types.GType {
	return xBreakpointGLibType()
}

func BreakpointNewFromInternalPtr(ptr uintptr) *Breakpoint {
	cls := &Breakpoint{}
	cls.Ptr = ptr
	return cls
}

var xNewBreakpoint func(*BreakpointCondition) uintptr

// Creates a new `AdwBreakpoint` with @condition.
func NewBreakpoint(ConditionVar *BreakpointCondition) *Breakpoint {
	var cls *Breakpoint

	cret := xNewBreakpoint(ConditionVar)

	if cret == 0 {
		return nil
	}
	cls = &Breakpoint{}
	cls.Ptr = cret
	return cls
}

var xBreakpointAddSetter func(uintptr, uintptr, string, *gobject.Value)

// Adds a setter to @self.
//
// The setter will automatically set @property on @object to @value when
// applying the breakpoint, and set it back to its original value upon
// unapplying it.
//
// ::: note
//
//	Setting properties to their original values does not work for properties
//	that have irreversible side effects. For example, changing
//	[property@Gtk.Button:label] while [property@Gtk.Button:icon-name] is set
//	will reset the icon. However, resetting the label will not set
//	`icon-name` to its original value.
//
// Use the [signal@Breakpoint::apply] and [signal@Breakpoint::unapply] signals
// for those properties instead, as follows:
//
// ```c
// static void
// breakpoint_apply_cb (MyWidget *self)
//
//	{
//	  gtk_button_set_icon_name (self-&gt;button, "go-previous-symbolic");
//	}
//
// static void
// breakpoint_apply_cb (MyWidget *self)
//
//	{
//	  gtk_button_set_label (self-&gt;button, _("_Back"));
//	}
//
// // ...
//
// g_signal_connect_swapped (breakpoint, "apply",
//
//	G_CALLBACK (breakpoint_apply_cb), self);
//
// g_signal_connect_swapped (breakpoint, "unapply",
//
//	G_CALLBACK (breakpoint_unapply_cb), self);
//
// ```
func (x *Breakpoint) AddSetter(ObjectVar *gobject.Object, PropertyVar string, ValueVar *gobject.Value) {

	xBreakpointAddSetter(x.GoPointer(), ObjectVar.GoPointer(), PropertyVar, ValueVar)

}

var xBreakpointAddSetters func(uintptr, uintptr, string, ...interface{})

// Adds multiple setters to @self.
//
// See [method@Breakpoint.add_setter].
//
// Example:
//
// ```c
// adw_breakpoint_add_setters (breakpoint,
//
//	G_OBJECT (box), "orientation", GTK_ORIENTATION_VERTICAL,
//	G_OBJECT (button), "halign", GTK_ALIGN_FILL,
//	G_OBJECT (button), "valign", GTK_ALIGN_END,
//	NULL);
//
// ```
func (x *Breakpoint) AddSetters(FirstObjectVar *gobject.Object, FirstPropertyVar string, varArgs ...interface{}) {

	xBreakpointAddSetters(x.GoPointer(), FirstObjectVar.GoPointer(), FirstPropertyVar, varArgs...)

}

var xBreakpointAddSettersValist func(uintptr, uintptr, string, []interface{})

// Adds multiple setters to @self.
//
// See [method@Breakpoint.add_setters].
func (x *Breakpoint) AddSettersValist(FirstObjectVar *gobject.Object, FirstPropertyVar string, ArgsVar []interface{}) {

	xBreakpointAddSettersValist(x.GoPointer(), FirstObjectVar.GoPointer(), FirstPropertyVar, ArgsVar)

}

var xBreakpointAddSettersv func(uintptr, int, uintptr, []string, uintptr)

// Adds @n_setters setters to @self.
//
// This is a convenience function for adding multiple setters at once.
//
// See [method@Breakpoint.add_setter].
//
// This function is meant to be used by language bindings.
func (x *Breakpoint) AddSettersv(NSettersVar int, ObjectsVar uintptr, NamesVar []string, ValuesVar uintptr) {

	xBreakpointAddSettersv(x.GoPointer(), NSettersVar, ObjectsVar, NamesVar, ValuesVar)

}

var xBreakpointGetCondition func(uintptr) *BreakpointCondition

// Gets the condition for @self.
func (x *Breakpoint) GetCondition() *BreakpointCondition {

	cret := xBreakpointGetCondition(x.GoPointer())
	return cret
}

var xBreakpointSetCondition func(uintptr, *BreakpointCondition)

// Sets the condition for @self.
func (x *Breakpoint) SetCondition(ConditionVar *BreakpointCondition) {

	xBreakpointSetCondition(x.GoPointer(), ConditionVar)

}

func (c *Breakpoint) GoPointer() uintptr {
	return c.Ptr
}

func (c *Breakpoint) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the breakpoint is applied.
//
// This signal is emitted after the setters have been applied.
func (x *Breakpoint) ConnectApply(cb *func(Breakpoint)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "apply", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Breakpoint{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "apply", cbRefPtr)
}

// Emitted when the breakpoint is unapplied.
//
// This signal is emitted before resetting the setter values.
func (x *Breakpoint) ConnectUnapply(cb *func(Breakpoint)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "unapply", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Breakpoint{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "unapply", cbRefPtr)
}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *Breakpoint) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("ADW"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xBreakpointConditionLengthTypeGLibType, lib, "adw_breakpoint_condition_length_type_get_type")

	core.PuregoSafeRegister(&xBreakpointConditionRatioTypeGLibType, lib, "adw_breakpoint_condition_ratio_type_get_type")

	core.PuregoSafeRegister(&xBreakpointConditionParse, lib, "adw_breakpoint_condition_parse")

	core.PuregoSafeRegister(&xBreakpointConditionGLibType, lib, "adw_breakpoint_condition_get_type")

	core.PuregoSafeRegister(&xNewBreakpointConditionAnd, lib, "adw_breakpoint_condition_new_and")
	core.PuregoSafeRegister(&xNewBreakpointConditionLength, lib, "adw_breakpoint_condition_new_length")
	core.PuregoSafeRegister(&xNewBreakpointConditionOr, lib, "adw_breakpoint_condition_new_or")
	core.PuregoSafeRegister(&xNewBreakpointConditionRatio, lib, "adw_breakpoint_condition_new_ratio")

	core.PuregoSafeRegister(&xBreakpointConditionCopy, lib, "adw_breakpoint_condition_copy")
	core.PuregoSafeRegister(&xBreakpointConditionFree, lib, "adw_breakpoint_condition_free")
	core.PuregoSafeRegister(&xBreakpointConditionToString, lib, "adw_breakpoint_condition_to_string")

	core.PuregoSafeRegister(&xBreakpointGLibType, lib, "adw_breakpoint_get_type")

	core.PuregoSafeRegister(&xNewBreakpoint, lib, "adw_breakpoint_new")

	core.PuregoSafeRegister(&xBreakpointAddSetter, lib, "adw_breakpoint_add_setter")
	core.PuregoSafeRegister(&xBreakpointAddSetters, lib, "adw_breakpoint_add_setters")
	core.PuregoSafeRegister(&xBreakpointAddSettersValist, lib, "adw_breakpoint_add_setters_valist")
	core.PuregoSafeRegister(&xBreakpointAddSettersv, lib, "adw_breakpoint_add_settersv")
	core.PuregoSafeRegister(&xBreakpointGetCondition, lib, "adw_breakpoint_get_condition")
	core.PuregoSafeRegister(&xBreakpointSetCondition, lib, "adw_breakpoint_set_condition")

}
