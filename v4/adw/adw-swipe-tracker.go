// Package adw was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package adw

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type SwipeTrackerClass struct {
	_ structs.HostLayout

	ParentClass uintptr
}

func (x *SwipeTrackerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A swipe tracker used in [class@Carousel], [class@Flap] and [class@Leaflet].
//
// The `AdwSwipeTracker` object can be used for implementing widgets with swipe
// gestures. It supports touch-based swipes, pointer dragging, and touchpad
// scrolling.
//
// The widgets will probably want to expose the [property@SwipeTracker:enabled]
// property. If they expect to use horizontal orientation,
// [property@SwipeTracker:reversed] can be used for supporting RTL text
// direction.
type SwipeTracker struct {
	gobject.Object
}

var xSwipeTrackerGLibType func() types.GType

func SwipeTrackerGLibType() types.GType {
	return xSwipeTrackerGLibType()
}

func SwipeTrackerNewFromInternalPtr(ptr uintptr) *SwipeTracker {
	cls := &SwipeTracker{}
	cls.Ptr = ptr
	return cls
}

var xNewSwipeTracker func(uintptr) uintptr

// Creates a new `AdwSwipeTracker` for @widget.
func NewSwipeTracker(SwipeableVar Swipeable) *SwipeTracker {
	var cls *SwipeTracker

	cret := xNewSwipeTracker(SwipeableVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &SwipeTracker{}
	cls.Ptr = cret
	return cls
}

var xSwipeTrackerGetAllowLongSwipes func(uintptr) bool

// Gets whether to allow swiping for more than one snap point at a time.
func (x *SwipeTracker) GetAllowLongSwipes() bool {

	cret := xSwipeTrackerGetAllowLongSwipes(x.GoPointer())
	return cret
}

var xSwipeTrackerGetAllowMouseDrag func(uintptr) bool

// Gets whether @self can be dragged with mouse pointer.
func (x *SwipeTracker) GetAllowMouseDrag() bool {

	cret := xSwipeTrackerGetAllowMouseDrag(x.GoPointer())
	return cret
}

var xSwipeTrackerGetEnabled func(uintptr) bool

// Gets whether @self is enabled.
func (x *SwipeTracker) GetEnabled() bool {

	cret := xSwipeTrackerGetEnabled(x.GoPointer())
	return cret
}

var xSwipeTrackerGetReversed func(uintptr) bool

// Gets whether @self is reversing the swipe direction.
func (x *SwipeTracker) GetReversed() bool {

	cret := xSwipeTrackerGetReversed(x.GoPointer())
	return cret
}

var xSwipeTrackerGetSwipeable func(uintptr) uintptr

// Get the widget @self is attached to.
func (x *SwipeTracker) GetSwipeable() *SwipeableBase {
	var cls *SwipeableBase

	cret := xSwipeTrackerGetSwipeable(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &SwipeableBase{}
	cls.Ptr = cret
	return cls
}

var xSwipeTrackerSetAllowLongSwipes func(uintptr, bool)

// Sets whether to allow swiping for more than one snap point at a time.
//
// If the value is `FALSE`, each swipe can only move to the adjacent snap
// points.
func (x *SwipeTracker) SetAllowLongSwipes(AllowLongSwipesVar bool) {

	xSwipeTrackerSetAllowLongSwipes(x.GoPointer(), AllowLongSwipesVar)

}

var xSwipeTrackerSetAllowMouseDrag func(uintptr, bool)

// Sets whether @self can be dragged with mouse pointer.
func (x *SwipeTracker) SetAllowMouseDrag(AllowMouseDragVar bool) {

	xSwipeTrackerSetAllowMouseDrag(x.GoPointer(), AllowMouseDragVar)

}

var xSwipeTrackerSetEnabled func(uintptr, bool)

// Sets whether @self is enabled.
//
// When it's not enabled, no events will be processed. Usually widgets will want
// to expose this via a property.
func (x *SwipeTracker) SetEnabled(EnabledVar bool) {

	xSwipeTrackerSetEnabled(x.GoPointer(), EnabledVar)

}

var xSwipeTrackerSetReversed func(uintptr, bool)

// Sets whether to reverse the swipe direction.
//
// If the swipe tracker is horizontal, it can be used for supporting RTL text
// direction.
func (x *SwipeTracker) SetReversed(ReversedVar bool) {

	xSwipeTrackerSetReversed(x.GoPointer(), ReversedVar)

}

var xSwipeTrackerShiftPosition func(uintptr, float64)

// Moves the current progress value by @delta.
//
// This can be used to adjust the current position if snap points move during
// the gesture.
func (x *SwipeTracker) ShiftPosition(DeltaVar float64) {

	xSwipeTrackerShiftPosition(x.GoPointer(), DeltaVar)

}

func (c *SwipeTracker) GoPointer() uintptr {
	return c.Ptr
}

func (c *SwipeTracker) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// This signal is emitted right before a swipe will be started, after the
// drag threshold has been passed.
func (x *SwipeTracker) ConnectBeginSwipe(cb *func(SwipeTracker)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "begin-swipe", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := SwipeTracker{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "begin-swipe", cbRefPtr)
}

// This signal is emitted as soon as the gesture has stopped.
//
// The user is expected to animate the deceleration from the current progress
// value to @to with an animation using @velocity as the initial velocity,
// provided in pixels per second. [class@SpringAnimation] is usually a good
// fit for this.
func (x *SwipeTracker) ConnectEndSwipe(cb *func(SwipeTracker, float64, float64)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "end-swipe", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, VelocityVarp float64, ToVarp float64) {
		fa := SwipeTracker{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, VelocityVarp, ToVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "end-swipe", cbRefPtr)
}

// This signal is emitted when a possible swipe is detected.
//
// The @direction value can be used to restrict the swipe to a certain
// direction.
func (x *SwipeTracker) ConnectPrepare(cb *func(SwipeTracker, NavigationDirection)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "prepare", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, DirectionVarp NavigationDirection) {
		fa := SwipeTracker{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, DirectionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "prepare", cbRefPtr)
}

// This signal is emitted every time the progress value changes.
func (x *SwipeTracker) ConnectUpdateSwipe(cb *func(SwipeTracker, float64)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "update-swipe", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ProgressVarp float64) {
		fa := SwipeTracker{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ProgressVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "update-swipe", cbRefPtr)
}

// Retrieves the orientation of the @orientable.
func (x *SwipeTracker) GetOrientation() gtk.Orientation {

	cret := gtk.XGtkOrientableGetOrientation(x.GoPointer())
	return cret
}

// Sets the orientation of the @orientable.
func (x *SwipeTracker) SetOrientation(OrientationVar gtk.Orientation) {

	gtk.XGtkOrientableSetOrientation(x.GoPointer(), OrientationVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("ADW"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xSwipeTrackerGLibType, lib, "adw_swipe_tracker_get_type")

	core.PuregoSafeRegister(&xNewSwipeTracker, lib, "adw_swipe_tracker_new")

	core.PuregoSafeRegister(&xSwipeTrackerGetAllowLongSwipes, lib, "adw_swipe_tracker_get_allow_long_swipes")
	core.PuregoSafeRegister(&xSwipeTrackerGetAllowMouseDrag, lib, "adw_swipe_tracker_get_allow_mouse_drag")
	core.PuregoSafeRegister(&xSwipeTrackerGetEnabled, lib, "adw_swipe_tracker_get_enabled")
	core.PuregoSafeRegister(&xSwipeTrackerGetReversed, lib, "adw_swipe_tracker_get_reversed")
	core.PuregoSafeRegister(&xSwipeTrackerGetSwipeable, lib, "adw_swipe_tracker_get_swipeable")
	core.PuregoSafeRegister(&xSwipeTrackerSetAllowLongSwipes, lib, "adw_swipe_tracker_set_allow_long_swipes")
	core.PuregoSafeRegister(&xSwipeTrackerSetAllowMouseDrag, lib, "adw_swipe_tracker_set_allow_mouse_drag")
	core.PuregoSafeRegister(&xSwipeTrackerSetEnabled, lib, "adw_swipe_tracker_set_enabled")
	core.PuregoSafeRegister(&xSwipeTrackerSetReversed, lib, "adw_swipe_tracker_set_reversed")
	core.PuregoSafeRegister(&xSwipeTrackerShiftPosition, lib, "adw_swipe_tracker_shift_position")

}
