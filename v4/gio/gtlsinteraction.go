// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The class for #GTlsInteraction. Derived classes implement the various
// virtual interaction methods to handle TLS interactions.
//
// Derived classes can choose to implement whichever interactions methods they'd
// like to support by overriding those virtual methods in their class
// initialization function. If a derived class implements an async method,
// it must also implement the corresponding finish method.
//
// The synchronous interaction methods should implement to display modal dialogs,
// and the asynchronous methods to display modeless dialogs.
//
// If the user cancels an interaction, then the result should be
// %G_TLS_INTERACTION_FAILED and the error should be set with a domain of
// %G_IO_ERROR and code of %G_IO_ERROR_CANCELLED.
type TlsInteractionClass struct {
	ParentClass uintptr

	Padding [21]uintptr
}

func (x *TlsInteractionClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type TlsInteractionPrivate struct {
}

func (x *TlsInteractionPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GTlsInteraction provides a mechanism for the TLS connection and database
// code to interact with the user. It can be used to ask the user for passwords.
//
// To use a #GTlsInteraction with a TLS connection use
// g_tls_connection_set_interaction().
//
// Callers should instantiate a derived class that implements the various
// interaction methods to show the required dialogs.
//
// Callers should use the 'invoke' functions like
// g_tls_interaction_invoke_ask_password() to run interaction methods. These
// functions make sure that the interaction is invoked in the main loop
// and not in the current thread, if the current thread is not running the
// main loop.
//
// Derived classes can choose to implement whichever interactions methods they'd
// like to support by overriding those virtual methods in their class
// initialization function. Any interactions not implemented will return
// %G_TLS_INTERACTION_UNHANDLED. If a derived class implements an async method,
// it must also implement the corresponding finish method.
type TlsInteraction struct {
	gobject.Object
}

var xTlsInteractionGLibType func() types.GType

func TlsInteractionGLibType() types.GType {
	return xTlsInteractionGLibType()
}

func TlsInteractionNewFromInternalPtr(ptr uintptr) *TlsInteraction {
	cls := &TlsInteraction{}
	cls.Ptr = ptr
	return cls
}

var xTlsInteractionAskPassword func(uintptr, uintptr, uintptr, **glib.Error) TlsInteractionResult

// Run synchronous interaction to ask the user for a password. In general,
// g_tls_interaction_invoke_ask_password() should be used instead of this
// function.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value will
// be filled in and then @callback will be called. Alternatively the user may
// abort this password request, which will usually abort the TLS connection.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (x *TlsInteraction) AskPassword(PasswordVar *TlsPassword, CancellableVar *Cancellable) (TlsInteractionResult, error) {
	var cerr *glib.Error

	cret := xTlsInteractionAskPassword(x.GoPointer(), PasswordVar.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsInteractionAskPasswordAsync func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Run asynchronous interaction to ask the user for a password. In general,
// g_tls_interaction_invoke_ask_password() should be used instead of this
// function.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value will
// be filled in and then @callback will be called. Alternatively the user may
// abort this password request, which will usually abort the TLS connection.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
//
// Certain implementations may not support immediate cancellation.
func (x *TlsInteraction) AskPasswordAsync(PasswordVar *TlsPassword, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xTlsInteractionAskPasswordAsync(x.GoPointer(), PasswordVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xTlsInteractionAskPasswordFinish func(uintptr, uintptr, **glib.Error) TlsInteractionResult

// Complete an ask password user interaction request. This should be once
// the g_tls_interaction_ask_password_async() completion callback is called.
//
// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
// to g_tls_interaction_ask_password() will have its password filled in.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code.
func (x *TlsInteraction) AskPasswordFinish(ResultVar AsyncResult) (TlsInteractionResult, error) {
	var cerr *glib.Error

	cret := xTlsInteractionAskPasswordFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsInteractionInvokeAskPassword func(uintptr, uintptr, uintptr, **glib.Error) TlsInteractionResult

// Invoke the interaction to ask the user for a password. It invokes this
// interaction in the main loop, specifically the #GMainContext returned by
// g_main_context_get_thread_default() when the interaction is created. This
// is called by called by #GTlsConnection or #GTlsDatabase to ask the user
// for a password.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value will
// be filled in and then @callback will be called. Alternatively the user may
// abort this password request, which will usually abort the TLS connection.
//
// The implementation can either be a synchronous (eg: modal dialog) or an
// asynchronous one (eg: modeless dialog). This function will take care of
// calling which ever one correctly.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (x *TlsInteraction) InvokeAskPassword(PasswordVar *TlsPassword, CancellableVar *Cancellable) (TlsInteractionResult, error) {
	var cerr *glib.Error

	cret := xTlsInteractionInvokeAskPassword(x.GoPointer(), PasswordVar.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsInteractionInvokeRequestCertificate func(uintptr, uintptr, TlsCertificateRequestFlags, uintptr, **glib.Error) TlsInteractionResult

// Invoke the interaction to ask the user to choose a certificate to
// use with the connection. It invokes this interaction in the main
// loop, specifically the #GMainContext returned by
// g_main_context_get_thread_default() when the interaction is
// created. This is called by called by #GTlsConnection when the peer
// requests a certificate during the handshake.
//
// Derived subclasses usually implement a certificate selector,
// although they may also choose to provide a certificate from
// elsewhere. Alternatively the user may abort this certificate
// request, which may or may not abort the TLS connection.
//
// The implementation can either be a synchronous (eg: modal dialog) or an
// asynchronous one (eg: modeless dialog). This function will take care of
// calling which ever one correctly.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (x *TlsInteraction) InvokeRequestCertificate(ConnectionVar *TlsConnection, FlagsVar TlsCertificateRequestFlags, CancellableVar *Cancellable) (TlsInteractionResult, error) {
	var cerr *glib.Error

	cret := xTlsInteractionInvokeRequestCertificate(x.GoPointer(), ConnectionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsInteractionRequestCertificate func(uintptr, uintptr, TlsCertificateRequestFlags, uintptr, **glib.Error) TlsInteractionResult

// Run synchronous interaction to ask the user to choose a certificate to use
// with the connection. In general, g_tls_interaction_invoke_request_certificate()
// should be used instead of this function.
//
// Derived subclasses usually implement a certificate selector, although they may
// also choose to provide a certificate from elsewhere. Alternatively the user may
// abort this certificate request, which will usually abort the TLS connection.
//
// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
// passed to g_tls_interaction_request_certificate() will have had its
// #GTlsConnection:certificate filled in.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (x *TlsInteraction) RequestCertificate(ConnectionVar *TlsConnection, FlagsVar TlsCertificateRequestFlags, CancellableVar *Cancellable) (TlsInteractionResult, error) {
	var cerr *glib.Error

	cret := xTlsInteractionRequestCertificate(x.GoPointer(), ConnectionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsInteractionRequestCertificateAsync func(uintptr, uintptr, TlsCertificateRequestFlags, uintptr, uintptr, uintptr)

// Run asynchronous interaction to ask the user for a certificate to use with
// the connection. In general, g_tls_interaction_invoke_request_certificate() should
// be used instead of this function.
//
// Derived subclasses usually implement a certificate selector, although they may
// also choose to provide a certificate from elsewhere. @callback will be called
// when the operation completes. Alternatively the user may abort this certificate
// request, which will usually abort the TLS connection.
func (x *TlsInteraction) RequestCertificateAsync(ConnectionVar *TlsConnection, FlagsVar TlsCertificateRequestFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xTlsInteractionRequestCertificateAsync(x.GoPointer(), ConnectionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xTlsInteractionRequestCertificateFinish func(uintptr, uintptr, **glib.Error) TlsInteractionResult

// Complete a request certificate user interaction request. This should be once
// the g_tls_interaction_request_certificate_async() completion callback is called.
//
// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
// passed to g_tls_interaction_request_certificate_async() will have had its
// #GTlsConnection:certificate filled in.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code.
func (x *TlsInteraction) RequestCertificateFinish(ResultVar AsyncResult) (TlsInteractionResult, error) {
	var cerr *glib.Error

	cret := xTlsInteractionRequestCertificateFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *TlsInteraction) GoPointer() uintptr {
	return c.Ptr
}

func (c *TlsInteraction) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xTlsInteractionGLibType, lib, "g_tls_interaction_get_type")

	core.PuregoSafeRegister(&xTlsInteractionAskPassword, lib, "g_tls_interaction_ask_password")
	core.PuregoSafeRegister(&xTlsInteractionAskPasswordAsync, lib, "g_tls_interaction_ask_password_async")
	core.PuregoSafeRegister(&xTlsInteractionAskPasswordFinish, lib, "g_tls_interaction_ask_password_finish")
	core.PuregoSafeRegister(&xTlsInteractionInvokeAskPassword, lib, "g_tls_interaction_invoke_ask_password")
	core.PuregoSafeRegister(&xTlsInteractionInvokeRequestCertificate, lib, "g_tls_interaction_invoke_request_certificate")
	core.PuregoSafeRegister(&xTlsInteractionRequestCertificate, lib, "g_tls_interaction_request_certificate")
	core.PuregoSafeRegister(&xTlsInteractionRequestCertificateAsync, lib, "g_tls_interaction_request_certificate_async")
	core.PuregoSafeRegister(&xTlsInteractionRequestCertificateFinish, lib, "g_tls_interaction_request_certificate_finish")

}
