// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type PermissionClass struct {
	_ structs.HostLayout

	ParentClass uintptr

	Reserved [16]uintptr
}

func (x *PermissionClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type PermissionPrivate struct {
	_ structs.HostLayout
}

func (x *PermissionPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A #GPermission represents the status of the caller's permission to
// perform a certain action.
//
// You can query if the action is currently allowed and if it is
// possible to acquire the permission so that the action will be allowed
// in the future.
//
// There is also an API to actually acquire the permission and one to
// release it.
//
// As an example, a #GPermission might represent the ability for the
// user to write to a #GSettings object.  This #GPermission object could
// then be used to decide if it is appropriate to show a "Click here to
// unlock" button in a dialog and to provide the mechanism to invoke
// when that button is clicked.
type Permission struct {
	gobject.Object
}

var xPermissionGLibType func() types.GType

func PermissionGLibType() types.GType {
	return xPermissionGLibType()
}

func PermissionNewFromInternalPtr(ptr uintptr) *Permission {
	cls := &Permission{}
	cls.Ptr = ptr
	return cls
}

var xPermissionAcquire func(uintptr, uintptr, **glib.Error) bool

// Attempts to acquire the permission represented by @permission.
//
// The precise method by which this happens depends on the permission
// and the underlying authentication mechanism.  A simple example is
// that a dialog may appear asking the user to enter their password.
//
// You should check with g_permission_get_can_acquire() before calling
// this function.
//
// If the permission is acquired then %TRUE is returned.  Otherwise,
// %FALSE is returned and @error is set appropriately.
//
// This call is blocking, likely for a very long time (in the case that
// user interaction is required).  See g_permission_acquire_async() for
// the non-blocking version.
func (x *Permission) Acquire(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xPermissionAcquire(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPermissionAcquireAsync func(uintptr, uintptr, uintptr, uintptr)

// Attempts to acquire the permission represented by @permission.
//
// This is the first half of the asynchronous version of
// g_permission_acquire().
func (x *Permission) AcquireAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xPermissionAcquireAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xPermissionAcquireFinish func(uintptr, uintptr, **glib.Error) bool

// Collects the result of attempting to acquire the permission
// represented by @permission.
//
// This is the second half of the asynchronous version of
// g_permission_acquire().
func (x *Permission) AcquireFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xPermissionAcquireFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPermissionGetAllowed func(uintptr) bool

// Gets the value of the 'allowed' property.  This property is %TRUE if
// the caller currently has permission to perform the action that
// @permission represents the permission to perform.
func (x *Permission) GetAllowed() bool {

	cret := xPermissionGetAllowed(x.GoPointer())
	return cret
}

var xPermissionGetCanAcquire func(uintptr) bool

// Gets the value of the 'can-acquire' property.  This property is %TRUE
// if it is generally possible to acquire the permission by calling
// g_permission_acquire().
func (x *Permission) GetCanAcquire() bool {

	cret := xPermissionGetCanAcquire(x.GoPointer())
	return cret
}

var xPermissionGetCanRelease func(uintptr) bool

// Gets the value of the 'can-release' property.  This property is %TRUE
// if it is generally possible to release the permission by calling
// g_permission_release().
func (x *Permission) GetCanRelease() bool {

	cret := xPermissionGetCanRelease(x.GoPointer())
	return cret
}

var xPermissionImplUpdate func(uintptr, bool, bool, bool)

// This function is called by the #GPermission implementation to update
// the properties of the permission.  You should never call this
// function except from a #GPermission implementation.
//
// GObject notify signals are generated, as appropriate.
func (x *Permission) ImplUpdate(AllowedVar bool, CanAcquireVar bool, CanReleaseVar bool) {

	xPermissionImplUpdate(x.GoPointer(), AllowedVar, CanAcquireVar, CanReleaseVar)

}

var xPermissionRelease func(uintptr, uintptr, **glib.Error) bool

// Attempts to release the permission represented by @permission.
//
// The precise method by which this happens depends on the permission
// and the underlying authentication mechanism.  In most cases the
// permission will be dropped immediately without further action.
//
// You should check with g_permission_get_can_release() before calling
// this function.
//
// If the permission is released then %TRUE is returned.  Otherwise,
// %FALSE is returned and @error is set appropriately.
//
// This call is blocking, likely for a very long time (in the case that
// user interaction is required).  See g_permission_release_async() for
// the non-blocking version.
func (x *Permission) Release(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xPermissionRelease(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPermissionReleaseAsync func(uintptr, uintptr, uintptr, uintptr)

// Attempts to release the permission represented by @permission.
//
// This is the first half of the asynchronous version of
// g_permission_release().
func (x *Permission) ReleaseAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xPermissionReleaseAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xPermissionReleaseFinish func(uintptr, uintptr, **glib.Error) bool

// Collects the result of attempting to release the permission
// represented by @permission.
//
// This is the second half of the asynchronous version of
// g_permission_release().
func (x *Permission) ReleaseFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xPermissionReleaseFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *Permission) GoPointer() uintptr {
	return c.Ptr
}

func (c *Permission) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xPermissionGLibType, lib, "g_permission_get_type")

	core.PuregoSafeRegister(&xPermissionAcquire, lib, "g_permission_acquire")
	core.PuregoSafeRegister(&xPermissionAcquireAsync, lib, "g_permission_acquire_async")
	core.PuregoSafeRegister(&xPermissionAcquireFinish, lib, "g_permission_acquire_finish")
	core.PuregoSafeRegister(&xPermissionGetAllowed, lib, "g_permission_get_allowed")
	core.PuregoSafeRegister(&xPermissionGetCanAcquire, lib, "g_permission_get_can_acquire")
	core.PuregoSafeRegister(&xPermissionGetCanRelease, lib, "g_permission_get_can_release")
	core.PuregoSafeRegister(&xPermissionImplUpdate, lib, "g_permission_impl_update")
	core.PuregoSafeRegister(&xPermissionRelease, lib, "g_permission_release")
	core.PuregoSafeRegister(&xPermissionReleaseAsync, lib, "g_permission_release_async")
	core.PuregoSafeRegister(&xPermissionReleaseFinish, lib, "g_permission_release_finish")

}
