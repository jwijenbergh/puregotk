// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Class structure for #GSocketListener.
type SocketListenerClass struct {
	_ structs.HostLayout

	ParentClass uintptr
}

func (x *SocketListenerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type SocketListenerPrivate struct {
	_ structs.HostLayout
}

func (x *SocketListenerPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A #GSocketListener is an object that keeps track of a set
// of server sockets and helps you accept sockets from any of the
// socket, either sync or async.
//
// Add addresses and ports to listen on using g_socket_listener_add_address()
// and g_socket_listener_add_inet_port(). These will be listened on until
// g_socket_listener_close() is called. Dropping your final reference to the
// #GSocketListener will not cause g_socket_listener_close() to be called
// implicitly, as some references to the #GSocketListener may be held
// internally.
//
// If you want to implement a network server, also look at #GSocketService
// and #GThreadedSocketService which are subclasses of #GSocketListener
// that make this even easier.
type SocketListener struct {
	gobject.Object
}

var xSocketListenerGLibType func() types.GType

func SocketListenerGLibType() types.GType {
	return xSocketListenerGLibType()
}

func SocketListenerNewFromInternalPtr(ptr uintptr) *SocketListener {
	cls := &SocketListener{}
	cls.Ptr = ptr
	return cls
}

var xNewSocketListener func() uintptr

// Creates a new #GSocketListener with no sockets to listen for.
// New listeners can be added with e.g. g_socket_listener_add_address()
// or g_socket_listener_add_inet_port().
func NewSocketListener() *SocketListener {
	var cls *SocketListener

	cret := xNewSocketListener()

	if cret == 0 {
		return nil
	}
	cls = &SocketListener{}
	cls.Ptr = cret
	return cls
}

var xSocketListenerAccept func(uintptr, *uintptr, uintptr, **glib.Error) uintptr

// Blocks waiting for a client to connect to any of the sockets added
// to the listener. Returns a #GSocketConnection for the socket that was
// accepted.
//
// If @source_object is not %NULL it will be filled out with the source
// object specified when the corresponding socket or address was added
// to the listener.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *SocketListener) Accept(SourceObjectVar **gobject.Object, CancellableVar *Cancellable) (*SocketConnection, error) {
	var cls *SocketConnection
	var cerr *glib.Error

	cret := xSocketListenerAccept(x.GoPointer(), gobject.ConvertPtr(SourceObjectVar), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &SocketConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xSocketListenerAcceptAsync func(uintptr, uintptr, uintptr, uintptr)

// This is the asynchronous version of g_socket_listener_accept().
//
// When the operation is finished @callback will be
// called. You can then call g_socket_listener_accept_finish()
// to get the result of the operation.
func (x *SocketListener) AcceptAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xSocketListenerAcceptAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xSocketListenerAcceptFinish func(uintptr, uintptr, *uintptr, **glib.Error) uintptr

// Finishes an async accept operation. See g_socket_listener_accept_async()
func (x *SocketListener) AcceptFinish(ResultVar AsyncResult, SourceObjectVar **gobject.Object) (*SocketConnection, error) {
	var cls *SocketConnection
	var cerr *glib.Error

	cret := xSocketListenerAcceptFinish(x.GoPointer(), ResultVar.GoPointer(), gobject.ConvertPtr(SourceObjectVar), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &SocketConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xSocketListenerAcceptSocket func(uintptr, *uintptr, uintptr, **glib.Error) uintptr

// Blocks waiting for a client to connect to any of the sockets added
// to the listener. Returns the #GSocket that was accepted.
//
// If you want to accept the high-level #GSocketConnection, not a #GSocket,
// which is often the case, then you should use g_socket_listener_accept()
// instead.
//
// If @source_object is not %NULL it will be filled out with the source
// object specified when the corresponding socket or address was added
// to the listener.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *SocketListener) AcceptSocket(SourceObjectVar **gobject.Object, CancellableVar *Cancellable) (*Socket, error) {
	var cls *Socket
	var cerr *glib.Error

	cret := xSocketListenerAcceptSocket(x.GoPointer(), gobject.ConvertPtr(SourceObjectVar), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Socket{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xSocketListenerAcceptSocketAsync func(uintptr, uintptr, uintptr, uintptr)

// This is the asynchronous version of g_socket_listener_accept_socket().
//
// When the operation is finished @callback will be
// called. You can then call g_socket_listener_accept_socket_finish()
// to get the result of the operation.
func (x *SocketListener) AcceptSocketAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xSocketListenerAcceptSocketAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xSocketListenerAcceptSocketFinish func(uintptr, uintptr, *uintptr, **glib.Error) uintptr

// Finishes an async accept operation. See g_socket_listener_accept_socket_async()
func (x *SocketListener) AcceptSocketFinish(ResultVar AsyncResult, SourceObjectVar **gobject.Object) (*Socket, error) {
	var cls *Socket
	var cerr *glib.Error

	cret := xSocketListenerAcceptSocketFinish(x.GoPointer(), ResultVar.GoPointer(), gobject.ConvertPtr(SourceObjectVar), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Socket{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xSocketListenerAddAddress func(uintptr, uintptr, SocketType, SocketProtocol, uintptr, *uintptr, **glib.Error) bool

// Creates a socket of type @type and protocol @protocol, binds
// it to @address and adds it to the set of sockets we're accepting
// sockets from.
//
// Note that adding an IPv6 address, depending on the platform,
// may or may not result in a listener that also accepts IPv4
// connections.  For more deterministic behavior, see
// g_socket_listener_add_inet_port().
//
// @source_object will be passed out in the various calls
// to accept to identify this particular source, which is
// useful if you're listening on multiple addresses and do
// different things depending on what address is connected to.
//
// If successful and @effective_address is non-%NULL then it will
// be set to the address that the binding actually occurred at.  This
// is helpful for determining the port number that was used for when
// requesting a binding to port 0 (ie: "any port").  This address, if
// requested, belongs to the caller and must be freed.
//
// Call g_socket_listener_close() to stop listening on @address; this will not
// be done automatically when you drop your final reference to @listener, as
// references may be held internally.
func (x *SocketListener) AddAddress(AddressVar *SocketAddress, TypeVar SocketType, ProtocolVar SocketProtocol, SourceObjectVar *gobject.Object, EffectiveAddressVar **SocketAddress) (bool, error) {
	var cerr *glib.Error

	cret := xSocketListenerAddAddress(x.GoPointer(), AddressVar.GoPointer(), TypeVar, ProtocolVar, SourceObjectVar.GoPointer(), gobject.ConvertPtr(EffectiveAddressVar), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSocketListenerAddAnyInetPort func(uintptr, uintptr, **glib.Error) uint16

// Listens for TCP connections on any available port number for both
// IPv6 and IPv4 (if each is available).
//
// This is useful if you need to have a socket for incoming connections
// but don't care about the specific port number.
//
// @source_object will be passed out in the various calls
// to accept to identify this particular source, which is
// useful if you're listening on multiple addresses and do
// different things depending on what address is connected to.
func (x *SocketListener) AddAnyInetPort(SourceObjectVar *gobject.Object) (uint16, error) {
	var cerr *glib.Error

	cret := xSocketListenerAddAnyInetPort(x.GoPointer(), SourceObjectVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSocketListenerAddInetPort func(uintptr, uint16, uintptr, **glib.Error) bool

// Helper function for g_socket_listener_add_address() that
// creates a TCP/IP socket listening on IPv4 and IPv6 (if
// supported) on the specified port on all interfaces.
//
// @source_object will be passed out in the various calls
// to accept to identify this particular source, which is
// useful if you're listening on multiple addresses and do
// different things depending on what address is connected to.
//
// Call g_socket_listener_close() to stop listening on @port; this will not
// be done automatically when you drop your final reference to @listener, as
// references may be held internally.
func (x *SocketListener) AddInetPort(PortVar uint16, SourceObjectVar *gobject.Object) (bool, error) {
	var cerr *glib.Error

	cret := xSocketListenerAddInetPort(x.GoPointer(), PortVar, SourceObjectVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSocketListenerAddSocket func(uintptr, uintptr, uintptr, **glib.Error) bool

// Adds @socket to the set of sockets that we try to accept
// new clients from. The socket must be bound to a local
// address and listened to.
//
// @source_object will be passed out in the various calls
// to accept to identify this particular source, which is
// useful if you're listening on multiple addresses and do
// different things depending on what address is connected to.
//
// The @socket will not be automatically closed when the @listener is finalized
// unless the listener held the final reference to the socket. Before GLib 2.42,
// the @socket was automatically closed on finalization of the @listener, even
// if references to it were held elsewhere.
func (x *SocketListener) AddSocket(SocketVar *Socket, SourceObjectVar *gobject.Object) (bool, error) {
	var cerr *glib.Error

	cret := xSocketListenerAddSocket(x.GoPointer(), SocketVar.GoPointer(), SourceObjectVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSocketListenerClose func(uintptr)

// Closes all the sockets in the listener.
func (x *SocketListener) Close() {

	xSocketListenerClose(x.GoPointer())

}

var xSocketListenerSetBacklog func(uintptr, int)

// Sets the listen backlog on the sockets in the listener. This must be called
// before adding any sockets, addresses or ports to the #GSocketListener (for
// example, by calling g_socket_listener_add_inet_port()) to be effective.
//
// See g_socket_set_listen_backlog() for details
func (x *SocketListener) SetBacklog(ListenBacklogVar int) {

	xSocketListenerSetBacklog(x.GoPointer(), ListenBacklogVar)

}

func (c *SocketListener) GoPointer() uintptr {
	return c.Ptr
}

func (c *SocketListener) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when @listener's activity on @socket changes state.
// Note that when @listener is used to listen on both IPv4 and
// IPv6, a separate set of signals will be emitted for each, and
// the order they happen in is undefined.
func (x *SocketListener) ConnectEvent(cb *func(SocketListener, SocketListenerEvent, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "event", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, EventVarp SocketListenerEvent, SocketVarp uintptr) {
		fa := SocketListener{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, EventVarp, SocketVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "event", cbRefPtr)
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xSocketListenerGLibType, lib, "g_socket_listener_get_type")

	core.PuregoSafeRegister(&xNewSocketListener, lib, "g_socket_listener_new")

	core.PuregoSafeRegister(&xSocketListenerAccept, lib, "g_socket_listener_accept")
	core.PuregoSafeRegister(&xSocketListenerAcceptAsync, lib, "g_socket_listener_accept_async")
	core.PuregoSafeRegister(&xSocketListenerAcceptFinish, lib, "g_socket_listener_accept_finish")
	core.PuregoSafeRegister(&xSocketListenerAcceptSocket, lib, "g_socket_listener_accept_socket")
	core.PuregoSafeRegister(&xSocketListenerAcceptSocketAsync, lib, "g_socket_listener_accept_socket_async")
	core.PuregoSafeRegister(&xSocketListenerAcceptSocketFinish, lib, "g_socket_listener_accept_socket_finish")
	core.PuregoSafeRegister(&xSocketListenerAddAddress, lib, "g_socket_listener_add_address")
	core.PuregoSafeRegister(&xSocketListenerAddAnyInetPort, lib, "g_socket_listener_add_any_inet_port")
	core.PuregoSafeRegister(&xSocketListenerAddInetPort, lib, "g_socket_listener_add_inet_port")
	core.PuregoSafeRegister(&xSocketListenerAddSocket, lib, "g_socket_listener_add_socket")
	core.PuregoSafeRegister(&xSocketListenerClose, lib, "g_socket_listener_close")
	core.PuregoSafeRegister(&xSocketListenerSetBacklog, lib, "g_socket_listener_set_backlog")

}
