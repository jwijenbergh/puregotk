// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

var xIoErrorQuark func() glib.Quark

// Gets the GIO Error Quark.
func IoErrorQuark() glib.Quark {

	cret := xIoErrorQuark()
	return cret
}

var xResolverErrorQuark func() glib.Quark

// Gets the #GResolver Error Quark.
func ResolverErrorQuark() glib.Quark {

	cret := xResolverErrorQuark()
	return cret
}

var xResourceErrorQuark func() glib.Quark

// Gets the #GResource Error Quark.
func ResourceErrorQuark() glib.Quark {

	cret := xResourceErrorQuark()
	return cret
}

var xTlsChannelBindingErrorQuark func() glib.Quark

// Gets the TLS channel binding error quark.
func TlsChannelBindingErrorQuark() glib.Quark {

	cret := xTlsChannelBindingErrorQuark()
	return cret
}

var xTlsErrorQuark func() glib.Quark

// Gets the TLS error quark.
func TlsErrorQuark() glib.Quark {

	cret := xTlsErrorQuark()
	return cret
}

// #GAppInfoMonitor is a very simple object used for monitoring the app
// info database for changes (ie: newly installed or removed
// applications).
//
// Call g_app_info_monitor_get() to get a #GAppInfoMonitor and connect
// to the "changed" signal.
//
// In the usual case, applications should try to make note of the change
// (doing things like invalidating caches) but not act on it.  In
// particular, applications should avoid making calls to #GAppInfo APIs
// in response to the change signal, deferring these until the time that
// the data is actually required.  The exception to this case is when
// application information is actually being displayed on the screen
// (eg: during a search or when the list of all applications is shown).
// The reason for this is that changes to the list of installed
// applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
type AppInfoMonitor struct {
	gobject.Object
}

func AppInfoMonitorNewFromInternalPtr(ptr uintptr) *AppInfoMonitor {
	cls := &AppInfoMonitor{}
	cls.Ptr = ptr
	return cls
}

func (c *AppInfoMonitor) GoPointer() uintptr {
	return c.Ptr
}

func (c *AppInfoMonitor) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Signal emitted when the app info database for changes (ie: newly installed
// or removed applications).
func (x *AppInfoMonitor) ConnectChanged(cb *func(AppInfoMonitor)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := AppInfoMonitor{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
}

var xAppInfoMonitorGet func() uintptr

// Gets the #GAppInfoMonitor for the current thread-default main
// context.
//
// The #GAppInfoMonitor will emit a "changed" signal in the
// thread-default main context whenever the list of installed
// applications (as reported by g_app_info_get_all()) may have changed.
//
// You must only call g_object_unref() on the return value from under
// the same main context as you created it.
func AppInfoMonitorGet() *AppInfoMonitor {
	var cls *AppInfoMonitor

	cret := xAppInfoMonitorGet()

	if cret == 0 {
		return nil
	}
	cls = &AppInfoMonitor{}
	cls.Ptr = cret
	return cls
}

// #GBytesIcon specifies an image held in memory in a common format (usually
// png) to be used as icon.
type BytesIcon struct {
	gobject.Object
}

func BytesIconNewFromInternalPtr(ptr uintptr) *BytesIcon {
	cls := &BytesIcon{}
	cls.Ptr = ptr
	return cls
}

var xNewBytesIcon func(*glib.Bytes) uintptr

// Creates a new icon for a bytes.
//
// This cannot fail, but loading and interpreting the bytes may fail later on
// (for example, if g_loadable_icon_load() is called) if the image is invalid.
func NewBytesIcon(BytesVar *glib.Bytes) *BytesIcon {
	var cls *BytesIcon

	cret := xNewBytesIcon(BytesVar)

	if cret == 0 {
		return nil
	}
	cls = &BytesIcon{}
	cls.Ptr = cret
	return cls
}

var xBytesIconGetBytes func(uintptr) *glib.Bytes

// Gets the #GBytes associated with the given @icon.
func (x *BytesIcon) GetBytes() *glib.Bytes {

	cret := xBytesIconGetBytes(x.GoPointer())
	return cret
}

func (c *BytesIcon) GoPointer() uintptr {
	return c.Ptr
}

func (c *BytesIcon) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Checks if two icons are equal.
func (x *BytesIcon) Equal(Icon2Var Icon) bool {

	cret := XGIconEqual(x.GoPointer(), Icon2Var.GoPointer())
	return cret
}

// Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
// back by calling g_icon_deserialize() on the returned value.
// As serialization will avoid using raw icon data when possible, it only
// makes sense to transfer the #GVariant between processes on the same machine,
// (as opposed to over the network), and within the same file system namespace.
func (x *BytesIcon) Serialize() *glib.Variant {

	cret := XGIconSerialize(x.GoPointer())
	return cret
}

// Generates a textual representation of @icon that can be used for
// serialization such as when passing @icon to a different process or
// saving it to persistent storage. Use g_icon_new_for_string() to
// get @icon back from the returned string.
//
// The encoding of the returned string is proprietary to #GIcon except
// in the following two cases
//
//   - If @icon is a #GFileIcon, the returned string is a native path
//     (such as `/path/to/my icon.png`) without escaping
//     if the #GFile for @icon is a native file.  If the file is not
//     native, the returned string is the result of g_file_get_uri()
//     (such as `sftp://path/to/my%20icon.png`).
//
//   - If @icon is a #GThemedIcon with exactly one name and no fallbacks,
//     the encoding is simply the name (such as `network-server`).
func (x *BytesIcon) ToString() string {

	cret := XGIconToString(x.GoPointer())
	return cret
}

// Loads a loadable icon. For the asynchronous version of this function,
// see g_loadable_icon_load_async().
func (x *BytesIcon) Load(SizeVar int, TypeVar string, CancellableVar *Cancellable) (*InputStream, error) {
	var cls *InputStream
	var cerr *glib.Error

	cret := XGLoadableIconLoad(x.GoPointer(), SizeVar, TypeVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &InputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Loads an icon asynchronously. To finish this function, see
// g_loadable_icon_load_finish(). For the synchronous, blocking
// version of this function, see g_loadable_icon_load().
func (x *BytesIcon) LoadAsync(SizeVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGLoadableIconLoadAsync(x.GoPointer(), SizeVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous icon load started in g_loadable_icon_load_async().
func (x *BytesIcon) LoadFinish(ResVar AsyncResult, TypeVar string) (*InputStream, error) {
	var cls *InputStream
	var cerr *glib.Error

	cret := XGLoadableIconLoadFinish(x.GoPointer(), ResVar.GoPointer(), TypeVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &InputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// #GDBusActionGroup is an implementation of the #GActionGroup
// interface that can be used as a proxy for an action group
// that is exported over D-Bus with g_dbus_connection_export_action_group().
type DBusActionGroup struct {
	gobject.Object
}

func DBusActionGroupNewFromInternalPtr(ptr uintptr) *DBusActionGroup {
	cls := &DBusActionGroup{}
	cls.Ptr = ptr
	return cls
}

func (c *DBusActionGroup) GoPointer() uintptr {
	return c.Ptr
}

func (c *DBusActionGroup) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emits the #GActionGroup::action-added signal on @action_group.
//
// This function should only be called by #GActionGroup implementations.
func (x *DBusActionGroup) ActionAdded(ActionNameVar string) {

	XGActionGroupActionAdded(x.GoPointer(), ActionNameVar)

}

// Emits the #GActionGroup::action-enabled-changed signal on @action_group.
//
// This function should only be called by #GActionGroup implementations.
func (x *DBusActionGroup) ActionEnabledChanged(ActionNameVar string, EnabledVar bool) {

	XGActionGroupActionEnabledChanged(x.GoPointer(), ActionNameVar, EnabledVar)

}

// Emits the #GActionGroup::action-removed signal on @action_group.
//
// This function should only be called by #GActionGroup implementations.
func (x *DBusActionGroup) ActionRemoved(ActionNameVar string) {

	XGActionGroupActionRemoved(x.GoPointer(), ActionNameVar)

}

// Emits the #GActionGroup::action-state-changed signal on @action_group.
//
// This function should only be called by #GActionGroup implementations.
func (x *DBusActionGroup) ActionStateChanged(ActionNameVar string, StateVar *glib.Variant) {

	XGActionGroupActionStateChanged(x.GoPointer(), ActionNameVar, StateVar)

}

// Activate the named action within @action_group.
//
// If the action is expecting a parameter, then the correct type of
// parameter must be given as @parameter.  If the action is expecting no
// parameters then @parameter must be %NULL.  See
// g_action_group_get_action_parameter_type().
//
// If the #GActionGroup implementation supports asynchronous remote
// activation over D-Bus, this call may return before the relevant
// D-Bus traffic has been sent, or any replies have been received. In
// order to block on such asynchronous activation calls,
// g_dbus_connection_flush() should be called prior to the code, which
// depends on the result of the action activation. Without flushing
// the D-Bus connection, there is no guarantee that the action would
// have been activated.
//
// The following code which runs in a remote app instance, shows an
// example of a "quit" action being activated on the primary app
// instance over D-Bus. Here g_dbus_connection_flush() is called
// before `exit()`. Without g_dbus_connection_flush(), the "quit" action
// may fail to be activated on the primary instance.
//
// |[&lt;!-- language="C" --&gt;
// // call "quit" action on primary instance
// g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
//
// // make sure the action is activated now
// g_dbus_connection_flush (...);
//
// g_debug ("application has been terminated. exiting.");
//
// exit (0);
// ]|
func (x *DBusActionGroup) ActivateAction(ActionNameVar string, ParameterVar *glib.Variant) {

	XGActionGroupActivateAction(x.GoPointer(), ActionNameVar, ParameterVar)

}

// Request for the state of the named action within @action_group to be
// changed to @value.
//
// The action must be stateful and @value must be of the correct type.
// See g_action_group_get_action_state_type().
//
// This call merely requests a change.  The action may refuse to change
// its state or may change its state to something other than @value.
// See g_action_group_get_action_state_hint().
//
// If the @value GVariant is floating, it is consumed.
func (x *DBusActionGroup) ChangeActionState(ActionNameVar string, ValueVar *glib.Variant) {

	XGActionGroupChangeActionState(x.GoPointer(), ActionNameVar, ValueVar)

}

// Checks if the named action within @action_group is currently enabled.
//
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
func (x *DBusActionGroup) GetActionEnabled(ActionNameVar string) bool {

	cret := XGActionGroupGetActionEnabled(x.GoPointer(), ActionNameVar)
	return cret
}

// Queries the type of the parameter that must be given when activating
// the named action within @action_group.
//
// When activating the action using g_action_group_activate_action(),
// the #GVariant given to that function must be of the type returned
// by this function.
//
// In the case that this function returns %NULL, you must not give any
// #GVariant, but %NULL instead.
//
// The parameter type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added
// with the same name but a different parameter type.
func (x *DBusActionGroup) GetActionParameterType(ActionNameVar string) *glib.VariantType {

	cret := XGActionGroupGetActionParameterType(x.GoPointer(), ActionNameVar)
	return cret
}

// Queries the current state of the named action within @action_group.
//
// If the action is not stateful then %NULL will be returned.  If the
// action is stateful then the type of the return value is the type
// given by g_action_group_get_action_state_type().
//
// The return value (if non-%NULL) should be freed with
// g_variant_unref() when it is no longer required.
func (x *DBusActionGroup) GetActionState(ActionNameVar string) *glib.Variant {

	cret := XGActionGroupGetActionState(x.GoPointer(), ActionNameVar)
	return cret
}

// Requests a hint about the valid range of values for the state of the
// named action within @action_group.
//
// If %NULL is returned it either means that the action is not stateful
// or that there is no hint about the valid range of values for the
// state of the action.
//
// If a #GVariant array is returned then each item in the array is a
// possible value for the state.  If a #GVariant pair (ie: two-tuple) is
// returned then the tuple specifies the inclusive lower and upper bound
// of valid values for the state.
//
// In any case, the information is merely a hint.  It may be possible to
// have a state value outside of the hinted range and setting a value
// within the range may fail.
//
// The return value (if non-%NULL) should be freed with
// g_variant_unref() when it is no longer required.
func (x *DBusActionGroup) GetActionStateHint(ActionNameVar string) *glib.Variant {

	cret := XGActionGroupGetActionStateHint(x.GoPointer(), ActionNameVar)
	return cret
}

// Queries the type of the state of the named action within
// @action_group.
//
// If the action is stateful then this function returns the
// #GVariantType of the state.  All calls to
// g_action_group_change_action_state() must give a #GVariant of this
// type and g_action_group_get_action_state() will return a #GVariant
// of the same type.
//
// If the action is not stateful then this function will return %NULL.
// In that case, g_action_group_get_action_state() will return %NULL
// and you must not call g_action_group_change_action_state().
//
// The state type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added
// with the same name but a different state type.
func (x *DBusActionGroup) GetActionStateType(ActionNameVar string) *glib.VariantType {

	cret := XGActionGroupGetActionStateType(x.GoPointer(), ActionNameVar)
	return cret
}

// Checks if the named action exists within @action_group.
func (x *DBusActionGroup) HasAction(ActionNameVar string) bool {

	cret := XGActionGroupHasAction(x.GoPointer(), ActionNameVar)
	return cret
}

// Lists the actions contained within @action_group.
//
// The caller is responsible for freeing the list with g_strfreev() when
// it is no longer required.
func (x *DBusActionGroup) ListActions() uintptr {

	cret := XGActionGroupListActions(x.GoPointer())
	return cret
}

// Queries all aspects of the named action within an @action_group.
//
// This function acquires the information available from
// g_action_group_has_action(), g_action_group_get_action_enabled(),
// g_action_group_get_action_parameter_type(),
// g_action_group_get_action_state_type(),
// g_action_group_get_action_state_hint() and
// g_action_group_get_action_state() with a single function call.
//
// This provides two main benefits.
//
// The first is the improvement in efficiency that comes with not having
// to perform repeated lookups of the action in order to discover
// different things about it.  The second is that implementing
// #GActionGroup can now be done by only overriding this one virtual
// function.
//
// The interface provides a default implementation of this function that
// calls the individual functions, as required, to fetch the
// information.  The interface also provides default implementations of
// those functions that call this function.  All implementations,
// therefore, must override either this function or all of the others.
//
// If the action exists, %TRUE is returned and any of the requested
// fields (as indicated by having a non-%NULL reference passed in) are
// filled.  If the action doesn't exist, %FALSE is returned and the
// fields may or may not have been modified.
func (x *DBusActionGroup) QueryAction(ActionNameVar string, EnabledVar bool, ParameterTypeVar **glib.VariantType, StateTypeVar **glib.VariantType, StateHintVar **glib.Variant, StateVar **glib.Variant) bool {

	cret := XGActionGroupQueryAction(x.GoPointer(), ActionNameVar, EnabledVar, ParameterTypeVar, StateTypeVar, StateHintVar, StateVar)
	return cret
}

// Activates the remote action.
//
// This is the same as g_action_group_activate_action() except that it
// allows for provision of "platform data" to be sent along with the
// activation request.  This typically contains details such as the user
// interaction timestamp or startup notification information.
//
// @platform_data must be non-%NULL and must have the type
// %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
func (x *DBusActionGroup) ActivateActionFull(ActionNameVar string, ParameterVar *glib.Variant, PlatformDataVar *glib.Variant) {

	XGRemoteActionGroupActivateActionFull(x.GoPointer(), ActionNameVar, ParameterVar, PlatformDataVar)

}

// Changes the state of a remote action.
//
// This is the same as g_action_group_change_action_state() except that
// it allows for provision of "platform data" to be sent along with the
// state change request.  This typically contains details such as the
// user interaction timestamp or startup notification information.
//
// @platform_data must be non-%NULL and must have the type
// %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
func (x *DBusActionGroup) ChangeActionStateFull(ActionNameVar string, ValueVar *glib.Variant, PlatformDataVar *glib.Variant) {

	XGRemoteActionGroupChangeActionStateFull(x.GoPointer(), ActionNameVar, ValueVar, PlatformDataVar)

}

var xDBusActionGroupGet func(uintptr, string, string) uintptr

// Obtains a #GDBusActionGroup for the action group which is exported at
// the given @bus_name and @object_path.
//
// The thread default main context is taken at the time of this call.
// All signals on the menu model (and any linked models) are reported
// with respect to this context.  All calls on the returned menu model
// (and linked models) must also originate from this same context, with
// the thread default main context unchanged.
//
// This call is non-blocking.  The returned action group may or may not
// already be filled in.  The correct thing to do is connect the signals
// for the action group to monitor for changes and then to call
// g_action_group_list_actions() to get the initial list.
func DBusActionGroupGet(ConnectionVar *DBusConnection, BusNameVar string, ObjectPathVar string) *DBusActionGroup {
	var cls *DBusActionGroup

	cret := xDBusActionGroupGet(ConnectionVar.GoPointer(), BusNameVar, ObjectPathVar)

	if cret == 0 {
		return nil
	}
	cls = &DBusActionGroup{}
	cls.Ptr = cret
	return cls
}

// The #GDBusAuthObserver type provides a mechanism for participating
// in how a #GDBusServer (or a #GDBusConnection) authenticates remote
// peers. Simply instantiate a #GDBusAuthObserver and connect to the
// signals you are interested in. Note that new signals may be added
// in the future
//
// ## Controlling Authentication Mechanisms
//
// By default, a #GDBusServer or server-side #GDBusConnection will allow
// any authentication mechanism to be used. If you only
// want to allow D-Bus connections with the `EXTERNAL` mechanism,
// which makes use of credentials passing and is the recommended
// mechanism for modern Unix platforms such as Linux and the BSD family,
// you would use a signal handler like this:
//
// |[&lt;!-- language="C" --&gt;
// static gboolean
// on_allow_mechanism (GDBusAuthObserver *observer,
//
//	const gchar       *mechanism,
//	gpointer           user_data)
//
//	{
//	  if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
//	    {
//	      return TRUE;
//	    }
//
//	  return FALSE;
//	}
//
// ]|
//
// ## Controlling Authorization # {#auth-observer}
//
// By default, a #GDBusServer or server-side #GDBusConnection will accept
// connections from any successfully authenticated user (but not from
// anonymous connections using the `ANONYMOUS` mechanism). If you only
// want to allow D-Bus connections from processes owned by the same uid
// as the server, since GLib 2.68, you should use the
// %G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag. It’s equivalent
// to the following signal handler:
//
// |[&lt;!-- language="C" --&gt;
// static gboolean
// on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//
//	GIOStream         *stream,
//	GCredentials      *credentials,
//	gpointer           user_data)
//
//	{
//	  gboolean authorized;
//
//	  authorized = FALSE;
//	  if (credentials != NULL)
//	    {
//	      GCredentials *own_credentials;
//	      own_credentials = g_credentials_new ();
//	      if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//	        authorized = TRUE;
//	      g_object_unref (own_credentials);
//	    }
//
//	  return authorized;
//	}
//
// ]|
type DBusAuthObserver struct {
	gobject.Object
}

func DBusAuthObserverNewFromInternalPtr(ptr uintptr) *DBusAuthObserver {
	cls := &DBusAuthObserver{}
	cls.Ptr = ptr
	return cls
}

var xNewDBusAuthObserver func() uintptr

// Creates a new #GDBusAuthObserver object.
func NewDBusAuthObserver() *DBusAuthObserver {
	var cls *DBusAuthObserver

	cret := xNewDBusAuthObserver()

	if cret == 0 {
		return nil
	}
	cls = &DBusAuthObserver{}
	cls.Ptr = cret
	return cls
}

var xDBusAuthObserverAllowMechanism func(uintptr, string) bool

// Emits the #GDBusAuthObserver::allow-mechanism signal on @observer.
func (x *DBusAuthObserver) AllowMechanism(MechanismVar string) bool {

	cret := xDBusAuthObserverAllowMechanism(x.GoPointer(), MechanismVar)
	return cret
}

var xDBusAuthObserverAuthorizeAuthenticatedPeer func(uintptr, uintptr, uintptr) bool

// Emits the #GDBusAuthObserver::authorize-authenticated-peer signal on @observer.
func (x *DBusAuthObserver) AuthorizeAuthenticatedPeer(StreamVar *IOStream, CredentialsVar *Credentials) bool {

	cret := xDBusAuthObserverAuthorizeAuthenticatedPeer(x.GoPointer(), StreamVar.GoPointer(), CredentialsVar.GoPointer())
	return cret
}

func (c *DBusAuthObserver) GoPointer() uintptr {
	return c.Ptr
}

func (c *DBusAuthObserver) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted to check if @mechanism is allowed to be used.
func (x *DBusAuthObserver) ConnectAllowMechanism(cb *func(DBusAuthObserver, string) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "allow-mechanism", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, MechanismVarp string) bool {
		fa := DBusAuthObserver{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, MechanismVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "allow-mechanism", cbRefPtr)
}

// Emitted to check if a peer that is successfully authenticated
// is authorized.
func (x *DBusAuthObserver) ConnectAuthorizeAuthenticatedPeer(cb *func(DBusAuthObserver, uintptr, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "authorize-authenticated-peer", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, StreamVarp uintptr, CredentialsVarp uintptr) bool {
		fa := DBusAuthObserver{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, StreamVarp, CredentialsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "authorize-authenticated-peer", cbRefPtr)
}

// The #GDBusConnection type is used for D-Bus connections to remote
// peers such as a message buses. It is a low-level API that offers a
// lot of flexibility. For instance, it lets you establish a connection
// over any transport that can by represented as a #GIOStream.
//
// This class is rarely used directly in D-Bus clients. If you are writing
// a D-Bus client, it is often easier to use the g_bus_own_name(),
// g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
//
// As an exception to the usual GLib rule that a particular object must not
// be used by two threads at the same time, #GDBusConnection's methods may be
// called from any thread. This is so that g_bus_get() and g_bus_get_sync()
// can safely return the same #GDBusConnection when called from any thread.
//
// Most of the ways to obtain a #GDBusConnection automatically initialize it
// (i.e. connect to D-Bus): for instance, g_dbus_connection_new() and
// g_bus_get(), and the synchronous versions of those methods, give you an
// initialized connection. Language bindings for GIO should use
// g_initable_new() or g_async_initable_new_async(), which also initialize the
// connection.
//
// If you construct an uninitialized #GDBusConnection, such as via
// g_object_new(), you must initialize it via g_initable_init() or
// g_async_initable_init_async() before using its methods or properties.
// Calling methods or accessing properties on a #GDBusConnection that has not
// completed initialization successfully is considered to be invalid, and leads
// to undefined behaviour. In particular, if initialization fails with a
// #GError, the only valid thing you can do with that #GDBusConnection is to
// free it with g_object_unref().
//
// ## An example D-Bus server # {#gdbus-server}
//
// Here is an example for a D-Bus server:
// [gdbus-example-server.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-server.c)
//
// ## An example for exporting a subtree # {#gdbus-subtree-server}
//
// Here is an example for exporting a subtree:
// [gdbus-example-subtree.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-subtree.c)
//
// ## An example for file descriptor passing # {#gdbus-unix-fd-client}
//
// Here is an example for passing UNIX file descriptors:
// [gdbus-unix-fd-client.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-unix-fd-client.c)
//
// ## An example for exporting a GObject # {#gdbus-export}
//
// Here is an example for exporting a #GObject:
// [gdbus-example-export.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-export.c)
type DBusConnection struct {
	gobject.Object
}

func DBusConnectionNewFromInternalPtr(ptr uintptr) *DBusConnection {
	cls := &DBusConnection{}
	cls.Ptr = ptr
	return cls
}

var xNewDBusConnectionFinish func(uintptr, **glib.Error) uintptr

// Finishes an operation started with g_dbus_connection_new().
func NewDBusConnectionFinish(ResVar AsyncResult) (*DBusConnection, error) {
	var cls *DBusConnection
	var cerr *glib.Error

	cret := xNewDBusConnectionFinish(ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewDBusConnectionForAddressFinish func(uintptr, **glib.Error) uintptr

// Finishes an operation started with g_dbus_connection_new_for_address().
func NewDBusConnectionForAddressFinish(ResVar AsyncResult) (*DBusConnection, error) {
	var cls *DBusConnection
	var cerr *glib.Error

	cret := xNewDBusConnectionForAddressFinish(ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewDBusConnectionForAddressSync func(string, DBusConnectionFlags, uintptr, uintptr, **glib.Error) uintptr

// Synchronously connects and sets up a D-Bus client connection for
// exchanging D-Bus messages with an endpoint specified by @address
// which must be in the
// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This constructor can only be used to initiate client-side
// connections - use g_dbus_connection_new_sync() if you need to act
// as the server. In particular, @flags cannot contain the
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
//
// This is a synchronous failable constructor. See
// g_dbus_connection_new_for_address() for the asynchronous version.
//
// If @observer is not %NULL it may be used to control the
// authentication process.
func NewDBusConnectionForAddressSync(AddressVar string, FlagsVar DBusConnectionFlags, ObserverVar *DBusAuthObserver, CancellableVar *Cancellable) (*DBusConnection, error) {
	var cls *DBusConnection
	var cerr *glib.Error

	cret := xNewDBusConnectionForAddressSync(AddressVar, FlagsVar, ObserverVar.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewDBusConnectionSync func(uintptr, string, DBusConnectionFlags, uintptr, uintptr, **glib.Error) uintptr

// Synchronously sets up a D-Bus connection for exchanging D-Bus messages
// with the end represented by @stream.
//
// If @stream is a #GSocketConnection, then the corresponding #GSocket
// will be put into non-blocking mode.
//
// The D-Bus connection will interact with @stream from a worker thread.
// As a result, the caller should not interact with @stream after this
// method has been called, except by calling g_object_unref() on it.
//
// If @observer is not %NULL it may be used to control the
// authentication process.
//
// This is a synchronous failable constructor. See
// g_dbus_connection_new() for the asynchronous version.
func NewDBusConnectionSync(StreamVar *IOStream, GuidVar string, FlagsVar DBusConnectionFlags, ObserverVar *DBusAuthObserver, CancellableVar *Cancellable) (*DBusConnection, error) {
	var cls *DBusConnection
	var cerr *glib.Error

	cret := xNewDBusConnectionSync(StreamVar.GoPointer(), GuidVar, FlagsVar, ObserverVar.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDBusConnectionAddFilter func(uintptr, uintptr, uintptr, uintptr) uint

// Adds a message filter. Filters are handlers that are run on all
// incoming and outgoing messages, prior to standard dispatch. Filters
// are run in the order that they were added.  The same handler can be
// added as a filter more than once, in which case it will be run more
// than once.  Filters added during a filter callback won't be run on
// the message being processed. Filter functions are allowed to modify
// and even drop messages.
//
// Note that filters are run in a dedicated message handling thread so
// they can't block and, generally, can't do anything but signal a
// worker thread. Also note that filters are rarely needed - use API
// such as g_dbus_connection_send_message_with_reply(),
// g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
//
// If a filter consumes an incoming message the message is not
// dispatched anywhere else - not even the standard dispatch machinery
// (that API such as g_dbus_connection_signal_subscribe() and
// g_dbus_connection_send_message_with_reply() relies on) will see the
// message. Similarly, if a filter consumes an outgoing message, the
// message will not be sent to the other peer.
//
// If @user_data_free_func is non-%NULL, it will be called (in the
// thread-default main context of the thread you are calling this
// method from) at some point after @user_data is no longer
// needed. (It is not guaranteed to be called synchronously when the
// filter is removed, and may be called after @connection has been
// destroyed.)
func (x *DBusConnection) AddFilter(FilterFunctionVar *DBusMessageFilterFunction, UserDataVar uintptr, UserDataFreeFuncVar *glib.DestroyNotify) uint {

	cret := xDBusConnectionAddFilter(x.GoPointer(), glib.NewCallback(FilterFunctionVar), UserDataVar, glib.NewCallback(UserDataFreeFuncVar))
	return cret
}

var xDBusConnectionCall func(uintptr, string, string, string, string, *glib.Variant, *glib.VariantType, DBusCallFlags, int, uintptr, uintptr, uintptr)

// Asynchronously invokes the @method_name method on the
// @interface_name D-Bus interface on the remote object at
// @object_path owned by @bus_name.
//
// If @connection is closed then the operation will fail with
// %G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will
// fail with %G_IO_ERROR_CANCELLED. If @parameters contains a value
// not compatible with the D-Bus protocol, the operation fails with
// %G_IO_ERROR_INVALID_ARGUMENT.
//
// If @reply_type is non-%NULL then the reply will be checked for having this type and an
// error will be raised if it does not match.  Said another way, if you give a @reply_type
// then any non-%NULL return value will be of this type. Unless it’s
// %G_VARIANT_TYPE_UNIT, the @reply_type will be a tuple containing one or more
// values.
//
// If the @parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
// |[&lt;!-- language="C" --&gt;
//
//	g_dbus_connection_call (connection,
//	                        "org.freedesktop.StringThings",
//	                        "/org/freedesktop/StringThings",
//	                        "org.freedesktop.StringThings",
//	                        "TwoStrings",
//	                        g_variant_new ("(ss)",
//	                                       "Thing One",
//	                                       "Thing Two"),
//	                        NULL,
//	                        G_DBUS_CALL_FLAGS_NONE,
//	                        -1,
//	                        NULL,
//	                        (GAsyncReadyCallback) two_strings_done,
//	                        NULL);
//
// ]|
//
// This is an asynchronous method. When the operation is finished,
// @callback will be invoked in the
// [thread-default main context][g-main-context-push-thread-default]
// of the thread you are calling this method from. You can then call
// g_dbus_connection_call_finish() to get the result of the operation.
// See g_dbus_connection_call_sync() for the synchronous version of this
// function.
//
// If @callback is %NULL then the D-Bus method call message will be sent with
// the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
func (x *DBusConnection) Call(BusNameVar string, ObjectPathVar string, InterfaceNameVar string, MethodNameVar string, ParametersVar *glib.Variant, ReplyTypeVar *glib.VariantType, FlagsVar DBusCallFlags, TimeoutMsecVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionCall(x.GoPointer(), BusNameVar, ObjectPathVar, InterfaceNameVar, MethodNameVar, ParametersVar, ReplyTypeVar, FlagsVar, TimeoutMsecVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xDBusConnectionCallFinish func(uintptr, uintptr, **glib.Error) *glib.Variant

// Finishes an operation started with g_dbus_connection_call().
func (x *DBusConnection) CallFinish(ResVar AsyncResult) (*glib.Variant, error) {
	var cerr *glib.Error

	cret := xDBusConnectionCallFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionCallSync func(uintptr, string, string, string, string, *glib.Variant, *glib.VariantType, DBusCallFlags, int, uintptr, **glib.Error) *glib.Variant

// Synchronously invokes the @method_name method on the
// @interface_name D-Bus interface on the remote object at
// @object_path owned by @bus_name.
//
// If @connection is closed then the operation will fail with
// %G_IO_ERROR_CLOSED. If @cancellable is canceled, the
// operation will fail with %G_IO_ERROR_CANCELLED. If @parameters
// contains a value not compatible with the D-Bus protocol, the operation
// fails with %G_IO_ERROR_INVALID_ARGUMENT.
//
// If @reply_type is non-%NULL then the reply will be checked for having
// this type and an error will be raised if it does not match.  Said
// another way, if you give a @reply_type then any non-%NULL return
// value will be of this type.
//
// If the @parameters #GVariant is floating, it is consumed.
// This allows convenient 'inline' use of g_variant_new(), e.g.:
// |[&lt;!-- language="C" --&gt;
//
//	g_dbus_connection_call_sync (connection,
//	                             "org.freedesktop.StringThings",
//	                             "/org/freedesktop/StringThings",
//	                             "org.freedesktop.StringThings",
//	                             "TwoStrings",
//	                             g_variant_new ("(ss)",
//	                                            "Thing One",
//	                                            "Thing Two"),
//	                             NULL,
//	                             G_DBUS_CALL_FLAGS_NONE,
//	                             -1,
//	                             NULL,
//	                             &amp;error);
//
// ]|
//
// The calling thread is blocked until a reply is received. See
// g_dbus_connection_call() for the asynchronous version of
// this method.
func (x *DBusConnection) CallSync(BusNameVar string, ObjectPathVar string, InterfaceNameVar string, MethodNameVar string, ParametersVar *glib.Variant, ReplyTypeVar *glib.VariantType, FlagsVar DBusCallFlags, TimeoutMsecVar int, CancellableVar *Cancellable) (*glib.Variant, error) {
	var cerr *glib.Error

	cret := xDBusConnectionCallSync(x.GoPointer(), BusNameVar, ObjectPathVar, InterfaceNameVar, MethodNameVar, ParametersVar, ReplyTypeVar, FlagsVar, TimeoutMsecVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionCallWithUnixFdList func(uintptr, string, string, string, string, *glib.Variant, *glib.VariantType, DBusCallFlags, int, uintptr, uintptr, uintptr, uintptr)

// Like g_dbus_connection_call() but also takes a #GUnixFDList object.
//
// The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
// values in the body of the message. For example, if a message contains
// two file descriptors, @fd_list would have length 2, and
// `g_variant_new_handle (0)` and `g_variant_new_handle (1)` would appear
// somewhere in the body of the message (not necessarily in that order!)
// to represent the file descriptors at indexes 0 and 1 respectively.
//
// When designing D-Bus APIs that are intended to be interoperable,
// please note that non-GDBus implementations of D-Bus can usually only
// access file descriptors if they are referenced in this way by a
// value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
//
// This method is only available on UNIX.
func (x *DBusConnection) CallWithUnixFdList(BusNameVar string, ObjectPathVar string, InterfaceNameVar string, MethodNameVar string, ParametersVar *glib.Variant, ReplyTypeVar *glib.VariantType, FlagsVar DBusCallFlags, TimeoutMsecVar int, FdListVar *UnixFDList, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionCallWithUnixFdList(x.GoPointer(), BusNameVar, ObjectPathVar, InterfaceNameVar, MethodNameVar, ParametersVar, ReplyTypeVar, FlagsVar, TimeoutMsecVar, FdListVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xDBusConnectionCallWithUnixFdListFinish func(uintptr, *uintptr, uintptr, **glib.Error) *glib.Variant

// Finishes an operation started with g_dbus_connection_call_with_unix_fd_list().
//
// The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
// values in the body of the message. For example,
// if g_variant_get_handle() returns 5, that is intended to be a reference
// to the file descriptor that can be accessed by
// `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
//
// When designing D-Bus APIs that are intended to be interoperable,
// please note that non-GDBus implementations of D-Bus can usually only
// access file descriptors if they are referenced in this way by a
// value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
func (x *DBusConnection) CallWithUnixFdListFinish(OutFdListVar **UnixFDList, ResVar AsyncResult) (*glib.Variant, error) {
	var cerr *glib.Error

	cret := xDBusConnectionCallWithUnixFdListFinish(x.GoPointer(), gobject.ConvertPtr(OutFdListVar), ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionCallWithUnixFdListSync func(uintptr, string, string, string, string, *glib.Variant, *glib.VariantType, DBusCallFlags, int, uintptr, *uintptr, uintptr, **glib.Error) *glib.Variant

// Like g_dbus_connection_call_sync() but also takes and returns #GUnixFDList objects.
// See g_dbus_connection_call_with_unix_fd_list() and
// g_dbus_connection_call_with_unix_fd_list_finish() for more details.
//
// This method is only available on UNIX.
func (x *DBusConnection) CallWithUnixFdListSync(BusNameVar string, ObjectPathVar string, InterfaceNameVar string, MethodNameVar string, ParametersVar *glib.Variant, ReplyTypeVar *glib.VariantType, FlagsVar DBusCallFlags, TimeoutMsecVar int, FdListVar *UnixFDList, OutFdListVar **UnixFDList, CancellableVar *Cancellable) (*glib.Variant, error) {
	var cerr *glib.Error

	cret := xDBusConnectionCallWithUnixFdListSync(x.GoPointer(), BusNameVar, ObjectPathVar, InterfaceNameVar, MethodNameVar, ParametersVar, ReplyTypeVar, FlagsVar, TimeoutMsecVar, FdListVar.GoPointer(), gobject.ConvertPtr(OutFdListVar), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionClose func(uintptr, uintptr, uintptr, uintptr)

// Closes @connection. Note that this never causes the process to
// exit (this might only happen if the other end of a shared message
// bus connection disconnects, see #GDBusConnection:exit-on-close).
//
// Once the connection is closed, operations such as sending a message
// will return with the error %G_IO_ERROR_CLOSED. Closing a connection
// will not automatically flush the connection so queued messages may
// be lost. Use g_dbus_connection_flush() if you need such guarantees.
//
// If @connection is already closed, this method fails with
// %G_IO_ERROR_CLOSED.
//
// When @connection has been closed, the #GDBusConnection::closed
// signal is emitted in the
// [thread-default main context][g-main-context-push-thread-default]
// of the thread that @connection was constructed in.
//
// This is an asynchronous method. When the operation is finished,
// @callback will be invoked in the
// [thread-default main context][g-main-context-push-thread-default]
// of the thread you are calling this method from. You can
// then call g_dbus_connection_close_finish() to get the result of the
// operation. See g_dbus_connection_close_sync() for the synchronous
// version.
func (x *DBusConnection) Close(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionClose(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xDBusConnectionCloseFinish func(uintptr, uintptr, **glib.Error) bool

// Finishes an operation started with g_dbus_connection_close().
func (x *DBusConnection) CloseFinish(ResVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xDBusConnectionCloseFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionCloseSync func(uintptr, uintptr, **glib.Error) bool

// Synchronously closes @connection. The calling thread is blocked
// until this is done. See g_dbus_connection_close() for the
// asynchronous version of this method and more details about what it
// does.
func (x *DBusConnection) CloseSync(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xDBusConnectionCloseSync(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionEmitSignal func(uintptr, string, string, string, string, *glib.Variant, **glib.Error) bool

// Emits a signal.
//
// If the parameters GVariant is floating, it is consumed.
//
// This can only fail if @parameters is not compatible with the D-Bus protocol
// (%G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
// (%G_IO_ERROR_CLOSED).
func (x *DBusConnection) EmitSignal(DestinationBusNameVar string, ObjectPathVar string, InterfaceNameVar string, SignalNameVar string, ParametersVar *glib.Variant) (bool, error) {
	var cerr *glib.Error

	cret := xDBusConnectionEmitSignal(x.GoPointer(), DestinationBusNameVar, ObjectPathVar, InterfaceNameVar, SignalNameVar, ParametersVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionExportActionGroup func(uintptr, string, uintptr, **glib.Error) uint

// Exports @action_group on @connection at @object_path.
//
// The implemented D-Bus API should be considered private.  It is
// subject to change in the future.
//
// A given object path can only have one action group exported on it.
// If this constraint is violated, the export will fail and 0 will be
// returned (with @error set accordingly).
//
// You can unexport the action group using
// g_dbus_connection_unexport_action_group() with the return value of
// this function.
//
// The thread default main context is taken at the time of this call.
// All incoming action activations and state change requests are
// reported from this context.  Any changes on the action group that
// cause it to emit signals must also come from this same context.
// Since incoming action activations and state change requests are
// rather likely to cause changes on the action group, this effectively
// limits a given action group to being exported from only one main
// context.
func (x *DBusConnection) ExportActionGroup(ObjectPathVar string, ActionGroupVar ActionGroup) (uint, error) {
	var cerr *glib.Error

	cret := xDBusConnectionExportActionGroup(x.GoPointer(), ObjectPathVar, ActionGroupVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionExportMenuModel func(uintptr, string, uintptr, **glib.Error) uint

// Exports @menu on @connection at @object_path.
//
// The implemented D-Bus API should be considered private.
// It is subject to change in the future.
//
// An object path can only have one menu model exported on it. If this
// constraint is violated, the export will fail and 0 will be
// returned (with @error set accordingly).
//
// You can unexport the menu model using
// g_dbus_connection_unexport_menu_model() with the return value of
// this function.
func (x *DBusConnection) ExportMenuModel(ObjectPathVar string, MenuVar *MenuModel) (uint, error) {
	var cerr *glib.Error

	cret := xDBusConnectionExportMenuModel(x.GoPointer(), ObjectPathVar, MenuVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionFlush func(uintptr, uintptr, uintptr, uintptr)

// Asynchronously flushes @connection, that is, writes all queued
// outgoing message to the transport and then flushes the transport
// (using g_output_stream_flush_async()). This is useful in programs
// that wants to emit a D-Bus signal and then exit immediately. Without
// flushing the connection, there is no guaranteed that the message has
// been sent to the networking buffers in the OS kernel.
//
// This is an asynchronous method. When the operation is finished,
// @callback will be invoked in the
// [thread-default main context][g-main-context-push-thread-default]
// of the thread you are calling this method from. You can
// then call g_dbus_connection_flush_finish() to get the result of the
// operation. See g_dbus_connection_flush_sync() for the synchronous
// version.
func (x *DBusConnection) Flush(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionFlush(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xDBusConnectionFlushFinish func(uintptr, uintptr, **glib.Error) bool

// Finishes an operation started with g_dbus_connection_flush().
func (x *DBusConnection) FlushFinish(ResVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xDBusConnectionFlushFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionFlushSync func(uintptr, uintptr, **glib.Error) bool

// Synchronously flushes @connection. The calling thread is blocked
// until this is done. See g_dbus_connection_flush() for the
// asynchronous version of this method and more details about what it
// does.
func (x *DBusConnection) FlushSync(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xDBusConnectionFlushSync(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionGetCapabilities func(uintptr) DBusCapabilityFlags

// Gets the capabilities negotiated with the remote peer
func (x *DBusConnection) GetCapabilities() DBusCapabilityFlags {

	cret := xDBusConnectionGetCapabilities(x.GoPointer())
	return cret
}

var xDBusConnectionGetExitOnClose func(uintptr) bool

// Gets whether the process is terminated when @connection is
// closed by the remote peer. See
// #GDBusConnection:exit-on-close for more details.
func (x *DBusConnection) GetExitOnClose() bool {

	cret := xDBusConnectionGetExitOnClose(x.GoPointer())
	return cret
}

var xDBusConnectionGetFlags func(uintptr) DBusConnectionFlags

// Gets the flags used to construct this connection
func (x *DBusConnection) GetFlags() DBusConnectionFlags {

	cret := xDBusConnectionGetFlags(x.GoPointer())
	return cret
}

var xDBusConnectionGetGuid func(uintptr) string

// The GUID of the peer performing the role of server when
// authenticating. See #GDBusConnection:guid for more details.
func (x *DBusConnection) GetGuid() string {

	cret := xDBusConnectionGetGuid(x.GoPointer())
	return cret
}

var xDBusConnectionGetLastSerial func(uintptr) uint32

// Retrieves the last serial number assigned to a #GDBusMessage on
// the current thread. This includes messages sent via both low-level
// API such as g_dbus_connection_send_message() as well as
// high-level API such as g_dbus_connection_emit_signal(),
// g_dbus_connection_call() or g_dbus_proxy_call().
func (x *DBusConnection) GetLastSerial() uint32 {

	cret := xDBusConnectionGetLastSerial(x.GoPointer())
	return cret
}

var xDBusConnectionGetPeerCredentials func(uintptr) uintptr

// Gets the credentials of the authenticated peer. This will always
// return %NULL unless @connection acted as a server
// (e.g. %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed)
// when set up and the client passed credentials as part of the
// authentication process.
//
// In a message bus setup, the message bus is always the server and
// each application is a client. So this method will always return
// %NULL for message bus clients.
func (x *DBusConnection) GetPeerCredentials() *Credentials {
	var cls *Credentials

	cret := xDBusConnectionGetPeerCredentials(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Credentials{}
	cls.Ptr = cret
	return cls
}

var xDBusConnectionGetStream func(uintptr) uintptr

// Gets the underlying stream used for IO.
//
// While the #GDBusConnection is active, it will interact with this
// stream from a worker thread, so it is not safe to interact with
// the stream directly.
func (x *DBusConnection) GetStream() *IOStream {
	var cls *IOStream

	cret := xDBusConnectionGetStream(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &IOStream{}
	cls.Ptr = cret
	return cls
}

var xDBusConnectionGetUniqueName func(uintptr) string

// Gets the unique name of @connection as assigned by the message
// bus. This can also be used to figure out if @connection is a
// message bus connection.
func (x *DBusConnection) GetUniqueName() string {

	cret := xDBusConnectionGetUniqueName(x.GoPointer())
	return cret
}

var xDBusConnectionIsClosed func(uintptr) bool

// Gets whether @connection is closed.
func (x *DBusConnection) IsClosed() bool {

	cret := xDBusConnectionIsClosed(x.GoPointer())
	return cret
}

var xDBusConnectionRegisterObject func(uintptr, string, *DBusInterfaceInfo, *DBusInterfaceVTable, uintptr, uintptr, **glib.Error) uint

// Registers callbacks for exported objects at @object_path with the
// D-Bus interface that is described in @interface_info.
//
// Calls to functions in @vtable (and @user_data_free_func) will happen
// in the
// [thread-default main context][g-main-context-push-thread-default]
// of the thread you are calling this method from.
//
// Note that all #GVariant values passed to functions in @vtable will match
// the signature given in @interface_info - if a remote caller passes
// incorrect values, the `org.freedesktop.DBus.Error.InvalidArgs`
// is returned to the remote caller.
//
// Additionally, if the remote caller attempts to invoke methods or
// access properties not mentioned in @interface_info the
// `org.freedesktop.DBus.Error.UnknownMethod` resp.
// `org.freedesktop.DBus.Error.InvalidArgs` errors
// are returned to the caller.
//
// It is considered a programming error if the
// #GDBusInterfaceGetPropertyFunc function in @vtable returns a
// #GVariant of incorrect type.
//
// If an existing callback is already registered at @object_path and
// @interface_name, then @error is set to %G_IO_ERROR_EXISTS.
//
// GDBus automatically implements the standard D-Bus interfaces
// org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable
// and org.freedesktop.Peer, so you don't have to implement those for the
// objects you export. You can implement org.freedesktop.DBus.Properties
// yourself, e.g. to handle getting and setting of properties asynchronously.
//
// Note that the reference count on @interface_info will be
// incremented by 1 (unless allocated statically, e.g. if the
// reference count is -1, see g_dbus_interface_info_ref()) for as long
// as the object is exported. Also note that @vtable will be copied.
//
// See this [server][gdbus-server] for an example of how to use this method.
func (x *DBusConnection) RegisterObject(ObjectPathVar string, InterfaceInfoVar *DBusInterfaceInfo, VtableVar *DBusInterfaceVTable, UserDataVar uintptr, UserDataFreeFuncVar *glib.DestroyNotify) (uint, error) {
	var cerr *glib.Error

	cret := xDBusConnectionRegisterObject(x.GoPointer(), ObjectPathVar, InterfaceInfoVar, VtableVar, UserDataVar, glib.NewCallback(UserDataFreeFuncVar), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionRegisterObjectWithClosures func(uintptr, string, *DBusInterfaceInfo, *gobject.Closure, *gobject.Closure, *gobject.Closure, **glib.Error) uint

// Version of g_dbus_connection_register_object() using closures instead of a
// #GDBusInterfaceVTable for easier binding in other languages.
func (x *DBusConnection) RegisterObjectWithClosures(ObjectPathVar string, InterfaceInfoVar *DBusInterfaceInfo, MethodCallClosureVar *gobject.Closure, GetPropertyClosureVar *gobject.Closure, SetPropertyClosureVar *gobject.Closure) (uint, error) {
	var cerr *glib.Error

	cret := xDBusConnectionRegisterObjectWithClosures(x.GoPointer(), ObjectPathVar, InterfaceInfoVar, MethodCallClosureVar, GetPropertyClosureVar, SetPropertyClosureVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionRegisterSubtree func(uintptr, string, *DBusSubtreeVTable, DBusSubtreeFlags, uintptr, uintptr, **glib.Error) uint

// Registers a whole subtree of dynamic objects.
//
// The @enumerate and @introspection functions in @vtable are used to
// convey, to remote callers, what nodes exist in the subtree rooted
// by @object_path.
//
// When handling remote calls into any node in the subtree, first the
// @enumerate function is used to check if the node exists. If the node exists
// or the %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is set
// the @introspection function is used to check if the node supports the
// requested method. If so, the @dispatch function is used to determine
// where to dispatch the call. The collected #GDBusInterfaceVTable and
// #gpointer will be used to call into the interface vtable for processing
// the request.
//
// All calls into user-provided code will be invoked in the
// [thread-default main context][g-main-context-push-thread-default]
// of the thread you are calling this method from.
//
// If an existing subtree is already registered at @object_path or
// then @error is set to %G_IO_ERROR_EXISTS.
//
// Note that it is valid to register regular objects (using
// g_dbus_connection_register_object()) in a subtree registered with
// g_dbus_connection_register_subtree() - if so, the subtree handler
// is tried as the last resort. One way to think about a subtree
// handler is to consider it a fallback handler for object paths not
// registered via g_dbus_connection_register_object() or other bindings.
//
// Note that @vtable will be copied so you cannot change it after
// registration.
//
// See this [server][gdbus-subtree-server] for an example of how to use
// this method.
func (x *DBusConnection) RegisterSubtree(ObjectPathVar string, VtableVar *DBusSubtreeVTable, FlagsVar DBusSubtreeFlags, UserDataVar uintptr, UserDataFreeFuncVar *glib.DestroyNotify) (uint, error) {
	var cerr *glib.Error

	cret := xDBusConnectionRegisterSubtree(x.GoPointer(), ObjectPathVar, VtableVar, FlagsVar, UserDataVar, glib.NewCallback(UserDataFreeFuncVar), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionRemoveFilter func(uintptr, uint)

// Removes a filter.
//
// Note that since filters run in a different thread, there is a race
// condition where it is possible that the filter will be running even
// after calling g_dbus_connection_remove_filter(), so you cannot just
// free data that the filter might be using. Instead, you should pass
// a #GDestroyNotify to g_dbus_connection_add_filter(), which will be
// called when it is guaranteed that the data is no longer needed.
func (x *DBusConnection) RemoveFilter(FilterIdVar uint) {

	xDBusConnectionRemoveFilter(x.GoPointer(), FilterIdVar)

}

var xDBusConnectionSendMessage func(uintptr, uintptr, DBusSendMessageFlags, uint32, **glib.Error) bool

// Asynchronously sends @message to the peer represented by @connection.
//
// Unless @flags contain the
// %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
// will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not %NULL, then the
// serial number used will be written to this location prior to
// submitting the message to the underlying transport. While it has a `volatile`
// qualifier, this is a historical artifact and the argument passed to it should
// not be `volatile`.
//
// If @connection is closed then the operation will fail with
// %G_IO_ERROR_CLOSED. If @message is not well-formed,
// the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
// for an example of how to use this low-level API to send and receive
// UNIX file descriptors.
//
// Note that @message must be unlocked, unless @flags contain the
// %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
func (x *DBusConnection) SendMessage(MessageVar *DBusMessage, FlagsVar DBusSendMessageFlags, OutSerialVar uint32) (bool, error) {
	var cerr *glib.Error

	cret := xDBusConnectionSendMessage(x.GoPointer(), MessageVar.GoPointer(), FlagsVar, OutSerialVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionSendMessageWithReply func(uintptr, uintptr, DBusSendMessageFlags, int, uint32, uintptr, uintptr, uintptr)

// Asynchronously sends @message to the peer represented by @connection.
//
// Unless @flags contain the
// %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
// will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not %NULL, then the
// serial number used will be written to this location prior to
// submitting the message to the underlying transport. While it has a `volatile`
// qualifier, this is a historical artifact and the argument passed to it should
// not be `volatile`.
//
// If @connection is closed then the operation will fail with
// %G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will
// fail with %G_IO_ERROR_CANCELLED. If @message is not well-formed,
// the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the
// [thread-default main context][g-main-context-push-thread-default]
// of the thread you are calling this method from. You can then call
// g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.
// See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.
//
// Note that @message must be unlocked, unless @flags contain the
// %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
// for an example of how to use this low-level API to send and receive
// UNIX file descriptors.
func (x *DBusConnection) SendMessageWithReply(MessageVar *DBusMessage, FlagsVar DBusSendMessageFlags, TimeoutMsecVar int, OutSerialVar uint32, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionSendMessageWithReply(x.GoPointer(), MessageVar.GoPointer(), FlagsVar, TimeoutMsecVar, OutSerialVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xDBusConnectionSendMessageWithReplyFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finishes an operation started with g_dbus_connection_send_message_with_reply().
//
// Note that @error is only set if a local in-process error
// occurred. That is to say that the returned #GDBusMessage object may
// be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
// g_dbus_message_to_gerror() to transcode this to a #GError.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
// for an example of how to use this low-level API to send and receive
// UNIX file descriptors.
func (x *DBusConnection) SendMessageWithReplyFinish(ResVar AsyncResult) (*DBusMessage, error) {
	var cls *DBusMessage
	var cerr *glib.Error

	cret := xDBusConnectionSendMessageWithReplyFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusMessage{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDBusConnectionSendMessageWithReplySync func(uintptr, uintptr, DBusSendMessageFlags, int, uint32, uintptr, **glib.Error) uintptr

// Synchronously sends @message to the peer represented by @connection
// and blocks the calling thread until a reply is received or the
// timeout is reached. See g_dbus_connection_send_message_with_reply()
// for the asynchronous version of this method.
//
// Unless @flags contain the
// %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
// will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not %NULL, then the
// serial number used will be written to this location prior to
// submitting the message to the underlying transport. While it has a `volatile`
// qualifier, this is a historical artifact and the argument passed to it should
// not be `volatile`.
//
// If @connection is closed then the operation will fail with
// %G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will
// fail with %G_IO_ERROR_CANCELLED. If @message is not well-formed,
// the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
//
// Note that @error is only set if a local in-process error
// occurred. That is to say that the returned #GDBusMessage object may
// be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
// g_dbus_message_to_gerror() to transcode this to a #GError.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
// for an example of how to use this low-level API to send and receive
// UNIX file descriptors.
//
// Note that @message must be unlocked, unless @flags contain the
// %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
func (x *DBusConnection) SendMessageWithReplySync(MessageVar *DBusMessage, FlagsVar DBusSendMessageFlags, TimeoutMsecVar int, OutSerialVar uint32, CancellableVar *Cancellable) (*DBusMessage, error) {
	var cls *DBusMessage
	var cerr *glib.Error

	cret := xDBusConnectionSendMessageWithReplySync(x.GoPointer(), MessageVar.GoPointer(), FlagsVar, TimeoutMsecVar, OutSerialVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusMessage{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDBusConnectionSetExitOnClose func(uintptr, bool)

// Sets whether the process should be terminated when @connection is
// closed by the remote peer. See #GDBusConnection:exit-on-close for
// more details.
//
// Note that this function should be used with care. Most modern UNIX
// desktops tie the notion of a user session with the session bus, and expect
// all of a user's applications to quit when their bus connection goes away.
// If you are setting @exit_on_close to %FALSE for the shared session
// bus connection, you should make sure that your application exits
// when the user session ends.
func (x *DBusConnection) SetExitOnClose(ExitOnCloseVar bool) {

	xDBusConnectionSetExitOnClose(x.GoPointer(), ExitOnCloseVar)

}

var xDBusConnectionSignalSubscribe func(uintptr, string, string, string, string, string, DBusSignalFlags, uintptr, uintptr, uintptr) uint

// Subscribes to signals on @connection and invokes @callback with a whenever
// the signal is received. Note that @callback will be invoked in the
// [thread-default main context][g-main-context-push-thread-default]
// of the thread you are calling this method from.
//
// If @connection is not a message bus connection, @sender must be
// %NULL.
//
// If @sender is a well-known name note that @callback is invoked with
// the unique name for the owner of @sender, not the well-known name
// as one would expect. This is because the message bus rewrites the
// name. As such, to avoid certain race conditions, users should be
// tracking the name owner of the well-known name and use that when
// processing the received signal.
//
// If one of %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
// %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, @arg0 is
// interpreted as part of a namespace or path.  The first argument
// of a signal is matched against that part as specified by D-Bus.
//
// If @user_data_free_func is non-%NULL, it will be called (in the
// thread-default main context of the thread you are calling this
// method from) at some point after @user_data is no longer
// needed. (It is not guaranteed to be called synchronously when the
// signal is unsubscribed from, and may be called after @connection
// has been destroyed.)
//
// As @callback is potentially invoked in a different thread from where it’s
// emitted, it’s possible for this to happen after
// g_dbus_connection_signal_unsubscribe() has been called in another thread.
// Due to this, @user_data should have a strong reference which is freed with
// @user_data_free_func, rather than pointing to data whose lifecycle is tied
// to the signal subscription. For example, if a #GObject is used to store the
// subscription ID from g_dbus_connection_signal_subscribe(), a strong reference
// to that #GObject must be passed to @user_data, and g_object_unref() passed to
// @user_data_free_func. You are responsible for breaking the resulting
// reference count cycle by explicitly unsubscribing from the signal when
// dropping the last external reference to the #GObject. Alternatively, a weak
// reference may be used.
//
// It is guaranteed that if you unsubscribe from a signal using
// g_dbus_connection_signal_unsubscribe() from the same thread which made the
// corresponding g_dbus_connection_signal_subscribe() call, @callback will not
// be invoked after g_dbus_connection_signal_unsubscribe() returns.
//
// The returned subscription identifier is an opaque value which is guaranteed
// to never be zero.
//
// This function can never fail.
func (x *DBusConnection) SignalSubscribe(SenderVar string, InterfaceNameVar string, MemberVar string, ObjectPathVar string, Arg0Var string, FlagsVar DBusSignalFlags, CallbackVar *DBusSignalCallback, UserDataVar uintptr, UserDataFreeFuncVar *glib.DestroyNotify) uint {

	cret := xDBusConnectionSignalSubscribe(x.GoPointer(), SenderVar, InterfaceNameVar, MemberVar, ObjectPathVar, Arg0Var, FlagsVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallback(UserDataFreeFuncVar))
	return cret
}

var xDBusConnectionSignalUnsubscribe func(uintptr, uint)

// Unsubscribes from signals.
//
// Note that there may still be D-Bus traffic to process (relating to this
// signal subscription) in the current thread-default #GMainContext after this
// function has returned. You should continue to iterate the #GMainContext
// until the #GDestroyNotify function passed to
// g_dbus_connection_signal_subscribe() is called, in order to avoid memory
// leaks through callbacks queued on the #GMainContext after it’s stopped being
// iterated.
// Alternatively, any idle source with a priority lower than %G_PRIORITY_DEFAULT
// that was scheduled after unsubscription, also indicates that all resources
// of this subscription are released.
func (x *DBusConnection) SignalUnsubscribe(SubscriptionIdVar uint) {

	xDBusConnectionSignalUnsubscribe(x.GoPointer(), SubscriptionIdVar)

}

var xDBusConnectionStartMessageProcessing func(uintptr)

// If @connection was created with
// %G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method
// starts processing messages. Does nothing on if @connection wasn't
// created with this flag or if the method has already been called.
func (x *DBusConnection) StartMessageProcessing() {

	xDBusConnectionStartMessageProcessing(x.GoPointer())

}

var xDBusConnectionUnexportActionGroup func(uintptr, uint)

// Reverses the effect of a previous call to
// g_dbus_connection_export_action_group().
//
// It is an error to call this function with an ID that wasn't returned
// from g_dbus_connection_export_action_group() or to call it with the
// same ID more than once.
func (x *DBusConnection) UnexportActionGroup(ExportIdVar uint) {

	xDBusConnectionUnexportActionGroup(x.GoPointer(), ExportIdVar)

}

var xDBusConnectionUnexportMenuModel func(uintptr, uint)

// Reverses the effect of a previous call to
// g_dbus_connection_export_menu_model().
//
// It is an error to call this function with an ID that wasn't returned
// from g_dbus_connection_export_menu_model() or to call it with the
// same ID more than once.
func (x *DBusConnection) UnexportMenuModel(ExportIdVar uint) {

	xDBusConnectionUnexportMenuModel(x.GoPointer(), ExportIdVar)

}

var xDBusConnectionUnregisterObject func(uintptr, uint) bool

// Unregisters an object.
func (x *DBusConnection) UnregisterObject(RegistrationIdVar uint) bool {

	cret := xDBusConnectionUnregisterObject(x.GoPointer(), RegistrationIdVar)
	return cret
}

var xDBusConnectionUnregisterSubtree func(uintptr, uint) bool

// Unregisters a subtree.
func (x *DBusConnection) UnregisterSubtree(RegistrationIdVar uint) bool {

	cret := xDBusConnectionUnregisterSubtree(x.GoPointer(), RegistrationIdVar)
	return cret
}

func (c *DBusConnection) GoPointer() uintptr {
	return c.Ptr
}

func (c *DBusConnection) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the connection is closed.
//
// # The cause of this event can be
//
//   - If g_dbus_connection_close() is called. In this case
//     @remote_peer_vanished is set to %FALSE and @error is %NULL.
//
//   - If the remote peer closes the connection. In this case
//     @remote_peer_vanished is set to %TRUE and @error is set.
//
//   - If the remote peer sends invalid or malformed data. In this
//     case @remote_peer_vanished is set to %FALSE and @error is set.
//
// Upon receiving this signal, you should give up your reference to
// @connection. You are guaranteed that this signal is emitted only
// once.
func (x *DBusConnection) ConnectClosed(cb *func(DBusConnection, bool, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, RemotePeerVanishedVarp bool, ErrorVarp uintptr) {
		fa := DBusConnection{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, RemotePeerVanishedVarp, ErrorVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
}

// Starts asynchronous initialization of the object implementing the
// interface. This must be done before any real use of the object after
// initial construction. If the object also implements #GInitable you can
// optionally call g_initable_init() instead.
//
// This method is intended for language bindings. If writing in C,
// g_async_initable_new_async() should typically be used instead.
//
// When the initialization is finished, @callback will be called. You can
// then call g_async_initable_init_finish() to get the result of the
// initialization.
//
// Implementations may also support cancellation. If @cancellable is not
// %NULL, then initialization can be cancelled by triggering the cancellable
// object from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
// the object doesn't support cancellable initialization, the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// As with #GInitable, if the object is not initialized, or initialization
// returns with an error, then all operations on the object except
// g_object_ref() and g_object_unref() are considered to be invalid, and
// have undefined behaviour. They will often fail with g_critical() or
// g_warning(), but this must not be relied on.
//
// Callers should not assume that a class which implements #GAsyncInitable can
// be initialized multiple times; for more information, see g_initable_init().
// If a class explicitly supports being initialized multiple times,
// implementation requires yielding all subsequent calls to init_async() on the
// results of the first call.
//
// For classes that also support the #GInitable interface, the default
// implementation of this method will run the g_initable_init() function
// in a thread, so if you want to support asynchronous initialization via
// threads, just implement the #GAsyncInitable interface without overriding
// any interface methods.
func (x *DBusConnection) InitAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGAsyncInitableInitAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes asynchronous initialization and returns the result.
// See g_async_initable_init_async().
func (x *DBusConnection) InitFinish(ResVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGAsyncInitableInitFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Finishes the async construction for the various g_async_initable_new
// calls, returning the created object or %NULL on error.
func (x *DBusConnection) NewFinish(ResVar AsyncResult) (*gobject.Object, error) {
	var cls *gobject.Object
	var cerr *glib.Error

	cret := XGAsyncInitableNewFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Initializes the object implementing the interface.
//
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
//
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
//
// Implementations may also support cancellation. If @cancellable is not %NULL,
// then initialization can be cancelled by triggering the cancellable object
// from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
// the object doesn't support cancellable initialization the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// If the object is not initialized, or initialization returns with an
// error, then all operations on the object except g_object_ref() and
// g_object_unref() are considered to be invalid, and have undefined
// behaviour. See the [introduction][ginitable] for more details.
//
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a class’ implementation of init() can assume
// (and assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
//
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes
// the object; further calls return the result of the first call.
//
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a
// #GObjectClass.constructor that sometimes returns an existing instance.
// In this pattern, a caller would expect to be able to call g_initable_init()
// on the result of g_object_new(), regardless of whether it is in fact a new
// instance.
func (x *DBusConnection) Init(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGInitableInit(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusConnectionNew func(uintptr, string, DBusConnectionFlags, uintptr, uintptr, uintptr, uintptr)

// Asynchronously sets up a D-Bus connection for exchanging D-Bus messages
// with the end represented by @stream.
//
// If @stream is a #GSocketConnection, then the corresponding #GSocket
// will be put into non-blocking mode.
//
// The D-Bus connection will interact with @stream from a worker thread.
// As a result, the caller should not interact with @stream after this
// method has been called, except by calling g_object_unref() on it.
//
// If @observer is not %NULL it may be used to control the
// authentication process.
//
// When the operation is finished, @callback will be invoked. You can
// then call g_dbus_connection_new_finish() to get the result of the
// operation.
//
// This is an asynchronous failable constructor. See
// g_dbus_connection_new_sync() for the synchronous
// version.
func DBusConnectionNew(StreamVar *IOStream, GuidVar string, FlagsVar DBusConnectionFlags, ObserverVar *DBusAuthObserver, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionNew(StreamVar.GoPointer(), GuidVar, FlagsVar, ObserverVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xDBusConnectionNewForAddress func(string, DBusConnectionFlags, uintptr, uintptr, uintptr, uintptr)

// Asynchronously connects and sets up a D-Bus client connection for
// exchanging D-Bus messages with an endpoint specified by @address
// which must be in the
// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This constructor can only be used to initiate client-side
// connections - use g_dbus_connection_new() if you need to act as the
// server. In particular, @flags cannot contain the
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
//
// When the operation is finished, @callback will be invoked. You can
// then call g_dbus_connection_new_for_address_finish() to get the result of
// the operation.
//
// If @observer is not %NULL it may be used to control the
// authentication process.
//
// This is an asynchronous failable constructor. See
// g_dbus_connection_new_for_address_sync() for the synchronous
// version.
func DBusConnectionNewForAddress(AddressVar string, FlagsVar DBusConnectionFlags, ObserverVar *DBusAuthObserver, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusConnectionNewForAddress(AddressVar, FlagsVar, ObserverVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// #GDBusMenuModel is an implementation of #GMenuModel that can be used
// as a proxy for a menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
type DBusMenuModel struct {
	MenuModel
}

func DBusMenuModelNewFromInternalPtr(ptr uintptr) *DBusMenuModel {
	cls := &DBusMenuModel{}
	cls.Ptr = ptr
	return cls
}

func (c *DBusMenuModel) GoPointer() uintptr {
	return c.Ptr
}

func (c *DBusMenuModel) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

var xDBusMenuModelGet func(uintptr, string, string) uintptr

// Obtains a #GDBusMenuModel for the menu model which is exported
// at the given @bus_name and @object_path.
//
// The thread default main context is taken at the time of this call.
// All signals on the menu model (and any linked models) are reported
// with respect to this context.  All calls on the returned menu model
// (and linked models) must also originate from this same context, with
// the thread default main context unchanged.
func DBusMenuModelGet(ConnectionVar *DBusConnection, BusNameVar string, ObjectPathVar string) *DBusMenuModel {
	var cls *DBusMenuModel

	cret := xDBusMenuModelGet(ConnectionVar.GoPointer(), BusNameVar, ObjectPathVar)

	if cret == 0 {
		return nil
	}
	cls = &DBusMenuModel{}
	cls.Ptr = cret
	return cls
}

// A type for representing D-Bus messages that can be sent or received
// on a #GDBusConnection.
type DBusMessage struct {
	gobject.Object
}

func DBusMessageNewFromInternalPtr(ptr uintptr) *DBusMessage {
	cls := &DBusMessage{}
	cls.Ptr = ptr
	return cls
}

var xNewDBusMessage func() uintptr

// Creates a new empty #GDBusMessage.
func NewDBusMessage() *DBusMessage {
	var cls *DBusMessage

	cret := xNewDBusMessage()

	if cret == 0 {
		return nil
	}
	cls = &DBusMessage{}
	cls.Ptr = cret
	return cls
}

var xNewDBusMessageFromBlob func(uintptr, uint, DBusCapabilityFlags, **glib.Error) uintptr

// Creates a new #GDBusMessage from the data stored at @blob. The byte
// order that the message was in can be retrieved using
// g_dbus_message_get_byte_order().
//
// If the @blob cannot be parsed, contains invalid fields, or contains invalid
// headers, %G_IO_ERROR_INVALID_ARGUMENT will be returned.
func NewDBusMessageFromBlob(BlobVar uintptr, BlobLenVar uint, CapabilitiesVar DBusCapabilityFlags) (*DBusMessage, error) {
	var cls *DBusMessage
	var cerr *glib.Error

	cret := xNewDBusMessageFromBlob(BlobVar, BlobLenVar, CapabilitiesVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusMessage{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewDBusMessageMethodCall func(string, string, string, string) uintptr

// Creates a new #GDBusMessage for a method call.
func NewDBusMessageMethodCall(NameVar string, PathVar string, InterfaceVar string, MethodVar string) *DBusMessage {
	var cls *DBusMessage

	cret := xNewDBusMessageMethodCall(NameVar, PathVar, InterfaceVar, MethodVar)

	if cret == 0 {
		return nil
	}
	cls = &DBusMessage{}
	cls.Ptr = cret
	return cls
}

var xNewDBusMessageSignal func(string, string, string) uintptr

// Creates a new #GDBusMessage for a signal emission.
func NewDBusMessageSignal(PathVar string, InterfaceVar string, SignalVar string) *DBusMessage {
	var cls *DBusMessage

	cret := xNewDBusMessageSignal(PathVar, InterfaceVar, SignalVar)

	if cret == 0 {
		return nil
	}
	cls = &DBusMessage{}
	cls.Ptr = cret
	return cls
}

var xDBusMessageCopy func(uintptr) uintptr

// Copies @message. The copy is a deep copy and the returned
// #GDBusMessage is completely identical except that it is guaranteed
// to not be locked.
//
// This operation can fail if e.g. @message contains file descriptors
// and the per-process or system-wide open files limit is reached.
func (x *DBusMessage) Copy() (*DBusMessage, error) {
	var cls *DBusMessage
	var cerr *glib.Error

	cret := xDBusMessageCopy(x.GoPointer())

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusMessage{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDBusMessageGetArg0 func(uintptr) string

// Convenience to get the first item in the body of @message.
func (x *DBusMessage) GetArg0() string {

	cret := xDBusMessageGetArg0(x.GoPointer())
	return cret
}

var xDBusMessageGetBody func(uintptr) *glib.Variant

// Gets the body of a message.
func (x *DBusMessage) GetBody() *glib.Variant {

	cret := xDBusMessageGetBody(x.GoPointer())
	return cret
}

var xDBusMessageGetByteOrder func(uintptr) DBusMessageByteOrder

// Gets the byte order of @message.
func (x *DBusMessage) GetByteOrder() DBusMessageByteOrder {

	cret := xDBusMessageGetByteOrder(x.GoPointer())
	return cret
}

var xDBusMessageGetDestination func(uintptr) string

// Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
func (x *DBusMessage) GetDestination() string {

	cret := xDBusMessageGetDestination(x.GoPointer())
	return cret
}

var xDBusMessageGetErrorName func(uintptr) string

// Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
func (x *DBusMessage) GetErrorName() string {

	cret := xDBusMessageGetErrorName(x.GoPointer())
	return cret
}

var xDBusMessageGetFlags func(uintptr) DBusMessageFlags

// Gets the flags for @message.
func (x *DBusMessage) GetFlags() DBusMessageFlags {

	cret := xDBusMessageGetFlags(x.GoPointer())
	return cret
}

var xDBusMessageGetHeader func(uintptr, DBusMessageHeaderField) *glib.Variant

// Gets a header field on @message.
//
// The caller is responsible for checking the type of the returned #GVariant
// matches what is expected.
func (x *DBusMessage) GetHeader(HeaderFieldVar DBusMessageHeaderField) *glib.Variant {

	cret := xDBusMessageGetHeader(x.GoPointer(), HeaderFieldVar)
	return cret
}

var xDBusMessageGetHeaderFields func(uintptr) uintptr

// Gets an array of all header fields on @message that are set.
func (x *DBusMessage) GetHeaderFields() uintptr {

	cret := xDBusMessageGetHeaderFields(x.GoPointer())
	return cret
}

var xDBusMessageGetInterface func(uintptr) string

// Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
func (x *DBusMessage) GetInterface() string {

	cret := xDBusMessageGetInterface(x.GoPointer())
	return cret
}

var xDBusMessageGetLocked func(uintptr) bool

// Checks whether @message is locked. To monitor changes to this
// value, conncet to the #GObject::notify signal to listen for changes
// on the #GDBusMessage:locked property.
func (x *DBusMessage) GetLocked() bool {

	cret := xDBusMessageGetLocked(x.GoPointer())
	return cret
}

var xDBusMessageGetMember func(uintptr) string

// Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
func (x *DBusMessage) GetMember() string {

	cret := xDBusMessageGetMember(x.GoPointer())
	return cret
}

var xDBusMessageGetMessageType func(uintptr) DBusMessageType

// Gets the type of @message.
func (x *DBusMessage) GetMessageType() DBusMessageType {

	cret := xDBusMessageGetMessageType(x.GoPointer())
	return cret
}

var xDBusMessageGetNumUnixFds func(uintptr) uint32

// Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
func (x *DBusMessage) GetNumUnixFds() uint32 {

	cret := xDBusMessageGetNumUnixFds(x.GoPointer())
	return cret
}

var xDBusMessageGetPath func(uintptr) string

// Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
func (x *DBusMessage) GetPath() string {

	cret := xDBusMessageGetPath(x.GoPointer())
	return cret
}

var xDBusMessageGetReplySerial func(uintptr) uint32

// Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
func (x *DBusMessage) GetReplySerial() uint32 {

	cret := xDBusMessageGetReplySerial(x.GoPointer())
	return cret
}

var xDBusMessageGetSender func(uintptr) string

// Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
func (x *DBusMessage) GetSender() string {

	cret := xDBusMessageGetSender(x.GoPointer())
	return cret
}

var xDBusMessageGetSerial func(uintptr) uint32

// Gets the serial for @message.
func (x *DBusMessage) GetSerial() uint32 {

	cret := xDBusMessageGetSerial(x.GoPointer())
	return cret
}

var xDBusMessageGetSignature func(uintptr) string

// Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
//
// This will always be non-%NULL, but may be an empty string.
func (x *DBusMessage) GetSignature() string {

	cret := xDBusMessageGetSignature(x.GoPointer())
	return cret
}

var xDBusMessageGetUnixFdList func(uintptr) uintptr

// Gets the UNIX file descriptors associated with @message, if any.
//
// This method is only available on UNIX.
//
// The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
// values in the body of the message. For example,
// if g_variant_get_handle() returns 5, that is intended to be a reference
// to the file descriptor that can be accessed by
// `g_unix_fd_list_get (list, 5, ...)`.
func (x *DBusMessage) GetUnixFdList() *UnixFDList {
	var cls *UnixFDList

	cret := xDBusMessageGetUnixFdList(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &UnixFDList{}
	cls.Ptr = cret
	return cls
}

var xDBusMessageLock func(uintptr)

// If @message is locked, does nothing. Otherwise locks the message.
func (x *DBusMessage) Lock() {

	xDBusMessageLock(x.GoPointer())

}

var xDBusMessageNewMethodError func(uintptr, string, string, ...interface{}) uintptr

// Creates a new #GDBusMessage that is an error reply to @method_call_message.
func (x *DBusMessage) NewMethodError(ErrorNameVar string, ErrorMessageFormatVar string, varArgs ...interface{}) *DBusMessage {
	var cls *DBusMessage

	cret := xDBusMessageNewMethodError(x.GoPointer(), ErrorNameVar, ErrorMessageFormatVar, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &DBusMessage{}
	cls.Ptr = cret
	return cls
}

var xDBusMessageNewMethodErrorLiteral func(uintptr, string, string) uintptr

// Creates a new #GDBusMessage that is an error reply to @method_call_message.
func (x *DBusMessage) NewMethodErrorLiteral(ErrorNameVar string, ErrorMessageVar string) *DBusMessage {
	var cls *DBusMessage

	cret := xDBusMessageNewMethodErrorLiteral(x.GoPointer(), ErrorNameVar, ErrorMessageVar)

	if cret == 0 {
		return nil
	}
	cls = &DBusMessage{}
	cls.Ptr = cret
	return cls
}

var xDBusMessageNewMethodErrorValist func(uintptr, string, string, []interface{}) uintptr

// Like g_dbus_message_new_method_error() but intended for language bindings.
func (x *DBusMessage) NewMethodErrorValist(ErrorNameVar string, ErrorMessageFormatVar string, VarArgsVar []interface{}) *DBusMessage {
	var cls *DBusMessage

	cret := xDBusMessageNewMethodErrorValist(x.GoPointer(), ErrorNameVar, ErrorMessageFormatVar, VarArgsVar)

	if cret == 0 {
		return nil
	}
	cls = &DBusMessage{}
	cls.Ptr = cret
	return cls
}

var xDBusMessageNewMethodReply func(uintptr) uintptr

// Creates a new #GDBusMessage that is a reply to @method_call_message.
func (x *DBusMessage) NewMethodReply() *DBusMessage {
	var cls *DBusMessage

	cret := xDBusMessageNewMethodReply(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &DBusMessage{}
	cls.Ptr = cret
	return cls
}

var xDBusMessagePrint func(uintptr, uint) string

// Produces a human-readable multi-line description of @message.
//
// The contents of the description has no ABI guarantees, the contents
// and formatting is subject to change at any time. Typical output
// looks something like this:
// |[
// Flags:   none
// Version: 0
// Serial:  4
// Headers:
//
//	path -&gt; objectpath '/org/gtk/GDBus/TestObject'
//	interface -&gt; 'org.gtk.GDBus.TestInterface'
//	member -&gt; 'GimmeStdout'
//	destination -&gt; ':1.146'
//
// Body: ()
// UNIX File Descriptors:
//
//	(none)
//
// ]|
// or
// |[
// Flags:   no-reply-expected
// Version: 0
// Serial:  477
// Headers:
//
//	reply-serial -&gt; uint32 4
//	destination -&gt; ':1.159'
//	sender -&gt; ':1.146'
//	num-unix-fds -&gt; uint32 1
//
// Body: ()
// UNIX File Descriptors:
//
//	fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
//
// ]|
func (x *DBusMessage) Print(IndentVar uint) string {

	cret := xDBusMessagePrint(x.GoPointer(), IndentVar)
	return cret
}

var xDBusMessageSetBody func(uintptr, *glib.Variant)

// Sets the body @message. As a side-effect the
// %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the
// type string of @body (or cleared if @body is %NULL).
//
// If @body is floating, @message assumes ownership of @body.
func (x *DBusMessage) SetBody(BodyVar *glib.Variant) {

	xDBusMessageSetBody(x.GoPointer(), BodyVar)

}

var xDBusMessageSetByteOrder func(uintptr, DBusMessageByteOrder)

// Sets the byte order of @message.
func (x *DBusMessage) SetByteOrder(ByteOrderVar DBusMessageByteOrder) {

	xDBusMessageSetByteOrder(x.GoPointer(), ByteOrderVar)

}

var xDBusMessageSetDestination func(uintptr, string)

// Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
func (x *DBusMessage) SetDestination(ValueVar string) {

	xDBusMessageSetDestination(x.GoPointer(), ValueVar)

}

var xDBusMessageSetErrorName func(uintptr, string)

// Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
func (x *DBusMessage) SetErrorName(ValueVar string) {

	xDBusMessageSetErrorName(x.GoPointer(), ValueVar)

}

var xDBusMessageSetFlags func(uintptr, DBusMessageFlags)

// Sets the flags to set on @message.
func (x *DBusMessage) SetFlags(FlagsVar DBusMessageFlags) {

	xDBusMessageSetFlags(x.GoPointer(), FlagsVar)

}

var xDBusMessageSetHeader func(uintptr, DBusMessageHeaderField, *glib.Variant)

// Sets a header field on @message.
//
// If @value is floating, @message assumes ownership of @value.
func (x *DBusMessage) SetHeader(HeaderFieldVar DBusMessageHeaderField, ValueVar *glib.Variant) {

	xDBusMessageSetHeader(x.GoPointer(), HeaderFieldVar, ValueVar)

}

var xDBusMessageSetInterface func(uintptr, string)

// Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
func (x *DBusMessage) SetInterface(ValueVar string) {

	xDBusMessageSetInterface(x.GoPointer(), ValueVar)

}

var xDBusMessageSetMember func(uintptr, string)

// Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
func (x *DBusMessage) SetMember(ValueVar string) {

	xDBusMessageSetMember(x.GoPointer(), ValueVar)

}

var xDBusMessageSetMessageType func(uintptr, DBusMessageType)

// Sets @message to be of @type.
func (x *DBusMessage) SetMessageType(TypeVar DBusMessageType) {

	xDBusMessageSetMessageType(x.GoPointer(), TypeVar)

}

var xDBusMessageSetNumUnixFds func(uintptr, uint32)

// Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
func (x *DBusMessage) SetNumUnixFds(ValueVar uint32) {

	xDBusMessageSetNumUnixFds(x.GoPointer(), ValueVar)

}

var xDBusMessageSetPath func(uintptr, string)

// Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
func (x *DBusMessage) SetPath(ValueVar string) {

	xDBusMessageSetPath(x.GoPointer(), ValueVar)

}

var xDBusMessageSetReplySerial func(uintptr, uint32)

// Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
func (x *DBusMessage) SetReplySerial(ValueVar uint32) {

	xDBusMessageSetReplySerial(x.GoPointer(), ValueVar)

}

var xDBusMessageSetSender func(uintptr, string)

// Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
func (x *DBusMessage) SetSender(ValueVar string) {

	xDBusMessageSetSender(x.GoPointer(), ValueVar)

}

var xDBusMessageSetSerial func(uintptr, uint32)

// Sets the serial for @message.
func (x *DBusMessage) SetSerial(SerialVar uint32) {

	xDBusMessageSetSerial(x.GoPointer(), SerialVar)

}

var xDBusMessageSetSignature func(uintptr, string)

// Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
func (x *DBusMessage) SetSignature(ValueVar string) {

	xDBusMessageSetSignature(x.GoPointer(), ValueVar)

}

var xDBusMessageSetUnixFdList func(uintptr, uintptr)

// Sets the UNIX file descriptors associated with @message. As a
// side-effect the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header
// field is set to the number of fds in @fd_list (or cleared if
// @fd_list is %NULL).
//
// This method is only available on UNIX.
//
// When designing D-Bus APIs that are intended to be interoperable,
// please note that non-GDBus implementations of D-Bus can usually only
// access file descriptors if they are referenced by a value of type
// %G_VARIANT_TYPE_HANDLE in the body of the message.
func (x *DBusMessage) SetUnixFdList(FdListVar *UnixFDList) {

	xDBusMessageSetUnixFdList(x.GoPointer(), FdListVar.GoPointer())

}

var xDBusMessageToBlob func(uintptr, uint, DBusCapabilityFlags, **glib.Error) uintptr

// Serializes @message to a blob. The byte order returned by
// g_dbus_message_get_byte_order() will be used.
func (x *DBusMessage) ToBlob(OutSizeVar uint, CapabilitiesVar DBusCapabilityFlags) (uintptr, error) {
	var cerr *glib.Error

	cret := xDBusMessageToBlob(x.GoPointer(), OutSizeVar, CapabilitiesVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusMessageToGerror func(uintptr) bool

// If @message is not of type %G_DBUS_MESSAGE_TYPE_ERROR does
// nothing and returns %FALSE.
//
// Otherwise this method encodes the error in @message as a #GError
// using g_dbus_error_set_dbus_error() using the information in the
// %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as
// well as the first string item in @message's body.
func (x *DBusMessage) ToGerror() (bool, error) {
	var cerr *glib.Error

	cret := xDBusMessageToGerror(x.GoPointer())
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *DBusMessage) GoPointer() uintptr {
	return c.Ptr
}

func (c *DBusMessage) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

var xDBusMessageBytesNeeded func(uintptr, uint, **glib.Error) int

// Utility function to calculate how many bytes are needed to
// completely deserialize the D-Bus message stored at @blob.
func DBusMessageBytesNeeded(BlobVar uintptr, BlobLenVar uint) (int, error) {
	var cerr *glib.Error

	cret := xDBusMessageBytesNeeded(BlobVar, BlobLenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Instances of the #GDBusMethodInvocation class are used when
// handling D-Bus method calls. It provides a way to asynchronously
// return results and errors.
//
// The normal way to obtain a #GDBusMethodInvocation object is to receive
// it as an argument to the handle_method_call() function in a
// #GDBusInterfaceVTable that was passed to g_dbus_connection_register_object().
type DBusMethodInvocation struct {
	gobject.Object
}

func DBusMethodInvocationNewFromInternalPtr(ptr uintptr) *DBusMethodInvocation {
	cls := &DBusMethodInvocation{}
	cls.Ptr = ptr
	return cls
}

var xDBusMethodInvocationGetConnection func(uintptr) uintptr

// Gets the #GDBusConnection the method was invoked on.
func (x *DBusMethodInvocation) GetConnection() *DBusConnection {
	var cls *DBusConnection

	cret := xDBusMethodInvocationGetConnection(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &DBusConnection{}
	cls.Ptr = cret
	return cls
}

var xDBusMethodInvocationGetInterfaceName func(uintptr) string

// Gets the name of the D-Bus interface the method was invoked on.
//
// If this method call is a property Get, Set or GetAll call that has
// been redirected to the method call handler then
// "org.freedesktop.DBus.Properties" will be returned.  See
// #GDBusInterfaceVTable for more information.
func (x *DBusMethodInvocation) GetInterfaceName() string {

	cret := xDBusMethodInvocationGetInterfaceName(x.GoPointer())
	return cret
}

var xDBusMethodInvocationGetMessage func(uintptr) uintptr

// Gets the #GDBusMessage for the method invocation. This is useful if
// you need to use low-level protocol features, such as UNIX file
// descriptor passing, that cannot be properly expressed in the
// #GVariant API.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
// for an example of how to use this low-level API to send and receive
// UNIX file descriptors.
func (x *DBusMethodInvocation) GetMessage() *DBusMessage {
	var cls *DBusMessage

	cret := xDBusMethodInvocationGetMessage(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &DBusMessage{}
	cls.Ptr = cret
	return cls
}

var xDBusMethodInvocationGetMethodInfo func(uintptr) *DBusMethodInfo

// Gets information about the method call, if any.
//
// If this method invocation is a property Get, Set or GetAll call that
// has been redirected to the method call handler then %NULL will be
// returned.  See g_dbus_method_invocation_get_property_info() and
// #GDBusInterfaceVTable for more information.
func (x *DBusMethodInvocation) GetMethodInfo() *DBusMethodInfo {

	cret := xDBusMethodInvocationGetMethodInfo(x.GoPointer())
	return cret
}

var xDBusMethodInvocationGetMethodName func(uintptr) string

// Gets the name of the method that was invoked.
func (x *DBusMethodInvocation) GetMethodName() string {

	cret := xDBusMethodInvocationGetMethodName(x.GoPointer())
	return cret
}

var xDBusMethodInvocationGetObjectPath func(uintptr) string

// Gets the object path the method was invoked on.
func (x *DBusMethodInvocation) GetObjectPath() string {

	cret := xDBusMethodInvocationGetObjectPath(x.GoPointer())
	return cret
}

var xDBusMethodInvocationGetParameters func(uintptr) *glib.Variant

// Gets the parameters of the method invocation. If there are no input
// parameters then this will return a GVariant with 0 children rather than NULL.
func (x *DBusMethodInvocation) GetParameters() *glib.Variant {

	cret := xDBusMethodInvocationGetParameters(x.GoPointer())
	return cret
}

var xDBusMethodInvocationGetPropertyInfo func(uintptr) *DBusPropertyInfo

// Gets information about the property that this method call is for, if
// any.
//
// This will only be set in the case of an invocation in response to a
// property Get or Set call that has been directed to the method call
// handler for an object on account of its property_get() or
// property_set() vtable pointers being unset.
//
// See #GDBusInterfaceVTable for more information.
//
// If the call was GetAll, %NULL will be returned.
func (x *DBusMethodInvocation) GetPropertyInfo() *DBusPropertyInfo {

	cret := xDBusMethodInvocationGetPropertyInfo(x.GoPointer())
	return cret
}

var xDBusMethodInvocationGetSender func(uintptr) string

// Gets the bus name that invoked the method.
func (x *DBusMethodInvocation) GetSender() string {

	cret := xDBusMethodInvocationGetSender(x.GoPointer())
	return cret
}

var xDBusMethodInvocationGetUserData func(uintptr) uintptr

// Gets the @user_data #gpointer passed to g_dbus_connection_register_object().
func (x *DBusMethodInvocation) GetUserData() uintptr {

	cret := xDBusMethodInvocationGetUserData(x.GoPointer())
	return cret
}

var xDBusMethodInvocationReturnDbusError func(uintptr, string, string)

// Finishes handling a D-Bus method call by returning an error.
//
// This method will take ownership of @invocation. See
// #GDBusInterfaceVTable for more information about the ownership of
// @invocation.
func (x *DBusMethodInvocation) ReturnDbusError(ErrorNameVar string, ErrorMessageVar string) {

	xDBusMethodInvocationReturnDbusError(x.GoPointer(), ErrorNameVar, ErrorMessageVar)

}

var xDBusMethodInvocationReturnError func(uintptr, glib.Quark, int, string, ...interface{})

// Finishes handling a D-Bus method call by returning an error.
//
// See g_dbus_error_encode_gerror() for details about what error name
// will be returned on the wire. In a nutshell, if the given error is
// registered using g_dbus_error_register_error() the name given
// during registration is used. Otherwise, a name of the form
// `org.gtk.GDBus.UnmappedGError.Quark...` is used. This provides
// transparent mapping of #GError between applications using GDBus.
//
// If you are writing an application intended to be portable,
// always register errors with g_dbus_error_register_error()
// or use g_dbus_method_invocation_return_dbus_error().
//
// This method will take ownership of @invocation. See
// #GDBusInterfaceVTable for more information about the ownership of
// @invocation.
//
// Since 2.48, if the method call requested for a reply not to be sent
// then this call will free @invocation but otherwise do nothing (as per
// the recommendations of the D-Bus specification).
func (x *DBusMethodInvocation) ReturnError(DomainVar glib.Quark, CodeVar int, FormatVar string, varArgs ...interface{}) {

	xDBusMethodInvocationReturnError(x.GoPointer(), DomainVar, CodeVar, FormatVar, varArgs...)

}

var xDBusMethodInvocationReturnErrorLiteral func(uintptr, glib.Quark, int, string)

// Like g_dbus_method_invocation_return_error() but without printf()-style formatting.
//
// This method will take ownership of @invocation. See
// #GDBusInterfaceVTable for more information about the ownership of
// @invocation.
func (x *DBusMethodInvocation) ReturnErrorLiteral(DomainVar glib.Quark, CodeVar int, MessageVar string) {

	xDBusMethodInvocationReturnErrorLiteral(x.GoPointer(), DomainVar, CodeVar, MessageVar)

}

var xDBusMethodInvocationReturnErrorValist func(uintptr, glib.Quark, int, string, []interface{})

// Like g_dbus_method_invocation_return_error() but intended for
// language bindings.
//
// This method will take ownership of @invocation. See
// #GDBusInterfaceVTable for more information about the ownership of
// @invocation.
func (x *DBusMethodInvocation) ReturnErrorValist(DomainVar glib.Quark, CodeVar int, FormatVar string, VarArgsVar []interface{}) {

	xDBusMethodInvocationReturnErrorValist(x.GoPointer(), DomainVar, CodeVar, FormatVar, VarArgsVar)

}

var xDBusMethodInvocationReturnGerror func(uintptr, *glib.Error)

// Like g_dbus_method_invocation_return_error() but takes a #GError
// instead of the error domain, error code and message.
//
// This method will take ownership of @invocation. See
// #GDBusInterfaceVTable for more information about the ownership of
// @invocation.
func (x *DBusMethodInvocation) ReturnGerror(ErrorVar *glib.Error) {

	xDBusMethodInvocationReturnGerror(x.GoPointer(), ErrorVar)

}

var xDBusMethodInvocationReturnValue func(uintptr, *glib.Variant)

// Finishes handling a D-Bus method call by returning @parameters.
// If the @parameters GVariant is floating, it is consumed.
//
// It is an error if @parameters is not of the right format: it must be a tuple
// containing the out-parameters of the D-Bus method. Even if the method has a
// single out-parameter, it must be contained in a tuple. If the method has no
// out-parameters, @parameters may be %NULL or an empty tuple.
//
// |[&lt;!-- language="C" --&gt;
// GDBusMethodInvocation *invocation = some_invocation;
// g_autofree gchar *result_string = NULL;
// g_autoptr (GError) error = NULL;
//
// result_string = calculate_result (&amp;error);
//
// if (error != NULL)
//
//	g_dbus_method_invocation_return_gerror (invocation, error);
//
// else
//
//	g_dbus_method_invocation_return_value (invocation,
//	                                       g_variant_new ("(s)", result_string));
//
// // Do not free @invocation here; returning a value does that
// ]|
//
// This method will take ownership of @invocation. See
// #GDBusInterfaceVTable for more information about the ownership of
// @invocation.
//
// Since 2.48, if the method call requested for a reply not to be sent
// then this call will sink @parameters and free @invocation, but
// otherwise do nothing (as per the recommendations of the D-Bus
// specification).
func (x *DBusMethodInvocation) ReturnValue(ParametersVar *glib.Variant) {

	xDBusMethodInvocationReturnValue(x.GoPointer(), ParametersVar)

}

var xDBusMethodInvocationReturnValueWithUnixFdList func(uintptr, *glib.Variant, uintptr)

// Like g_dbus_method_invocation_return_value() but also takes a #GUnixFDList.
//
// This method is only available on UNIX.
//
// This method will take ownership of @invocation. See
// #GDBusInterfaceVTable for more information about the ownership of
// @invocation.
func (x *DBusMethodInvocation) ReturnValueWithUnixFdList(ParametersVar *glib.Variant, FdListVar *UnixFDList) {

	xDBusMethodInvocationReturnValueWithUnixFdList(x.GoPointer(), ParametersVar, FdListVar.GoPointer())

}

var xDBusMethodInvocationTakeError func(uintptr, *glib.Error)

// Like g_dbus_method_invocation_return_gerror() but takes ownership
// of @error so the caller does not need to free it.
//
// This method will take ownership of @invocation. See
// #GDBusInterfaceVTable for more information about the ownership of
// @invocation.
func (x *DBusMethodInvocation) TakeError(ErrorVar *glib.Error) {

	xDBusMethodInvocationTakeError(x.GoPointer(), ErrorVar)

}

func (c *DBusMethodInvocation) GoPointer() uintptr {
	return c.Ptr
}

func (c *DBusMethodInvocation) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// #GDBusServer is a helper for listening to and accepting D-Bus
// connections. This can be used to create a new D-Bus server, allowing two
// peers to use the D-Bus protocol for their own specialized communication.
// A server instance provided in this way will not perform message routing or
// implement the org.freedesktop.DBus interface.
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use g_bus_own_name().
//
// An example of peer-to-peer communication with GDBus can be found
// in [gdbus-example-peer.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal #GDBusServer will accept connections from any
// peer. In many use-cases it will be necessary to add a #GDBusAuthObserver
// that only accepts connections that have successfully authenticated
// as the same user that is running the #GDBusServer. Since GLib 2.68 this can
// be achieved more simply by passing the
// %G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag to the server.
type DBusServer struct {
	gobject.Object
}

func DBusServerNewFromInternalPtr(ptr uintptr) *DBusServer {
	cls := &DBusServer{}
	cls.Ptr = ptr
	return cls
}

var xNewDBusServerSync func(string, DBusServerFlags, string, uintptr, uintptr, **glib.Error) uintptr

// Creates a new D-Bus server that listens on the first address in
// @address that works.
//
// Once constructed, you can use g_dbus_server_get_client_address() to
// get a D-Bus address string that clients can use to connect.
//
// To have control over the available authentication mechanisms and
// the users that are authorized to connect, it is strongly recommended
// to provide a non-%NULL #GDBusAuthObserver.
//
// Connect to the #GDBusServer::new-connection signal to handle
// incoming connections.
//
// The returned #GDBusServer isn't active - you have to start it with
// g_dbus_server_start().
//
// #GDBusServer is used in this [example][gdbus-peer-to-peer].
//
// This is a synchronous failable constructor. There is currently no
// asynchronous version.
func NewDBusServerSync(AddressVar string, FlagsVar DBusServerFlags, GuidVar string, ObserverVar *DBusAuthObserver, CancellableVar *Cancellable) (*DBusServer, error) {
	var cls *DBusServer
	var cerr *glib.Error

	cret := xNewDBusServerSync(AddressVar, FlagsVar, GuidVar, ObserverVar.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusServer{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDBusServerGetClientAddress func(uintptr) string

// Gets a
// [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
// string that can be used by clients to connect to @server.
//
// This is valid and non-empty if initializing the #GDBusServer succeeded.
func (x *DBusServer) GetClientAddress() string {

	cret := xDBusServerGetClientAddress(x.GoPointer())
	return cret
}

var xDBusServerGetFlags func(uintptr) DBusServerFlags

// Gets the flags for @server.
func (x *DBusServer) GetFlags() DBusServerFlags {

	cret := xDBusServerGetFlags(x.GoPointer())
	return cret
}

var xDBusServerGetGuid func(uintptr) string

// Gets the GUID for @server, as provided to g_dbus_server_new_sync().
func (x *DBusServer) GetGuid() string {

	cret := xDBusServerGetGuid(x.GoPointer())
	return cret
}

var xDBusServerIsActive func(uintptr) bool

// Gets whether @server is active.
func (x *DBusServer) IsActive() bool {

	cret := xDBusServerIsActive(x.GoPointer())
	return cret
}

var xDBusServerStart func(uintptr)

// Starts @server.
func (x *DBusServer) Start() {

	xDBusServerStart(x.GoPointer())

}

var xDBusServerStop func(uintptr)

// Stops @server.
func (x *DBusServer) Stop() {

	xDBusServerStop(x.GoPointer())

}

func (c *DBusServer) GoPointer() uintptr {
	return c.Ptr
}

func (c *DBusServer) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when a new authenticated connection has been made. Use
// g_dbus_connection_get_peer_credentials() to figure out what
// identity (if any), was authenticated.
//
// If you want to accept the connection, take a reference to the
// @connection object and return %TRUE. When you are done with the
// connection call g_dbus_connection_close() and give up your
// reference. Note that the other peer may disconnect at any time -
// a typical thing to do when accepting a connection is to listen to
// the #GDBusConnection::closed signal.
//
// If #GDBusServer:flags contains %G_DBUS_SERVER_FLAGS_RUN_IN_THREAD
// then the signal is emitted in a new thread dedicated to the
// connection. Otherwise the signal is emitted in the
// [thread-default main context][g-main-context-push-thread-default]
// of the thread that @server was constructed in.
//
// You are guaranteed that signal handlers for this signal runs
// before incoming messages on @connection are processed. This means
// that it's suitable to call g_dbus_connection_register_object() or
// similar from the signal handler.
func (x *DBusServer) ConnectNewConnection(cb *func(DBusServer, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "new-connection", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ConnectionVarp uintptr) bool {
		fa := DBusServer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ConnectionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "new-connection", cbRefPtr)
}

// Initializes the object implementing the interface.
//
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
//
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
//
// Implementations may also support cancellation. If @cancellable is not %NULL,
// then initialization can be cancelled by triggering the cancellable object
// from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
// the object doesn't support cancellable initialization the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// If the object is not initialized, or initialization returns with an
// error, then all operations on the object except g_object_ref() and
// g_object_unref() are considered to be invalid, and have undefined
// behaviour. See the [introduction][ginitable] for more details.
//
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a class’ implementation of init() can assume
// (and assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
//
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes
// the object; further calls return the result of the first call.
//
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a
// #GObjectClass.constructor that sometimes returns an existing instance.
// In this pattern, a caller would expect to be able to call g_initable_init()
// on the result of g_object_new(), regardless of whether it is in fact a new
// instance.
func (x *DBusServer) Init(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGInitableInit(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// #GMenu is a simple implementation of #GMenuModel.
// You populate a #GMenu by adding #GMenuItem instances to it.
//
// There are some convenience functions to allow you to directly
// add items (avoiding #GMenuItem) for the common cases. To add
// a regular item, use g_menu_insert(). To add a section, use
// g_menu_insert_section(). To add a submenu, use
// g_menu_insert_submenu().
type Menu struct {
	MenuModel
}

func MenuNewFromInternalPtr(ptr uintptr) *Menu {
	cls := &Menu{}
	cls.Ptr = ptr
	return cls
}

var xNewMenu func() uintptr

// Creates a new #GMenu.
//
// The new menu has no items.
func NewMenu() *Menu {
	var cls *Menu

	cret := xNewMenu()

	if cret == 0 {
		return nil
	}
	cls = &Menu{}
	cls.Ptr = cret
	return cls
}

var xMenuAppend func(uintptr, string, string)

// Convenience function for appending a normal menu item to the end of
// @menu.  Combine g_menu_item_new() and g_menu_insert_item() for a more
// flexible alternative.
func (x *Menu) Append(LabelVar string, DetailedActionVar string) {

	xMenuAppend(x.GoPointer(), LabelVar, DetailedActionVar)

}

var xMenuAppendItem func(uintptr, uintptr)

// Appends @item to the end of @menu.
//
// See g_menu_insert_item() for more information.
func (x *Menu) AppendItem(ItemVar *MenuItem) {

	xMenuAppendItem(x.GoPointer(), ItemVar.GoPointer())

}

var xMenuAppendSection func(uintptr, string, uintptr)

// Convenience function for appending a section menu item to the end of
// @menu.  Combine g_menu_item_new_section() and g_menu_insert_item() for a
// more flexible alternative.
func (x *Menu) AppendSection(LabelVar string, SectionVar *MenuModel) {

	xMenuAppendSection(x.GoPointer(), LabelVar, SectionVar.GoPointer())

}

var xMenuAppendSubmenu func(uintptr, string, uintptr)

// Convenience function for appending a submenu menu item to the end of
// @menu.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for a
// more flexible alternative.
func (x *Menu) AppendSubmenu(LabelVar string, SubmenuVar *MenuModel) {

	xMenuAppendSubmenu(x.GoPointer(), LabelVar, SubmenuVar.GoPointer())

}

var xMenuFreeze func(uintptr)

// Marks @menu as frozen.
//
// After the menu is frozen, it is an error to attempt to make any
// changes to it.  In effect this means that the #GMenu API must no
// longer be used.
//
// This function causes g_menu_model_is_mutable() to begin returning
// %FALSE, which has some positive performance implications.
func (x *Menu) Freeze() {

	xMenuFreeze(x.GoPointer())

}

var xMenuInsert func(uintptr, int, string, string)

// Convenience function for inserting a normal menu item into @menu.
// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
func (x *Menu) Insert(PositionVar int, LabelVar string, DetailedActionVar string) {

	xMenuInsert(x.GoPointer(), PositionVar, LabelVar, DetailedActionVar)

}

var xMenuInsertItem func(uintptr, int, uintptr)

// Inserts @item into @menu.
//
// The "insertion" is actually done by copying all of the attribute and
// link values of @item and using them to form a new item within @menu.
// As such, @item itself is not really inserted, but rather, a menu item
// that is exactly the same as the one presently described by @item.
//
// This means that @item is essentially useless after the insertion
// occurs.  Any changes you make to it are ignored unless it is inserted
// again (at which point its updated values will be copied).
//
// You should probably just free @item once you're done.
//
// There are many convenience functions to take care of common cases.
// See g_menu_insert(), g_menu_insert_section() and
// g_menu_insert_submenu() as well as "prepend" and "append" variants of
// each of these functions.
func (x *Menu) InsertItem(PositionVar int, ItemVar *MenuItem) {

	xMenuInsertItem(x.GoPointer(), PositionVar, ItemVar.GoPointer())

}

var xMenuInsertSection func(uintptr, int, string, uintptr)

// Convenience function for inserting a section menu item into @menu.
// Combine g_menu_item_new_section() and g_menu_insert_item() for a more
// flexible alternative.
func (x *Menu) InsertSection(PositionVar int, LabelVar string, SectionVar *MenuModel) {

	xMenuInsertSection(x.GoPointer(), PositionVar, LabelVar, SectionVar.GoPointer())

}

var xMenuInsertSubmenu func(uintptr, int, string, uintptr)

// Convenience function for inserting a submenu menu item into @menu.
// Combine g_menu_item_new_submenu() and g_menu_insert_item() for a more
// flexible alternative.
func (x *Menu) InsertSubmenu(PositionVar int, LabelVar string, SubmenuVar *MenuModel) {

	xMenuInsertSubmenu(x.GoPointer(), PositionVar, LabelVar, SubmenuVar.GoPointer())

}

var xMenuPrepend func(uintptr, string, string)

// Convenience function for prepending a normal menu item to the start
// of @menu.  Combine g_menu_item_new() and g_menu_insert_item() for a more
// flexible alternative.
func (x *Menu) Prepend(LabelVar string, DetailedActionVar string) {

	xMenuPrepend(x.GoPointer(), LabelVar, DetailedActionVar)

}

var xMenuPrependItem func(uintptr, uintptr)

// Prepends @item to the start of @menu.
//
// See g_menu_insert_item() for more information.
func (x *Menu) PrependItem(ItemVar *MenuItem) {

	xMenuPrependItem(x.GoPointer(), ItemVar.GoPointer())

}

var xMenuPrependSection func(uintptr, string, uintptr)

// Convenience function for prepending a section menu item to the start
// of @menu.  Combine g_menu_item_new_section() and g_menu_insert_item() for
// a more flexible alternative.
func (x *Menu) PrependSection(LabelVar string, SectionVar *MenuModel) {

	xMenuPrependSection(x.GoPointer(), LabelVar, SectionVar.GoPointer())

}

var xMenuPrependSubmenu func(uintptr, string, uintptr)

// Convenience function for prepending a submenu menu item to the start
// of @menu.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for
// a more flexible alternative.
func (x *Menu) PrependSubmenu(LabelVar string, SubmenuVar *MenuModel) {

	xMenuPrependSubmenu(x.GoPointer(), LabelVar, SubmenuVar.GoPointer())

}

var xMenuRemove func(uintptr, int)

// Removes an item from the menu.
//
// @position gives the index of the item to remove.
//
// It is an error if position is not in range the range from 0 to one
// less than the number of items in the menu.
//
// It is not possible to remove items by identity since items are added
// to the menu simply by copying their links and attributes (ie:
// identity of the item itself is not preserved).
func (x *Menu) Remove(PositionVar int) {

	xMenuRemove(x.GoPointer(), PositionVar)

}

var xMenuRemoveAll func(uintptr)

// Removes all items in the menu.
func (x *Menu) RemoveAll() {

	xMenuRemoveAll(x.GoPointer())

}

func (c *Menu) GoPointer() uintptr {
	return c.Ptr
}

func (c *Menu) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// #GMenuItem is an opaque structure type.  You must access it using the
// functions below.
type MenuItem struct {
	gobject.Object
}

func MenuItemNewFromInternalPtr(ptr uintptr) *MenuItem {
	cls := &MenuItem{}
	cls.Ptr = ptr
	return cls
}

var xNewMenuItem func(string, string) uintptr

// Creates a new #GMenuItem.
//
// If @label is non-%NULL it is used to set the "label" attribute of the
// new item.
//
// If @detailed_action is non-%NULL it is used to set the "action" and
// possibly the "target" attribute of the new item.  See
// g_menu_item_set_detailed_action() for more information.
func NewMenuItem(LabelVar string, DetailedActionVar string) *MenuItem {
	var cls *MenuItem

	cret := xNewMenuItem(LabelVar, DetailedActionVar)

	if cret == 0 {
		return nil
	}
	cls = &MenuItem{}
	cls.Ptr = cret
	return cls
}

var xNewMenuItemFromModel func(uintptr, int) uintptr

// Creates a #GMenuItem as an exact copy of an existing menu item in a
// #GMenuModel.
//
// @item_index must be valid (ie: be sure to call
// g_menu_model_get_n_items() first).
func NewMenuItemFromModel(ModelVar *MenuModel, ItemIndexVar int) *MenuItem {
	var cls *MenuItem

	cret := xNewMenuItemFromModel(ModelVar.GoPointer(), ItemIndexVar)

	if cret == 0 {
		return nil
	}
	cls = &MenuItem{}
	cls.Ptr = cret
	return cls
}

var xNewMenuItemSection func(string, uintptr) uintptr

// Creates a new #GMenuItem representing a section.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_section().
//
// The effect of having one menu appear as a section of another is
// exactly as it sounds: the items from @section become a direct part of
// the menu that @menu_item is added to.
//
// Visual separation is typically displayed between two non-empty
// sections.  If @label is non-%NULL then it will be encorporated into
// this visual indication.  This allows for labeled subsections of a
// menu.
//
// As a simple example, consider a typical "Edit" menu from a simple
// program.  It probably contains an "Undo" and "Redo" item, followed by
// a separator, followed by "Cut", "Copy" and "Paste".
//
// This would be accomplished by creating three #GMenu instances.  The
// first would be populated with the "Undo" and "Redo" items, and the
// second with the "Cut", "Copy" and "Paste" items.  The first and
// second menus would then be added as submenus of the third.  In XML
// format, this would look something like the following:
// |[
// &lt;menu id='edit-menu'&gt;
//
//	&lt;section&gt;
//	  &lt;item label='Undo'/&gt;
//	  &lt;item label='Redo'/&gt;
//	&lt;/section&gt;
//	&lt;section&gt;
//	  &lt;item label='Cut'/&gt;
//	  &lt;item label='Copy'/&gt;
//	  &lt;item label='Paste'/&gt;
//	&lt;/section&gt;
//
// &lt;/menu&gt;
// ]|
//
// The following example is exactly equivalent.  It is more illustrative
// of the exact relationship between the menus and items (keeping in
// mind that the 'link' element defines a new menu that is linked to the
// containing one).  The style of the second example is more verbose and
// difficult to read (and therefore not recommended except for the
// purpose of understanding what is really going on).
// |[
// &lt;menu id='edit-menu'&gt;
//
//	&lt;item&gt;
//	  &lt;link name='section'&gt;
//	    &lt;item label='Undo'/&gt;
//	    &lt;item label='Redo'/&gt;
//	  &lt;/link&gt;
//	&lt;/item&gt;
//	&lt;item&gt;
//	  &lt;link name='section'&gt;
//	    &lt;item label='Cut'/&gt;
//	    &lt;item label='Copy'/&gt;
//	    &lt;item label='Paste'/&gt;
//	  &lt;/link&gt;
//	&lt;/item&gt;
//
// &lt;/menu&gt;
// ]|
func NewMenuItemSection(LabelVar string, SectionVar *MenuModel) *MenuItem {
	var cls *MenuItem

	cret := xNewMenuItemSection(LabelVar, SectionVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &MenuItem{}
	cls.Ptr = cret
	return cls
}

var xNewMenuItemSubmenu func(string, uintptr) uintptr

// Creates a new #GMenuItem representing a submenu.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_submenu().
func NewMenuItemSubmenu(LabelVar string, SubmenuVar *MenuModel) *MenuItem {
	var cls *MenuItem

	cret := xNewMenuItemSubmenu(LabelVar, SubmenuVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &MenuItem{}
	cls.Ptr = cret
	return cls
}

var xMenuItemGetAttribute func(uintptr, string, string, ...interface{}) bool

// Queries the named @attribute on @menu_item.
//
// If the attribute exists and matches the #GVariantType corresponding
// to @format_string then @format_string is used to deconstruct the
// value into the positional parameters and %TRUE is returned.
//
// If the attribute does not exist, or it does exist but has the wrong
// type, then the positional parameters are ignored and %FALSE is
// returned.
func (x *MenuItem) GetAttribute(AttributeVar string, FormatStringVar string, varArgs ...interface{}) bool {

	cret := xMenuItemGetAttribute(x.GoPointer(), AttributeVar, FormatStringVar, varArgs...)
	return cret
}

var xMenuItemGetAttributeValue func(uintptr, string, *glib.VariantType) *glib.Variant

// Queries the named @attribute on @menu_item.
//
// If @expected_type is specified and the attribute does not have this
// type, %NULL is returned.  %NULL is also returned if the attribute
// simply does not exist.
func (x *MenuItem) GetAttributeValue(AttributeVar string, ExpectedTypeVar *glib.VariantType) *glib.Variant {

	cret := xMenuItemGetAttributeValue(x.GoPointer(), AttributeVar, ExpectedTypeVar)
	return cret
}

var xMenuItemGetLink func(uintptr, string) uintptr

// Queries the named @link on @menu_item.
func (x *MenuItem) GetLink(LinkVar string) *MenuModel {
	var cls *MenuModel

	cret := xMenuItemGetLink(x.GoPointer(), LinkVar)

	if cret == 0 {
		return nil
	}
	cls = &MenuModel{}
	cls.Ptr = cret
	return cls
}

var xMenuItemSetActionAndTarget func(uintptr, string, string, ...interface{})

// Sets or unsets the "action" and "target" attributes of @menu_item.
//
// If @action is %NULL then both the "action" and "target" attributes
// are unset (and @format_string is ignored along with the positional
// parameters).
//
// If @action is non-%NULL then the "action" attribute is set.
// @format_string is then inspected.  If it is non-%NULL then the proper
// position parameters are collected to create a #GVariant instance to
// use as the target value.  If it is %NULL then the positional
// parameters are ignored and the "target" attribute is unset.
//
// See also g_menu_item_set_action_and_target_value() for an equivalent
// call that directly accepts a #GVariant.  See
// g_menu_item_set_detailed_action() for a more convenient version that
// works with string-typed targets.
//
// See also g_menu_item_set_action_and_target_value() for a
// description of the semantics of the action and target attributes.
func (x *MenuItem) SetActionAndTarget(ActionVar string, FormatStringVar string, varArgs ...interface{}) {

	xMenuItemSetActionAndTarget(x.GoPointer(), ActionVar, FormatStringVar, varArgs...)

}

var xMenuItemSetActionAndTargetValue func(uintptr, string, *glib.Variant)

// Sets or unsets the "action" and "target" attributes of @menu_item.
//
// If @action is %NULL then both the "action" and "target" attributes
// are unset (and @target_value is ignored).
//
// If @action is non-%NULL then the "action" attribute is set.  The
// "target" attribute is then set to the value of @target_value if it is
// non-%NULL or unset otherwise.
//
// Normal menu items (ie: not submenu, section or other custom item
// types) are expected to have the "action" attribute set to identify
// the action that they are associated with.  The state type of the
// action help to determine the disposition of the menu item.  See
// #GAction and #GActionGroup for an overview of actions.
//
// In general, clicking on the menu item will result in activation of
// the named action with the "target" attribute given as the parameter
// to the action invocation.  If the "target" attribute is not set then
// the action is invoked with no parameter.
//
// If the action has no state then the menu item is usually drawn as a
// plain menu item (ie: with no additional decoration).
//
// If the action has a boolean state then the menu item is usually drawn
// as a toggle menu item (ie: with a checkmark or equivalent
// indication).  The item should be marked as 'toggled' or 'checked'
// when the boolean state is %TRUE.
//
// If the action has a string state then the menu item is usually drawn
// as a radio menu item (ie: with a radio bullet or equivalent
// indication).  The item should be marked as 'selected' when the string
// state is equal to the value of the @target property.
//
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_detailed_action() for two equivalent calls that are
// probably more convenient for most uses.
func (x *MenuItem) SetActionAndTargetValue(ActionVar string, TargetValueVar *glib.Variant) {

	xMenuItemSetActionAndTargetValue(x.GoPointer(), ActionVar, TargetValueVar)

}

var xMenuItemSetAttribute func(uintptr, string, string, ...interface{})

// Sets or unsets an attribute on @menu_item.
//
// The attribute to set or unset is specified by @attribute. This
// can be one of the standard attribute names %G_MENU_ATTRIBUTE_LABEL,
// %G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, or a custom
// attribute name.
// Attribute names are restricted to lowercase characters, numbers
// and '-'. Furthermore, the names must begin with a lowercase character,
// must not end with a '-', and must not contain consecutive dashes.
//
// If @format_string is non-%NULL then the proper position parameters
// are collected to create a #GVariant instance to use as the attribute
// value.  If it is %NULL then the positional parameterrs are ignored
// and the named attribute is unset.
//
// See also g_menu_item_set_attribute_value() for an equivalent call
// that directly accepts a #GVariant.
func (x *MenuItem) SetAttribute(AttributeVar string, FormatStringVar string, varArgs ...interface{}) {

	xMenuItemSetAttribute(x.GoPointer(), AttributeVar, FormatStringVar, varArgs...)

}

var xMenuItemSetAttributeValue func(uintptr, string, *glib.Variant)

// Sets or unsets an attribute on @menu_item.
//
// The attribute to set or unset is specified by @attribute. This
// can be one of the standard attribute names %G_MENU_ATTRIBUTE_LABEL,
// %G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, or a custom
// attribute name.
// Attribute names are restricted to lowercase characters, numbers
// and '-'. Furthermore, the names must begin with a lowercase character,
// must not end with a '-', and must not contain consecutive dashes.
//
// must consist only of lowercase
// ASCII characters, digits and '-'.
//
// If @value is non-%NULL then it is used as the new value for the
// attribute.  If @value is %NULL then the attribute is unset. If
// the @value #GVariant is floating, it is consumed.
//
// See also g_menu_item_set_attribute() for a more convenient way to do
// the same.
func (x *MenuItem) SetAttributeValue(AttributeVar string, ValueVar *glib.Variant) {

	xMenuItemSetAttributeValue(x.GoPointer(), AttributeVar, ValueVar)

}

var xMenuItemSetDetailedAction func(uintptr, string)

// Sets the "action" and possibly the "target" attribute of @menu_item.
//
// The format of @detailed_action is the same format parsed by
// g_action_parse_detailed_name().
//
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_action_and_target_value() for more flexible (but
// slightly less convenient) alternatives.
//
// See also g_menu_item_set_action_and_target_value() for a description of
// the semantics of the action and target attributes.
func (x *MenuItem) SetDetailedAction(DetailedActionVar string) {

	xMenuItemSetDetailedAction(x.GoPointer(), DetailedActionVar)

}

var xMenuItemSetIcon func(uintptr, uintptr)

// Sets (or unsets) the icon on @menu_item.
//
// This call is the same as calling g_icon_serialize() and using the
// result as the value to g_menu_item_set_attribute_value() for
// %G_MENU_ATTRIBUTE_ICON.
//
// This API is only intended for use with "noun" menu items; things like
// bookmarks or applications in an "Open With" menu.  Don't use it on
// menu items corresponding to verbs (eg: stock icons for 'Save' or
// 'Quit').
//
// If @icon is %NULL then the icon is unset.
func (x *MenuItem) SetIcon(IconVar Icon) {

	xMenuItemSetIcon(x.GoPointer(), IconVar.GoPointer())

}

var xMenuItemSetLabel func(uintptr, string)

// Sets or unsets the "label" attribute of @menu_item.
//
// If @label is non-%NULL it is used as the label for the menu item.  If
// it is %NULL then the label attribute is unset.
func (x *MenuItem) SetLabel(LabelVar string) {

	xMenuItemSetLabel(x.GoPointer(), LabelVar)

}

var xMenuItemSetLink func(uintptr, string, uintptr)

// Creates a link from @menu_item to @model if non-%NULL, or unsets it.
//
// Links are used to establish a relationship between a particular menu
// item and another menu.  For example, %G_MENU_LINK_SUBMENU is used to
// associate a submenu with a particular menu item, and %G_MENU_LINK_SECTION
// is used to create a section. Other types of link can be used, but there
// is no guarantee that clients will be able to make sense of them.
// Link types are restricted to lowercase characters, numbers
// and '-'. Furthermore, the names must begin with a lowercase character,
// must not end with a '-', and must not contain consecutive dashes.
func (x *MenuItem) SetLink(LinkVar string, ModelVar *MenuModel) {

	xMenuItemSetLink(x.GoPointer(), LinkVar, ModelVar.GoPointer())

}

var xMenuItemSetSection func(uintptr, uintptr)

// Sets or unsets the "section" link of @menu_item to @section.
//
// The effect of having one menu appear as a section of another is
// exactly as it sounds: the items from @section become a direct part of
// the menu that @menu_item is added to.  See g_menu_item_new_section()
// for more information about what it means for a menu item to be a
// section.
func (x *MenuItem) SetSection(SectionVar *MenuModel) {

	xMenuItemSetSection(x.GoPointer(), SectionVar.GoPointer())

}

var xMenuItemSetSubmenu func(uintptr, uintptr)

// Sets or unsets the "submenu" link of @menu_item to @submenu.
//
// If @submenu is non-%NULL, it is linked to.  If it is %NULL then the
// link is unset.
//
// The effect of having one menu appear as a submenu of another is
// exactly as it sounds.
func (x *MenuItem) SetSubmenu(SubmenuVar *MenuModel) {

	xMenuItemSetSubmenu(x.GoPointer(), SubmenuVar.GoPointer())

}

func (c *MenuItem) GoPointer() uintptr {
	return c.Ptr
}

func (c *MenuItem) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// #GNotification is a mechanism for creating a notification to be shown
// to the user -- typically as a pop-up notification presented by the
// desktop environment shell.
//
// The key difference between #GNotification and other similar APIs is
// that, if supported by the desktop environment, notifications sent
// with #GNotification will persist after the application has exited,
// and even across system reboots.
//
// Since the user may click on a notification while the application is
// not running, applications using #GNotification should be able to be
// started as a D-Bus service, using #GApplication.
//
// In order for #GNotification to work, the application must have installed
// a `.desktop` file. For example:
// |[
//
//	[Desktop Entry]
//	 Name=Test Application
//	 Comment=Description of what Test Application does
//	 Exec=gnome-test-application
//	 Icon=org.gnome.TestApplication
//	 Terminal=false
//	 Type=Application
//	 Categories=GNOME;GTK;TestApplication Category;
//	 StartupNotify=true
//	 DBusActivatable=true
//	 X-GNOME-UsesNotifications=true
//
// ]|
//
// The `X-GNOME-UsesNotifications` key indicates to GNOME Control Center
// that this application uses notifications, so it can be listed in the
// Control Center’s ‘Notifications’ panel.
//
// The `.desktop` file must be named as `org.gnome.TestApplication.desktop`,
// where `org.gnome.TestApplication` is the ID passed to g_application_new().
//
// User interaction with a notification (either the default action, or
// buttons) must be associated with actions on the application (ie:
// "app." actions).  It is not possible to route user interaction
// through the notification itself, because the object will not exist if
// the application is autostarted as a result of a notification being
// clicked.
//
// A notification can be sent with g_application_send_notification().
type Notification struct {
	gobject.Object
}

func NotificationNewFromInternalPtr(ptr uintptr) *Notification {
	cls := &Notification{}
	cls.Ptr = ptr
	return cls
}

var xNewNotification func(string) uintptr

// Creates a new #GNotification with @title as its title.
//
// After populating @notification with more details, it can be sent to
// the desktop shell with g_application_send_notification(). Changing
// any properties after this call will not have any effect until
// resending @notification.
func NewNotification(TitleVar string) *Notification {
	var cls *Notification

	cret := xNewNotification(TitleVar)

	if cret == 0 {
		return nil
	}
	cls = &Notification{}
	cls.Ptr = cret
	return cls
}

var xNotificationAddButton func(uintptr, string, string)

// Adds a button to @notification that activates the action in
// @detailed_action when clicked. That action must be an
// application-wide action (starting with "app."). If @detailed_action
// contains a target, the action will be activated with that target as
// its parameter.
//
// See g_action_parse_detailed_name() for a description of the format
// for @detailed_action.
func (x *Notification) AddButton(LabelVar string, DetailedActionVar string) {

	xNotificationAddButton(x.GoPointer(), LabelVar, DetailedActionVar)

}

var xNotificationAddButtonWithTarget func(uintptr, string, string, string, ...interface{})

// Adds a button to @notification that activates @action when clicked.
// @action must be an application-wide action (it must start with "app.").
//
// If @target_format is given, it is used to collect remaining
// positional parameters into a #GVariant instance, similar to
// g_variant_new(). @action will be activated with that #GVariant as its
// parameter.
func (x *Notification) AddButtonWithTarget(LabelVar string, ActionVar string, TargetFormatVar string, varArgs ...interface{}) {

	xNotificationAddButtonWithTarget(x.GoPointer(), LabelVar, ActionVar, TargetFormatVar, varArgs...)

}

var xNotificationAddButtonWithTargetValue func(uintptr, string, string, *glib.Variant)

// Adds a button to @notification that activates @action when clicked.
// @action must be an application-wide action (it must start with "app.").
//
// If @target is non-%NULL, @action will be activated with @target as
// its parameter.
func (x *Notification) AddButtonWithTargetValue(LabelVar string, ActionVar string, TargetVar *glib.Variant) {

	xNotificationAddButtonWithTargetValue(x.GoPointer(), LabelVar, ActionVar, TargetVar)

}

var xNotificationSetBody func(uintptr, string)

// Sets the body of @notification to @body.
func (x *Notification) SetBody(BodyVar string) {

	xNotificationSetBody(x.GoPointer(), BodyVar)

}

var xNotificationSetCategory func(uintptr, string)

// Sets the type of @notification to @category. Categories have a main
// type like `email`, `im` or `device` and can have a detail separated
// by a `.`, e.g. `im.received` or `email.arrived`. Setting the category
// helps the notification server to select proper feedback to the user.
//
// Standard categories are [listed in the specification](https://specifications.freedesktop.org/notification-spec/latest/ar01s06.html).
func (x *Notification) SetCategory(CategoryVar string) {

	xNotificationSetCategory(x.GoPointer(), CategoryVar)

}

var xNotificationSetDefaultAction func(uintptr, string)

// Sets the default action of @notification to @detailed_action. This
// action is activated when the notification is clicked on.
//
// The action in @detailed_action must be an application-wide action (it
// must start with "app."). If @detailed_action contains a target, the
// given action will be activated with that target as its parameter.
// See g_action_parse_detailed_name() for a description of the format
// for @detailed_action.
//
// When no default action is set, the application that the notification
// was sent on is activated.
func (x *Notification) SetDefaultAction(DetailedActionVar string) {

	xNotificationSetDefaultAction(x.GoPointer(), DetailedActionVar)

}

var xNotificationSetDefaultActionAndTarget func(uintptr, string, string, ...interface{})

// Sets the default action of @notification to @action. This action is
// activated when the notification is clicked on. It must be an
// application-wide action (it must start with "app.").
//
// If @target_format is given, it is used to collect remaining
// positional parameters into a #GVariant instance, similar to
// g_variant_new(). @action will be activated with that #GVariant as its
// parameter.
//
// When no default action is set, the application that the notification
// was sent on is activated.
func (x *Notification) SetDefaultActionAndTarget(ActionVar string, TargetFormatVar string, varArgs ...interface{}) {

	xNotificationSetDefaultActionAndTarget(x.GoPointer(), ActionVar, TargetFormatVar, varArgs...)

}

var xNotificationSetDefaultActionAndTargetValue func(uintptr, string, *glib.Variant)

// Sets the default action of @notification to @action. This action is
// activated when the notification is clicked on. It must be an
// application-wide action (start with "app.").
//
// If @target is non-%NULL, @action will be activated with @target as
// its parameter.
//
// When no default action is set, the application that the notification
// was sent on is activated.
func (x *Notification) SetDefaultActionAndTargetValue(ActionVar string, TargetVar *glib.Variant) {

	xNotificationSetDefaultActionAndTargetValue(x.GoPointer(), ActionVar, TargetVar)

}

var xNotificationSetIcon func(uintptr, uintptr)

// Sets the icon of @notification to @icon.
func (x *Notification) SetIcon(IconVar Icon) {

	xNotificationSetIcon(x.GoPointer(), IconVar.GoPointer())

}

var xNotificationSetPriority func(uintptr, NotificationPriority)

// Sets the priority of @notification to @priority. See
// #GNotificationPriority for possible values.
func (x *Notification) SetPriority(PriorityVar NotificationPriority) {

	xNotificationSetPriority(x.GoPointer(), PriorityVar)

}

var xNotificationSetTitle func(uintptr, string)

// Sets the title of @notification to @title.
func (x *Notification) SetTitle(TitleVar string) {

	xNotificationSetTitle(x.GoPointer(), TitleVar)

}

var xNotificationSetUrgent func(uintptr, bool)

// Deprecated in favor of g_notification_set_priority().
func (x *Notification) SetUrgent(UrgentVar bool) {

	xNotificationSetUrgent(x.GoPointer(), UrgentVar)

}

func (c *Notification) GoPointer() uintptr {
	return c.Ptr
}

func (c *Notification) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A #GPropertyAction is a way to get a #GAction with a state value
// reflecting and controlling the value of a #GObject property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value
// matches the requirements as specified in the #GParamSpec).
//
// Only the most common types are presently supported.  Booleans are
// mapped to booleans, strings to strings, signed/unsigned integers to
// int32/uint32 and floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and
// conversion will automatically be performed between the enum value and
// "nick" string as per the #GEnumValue table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not
// supported and probably never will be.
//
// Properties of #GVariant types are not currently supported.
//
// If the property is boolean-valued then the action will have a NULL
// parameter type, and activating the action (with no parameter) will
// toggle the value of the property.
//
// In all other cases, the parameter type will correspond to the type of
// the property.
//
// The general idea here is to reduce the number of locations where a
// particular piece of state is kept (and therefore has to be synchronised
// between). #GPropertyAction does not have a separate state that is kept
// in sync with the property value -- its state is the property value.
//
// For example, it might be useful to create a #GAction corresponding to
// the "visible-child-name" property of a #GtkStack so that the current
// page can be switched from a menu.  The active radio indication in the
// menu is then directly determined from the active page of the
// #GtkStack.
//
// An anti-example would be binding the "active-id" property on a
// #GtkComboBox.  This is because the state of the combobox itself is
// probably uninteresting and is actually being used to control
// something else.
//
// Another anti-example would be to bind to the "visible-child-name"
// property of a #GtkStack if this value is actually stored in
// #GSettings.  In that case, the real source of the value is
// #GSettings.  If you want a #GAction to control a setting stored in
// #GSettings, see g_settings_create_action() instead, and possibly
// combine its use with g_settings_bind().
type PropertyAction struct {
	gobject.Object
}

func PropertyActionNewFromInternalPtr(ptr uintptr) *PropertyAction {
	cls := &PropertyAction{}
	cls.Ptr = ptr
	return cls
}

var xNewPropertyAction func(string, uintptr, string) uintptr

// Creates a #GAction corresponding to the value of property
// @property_name on @object.
//
// The property must be existent and readable and writable (and not
// construct-only).
//
// This function takes a reference on @object and doesn't release it
// until the action is destroyed.
func NewPropertyAction(NameVar string, ObjectVar *gobject.Object, PropertyNameVar string) *PropertyAction {
	var cls *PropertyAction

	cret := xNewPropertyAction(NameVar, ObjectVar.GoPointer(), PropertyNameVar)

	if cret == 0 {
		return nil
	}
	cls = &PropertyAction{}
	cls.Ptr = cret
	return cls
}

func (c *PropertyAction) GoPointer() uintptr {
	return c.Ptr
}

func (c *PropertyAction) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Activates the action.
//
// @parameter must be the correct type of parameter for the action (ie:
// the parameter type given at construction time).  If the parameter
// type was %NULL then @parameter must also be %NULL.
//
// If the @parameter GVariant is floating, it is consumed.
func (x *PropertyAction) Activate(ParameterVar *glib.Variant) {

	XGActionActivate(x.GoPointer(), ParameterVar)

}

// Request for the state of @action to be changed to @value.
//
// The action must be stateful and @value must be of the correct type.
// See g_action_get_state_type().
//
// This call merely requests a change.  The action may refuse to change
// its state or may change its state to something other than @value.
// See g_action_get_state_hint().
//
// If the @value GVariant is floating, it is consumed.
func (x *PropertyAction) ChangeState(ValueVar *glib.Variant) {

	XGActionChangeState(x.GoPointer(), ValueVar)

}

// Checks if @action is currently enabled.
//
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
func (x *PropertyAction) GetEnabled() bool {

	cret := XGActionGetEnabled(x.GoPointer())
	return cret
}

// Queries the name of @action.
func (x *PropertyAction) GetName() string {

	cret := XGActionGetName(x.GoPointer())
	return cret
}

// Queries the type of the parameter that must be given when activating
// @action.
//
// When activating the action using g_action_activate(), the #GVariant
// given to that function must be of the type returned by this function.
//
// In the case that this function returns %NULL, you must not give any
// #GVariant, but %NULL instead.
func (x *PropertyAction) GetParameterType() *glib.VariantType {

	cret := XGActionGetParameterType(x.GoPointer())
	return cret
}

// Queries the current state of @action.
//
// If the action is not stateful then %NULL will be returned.  If the
// action is stateful then the type of the return value is the type
// given by g_action_get_state_type().
//
// The return value (if non-%NULL) should be freed with
// g_variant_unref() when it is no longer required.
func (x *PropertyAction) GetState() *glib.Variant {

	cret := XGActionGetState(x.GoPointer())
	return cret
}

// Requests a hint about the valid range of values for the state of
// @action.
//
// If %NULL is returned it either means that the action is not stateful
// or that there is no hint about the valid range of values for the
// state of the action.
//
// If a #GVariant array is returned then each item in the array is a
// possible value for the state.  If a #GVariant pair (ie: two-tuple) is
// returned then the tuple specifies the inclusive lower and upper bound
// of valid values for the state.
//
// In any case, the information is merely a hint.  It may be possible to
// have a state value outside of the hinted range and setting a value
// within the range may fail.
//
// The return value (if non-%NULL) should be freed with
// g_variant_unref() when it is no longer required.
func (x *PropertyAction) GetStateHint() *glib.Variant {

	cret := XGActionGetStateHint(x.GoPointer())
	return cret
}

// Queries the type of the state of @action.
//
// If the action is stateful (e.g. created with
// g_simple_action_new_stateful()) then this function returns the
// #GVariantType of the state.  This is the type of the initial value
// given as the state. All calls to g_action_change_state() must give a
// #GVariant of this type and g_action_get_state() will return a
// #GVariant of the same type.
//
// If the action is not stateful (e.g. created with g_simple_action_new())
// then this function will return %NULL. In that case, g_action_get_state()
// will return %NULL and you must not call g_action_change_state().
func (x *PropertyAction) GetStateType() *glib.VariantType {

	cret := XGActionGetStateType(x.GoPointer())
	return cret
}

// A #GSimpleAction is the obvious simple implementation of the #GAction
// interface. This is the easiest way to create an action for purposes of
// adding it to a #GSimpleActionGroup.
//
// See also #GtkAction.
type SimpleAction struct {
	gobject.Object
}

func SimpleActionNewFromInternalPtr(ptr uintptr) *SimpleAction {
	cls := &SimpleAction{}
	cls.Ptr = ptr
	return cls
}

var xNewSimpleAction func(string, *glib.VariantType) uintptr

// Creates a new action.
//
// The created action is stateless. See g_simple_action_new_stateful() to create
// an action that has state.
func NewSimpleAction(NameVar string, ParameterTypeVar *glib.VariantType) *SimpleAction {
	var cls *SimpleAction

	cret := xNewSimpleAction(NameVar, ParameterTypeVar)

	if cret == 0 {
		return nil
	}
	cls = &SimpleAction{}
	cls.Ptr = cret
	return cls
}

var xNewSimpleActionStateful func(string, *glib.VariantType, *glib.Variant) uintptr

// Creates a new stateful action.
//
// All future state values must have the same #GVariantType as the initial
// @state.
//
// If the @state #GVariant is floating, it is consumed.
func NewSimpleActionStateful(NameVar string, ParameterTypeVar *glib.VariantType, StateVar *glib.Variant) *SimpleAction {
	var cls *SimpleAction

	cret := xNewSimpleActionStateful(NameVar, ParameterTypeVar, StateVar)

	if cret == 0 {
		return nil
	}
	cls = &SimpleAction{}
	cls.Ptr = cret
	return cls
}

var xSimpleActionSetEnabled func(uintptr, bool)

// Sets the action as enabled or not.
//
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
//
// This should only be called by the implementor of the action.  Users
// of the action should not attempt to modify its enabled flag.
func (x *SimpleAction) SetEnabled(EnabledVar bool) {

	xSimpleActionSetEnabled(x.GoPointer(), EnabledVar)

}

var xSimpleActionSetState func(uintptr, *glib.Variant)

// Sets the state of the action.
//
// This directly updates the 'state' property to the given value.
//
// This should only be called by the implementor of the action.  Users
// of the action should not attempt to directly modify the 'state'
// property.  Instead, they should call g_action_change_state() to
// request the change.
//
// If the @value GVariant is floating, it is consumed.
func (x *SimpleAction) SetState(ValueVar *glib.Variant) {

	xSimpleActionSetState(x.GoPointer(), ValueVar)

}

var xSimpleActionSetStateHint func(uintptr, *glib.Variant)

// Sets the state hint for the action.
//
// See g_action_get_state_hint() for more information about
// action state hints.
func (x *SimpleAction) SetStateHint(StateHintVar *glib.Variant) {

	xSimpleActionSetStateHint(x.GoPointer(), StateHintVar)

}

func (c *SimpleAction) GoPointer() uintptr {
	return c.Ptr
}

func (c *SimpleAction) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Indicates that the action was just activated.
//
// @parameter will always be of the expected type, i.e. the parameter type
// specified when the action was created. If an incorrect type is given when
// activating the action, this signal is not emitted.
//
// Since GLib 2.40, if no handler is connected to this signal then the
// default behaviour for boolean-stated actions with a %NULL parameter
// type is to toggle them via the #GSimpleAction::change-state signal.
// For stateful actions where the state type is equal to the parameter
// type, the default is to forward them directly to
// #GSimpleAction::change-state.  This should allow almost all users
// of #GSimpleAction to connect only one handler or the other.
func (x *SimpleAction) ConnectActivate(cb *func(SimpleAction, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ParameterVarp uintptr) {
		fa := SimpleAction{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ParameterVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
}

// Indicates that the action just received a request to change its
// state.
//
// @value will always be of the correct state type, i.e. the type of the
// initial state passed to g_simple_action_new_stateful(). If an incorrect
// type is given when requesting to change the state, this signal is not
// emitted.
//
// If no handler is connected to this signal then the default
// behaviour is to call g_simple_action_set_state() to set the state
// to the requested value. If you connect a signal handler then no
// default action is taken. If the state should change then you must
// call g_simple_action_set_state() from the handler.
//
// An example of a 'change-state' handler:
// |[&lt;!-- language="C" --&gt;
// static void
// change_volume_state (GSimpleAction *action,
//
//	GVariant      *value,
//	gpointer       user_data)
//
//	{
//	  gint requested;
//
//	  requested = g_variant_get_int32 (value);
//
//	  // Volume only goes from 0 to 10
//	  if (0 &lt;= requested &amp;&amp; requested &lt;= 10)
//	    g_simple_action_set_state (action, value);
//	}
//
// ]|
//
// The handler need not set the state to the requested value.
// It could set it to any value at all, or take some other action.
func (x *SimpleAction) ConnectChangeState(cb *func(SimpleAction, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "change-state", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ValueVarp uintptr) {
		fa := SimpleAction{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ValueVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "change-state", cbRefPtr)
}

// Activates the action.
//
// @parameter must be the correct type of parameter for the action (ie:
// the parameter type given at construction time).  If the parameter
// type was %NULL then @parameter must also be %NULL.
//
// If the @parameter GVariant is floating, it is consumed.
func (x *SimpleAction) Activate(ParameterVar *glib.Variant) {

	XGActionActivate(x.GoPointer(), ParameterVar)

}

// Request for the state of @action to be changed to @value.
//
// The action must be stateful and @value must be of the correct type.
// See g_action_get_state_type().
//
// This call merely requests a change.  The action may refuse to change
// its state or may change its state to something other than @value.
// See g_action_get_state_hint().
//
// If the @value GVariant is floating, it is consumed.
func (x *SimpleAction) ChangeState(ValueVar *glib.Variant) {

	XGActionChangeState(x.GoPointer(), ValueVar)

}

// Checks if @action is currently enabled.
//
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
func (x *SimpleAction) GetEnabled() bool {

	cret := XGActionGetEnabled(x.GoPointer())
	return cret
}

// Queries the name of @action.
func (x *SimpleAction) GetName() string {

	cret := XGActionGetName(x.GoPointer())
	return cret
}

// Queries the type of the parameter that must be given when activating
// @action.
//
// When activating the action using g_action_activate(), the #GVariant
// given to that function must be of the type returned by this function.
//
// In the case that this function returns %NULL, you must not give any
// #GVariant, but %NULL instead.
func (x *SimpleAction) GetParameterType() *glib.VariantType {

	cret := XGActionGetParameterType(x.GoPointer())
	return cret
}

// Queries the current state of @action.
//
// If the action is not stateful then %NULL will be returned.  If the
// action is stateful then the type of the return value is the type
// given by g_action_get_state_type().
//
// The return value (if non-%NULL) should be freed with
// g_variant_unref() when it is no longer required.
func (x *SimpleAction) GetState() *glib.Variant {

	cret := XGActionGetState(x.GoPointer())
	return cret
}

// Requests a hint about the valid range of values for the state of
// @action.
//
// If %NULL is returned it either means that the action is not stateful
// or that there is no hint about the valid range of values for the
// state of the action.
//
// If a #GVariant array is returned then each item in the array is a
// possible value for the state.  If a #GVariant pair (ie: two-tuple) is
// returned then the tuple specifies the inclusive lower and upper bound
// of valid values for the state.
//
// In any case, the information is merely a hint.  It may be possible to
// have a state value outside of the hinted range and setting a value
// within the range may fail.
//
// The return value (if non-%NULL) should be freed with
// g_variant_unref() when it is no longer required.
func (x *SimpleAction) GetStateHint() *glib.Variant {

	cret := XGActionGetStateHint(x.GoPointer())
	return cret
}

// Queries the type of the state of @action.
//
// If the action is stateful (e.g. created with
// g_simple_action_new_stateful()) then this function returns the
// #GVariantType of the state.  This is the type of the initial value
// given as the state. All calls to g_action_change_state() must give a
// #GVariant of this type and g_action_get_state() will return a
// #GVariant of the same type.
//
// If the action is not stateful (e.g. created with g_simple_action_new())
// then this function will return %NULL. In that case, g_action_get_state()
// will return %NULL and you must not call g_action_change_state().
func (x *SimpleAction) GetStateType() *glib.VariantType {

	cret := XGActionGetStateType(x.GoPointer())
	return cret
}

// GSimpleIOStream creates a #GIOStream from an arbitrary #GInputStream and
// #GOutputStream. This allows any pair of input and output streams to be used
// with #GIOStream methods.
//
// This is useful when you obtained a #GInputStream and a #GOutputStream
// by other means, for instance creating them with platform specific methods as
// g_unix_input_stream_new() or g_win32_input_stream_new(), and you want
// to take advantage of the methods provided by #GIOStream.
type SimpleIOStream struct {
	IOStream
}

func SimpleIOStreamNewFromInternalPtr(ptr uintptr) *SimpleIOStream {
	cls := &SimpleIOStream{}
	cls.Ptr = ptr
	return cls
}

var xNewSimpleIOStream func(uintptr, uintptr) uintptr

// Creates a new #GSimpleIOStream wrapping @input_stream and @output_stream.
// See also #GIOStream.
func NewSimpleIOStream(InputStreamVar *InputStream, OutputStreamVar *OutputStream) *SimpleIOStream {
	var cls *SimpleIOStream

	cret := xNewSimpleIOStream(InputStreamVar.GoPointer(), OutputStreamVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &SimpleIOStream{}
	cls.Ptr = cret
	return cls
}

func (c *SimpleIOStream) GoPointer() uintptr {
	return c.Ptr
}

func (c *SimpleIOStream) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// #GSimplePermission is a trivial implementation of #GPermission that
// represents a permission that is either always or never allowed.  The
// value is given at construction and doesn't change.
//
// Calling request or release will result in errors.
type SimplePermission struct {
	Permission
}

func SimplePermissionNewFromInternalPtr(ptr uintptr) *SimplePermission {
	cls := &SimplePermission{}
	cls.Ptr = ptr
	return cls
}

var xNewSimplePermission func(bool) uintptr

// Creates a new #GPermission instance that represents an action that is
// either always or never allowed.
func NewSimplePermission(AllowedVar bool) *SimplePermission {
	var cls *SimplePermission

	cret := xNewSimplePermission(AllowedVar)

	if cret == 0 {
		return nil
	}
	cls = &SimplePermission{}
	cls.Ptr = cret
	return cls
}

func (c *SimplePermission) GoPointer() uintptr {
	return c.Ptr
}

func (c *SimplePermission) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// #GSubprocess allows the creation of and interaction with child
// processes.
//
// Processes can be communicated with using standard GIO-style APIs (ie:
// #GInputStream, #GOutputStream).  There are GIO-style APIs to wait for
// process termination (ie: cancellable and with an asynchronous
// variant).
//
// There is an API to force a process to terminate, as well as a
// race-free API for sending UNIX signals to a subprocess.
//
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such
// g_output_stream_splice_async().  This makes GSubprocess
// significantly more powerful and flexible than equivalent APIs in
// some other languages such as the `subprocess.py`
// included with Python.  For example, using #GSubprocess one could
// create two child processes, reading standard output from the first,
// processing it, and writing to the input stream of the second, all
// without blocking the main loop.
//
// A powerful g_subprocess_communicate() API is provided similar to the
// `communicate()` method of `subprocess.py`. This enables very easy
// interaction with a subprocess that has been opened with pipes.
//
// #GSubprocess defaults to tight control over the file descriptors open
// in the child process, avoiding dangling-fd issues that are caused by
// a simple fork()/exec().  The only open file descriptors in the
// spawned process are ones that were explicitly specified by the
// #GSubprocess API (unless %G_SUBPROCESS_FLAGS_INHERIT_FDS was
// specified).
//
// #GSubprocess will quickly reap all child processes as they exit,
// avoiding "zombie processes" remaining around for long periods of
// time.  g_subprocess_wait() can be used to wait for this to happen,
// but it will happen even without the call being explicitly made.
//
// As a matter of principle, #GSubprocess has no API that accepts
// shell-style space-separated strings.  It will, however, match the
// typical shell behaviour of searching the PATH for executables that do
// not contain a directory separator in their name. By default, the `PATH`
// of the current process is used.  You can specify
// %G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP to use the `PATH` of the
// launcher environment instead.
//
// #GSubprocess attempts to have a very simple API for most uses (ie:
// spawning a subprocess with arguments and support for most typical
// kinds of input and output redirection).  See g_subprocess_new(). The
// #GSubprocessLauncher API is provided for more complicated cases
// (advanced types of redirection, environment variable manipulation,
// change of working directory, child setup functions, etc).
//
// A typical use of #GSubprocess will involve calling
// g_subprocess_new(), followed by g_subprocess_wait_async() or
// g_subprocess_wait().  After the process exits, the status can be
// checked using functions such as g_subprocess_get_if_exited() (which
// are similar to the familiar WIFEXITED-style POSIX macros).
type Subprocess struct {
	gobject.Object
}

func SubprocessNewFromInternalPtr(ptr uintptr) *Subprocess {
	cls := &Subprocess{}
	cls.Ptr = ptr
	return cls
}

var xNewSubprocess func(SubprocessFlags, **glib.Error, string, ...interface{}) uintptr

// Create a new process with the given flags and varargs argument
// list.  By default, matching the g_spawn_async() defaults, the
// child's stdin will be set to the system null device, and
// stdout/stderr will be inherited from the parent.  You can use
// @flags to control this behavior.
//
// The argument list must be terminated with %NULL.
func NewSubprocess(FlagsVar SubprocessFlags, ErrorVar **glib.Error, Argv0Var string, varArgs ...interface{}) *Subprocess {
	var cls *Subprocess

	cret := xNewSubprocess(FlagsVar, ErrorVar, Argv0Var, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &Subprocess{}
	cls.Ptr = cret
	return cls
}

var xNewSubprocessv func(uintptr, SubprocessFlags, **glib.Error) uintptr

// Create a new process with the given flags and argument list.
//
// The argument list is expected to be %NULL-terminated.
func NewSubprocessv(ArgvVar uintptr, FlagsVar SubprocessFlags) (*Subprocess, error) {
	var cls *Subprocess
	var cerr *glib.Error

	cret := xNewSubprocessv(ArgvVar, FlagsVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Subprocess{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xSubprocessCommunicate func(uintptr, *glib.Bytes, uintptr, **glib.Bytes, **glib.Bytes, **glib.Error) bool

// Communicate with the subprocess until it terminates, and all input
// and output has been completed.
//
// If @stdin_buf is given, the subprocess must have been created with
// %G_SUBPROCESS_FLAGS_STDIN_PIPE.  The given data is fed to the
// stdin of the subprocess and the pipe is closed (ie: EOF).
//
// At the same time (as not to cause blocking when dealing with large
// amounts of data), if %G_SUBPROCESS_FLAGS_STDOUT_PIPE or
// %G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those
// streams.  The data that was read is returned in @stdout and/or
// the @stderr.
//
// If the subprocess was created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
// @stdout_buf will contain the data read from stdout.  Otherwise, for
// subprocesses not created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
// @stdout_buf will be set to %NULL.  Similar provisions apply to
// @stderr_buf and %G_SUBPROCESS_FLAGS_STDERR_PIPE.
//
// As usual, any output variable may be given as %NULL to ignore it.
//
// If you desire the stdout and stderr data to be interleaved, create
// the subprocess with %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
// %G_SUBPROCESS_FLAGS_STDERR_MERGE.  The merged result will be returned
// in @stdout_buf and @stderr_buf will be set to %NULL.
//
// In case of any error (including cancellation), %FALSE will be
// returned with @error set.  Some or all of the stdin data may have
// been written.  Any stdout or stderr data that has been read will be
// discarded. None of the out variables (aside from @error) will have
// been set to anything in particular and should not be inspected.
//
// In the case that %TRUE is returned, the subprocess has exited and the
// exit status inspection APIs (eg: g_subprocess_get_if_exited(),
// g_subprocess_get_exit_status()) may be used.
//
// You should not attempt to use any of the subprocess pipes after
// starting this function, since they may be left in strange states,
// even if the operation was cancelled.  You should especially not
// attempt to interact with the pipes while the operation is in progress
// (either from another thread or if using the asynchronous version).
func (x *Subprocess) Communicate(StdinBufVar *glib.Bytes, CancellableVar *Cancellable, StdoutBufVar **glib.Bytes, StderrBufVar **glib.Bytes) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessCommunicate(x.GoPointer(), StdinBufVar, CancellableVar.GoPointer(), StdoutBufVar, StderrBufVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessCommunicateAsync func(uintptr, *glib.Bytes, uintptr, uintptr, uintptr)

// Asynchronous version of g_subprocess_communicate().  Complete
// invocation with g_subprocess_communicate_finish().
func (x *Subprocess) CommunicateAsync(StdinBufVar *glib.Bytes, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xSubprocessCommunicateAsync(x.GoPointer(), StdinBufVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xSubprocessCommunicateFinish func(uintptr, uintptr, **glib.Bytes, **glib.Bytes, **glib.Error) bool

// Complete an invocation of g_subprocess_communicate_async().
func (x *Subprocess) CommunicateFinish(ResultVar AsyncResult, StdoutBufVar **glib.Bytes, StderrBufVar **glib.Bytes) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessCommunicateFinish(x.GoPointer(), ResultVar.GoPointer(), StdoutBufVar, StderrBufVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessCommunicateUtf8 func(uintptr, string, uintptr, string, string, **glib.Error) bool

// Like g_subprocess_communicate(), but validates the output of the
// process as UTF-8, and returns it as a regular NUL terminated string.
//
// On error, @stdout_buf and @stderr_buf will be set to undefined values and
// should not be used.
func (x *Subprocess) CommunicateUtf8(StdinBufVar string, CancellableVar *Cancellable, StdoutBufVar string, StderrBufVar string) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessCommunicateUtf8(x.GoPointer(), StdinBufVar, CancellableVar.GoPointer(), StdoutBufVar, StderrBufVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessCommunicateUtf8Async func(uintptr, string, uintptr, uintptr, uintptr)

// Asynchronous version of g_subprocess_communicate_utf8().  Complete
// invocation with g_subprocess_communicate_utf8_finish().
func (x *Subprocess) CommunicateUtf8Async(StdinBufVar string, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xSubprocessCommunicateUtf8Async(x.GoPointer(), StdinBufVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xSubprocessCommunicateUtf8Finish func(uintptr, uintptr, string, string, **glib.Error) bool

// Complete an invocation of g_subprocess_communicate_utf8_async().
func (x *Subprocess) CommunicateUtf8Finish(ResultVar AsyncResult, StdoutBufVar string, StderrBufVar string) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessCommunicateUtf8Finish(x.GoPointer(), ResultVar.GoPointer(), StdoutBufVar, StderrBufVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessForceExit func(uintptr)

// Use an operating-system specific method to attempt an immediate,
// forceful termination of the process.  There is no mechanism to
// determine whether or not the request itself was successful;
// however, you can use g_subprocess_wait() to monitor the status of
// the process after calling this function.
//
// On Unix, this function sends %SIGKILL.
func (x *Subprocess) ForceExit() {

	xSubprocessForceExit(x.GoPointer())

}

var xSubprocessGetExitStatus func(uintptr) int

// Check the exit status of the subprocess, given that it exited
// normally.  This is the value passed to the exit() system call or the
// return value from main.
//
// This is equivalent to the system WEXITSTATUS macro.
//
// It is an error to call this function before g_subprocess_wait() and
// unless g_subprocess_get_if_exited() returned %TRUE.
func (x *Subprocess) GetExitStatus() int {

	cret := xSubprocessGetExitStatus(x.GoPointer())
	return cret
}

var xSubprocessGetIdentifier func(uintptr) string

// On UNIX, returns the process ID as a decimal string.
// On Windows, returns the result of GetProcessId() also as a string.
// If the subprocess has terminated, this will return %NULL.
func (x *Subprocess) GetIdentifier() string {

	cret := xSubprocessGetIdentifier(x.GoPointer())
	return cret
}

var xSubprocessGetIfExited func(uintptr) bool

// Check if the given subprocess exited normally (ie: by way of exit()
// or return from main()).
//
// This is equivalent to the system WIFEXITED macro.
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (x *Subprocess) GetIfExited() bool {

	cret := xSubprocessGetIfExited(x.GoPointer())
	return cret
}

var xSubprocessGetIfSignaled func(uintptr) bool

// Check if the given subprocess terminated in response to a signal.
//
// This is equivalent to the system WIFSIGNALED macro.
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (x *Subprocess) GetIfSignaled() bool {

	cret := xSubprocessGetIfSignaled(x.GoPointer())
	return cret
}

var xSubprocessGetStatus func(uintptr) int

// Gets the raw status code of the process, as from waitpid().
//
// This value has no particular meaning, but it can be used with the
// macros defined by the system headers such as WIFEXITED.  It can also
// be used with g_spawn_check_wait_status().
//
// It is more likely that you want to use g_subprocess_get_if_exited()
// followed by g_subprocess_get_exit_status().
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (x *Subprocess) GetStatus() int {

	cret := xSubprocessGetStatus(x.GoPointer())
	return cret
}

var xSubprocessGetStderrPipe func(uintptr) uintptr

// Gets the #GInputStream from which to read the stderr output of
// @subprocess.
//
// The process must have been created with %G_SUBPROCESS_FLAGS_STDERR_PIPE,
// otherwise %NULL will be returned.
func (x *Subprocess) GetStderrPipe() *InputStream {
	var cls *InputStream

	cret := xSubprocessGetStderrPipe(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &InputStream{}
	cls.Ptr = cret
	return cls
}

var xSubprocessGetStdinPipe func(uintptr) uintptr

// Gets the #GOutputStream that you can write to in order to give data
// to the stdin of @subprocess.
//
// The process must have been created with %G_SUBPROCESS_FLAGS_STDIN_PIPE and
// not %G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise %NULL will be returned.
func (x *Subprocess) GetStdinPipe() *OutputStream {
	var cls *OutputStream

	cret := xSubprocessGetStdinPipe(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &OutputStream{}
	cls.Ptr = cret
	return cls
}

var xSubprocessGetStdoutPipe func(uintptr) uintptr

// Gets the #GInputStream from which to read the stdout output of
// @subprocess.
//
// The process must have been created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
// otherwise %NULL will be returned.
func (x *Subprocess) GetStdoutPipe() *InputStream {
	var cls *InputStream

	cret := xSubprocessGetStdoutPipe(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &InputStream{}
	cls.Ptr = cret
	return cls
}

var xSubprocessGetSuccessful func(uintptr) bool

// Checks if the process was "successful".  A process is considered
// successful if it exited cleanly with an exit status of 0, either by
// way of the exit() system call or return from main().
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (x *Subprocess) GetSuccessful() bool {

	cret := xSubprocessGetSuccessful(x.GoPointer())
	return cret
}

var xSubprocessGetTermSig func(uintptr) int

// Get the signal number that caused the subprocess to terminate, given
// that it terminated due to a signal.
//
// This is equivalent to the system WTERMSIG macro.
//
// It is an error to call this function before g_subprocess_wait() and
// unless g_subprocess_get_if_signaled() returned %TRUE.
func (x *Subprocess) GetTermSig() int {

	cret := xSubprocessGetTermSig(x.GoPointer())
	return cret
}

var xSubprocessSendSignal func(uintptr, int)

// Sends the UNIX signal @signal_num to the subprocess, if it is still
// running.
//
// This API is race-free.  If the subprocess has terminated, it will not
// be signalled.
//
// This API is not available on Windows.
func (x *Subprocess) SendSignal(SignalNumVar int) {

	xSubprocessSendSignal(x.GoPointer(), SignalNumVar)

}

var xSubprocessWait func(uintptr, uintptr, **glib.Error) bool

// Synchronously wait for the subprocess to terminate.
//
// After the process terminates you can query its exit status with
// functions such as g_subprocess_get_if_exited() and
// g_subprocess_get_exit_status().
//
// This function does not fail in the case of the subprocess having
// abnormal termination.  See g_subprocess_wait_check() for that.
//
// Cancelling @cancellable doesn't kill the subprocess.  Call
// g_subprocess_force_exit() if it is desirable.
func (x *Subprocess) Wait(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessWait(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessWaitAsync func(uintptr, uintptr, uintptr, uintptr)

// Wait for the subprocess to terminate.
//
// This is the asynchronous version of g_subprocess_wait().
func (x *Subprocess) WaitAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xSubprocessWaitAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xSubprocessWaitCheck func(uintptr, uintptr, **glib.Error) bool

// Combines g_subprocess_wait() with g_spawn_check_wait_status().
func (x *Subprocess) WaitCheck(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessWaitCheck(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessWaitCheckAsync func(uintptr, uintptr, uintptr, uintptr)

// Combines g_subprocess_wait_async() with g_spawn_check_wait_status().
//
// This is the asynchronous version of g_subprocess_wait_check().
func (x *Subprocess) WaitCheckAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xSubprocessWaitCheckAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xSubprocessWaitCheckFinish func(uintptr, uintptr, **glib.Error) bool

// Collects the result of a previous call to
// g_subprocess_wait_check_async().
func (x *Subprocess) WaitCheckFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessWaitCheckFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSubprocessWaitFinish func(uintptr, uintptr, **glib.Error) bool

// Collects the result of a previous call to
// g_subprocess_wait_async().
func (x *Subprocess) WaitFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xSubprocessWaitFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *Subprocess) GoPointer() uintptr {
	return c.Ptr
}

func (c *Subprocess) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Initializes the object implementing the interface.
//
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
//
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
//
// Implementations may also support cancellation. If @cancellable is not %NULL,
// then initialization can be cancelled by triggering the cancellable object
// from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
// the object doesn't support cancellable initialization the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// If the object is not initialized, or initialization returns with an
// error, then all operations on the object except g_object_ref() and
// g_object_unref() are considered to be invalid, and have undefined
// behaviour. See the [introduction][ginitable] for more details.
//
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a class’ implementation of init() can assume
// (and assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
//
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes
// the object; further calls return the result of the first call.
//
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a
// #GObjectClass.constructor that sometimes returns an existing instance.
// In this pattern, a caller would expect to be able to call g_initable_init()
// on the result of g_object_new(), regardless of whether it is in fact a new
// instance.
func (x *Subprocess) Init(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGInitableInit(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// This class contains a set of options for launching child processes,
// such as where its standard input and output will be directed, the
// argument list, the environment, and more.
//
// While the #GSubprocess class has high level functions covering
// popular cases, use of this class allows access to more advanced
// options.  It can also be used to launch multiple subprocesses with
// a similar configuration.
type SubprocessLauncher struct {
	gobject.Object
}

func SubprocessLauncherNewFromInternalPtr(ptr uintptr) *SubprocessLauncher {
	cls := &SubprocessLauncher{}
	cls.Ptr = ptr
	return cls
}

var xNewSubprocessLauncher func(SubprocessFlags) uintptr

// Creates a new #GSubprocessLauncher.
//
// The launcher is created with the default options.  A copy of the
// environment of the calling process is made at the time of this call
// and will be used as the environment that the process is launched in.
func NewSubprocessLauncher(FlagsVar SubprocessFlags) *SubprocessLauncher {
	var cls *SubprocessLauncher

	cret := xNewSubprocessLauncher(FlagsVar)

	if cret == 0 {
		return nil
	}
	cls = &SubprocessLauncher{}
	cls.Ptr = cret
	return cls
}

var xSubprocessLauncherClose func(uintptr)

// Closes all the file descriptors previously passed to the object with
// g_subprocess_launcher_take_fd(), g_subprocess_launcher_take_stderr_fd(), etc.
//
// After calling this method, any subsequent calls to g_subprocess_launcher_spawn() or g_subprocess_launcher_spawnv() will
// return %G_IO_ERROR_CLOSED. This method is idempotent if
// called more than once.
//
// This function is called automatically when the #GSubprocessLauncher
// is disposed, but is provided separately so that garbage collected
// language bindings can call it earlier to guarantee when FDs are closed.
func (x *SubprocessLauncher) Close() {

	xSubprocessLauncherClose(x.GoPointer())

}

var xSubprocessLauncherGetenv func(uintptr, string) string

// Returns the value of the environment variable @variable in the
// environment of processes launched from this launcher.
//
// On UNIX, the returned string can be an arbitrary byte string.
// On Windows, it will be UTF-8.
func (x *SubprocessLauncher) Getenv(VariableVar string) string {

	cret := xSubprocessLauncherGetenv(x.GoPointer(), VariableVar)
	return cret
}

var xSubprocessLauncherSetChildSetup func(uintptr, uintptr, uintptr, uintptr)

// Sets up a child setup function.
//
// The child setup function will be called after fork() but before
// exec() on the child's side.
//
// @destroy_notify will not be automatically called on the child's side
// of the fork().  It will only be called when the last reference on the
// #GSubprocessLauncher is dropped or when a new child setup function is
// given.
//
// %NULL can be given as @child_setup to disable the functionality.
//
// Child setup functions are only available on UNIX.
func (x *SubprocessLauncher) SetChildSetup(ChildSetupVar *glib.SpawnChildSetupFunc, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify) {

	xSubprocessLauncherSetChildSetup(x.GoPointer(), glib.NewCallback(ChildSetupVar), UserDataVar, glib.NewCallback(DestroyNotifyVar))

}

var xSubprocessLauncherSetCwd func(uintptr, string)

// Sets the current working directory that processes will be launched
// with.
//
// By default processes are launched with the current working directory
// of the launching process at the time of launch.
func (x *SubprocessLauncher) SetCwd(CwdVar string) {

	xSubprocessLauncherSetCwd(x.GoPointer(), CwdVar)

}

var xSubprocessLauncherSetEnviron func(uintptr, uintptr)

// Replace the entire environment of processes launched from this
// launcher with the given 'environ' variable.
//
// Typically you will build this variable by using g_listenv() to copy
// the process 'environ' and using the functions g_environ_setenv(),
// g_environ_unsetenv(), etc.
//
// As an alternative, you can use g_subprocess_launcher_setenv(),
// g_subprocess_launcher_unsetenv(), etc.
//
// Pass an empty array to set an empty environment. Pass %NULL to inherit the
// parent process’ environment. As of GLib 2.54, the parent process’ environment
// will be copied when g_subprocess_launcher_set_environ() is called.
// Previously, it was copied when the subprocess was executed. This means the
// copied environment may now be modified (using g_subprocess_launcher_setenv(),
// etc.) before launching the subprocess.
//
// On UNIX, all strings in this array can be arbitrary byte strings.
// On Windows, they should be in UTF-8.
func (x *SubprocessLauncher) SetEnviron(EnvVar uintptr) {

	xSubprocessLauncherSetEnviron(x.GoPointer(), EnvVar)

}

var xSubprocessLauncherSetFlags func(uintptr, SubprocessFlags)

// Sets the flags on the launcher.
//
// The default flags are %G_SUBPROCESS_FLAGS_NONE.
//
// You may not set flags that specify conflicting options for how to
// handle a particular stdio stream (eg: specifying both
// %G_SUBPROCESS_FLAGS_STDIN_PIPE and
// %G_SUBPROCESS_FLAGS_STDIN_INHERIT).
//
// You may also not set a flag that conflicts with a previous call to a
// function like g_subprocess_launcher_set_stdin_file_path() or
// g_subprocess_launcher_take_stdout_fd().
func (x *SubprocessLauncher) SetFlags(FlagsVar SubprocessFlags) {

	xSubprocessLauncherSetFlags(x.GoPointer(), FlagsVar)

}

var xSubprocessLauncherSetStderrFilePath func(uintptr, string)

// Sets the file path to use as the stderr for spawned processes.
//
// If @path is %NULL then any previously given path is unset.
//
// The file will be created or truncated when the process is spawned, as
// would be the case if using '2&gt;' at the shell.
//
// If you want to send both stdout and stderr to the same file then use
// %G_SUBPROCESS_FLAGS_STDERR_MERGE.
//
// You may not set a stderr file path if a stderr fd is already set or
// if the launcher flags contain any flags directing stderr elsewhere.
//
// This feature is only available on UNIX.
func (x *SubprocessLauncher) SetStderrFilePath(PathVar string) {

	xSubprocessLauncherSetStderrFilePath(x.GoPointer(), PathVar)

}

var xSubprocessLauncherSetStdinFilePath func(uintptr, string)

// Sets the file path to use as the stdin for spawned processes.
//
// If @path is %NULL then any previously given path is unset.
//
// The file must exist or spawning the process will fail.
//
// You may not set a stdin file path if a stdin fd is already set or if
// the launcher flags contain any flags directing stdin elsewhere.
//
// This feature is only available on UNIX.
func (x *SubprocessLauncher) SetStdinFilePath(PathVar string) {

	xSubprocessLauncherSetStdinFilePath(x.GoPointer(), PathVar)

}

var xSubprocessLauncherSetStdoutFilePath func(uintptr, string)

// Sets the file path to use as the stdout for spawned processes.
//
// If @path is %NULL then any previously given path is unset.
//
// The file will be created or truncated when the process is spawned, as
// would be the case if using '&gt;' at the shell.
//
// You may not set a stdout file path if a stdout fd is already set or
// if the launcher flags contain any flags directing stdout elsewhere.
//
// This feature is only available on UNIX.
func (x *SubprocessLauncher) SetStdoutFilePath(PathVar string) {

	xSubprocessLauncherSetStdoutFilePath(x.GoPointer(), PathVar)

}

var xSubprocessLauncherSetenv func(uintptr, string, string, bool)

// Sets the environment variable @variable in the environment of
// processes launched from this launcher.
//
// On UNIX, both the variable's name and value can be arbitrary byte
// strings, except that the variable's name cannot contain '='.
// On Windows, they should be in UTF-8.
func (x *SubprocessLauncher) Setenv(VariableVar string, ValueVar string, OverwriteVar bool) {

	xSubprocessLauncherSetenv(x.GoPointer(), VariableVar, ValueVar, OverwriteVar)

}

var xSubprocessLauncherSpawn func(uintptr, **glib.Error, string, ...interface{}) uintptr

// Creates a #GSubprocess given a provided varargs list of arguments.
func (x *SubprocessLauncher) Spawn(ErrorVar **glib.Error, Argv0Var string, varArgs ...interface{}) *Subprocess {
	var cls *Subprocess

	cret := xSubprocessLauncherSpawn(x.GoPointer(), ErrorVar, Argv0Var, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &Subprocess{}
	cls.Ptr = cret
	return cls
}

var xSubprocessLauncherSpawnv func(uintptr, uintptr, **glib.Error) uintptr

// Creates a #GSubprocess given a provided array of arguments.
func (x *SubprocessLauncher) Spawnv(ArgvVar uintptr) (*Subprocess, error) {
	var cls *Subprocess
	var cerr *glib.Error

	cret := xSubprocessLauncherSpawnv(x.GoPointer(), ArgvVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Subprocess{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xSubprocessLauncherTakeFd func(uintptr, int, int)

// Transfer an arbitrary file descriptor from parent process to the
// child.  This function takes ownership of the @source_fd; it will be closed
// in the parent when @self is freed.
//
// By default, all file descriptors from the parent will be closed.
// This function allows you to create (for example) a custom `pipe()` or
// `socketpair()` before launching the process, and choose the target
// descriptor in the child.
//
// An example use case is GNUPG, which has a command line argument
// `--passphrase-fd` providing a file descriptor number where it expects
// the passphrase to be written.
func (x *SubprocessLauncher) TakeFd(SourceFdVar int, TargetFdVar int) {

	xSubprocessLauncherTakeFd(x.GoPointer(), SourceFdVar, TargetFdVar)

}

var xSubprocessLauncherTakeStderrFd func(uintptr, int)

// Sets the file descriptor to use as the stderr for spawned processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that the default behaviour is to pass stderr through to the
// stderr of the parent process.
//
// The passed @fd belongs to the #GSubprocessLauncher.  It will be
// automatically closed when the launcher is finalized.  The file
// descriptor will also be closed on the child side when executing the
// spawned process.
//
// You may not set a stderr fd if a stderr file path is already set or
// if the launcher flags contain any flags directing stderr elsewhere.
//
// This feature is only available on UNIX.
func (x *SubprocessLauncher) TakeStderrFd(FdVar int) {

	xSubprocessLauncherTakeStderrFd(x.GoPointer(), FdVar)

}

var xSubprocessLauncherTakeStdinFd func(uintptr, int)

// Sets the file descriptor to use as the stdin for spawned processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that if your intention is to have the stdin of the calling
// process inherited by the child then %G_SUBPROCESS_FLAGS_STDIN_INHERIT
// is a better way to go about doing that.
//
// The passed @fd is noted but will not be touched in the current
// process.  It is therefore necessary that it be kept open by the
// caller until the subprocess is spawned.  The file descriptor will
// also not be explicitly closed on the child side, so it must be marked
// O_CLOEXEC if that's what you want.
//
// You may not set a stdin fd if a stdin file path is already set or if
// the launcher flags contain any flags directing stdin elsewhere.
//
// This feature is only available on UNIX.
func (x *SubprocessLauncher) TakeStdinFd(FdVar int) {

	xSubprocessLauncherTakeStdinFd(x.GoPointer(), FdVar)

}

var xSubprocessLauncherTakeStdoutFd func(uintptr, int)

// Sets the file descriptor to use as the stdout for spawned processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that the default behaviour is to pass stdout through to the
// stdout of the parent process.
//
// The passed @fd is noted but will not be touched in the current
// process.  It is therefore necessary that it be kept open by the
// caller until the subprocess is spawned.  The file descriptor will
// also not be explicitly closed on the child side, so it must be marked
// O_CLOEXEC if that's what you want.
//
// You may not set a stdout fd if a stdout file path is already set or
// if the launcher flags contain any flags directing stdout elsewhere.
//
// This feature is only available on UNIX.
func (x *SubprocessLauncher) TakeStdoutFd(FdVar int) {

	xSubprocessLauncherTakeStdoutFd(x.GoPointer(), FdVar)

}

var xSubprocessLauncherUnsetenv func(uintptr, string)

// Removes the environment variable @variable from the environment of
// processes launched from this launcher.
//
// On UNIX, the variable's name can be an arbitrary byte string not
// containing '='. On Windows, it should be in UTF-8.
func (x *SubprocessLauncher) Unsetenv(VariableVar string) {

	xSubprocessLauncherUnsetenv(x.GoPointer(), VariableVar)

}

func (c *SubprocessLauncher) GoPointer() uintptr {
	return c.Ptr
}

func (c *SubprocessLauncher) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A helper class for testing code which uses D-Bus without touching the user's
// session bus.
//
// Note that #GTestDBus modifies the user’s environment, calling setenv().
// This is not thread-safe, so all #GTestDBus calls should be completed before
// threads are spawned, or should have appropriate locking to ensure no access
// conflicts to environment variables shared between #GTestDBus and other
// threads.
//
// ## Creating unit tests using GTestDBus
//
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we
// usually don't activate D-Bus services that are not yet installed into the
// target system. The #GTestDBus object makes this easier for us by taking care
// of the lower level tasks such as running a private D-Bus daemon and looking
// up uninstalled services in customizable locations, typically in your source
// code tree.
//
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
// is a good place to put this file.
//
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as `my-server.service.in` in the services
// directory and have it processed by configure.
// |[
//
//	[D-BUS Service]
//	Name=org.gtk.GDBus.Examples.ObjectManager
//	Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
//
// ]|
// You will also need to indicate this service directory in your test
// fixtures, so you will need to pass the path while compiling your
// test cases. Typically this is done with autotools with an added
// preprocessor flag specified to compile your tests such as:
// |[
//
//	-DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
//
// ]|
//
//	Once you have a service definition file which is local to your source tree,
//
// you can proceed to set up a GTest fixture using the #GTestDBus scaffolding.
//
// An example of a test fixture for D-Bus services can be found
// here:
// [gdbus-test-fixture.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-test-fixture.c)
//
// Note that these examples only deal with isolating the D-Bus aspect of your
// service. To successfully run isolated unit tests on your service you may need
// some additional modifications to your test case fixture. For example; if your
// service uses GSettings and installs a schema then it is important that your test service
// not load the schema in the ordinary installed location (chances are that your service
// and schema files are not yet installed, or worse; there is an older version of the
// schema file sitting in the install location).
//
// Most of the time we can work around these obstacles using the
// environment. Since the environment is inherited by the D-Bus daemon
// created by #GTestDBus and then in turn inherited by any services the
// D-Bus daemon activates, using the setup routine for your fixture is
// a practical place to help sandbox your runtime environment. For the
// rather typical GSettings case we can work around this by setting
// `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your schemas
// in the above fixture_setup() routine.
//
// The GSettings schemas need to be locally pre-compiled for this to work. This can be achieved
// by compiling the schemas locally as a step before running test cases, an autotools setup might
// do the following in the directory holding schemas:
// |[
//
//	all-am:
//	        $(GLIB_COMPILE_SCHEMAS) .
//
//	CLEANFILES += gschemas.compiled
//
// ]|
type TestDBus struct {
	gobject.Object
}

func TestDBusNewFromInternalPtr(ptr uintptr) *TestDBus {
	cls := &TestDBus{}
	cls.Ptr = ptr
	return cls
}

var xNewTestDBus func(TestDBusFlags) uintptr

// Create a new #GTestDBus object.
func NewTestDBus(FlagsVar TestDBusFlags) *TestDBus {
	var cls *TestDBus

	cret := xNewTestDBus(FlagsVar)

	if cret == 0 {
		return nil
	}
	cls = &TestDBus{}
	cls.Ptr = cret
	return cls
}

var xTestDBusAddServiceDir func(uintptr, string)

// Add a path where dbus-daemon will look up .service files. This can't be
// called after g_test_dbus_up().
func (x *TestDBus) AddServiceDir(PathVar string) {

	xTestDBusAddServiceDir(x.GoPointer(), PathVar)

}

var xTestDBusDown func(uintptr)

// Stop the session bus started by g_test_dbus_up().
//
// This will wait for the singleton returned by g_bus_get() or g_bus_get_sync()
// to be destroyed. This is done to ensure that the next unit test won't get a
// leaked singleton from this test.
func (x *TestDBus) Down() {

	xTestDBusDown(x.GoPointer())

}

var xTestDBusGetBusAddress func(uintptr) string

// Get the address on which dbus-daemon is running. If g_test_dbus_up() has not
// been called yet, %NULL is returned. This can be used with
// g_dbus_connection_new_for_address().
func (x *TestDBus) GetBusAddress() string {

	cret := xTestDBusGetBusAddress(x.GoPointer())
	return cret
}

var xTestDBusGetFlags func(uintptr) TestDBusFlags

// Get the flags of the #GTestDBus object.
func (x *TestDBus) GetFlags() TestDBusFlags {

	cret := xTestDBusGetFlags(x.GoPointer())
	return cret
}

var xTestDBusStop func(uintptr)

// Stop the session bus started by g_test_dbus_up().
//
// Unlike g_test_dbus_down(), this won't verify the #GDBusConnection
// singleton returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit
// tests wanting to verify behaviour after the session bus has been stopped
// can use this function but should still call g_test_dbus_down() when done.
func (x *TestDBus) Stop() {

	xTestDBusStop(x.GoPointer())

}

var xTestDBusUp func(uintptr)

// Start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After this
// call, it is safe for unit tests to start sending messages on the session bus.
//
// If this function is called from setup callback of g_test_add(),
// g_test_dbus_down() must be called in its teardown callback.
//
// If this function is called from unit test's main(), then g_test_dbus_down()
// must be called after g_test_run().
func (x *TestDBus) Up() {

	xTestDBusUp(x.GoPointer())

}

func (c *TestDBus) GoPointer() uintptr {
	return c.Ptr
}

func (c *TestDBus) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

var xTestDBusUnset func()

// Unset DISPLAY and DBUS_SESSION_BUS_ADDRESS env variables to ensure the test
// won't use user's session bus.
//
// This is useful for unit tests that want to verify behaviour when no session
// bus is running. It is not necessary to call this if unit test already calls
// g_test_dbus_up() before acquiring the session bus.
func TestDBusUnset() {

	xTestDBusUnset()

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xIoErrorQuark, lib, "g_io_error_quark")
	core.PuregoSafeRegister(&xResolverErrorQuark, lib, "g_resolver_error_quark")
	core.PuregoSafeRegister(&xResourceErrorQuark, lib, "g_resource_error_quark")
	core.PuregoSafeRegister(&xTlsChannelBindingErrorQuark, lib, "g_tls_channel_binding_error_quark")
	core.PuregoSafeRegister(&xTlsErrorQuark, lib, "g_tls_error_quark")

	core.PuregoSafeRegister(&xAppInfoMonitorGet, lib, "g_app_info_monitor_get")

	core.PuregoSafeRegister(&xNewBytesIcon, lib, "g_bytes_icon_new")

	core.PuregoSafeRegister(&xBytesIconGetBytes, lib, "g_bytes_icon_get_bytes")

	core.PuregoSafeRegister(&xDBusActionGroupGet, lib, "g_dbus_action_group_get")

	core.PuregoSafeRegister(&xNewDBusAuthObserver, lib, "g_dbus_auth_observer_new")

	core.PuregoSafeRegister(&xDBusAuthObserverAllowMechanism, lib, "g_dbus_auth_observer_allow_mechanism")
	core.PuregoSafeRegister(&xDBusAuthObserverAuthorizeAuthenticatedPeer, lib, "g_dbus_auth_observer_authorize_authenticated_peer")

	core.PuregoSafeRegister(&xNewDBusConnectionFinish, lib, "g_dbus_connection_new_finish")
	core.PuregoSafeRegister(&xNewDBusConnectionForAddressFinish, lib, "g_dbus_connection_new_for_address_finish")
	core.PuregoSafeRegister(&xNewDBusConnectionForAddressSync, lib, "g_dbus_connection_new_for_address_sync")
	core.PuregoSafeRegister(&xNewDBusConnectionSync, lib, "g_dbus_connection_new_sync")

	core.PuregoSafeRegister(&xDBusConnectionAddFilter, lib, "g_dbus_connection_add_filter")
	core.PuregoSafeRegister(&xDBusConnectionCall, lib, "g_dbus_connection_call")
	core.PuregoSafeRegister(&xDBusConnectionCallFinish, lib, "g_dbus_connection_call_finish")
	core.PuregoSafeRegister(&xDBusConnectionCallSync, lib, "g_dbus_connection_call_sync")
	core.PuregoSafeRegister(&xDBusConnectionCallWithUnixFdList, lib, "g_dbus_connection_call_with_unix_fd_list")
	core.PuregoSafeRegister(&xDBusConnectionCallWithUnixFdListFinish, lib, "g_dbus_connection_call_with_unix_fd_list_finish")
	core.PuregoSafeRegister(&xDBusConnectionCallWithUnixFdListSync, lib, "g_dbus_connection_call_with_unix_fd_list_sync")
	core.PuregoSafeRegister(&xDBusConnectionClose, lib, "g_dbus_connection_close")
	core.PuregoSafeRegister(&xDBusConnectionCloseFinish, lib, "g_dbus_connection_close_finish")
	core.PuregoSafeRegister(&xDBusConnectionCloseSync, lib, "g_dbus_connection_close_sync")
	core.PuregoSafeRegister(&xDBusConnectionEmitSignal, lib, "g_dbus_connection_emit_signal")
	core.PuregoSafeRegister(&xDBusConnectionExportActionGroup, lib, "g_dbus_connection_export_action_group")
	core.PuregoSafeRegister(&xDBusConnectionExportMenuModel, lib, "g_dbus_connection_export_menu_model")
	core.PuregoSafeRegister(&xDBusConnectionFlush, lib, "g_dbus_connection_flush")
	core.PuregoSafeRegister(&xDBusConnectionFlushFinish, lib, "g_dbus_connection_flush_finish")
	core.PuregoSafeRegister(&xDBusConnectionFlushSync, lib, "g_dbus_connection_flush_sync")
	core.PuregoSafeRegister(&xDBusConnectionGetCapabilities, lib, "g_dbus_connection_get_capabilities")
	core.PuregoSafeRegister(&xDBusConnectionGetExitOnClose, lib, "g_dbus_connection_get_exit_on_close")
	core.PuregoSafeRegister(&xDBusConnectionGetFlags, lib, "g_dbus_connection_get_flags")
	core.PuregoSafeRegister(&xDBusConnectionGetGuid, lib, "g_dbus_connection_get_guid")
	core.PuregoSafeRegister(&xDBusConnectionGetLastSerial, lib, "g_dbus_connection_get_last_serial")
	core.PuregoSafeRegister(&xDBusConnectionGetPeerCredentials, lib, "g_dbus_connection_get_peer_credentials")
	core.PuregoSafeRegister(&xDBusConnectionGetStream, lib, "g_dbus_connection_get_stream")
	core.PuregoSafeRegister(&xDBusConnectionGetUniqueName, lib, "g_dbus_connection_get_unique_name")
	core.PuregoSafeRegister(&xDBusConnectionIsClosed, lib, "g_dbus_connection_is_closed")
	core.PuregoSafeRegister(&xDBusConnectionRegisterObject, lib, "g_dbus_connection_register_object")
	core.PuregoSafeRegister(&xDBusConnectionRegisterObjectWithClosures, lib, "g_dbus_connection_register_object_with_closures")
	core.PuregoSafeRegister(&xDBusConnectionRegisterSubtree, lib, "g_dbus_connection_register_subtree")
	core.PuregoSafeRegister(&xDBusConnectionRemoveFilter, lib, "g_dbus_connection_remove_filter")
	core.PuregoSafeRegister(&xDBusConnectionSendMessage, lib, "g_dbus_connection_send_message")
	core.PuregoSafeRegister(&xDBusConnectionSendMessageWithReply, lib, "g_dbus_connection_send_message_with_reply")
	core.PuregoSafeRegister(&xDBusConnectionSendMessageWithReplyFinish, lib, "g_dbus_connection_send_message_with_reply_finish")
	core.PuregoSafeRegister(&xDBusConnectionSendMessageWithReplySync, lib, "g_dbus_connection_send_message_with_reply_sync")
	core.PuregoSafeRegister(&xDBusConnectionSetExitOnClose, lib, "g_dbus_connection_set_exit_on_close")
	core.PuregoSafeRegister(&xDBusConnectionSignalSubscribe, lib, "g_dbus_connection_signal_subscribe")
	core.PuregoSafeRegister(&xDBusConnectionSignalUnsubscribe, lib, "g_dbus_connection_signal_unsubscribe")
	core.PuregoSafeRegister(&xDBusConnectionStartMessageProcessing, lib, "g_dbus_connection_start_message_processing")
	core.PuregoSafeRegister(&xDBusConnectionUnexportActionGroup, lib, "g_dbus_connection_unexport_action_group")
	core.PuregoSafeRegister(&xDBusConnectionUnexportMenuModel, lib, "g_dbus_connection_unexport_menu_model")
	core.PuregoSafeRegister(&xDBusConnectionUnregisterObject, lib, "g_dbus_connection_unregister_object")
	core.PuregoSafeRegister(&xDBusConnectionUnregisterSubtree, lib, "g_dbus_connection_unregister_subtree")

	core.PuregoSafeRegister(&xDBusConnectionNew, lib, "g_dbus_connection_new")
	core.PuregoSafeRegister(&xDBusConnectionNewForAddress, lib, "g_dbus_connection_new_for_address")

	core.PuregoSafeRegister(&xDBusMenuModelGet, lib, "g_dbus_menu_model_get")

	core.PuregoSafeRegister(&xNewDBusMessage, lib, "g_dbus_message_new")
	core.PuregoSafeRegister(&xNewDBusMessageFromBlob, lib, "g_dbus_message_new_from_blob")
	core.PuregoSafeRegister(&xNewDBusMessageMethodCall, lib, "g_dbus_message_new_method_call")
	core.PuregoSafeRegister(&xNewDBusMessageSignal, lib, "g_dbus_message_new_signal")

	core.PuregoSafeRegister(&xDBusMessageCopy, lib, "g_dbus_message_copy")
	core.PuregoSafeRegister(&xDBusMessageGetArg0, lib, "g_dbus_message_get_arg0")
	core.PuregoSafeRegister(&xDBusMessageGetBody, lib, "g_dbus_message_get_body")
	core.PuregoSafeRegister(&xDBusMessageGetByteOrder, lib, "g_dbus_message_get_byte_order")
	core.PuregoSafeRegister(&xDBusMessageGetDestination, lib, "g_dbus_message_get_destination")
	core.PuregoSafeRegister(&xDBusMessageGetErrorName, lib, "g_dbus_message_get_error_name")
	core.PuregoSafeRegister(&xDBusMessageGetFlags, lib, "g_dbus_message_get_flags")
	core.PuregoSafeRegister(&xDBusMessageGetHeader, lib, "g_dbus_message_get_header")
	core.PuregoSafeRegister(&xDBusMessageGetHeaderFields, lib, "g_dbus_message_get_header_fields")
	core.PuregoSafeRegister(&xDBusMessageGetInterface, lib, "g_dbus_message_get_interface")
	core.PuregoSafeRegister(&xDBusMessageGetLocked, lib, "g_dbus_message_get_locked")
	core.PuregoSafeRegister(&xDBusMessageGetMember, lib, "g_dbus_message_get_member")
	core.PuregoSafeRegister(&xDBusMessageGetMessageType, lib, "g_dbus_message_get_message_type")
	core.PuregoSafeRegister(&xDBusMessageGetNumUnixFds, lib, "g_dbus_message_get_num_unix_fds")
	core.PuregoSafeRegister(&xDBusMessageGetPath, lib, "g_dbus_message_get_path")
	core.PuregoSafeRegister(&xDBusMessageGetReplySerial, lib, "g_dbus_message_get_reply_serial")
	core.PuregoSafeRegister(&xDBusMessageGetSender, lib, "g_dbus_message_get_sender")
	core.PuregoSafeRegister(&xDBusMessageGetSerial, lib, "g_dbus_message_get_serial")
	core.PuregoSafeRegister(&xDBusMessageGetSignature, lib, "g_dbus_message_get_signature")
	core.PuregoSafeRegister(&xDBusMessageGetUnixFdList, lib, "g_dbus_message_get_unix_fd_list")
	core.PuregoSafeRegister(&xDBusMessageLock, lib, "g_dbus_message_lock")
	core.PuregoSafeRegister(&xDBusMessageNewMethodError, lib, "g_dbus_message_new_method_error")
	core.PuregoSafeRegister(&xDBusMessageNewMethodErrorLiteral, lib, "g_dbus_message_new_method_error_literal")
	core.PuregoSafeRegister(&xDBusMessageNewMethodErrorValist, lib, "g_dbus_message_new_method_error_valist")
	core.PuregoSafeRegister(&xDBusMessageNewMethodReply, lib, "g_dbus_message_new_method_reply")
	core.PuregoSafeRegister(&xDBusMessagePrint, lib, "g_dbus_message_print")
	core.PuregoSafeRegister(&xDBusMessageSetBody, lib, "g_dbus_message_set_body")
	core.PuregoSafeRegister(&xDBusMessageSetByteOrder, lib, "g_dbus_message_set_byte_order")
	core.PuregoSafeRegister(&xDBusMessageSetDestination, lib, "g_dbus_message_set_destination")
	core.PuregoSafeRegister(&xDBusMessageSetErrorName, lib, "g_dbus_message_set_error_name")
	core.PuregoSafeRegister(&xDBusMessageSetFlags, lib, "g_dbus_message_set_flags")
	core.PuregoSafeRegister(&xDBusMessageSetHeader, lib, "g_dbus_message_set_header")
	core.PuregoSafeRegister(&xDBusMessageSetInterface, lib, "g_dbus_message_set_interface")
	core.PuregoSafeRegister(&xDBusMessageSetMember, lib, "g_dbus_message_set_member")
	core.PuregoSafeRegister(&xDBusMessageSetMessageType, lib, "g_dbus_message_set_message_type")
	core.PuregoSafeRegister(&xDBusMessageSetNumUnixFds, lib, "g_dbus_message_set_num_unix_fds")
	core.PuregoSafeRegister(&xDBusMessageSetPath, lib, "g_dbus_message_set_path")
	core.PuregoSafeRegister(&xDBusMessageSetReplySerial, lib, "g_dbus_message_set_reply_serial")
	core.PuregoSafeRegister(&xDBusMessageSetSender, lib, "g_dbus_message_set_sender")
	core.PuregoSafeRegister(&xDBusMessageSetSerial, lib, "g_dbus_message_set_serial")
	core.PuregoSafeRegister(&xDBusMessageSetSignature, lib, "g_dbus_message_set_signature")
	core.PuregoSafeRegister(&xDBusMessageSetUnixFdList, lib, "g_dbus_message_set_unix_fd_list")
	core.PuregoSafeRegister(&xDBusMessageToBlob, lib, "g_dbus_message_to_blob")
	core.PuregoSafeRegister(&xDBusMessageToGerror, lib, "g_dbus_message_to_gerror")

	core.PuregoSafeRegister(&xDBusMessageBytesNeeded, lib, "g_dbus_message_bytes_needed")

	core.PuregoSafeRegister(&xDBusMethodInvocationGetConnection, lib, "g_dbus_method_invocation_get_connection")
	core.PuregoSafeRegister(&xDBusMethodInvocationGetInterfaceName, lib, "g_dbus_method_invocation_get_interface_name")
	core.PuregoSafeRegister(&xDBusMethodInvocationGetMessage, lib, "g_dbus_method_invocation_get_message")
	core.PuregoSafeRegister(&xDBusMethodInvocationGetMethodInfo, lib, "g_dbus_method_invocation_get_method_info")
	core.PuregoSafeRegister(&xDBusMethodInvocationGetMethodName, lib, "g_dbus_method_invocation_get_method_name")
	core.PuregoSafeRegister(&xDBusMethodInvocationGetObjectPath, lib, "g_dbus_method_invocation_get_object_path")
	core.PuregoSafeRegister(&xDBusMethodInvocationGetParameters, lib, "g_dbus_method_invocation_get_parameters")
	core.PuregoSafeRegister(&xDBusMethodInvocationGetPropertyInfo, lib, "g_dbus_method_invocation_get_property_info")
	core.PuregoSafeRegister(&xDBusMethodInvocationGetSender, lib, "g_dbus_method_invocation_get_sender")
	core.PuregoSafeRegister(&xDBusMethodInvocationGetUserData, lib, "g_dbus_method_invocation_get_user_data")
	core.PuregoSafeRegister(&xDBusMethodInvocationReturnDbusError, lib, "g_dbus_method_invocation_return_dbus_error")
	core.PuregoSafeRegister(&xDBusMethodInvocationReturnError, lib, "g_dbus_method_invocation_return_error")
	core.PuregoSafeRegister(&xDBusMethodInvocationReturnErrorLiteral, lib, "g_dbus_method_invocation_return_error_literal")
	core.PuregoSafeRegister(&xDBusMethodInvocationReturnErrorValist, lib, "g_dbus_method_invocation_return_error_valist")
	core.PuregoSafeRegister(&xDBusMethodInvocationReturnGerror, lib, "g_dbus_method_invocation_return_gerror")
	core.PuregoSafeRegister(&xDBusMethodInvocationReturnValue, lib, "g_dbus_method_invocation_return_value")
	core.PuregoSafeRegister(&xDBusMethodInvocationReturnValueWithUnixFdList, lib, "g_dbus_method_invocation_return_value_with_unix_fd_list")
	core.PuregoSafeRegister(&xDBusMethodInvocationTakeError, lib, "g_dbus_method_invocation_take_error")

	core.PuregoSafeRegister(&xNewDBusServerSync, lib, "g_dbus_server_new_sync")

	core.PuregoSafeRegister(&xDBusServerGetClientAddress, lib, "g_dbus_server_get_client_address")
	core.PuregoSafeRegister(&xDBusServerGetFlags, lib, "g_dbus_server_get_flags")
	core.PuregoSafeRegister(&xDBusServerGetGuid, lib, "g_dbus_server_get_guid")
	core.PuregoSafeRegister(&xDBusServerIsActive, lib, "g_dbus_server_is_active")
	core.PuregoSafeRegister(&xDBusServerStart, lib, "g_dbus_server_start")
	core.PuregoSafeRegister(&xDBusServerStop, lib, "g_dbus_server_stop")

	core.PuregoSafeRegister(&xNewMenu, lib, "g_menu_new")

	core.PuregoSafeRegister(&xMenuAppend, lib, "g_menu_append")
	core.PuregoSafeRegister(&xMenuAppendItem, lib, "g_menu_append_item")
	core.PuregoSafeRegister(&xMenuAppendSection, lib, "g_menu_append_section")
	core.PuregoSafeRegister(&xMenuAppendSubmenu, lib, "g_menu_append_submenu")
	core.PuregoSafeRegister(&xMenuFreeze, lib, "g_menu_freeze")
	core.PuregoSafeRegister(&xMenuInsert, lib, "g_menu_insert")
	core.PuregoSafeRegister(&xMenuInsertItem, lib, "g_menu_insert_item")
	core.PuregoSafeRegister(&xMenuInsertSection, lib, "g_menu_insert_section")
	core.PuregoSafeRegister(&xMenuInsertSubmenu, lib, "g_menu_insert_submenu")
	core.PuregoSafeRegister(&xMenuPrepend, lib, "g_menu_prepend")
	core.PuregoSafeRegister(&xMenuPrependItem, lib, "g_menu_prepend_item")
	core.PuregoSafeRegister(&xMenuPrependSection, lib, "g_menu_prepend_section")
	core.PuregoSafeRegister(&xMenuPrependSubmenu, lib, "g_menu_prepend_submenu")
	core.PuregoSafeRegister(&xMenuRemove, lib, "g_menu_remove")
	core.PuregoSafeRegister(&xMenuRemoveAll, lib, "g_menu_remove_all")

	core.PuregoSafeRegister(&xNewMenuItem, lib, "g_menu_item_new")
	core.PuregoSafeRegister(&xNewMenuItemFromModel, lib, "g_menu_item_new_from_model")
	core.PuregoSafeRegister(&xNewMenuItemSection, lib, "g_menu_item_new_section")
	core.PuregoSafeRegister(&xNewMenuItemSubmenu, lib, "g_menu_item_new_submenu")

	core.PuregoSafeRegister(&xMenuItemGetAttribute, lib, "g_menu_item_get_attribute")
	core.PuregoSafeRegister(&xMenuItemGetAttributeValue, lib, "g_menu_item_get_attribute_value")
	core.PuregoSafeRegister(&xMenuItemGetLink, lib, "g_menu_item_get_link")
	core.PuregoSafeRegister(&xMenuItemSetActionAndTarget, lib, "g_menu_item_set_action_and_target")
	core.PuregoSafeRegister(&xMenuItemSetActionAndTargetValue, lib, "g_menu_item_set_action_and_target_value")
	core.PuregoSafeRegister(&xMenuItemSetAttribute, lib, "g_menu_item_set_attribute")
	core.PuregoSafeRegister(&xMenuItemSetAttributeValue, lib, "g_menu_item_set_attribute_value")
	core.PuregoSafeRegister(&xMenuItemSetDetailedAction, lib, "g_menu_item_set_detailed_action")
	core.PuregoSafeRegister(&xMenuItemSetIcon, lib, "g_menu_item_set_icon")
	core.PuregoSafeRegister(&xMenuItemSetLabel, lib, "g_menu_item_set_label")
	core.PuregoSafeRegister(&xMenuItemSetLink, lib, "g_menu_item_set_link")
	core.PuregoSafeRegister(&xMenuItemSetSection, lib, "g_menu_item_set_section")
	core.PuregoSafeRegister(&xMenuItemSetSubmenu, lib, "g_menu_item_set_submenu")

	core.PuregoSafeRegister(&xNewNotification, lib, "g_notification_new")

	core.PuregoSafeRegister(&xNotificationAddButton, lib, "g_notification_add_button")
	core.PuregoSafeRegister(&xNotificationAddButtonWithTarget, lib, "g_notification_add_button_with_target")
	core.PuregoSafeRegister(&xNotificationAddButtonWithTargetValue, lib, "g_notification_add_button_with_target_value")
	core.PuregoSafeRegister(&xNotificationSetBody, lib, "g_notification_set_body")
	core.PuregoSafeRegister(&xNotificationSetCategory, lib, "g_notification_set_category")
	core.PuregoSafeRegister(&xNotificationSetDefaultAction, lib, "g_notification_set_default_action")
	core.PuregoSafeRegister(&xNotificationSetDefaultActionAndTarget, lib, "g_notification_set_default_action_and_target")
	core.PuregoSafeRegister(&xNotificationSetDefaultActionAndTargetValue, lib, "g_notification_set_default_action_and_target_value")
	core.PuregoSafeRegister(&xNotificationSetIcon, lib, "g_notification_set_icon")
	core.PuregoSafeRegister(&xNotificationSetPriority, lib, "g_notification_set_priority")
	core.PuregoSafeRegister(&xNotificationSetTitle, lib, "g_notification_set_title")
	core.PuregoSafeRegister(&xNotificationSetUrgent, lib, "g_notification_set_urgent")

	core.PuregoSafeRegister(&xNewPropertyAction, lib, "g_property_action_new")

	core.PuregoSafeRegister(&xNewSimpleAction, lib, "g_simple_action_new")
	core.PuregoSafeRegister(&xNewSimpleActionStateful, lib, "g_simple_action_new_stateful")

	core.PuregoSafeRegister(&xSimpleActionSetEnabled, lib, "g_simple_action_set_enabled")
	core.PuregoSafeRegister(&xSimpleActionSetState, lib, "g_simple_action_set_state")
	core.PuregoSafeRegister(&xSimpleActionSetStateHint, lib, "g_simple_action_set_state_hint")

	core.PuregoSafeRegister(&xNewSimpleIOStream, lib, "g_simple_io_stream_new")

	core.PuregoSafeRegister(&xNewSimplePermission, lib, "g_simple_permission_new")

	core.PuregoSafeRegister(&xNewSubprocess, lib, "g_subprocess_new")
	core.PuregoSafeRegister(&xNewSubprocessv, lib, "g_subprocess_newv")

	core.PuregoSafeRegister(&xSubprocessCommunicate, lib, "g_subprocess_communicate")
	core.PuregoSafeRegister(&xSubprocessCommunicateAsync, lib, "g_subprocess_communicate_async")
	core.PuregoSafeRegister(&xSubprocessCommunicateFinish, lib, "g_subprocess_communicate_finish")
	core.PuregoSafeRegister(&xSubprocessCommunicateUtf8, lib, "g_subprocess_communicate_utf8")
	core.PuregoSafeRegister(&xSubprocessCommunicateUtf8Async, lib, "g_subprocess_communicate_utf8_async")
	core.PuregoSafeRegister(&xSubprocessCommunicateUtf8Finish, lib, "g_subprocess_communicate_utf8_finish")
	core.PuregoSafeRegister(&xSubprocessForceExit, lib, "g_subprocess_force_exit")
	core.PuregoSafeRegister(&xSubprocessGetExitStatus, lib, "g_subprocess_get_exit_status")
	core.PuregoSafeRegister(&xSubprocessGetIdentifier, lib, "g_subprocess_get_identifier")
	core.PuregoSafeRegister(&xSubprocessGetIfExited, lib, "g_subprocess_get_if_exited")
	core.PuregoSafeRegister(&xSubprocessGetIfSignaled, lib, "g_subprocess_get_if_signaled")
	core.PuregoSafeRegister(&xSubprocessGetStatus, lib, "g_subprocess_get_status")
	core.PuregoSafeRegister(&xSubprocessGetStderrPipe, lib, "g_subprocess_get_stderr_pipe")
	core.PuregoSafeRegister(&xSubprocessGetStdinPipe, lib, "g_subprocess_get_stdin_pipe")
	core.PuregoSafeRegister(&xSubprocessGetStdoutPipe, lib, "g_subprocess_get_stdout_pipe")
	core.PuregoSafeRegister(&xSubprocessGetSuccessful, lib, "g_subprocess_get_successful")
	core.PuregoSafeRegister(&xSubprocessGetTermSig, lib, "g_subprocess_get_term_sig")
	core.PuregoSafeRegister(&xSubprocessSendSignal, lib, "g_subprocess_send_signal")
	core.PuregoSafeRegister(&xSubprocessWait, lib, "g_subprocess_wait")
	core.PuregoSafeRegister(&xSubprocessWaitAsync, lib, "g_subprocess_wait_async")
	core.PuregoSafeRegister(&xSubprocessWaitCheck, lib, "g_subprocess_wait_check")
	core.PuregoSafeRegister(&xSubprocessWaitCheckAsync, lib, "g_subprocess_wait_check_async")
	core.PuregoSafeRegister(&xSubprocessWaitCheckFinish, lib, "g_subprocess_wait_check_finish")
	core.PuregoSafeRegister(&xSubprocessWaitFinish, lib, "g_subprocess_wait_finish")

	core.PuregoSafeRegister(&xNewSubprocessLauncher, lib, "g_subprocess_launcher_new")

	core.PuregoSafeRegister(&xSubprocessLauncherClose, lib, "g_subprocess_launcher_close")
	core.PuregoSafeRegister(&xSubprocessLauncherGetenv, lib, "g_subprocess_launcher_getenv")
	core.PuregoSafeRegister(&xSubprocessLauncherSetChildSetup, lib, "g_subprocess_launcher_set_child_setup")
	core.PuregoSafeRegister(&xSubprocessLauncherSetCwd, lib, "g_subprocess_launcher_set_cwd")
	core.PuregoSafeRegister(&xSubprocessLauncherSetEnviron, lib, "g_subprocess_launcher_set_environ")
	core.PuregoSafeRegister(&xSubprocessLauncherSetFlags, lib, "g_subprocess_launcher_set_flags")
	core.PuregoSafeRegister(&xSubprocessLauncherSetStderrFilePath, lib, "g_subprocess_launcher_set_stderr_file_path")
	core.PuregoSafeRegister(&xSubprocessLauncherSetStdinFilePath, lib, "g_subprocess_launcher_set_stdin_file_path")
	core.PuregoSafeRegister(&xSubprocessLauncherSetStdoutFilePath, lib, "g_subprocess_launcher_set_stdout_file_path")
	core.PuregoSafeRegister(&xSubprocessLauncherSetenv, lib, "g_subprocess_launcher_setenv")
	core.PuregoSafeRegister(&xSubprocessLauncherSpawn, lib, "g_subprocess_launcher_spawn")
	core.PuregoSafeRegister(&xSubprocessLauncherSpawnv, lib, "g_subprocess_launcher_spawnv")
	core.PuregoSafeRegister(&xSubprocessLauncherTakeFd, lib, "g_subprocess_launcher_take_fd")
	core.PuregoSafeRegister(&xSubprocessLauncherTakeStderrFd, lib, "g_subprocess_launcher_take_stderr_fd")
	core.PuregoSafeRegister(&xSubprocessLauncherTakeStdinFd, lib, "g_subprocess_launcher_take_stdin_fd")
	core.PuregoSafeRegister(&xSubprocessLauncherTakeStdoutFd, lib, "g_subprocess_launcher_take_stdout_fd")
	core.PuregoSafeRegister(&xSubprocessLauncherUnsetenv, lib, "g_subprocess_launcher_unsetenv")

	core.PuregoSafeRegister(&xNewTestDBus, lib, "g_test_dbus_new")

	core.PuregoSafeRegister(&xTestDBusAddServiceDir, lib, "g_test_dbus_add_service_dir")
	core.PuregoSafeRegister(&xTestDBusDown, lib, "g_test_dbus_down")
	core.PuregoSafeRegister(&xTestDBusGetBusAddress, lib, "g_test_dbus_get_bus_address")
	core.PuregoSafeRegister(&xTestDBusGetFlags, lib, "g_test_dbus_get_flags")
	core.PuregoSafeRegister(&xTestDBusStop, lib, "g_test_dbus_stop")
	core.PuregoSafeRegister(&xTestDBusUp, lib, "g_test_dbus_up")

	core.PuregoSafeRegister(&xTestDBusUnset, lib, "g_test_dbus_unset")

}
