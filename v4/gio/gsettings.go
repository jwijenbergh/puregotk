// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// The type for the function that is used to convert from #GSettings to
// an object property. The @value is already initialized to hold values
// of the appropriate type.
type SettingsBindGetMapping func(*gobject.Value, *glib.Variant, uintptr) bool

// The type for the function that is used to convert an object property
// value to a #GVariant for storing it in #GSettings.
type SettingsBindSetMapping func(*gobject.Value, *glib.VariantType, uintptr) *glib.Variant

// The type of the function that is used to convert from a value stored
// in a #GSettings to a value that is useful to the application.
//
// If the value is successfully mapped, the result should be stored at
// @result and %TRUE returned.  If mapping fails (for example, if @value
// is not in the right format) then %FALSE should be returned.
//
// If @value is %NULL then it means that the mapping function is being
// given a "last chance" to successfully return a valid value.  %TRUE
// must be returned in this case.
type SettingsGetMapping func(*glib.Variant, uintptr, uintptr) bool

type SettingsClass struct {
	ParentClass uintptr

	Padding uintptr
}

func (x *SettingsClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type SettingsPrivate struct {
}

func (x *SettingsPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Flags used when creating a binding. These flags determine in which
// direction the binding works. The default is to synchronize in both
// directions.
type SettingsBindFlags int

const (

	// Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
	GSettingsBindDefaultValue SettingsBindFlags = 0
	// Update the #GObject property when the setting changes.
	//     It is an error to use this flag if the property is not writable.
	GSettingsBindGetValue SettingsBindFlags = 1
	// Update the setting when the #GObject property changes.
	//     It is an error to use this flag if the property is not readable.
	GSettingsBindSetValue SettingsBindFlags = 2
	// Do not try to bind a "sensitivity" property to the writability of the setting
	GSettingsBindNoSensitivityValue SettingsBindFlags = 4
	// When set in addition to %G_SETTINGS_BIND_GET, set the #GObject property
	//     value initially from the setting, but do not listen for changes of the setting
	GSettingsBindGetNoChangesValue SettingsBindFlags = 8
	// When passed to g_settings_bind(), uses a pair of mapping functions that invert
	//     the boolean value when mapping between the setting and the property.  The setting and property must both
	//     be booleans.  You cannot pass this flag to g_settings_bind_with_mapping().
	GSettingsBindInvertBooleanValue SettingsBindFlags = 16
)

// The #GSettings class provides a convenient API for storing and retrieving
// application settings.
//
// Reads and writes can be considered to be non-blocking.  Reading
// settings with #GSettings is typically extremely fast: on
// approximately the same order of magnitude (but slower than) a
// #GHashTable lookup.  Writing settings is also extremely fast in terms
// of time to return to your application, but can be extremely expensive
// for other threads and other processes.  Many settings backends
// (including dconf) have lazy initialisation which means in the common
// case of the user using their computer without modifying any settings
// a lot of work can be avoided.  For dconf, the D-Bus service doesn't
// even need to be started in this case.  For this reason, you should
// only ever modify #GSettings keys in response to explicit user action.
// Particular care should be paid to ensure that modifications are not
// made during startup -- for example, when setting the initial value
// of preferences widgets.  The built-in g_settings_bind() functionality
// is careful not to write settings in response to notify signals as a
// result of modifications that it makes to widgets.
//
// When creating a GSettings instance, you have to specify a schema
// that describes the keys in your settings and their types and default
// values, as well as some other information.
//
// Normally, a schema has a fixed path that determines where the settings
// are stored in the conceptual global tree of settings. However, schemas
// can also be '[relocatable][gsettings-relocatable]', i.e. not equipped with
// a fixed path. This is
// useful e.g. when the schema describes an 'account', and you want to be
// able to store a arbitrary number of accounts.
//
// Paths must start with and end with a forward slash character ('/')
// and must not contain two sequential slash characters.  Paths should
// be chosen based on a domain name associated with the program or
// library to which the settings belong.  Examples of paths are
// "/org/gtk/settings/file-chooser/" and "/ca/desrt/dconf-editor/".
// Paths should not start with "/apps/", "/desktop/" or "/system/" as
// they often did in GConf.
//
// Unlike other configuration systems (like GConf), GSettings does not
// restrict keys to basic types like strings and numbers. GSettings stores
// values as #GVariant, and allows any #GVariantType for keys. Key names
// are restricted to lowercase characters, numbers and '-'. Furthermore,
// the names must begin with a lowercase character, must not end
// with a '-', and must not contain consecutive dashes.
//
// Similar to GConf, the default values in GSettings schemas can be
// localized, but the localized values are stored in gettext catalogs
// and looked up with the domain that is specified in the
// `gettext-domain` attribute of the &lt;schemalist&gt; or &lt;schema&gt;
// elements and the category that is specified in the `l10n` attribute of
// the &lt;default&gt; element. The string which is translated includes all text in
// the &lt;default&gt; element, including any surrounding quotation marks.
//
// The `l10n` attribute must be set to `messages` or `time`, and sets the
// [locale category for
// translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
// The `messages` category should be used by default; use `time` for
// translatable date or time formats. A translation comment can be added as an
// XML comment immediately above the &lt;default&gt; element â€” it is recommended to
// add these comments to aid translators understand the meaning and
// implications of the default value. An optional translation `context`
// attribute can be set on the &lt;default&gt; element to disambiguate multiple
// defaults which use the same string.
//
// For example:
// |[
//
//	&lt;!-- Translators: A list of words which are not allowed to be typed, in
//	     GVariant serialization syntax.
//	     See: https://developer.gnome.org/glib/stable/gvariant-text.html --&gt;
//	&lt;default l10n='messages' context='Banned words'&gt;['bad', 'words']&lt;/default&gt;
//
// ]|
//
// Translations of default values must remain syntactically valid serialized
// #GVariants (e.g. retaining any surrounding quotation marks) or runtime
// errors will occur.
//
// GSettings uses schemas in a compact binary form that is created
// by the [glib-compile-schemas][glib-compile-schemas]
// utility. The input is a schema description in an XML format.
//
// A DTD for the gschema XML format can be found here:
// [gschema.dtd](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/gschema.dtd)
//
// The [glib-compile-schemas][glib-compile-schemas] tool expects schema
// files to have the extension `.gschema.xml`.
//
// At runtime, schemas are identified by their id (as specified in the
// id attribute of the &lt;schema&gt; element). The convention for schema
// ids is to use a dotted name, similar in style to a D-Bus bus name,
// e.g. "org.gnome.SessionManager". In particular, if the settings are
// for a specific service that owns a D-Bus bus name, the D-Bus bus name
// and schema id should match. For schemas which deal with settings not
// associated with one named application, the id should not use
// StudlyCaps, e.g. "org.gnome.font-rendering".
//
// In addition to #GVariant types, keys can have types that have
// enumerated types. These can be described by a &lt;choice&gt;,
// &lt;enum&gt; or &lt;flags&gt; element, as seen in the
// [example][schema-enumerated]. The underlying type of such a key
// is string, but you can use g_settings_get_enum(), g_settings_set_enum(),
// g_settings_get_flags(), g_settings_set_flags() access the numeric values
// corresponding to the string value of enum and flags keys.
//
// An example for default value:
// |[
// &lt;schemalist&gt;
//
//	&lt;schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test"&gt;
//
//	  &lt;key name="greeting" type="s"&gt;
//	    &lt;default l10n="messages"&gt;"Hello, earthlings"&lt;/default&gt;
//	    &lt;summary&gt;A greeting&lt;/summary&gt;
//	    &lt;description&gt;
//	      Greeting of the invading martians
//	    &lt;/description&gt;
//	  &lt;/key&gt;
//
//	  &lt;key name="box" type="(ii)"&gt;
//	    &lt;default&gt;(20,30)&lt;/default&gt;
//	  &lt;/key&gt;
//
//	  &lt;key name="empty-string" type="s"&gt;
//	    &lt;default&gt;""&lt;/default&gt;
//	    &lt;summary&gt;Empty strings have to be provided in GVariant form&lt;/summary&gt;
//	  &lt;/key&gt;
//
//	&lt;/schema&gt;
//
// &lt;/schemalist&gt;
// ]|
//
// An example for ranges, choices and enumerated types:
// |[
// &lt;schemalist&gt;
//
//	&lt;enum id="org.gtk.Test.myenum"&gt;
//	  &lt;value nick="first" value="1"/&gt;
//	  &lt;value nick="second" value="2"/&gt;
//	&lt;/enum&gt;
//
//	&lt;flags id="org.gtk.Test.myflags"&gt;
//	  &lt;value nick="flag1" value="1"/&gt;
//	  &lt;value nick="flag2" value="2"/&gt;
//	  &lt;value nick="flag3" value="4"/&gt;
//	&lt;/flags&gt;
//
//	&lt;schema id="org.gtk.Test"&gt;
//
//	  &lt;key name="key-with-range" type="i"&gt;
//	    &lt;range min="1" max="100"/&gt;
//	    &lt;default&gt;10&lt;/default&gt;
//	  &lt;/key&gt;
//
//	  &lt;key name="key-with-choices" type="s"&gt;
//	    &lt;choices&gt;
//	      &lt;choice value='Elisabeth'/&gt;
//	      &lt;choice value='Annabeth'/&gt;
//	      &lt;choice value='Joe'/&gt;
//	    &lt;/choices&gt;
//	    &lt;aliases&gt;
//	      &lt;alias value='Anna' target='Annabeth'/&gt;
//	      &lt;alias value='Beth' target='Elisabeth'/&gt;
//	    &lt;/aliases&gt;
//	    &lt;default&gt;'Joe'&lt;/default&gt;
//	  &lt;/key&gt;
//
//	  &lt;key name='enumerated-key' enum='org.gtk.Test.myenum'&gt;
//	    &lt;default&gt;'first'&lt;/default&gt;
//	  &lt;/key&gt;
//
//	  &lt;key name='flags-key' flags='org.gtk.Test.myflags'&gt;
//	    &lt;default&gt;["flag1","flag2"]&lt;/default&gt;
//	  &lt;/key&gt;
//	&lt;/schema&gt;
//
// &lt;/schemalist&gt;
// ]|
//
// ## Vendor overrides
//
// Default values are defined in the schemas that get installed by
// an application. Sometimes, it is necessary for a vendor or distributor
// to adjust these defaults. Since patching the XML source for the schema
// is inconvenient and error-prone,
// [glib-compile-schemas][glib-compile-schemas] reads so-called vendor
// override' files. These are keyfiles in the same directory as the XML
// schema sources which can override default values. The schema id serves
// as the group name in the key file, and the values are expected in
// serialized GVariant form, as in the following example:
// |[
//
//	[org.gtk.Example]
//	key1='string'
//	key2=1.5
//
// ]|
//
// glib-compile-schemas expects schema files to have the extension
// `.gschema.override`.
//
// ## Binding
//
// A very convenient feature of GSettings lets you bind #GObject properties
// directly to settings, using g_settings_bind(). Once a GObject property
// has been bound to a setting, changes on either side are automatically
// propagated to the other side. GSettings handles details like mapping
// between GObject and GVariant types, and preventing infinite cycles.
//
// This makes it very easy to hook up a preferences dialog to the
// underlying settings. To make this even more convenient, GSettings
// looks for a boolean property with the name "sensitivity" and
// automatically binds it to the writability of the bound setting.
// If this 'magic' gets in the way, it can be suppressed with the
// %G_SETTINGS_BIND_NO_SENSITIVITY flag.
//
// ## Relocatable schemas # {#gsettings-relocatable}
//
// A relocatable schema is one with no `path` attribute specified on its
// &lt;schema&gt; element. By using g_settings_new_with_path(), a #GSettings object
// can be instantiated for a relocatable schema, assigning a path to the
// instance. Paths passed to g_settings_new_with_path() will typically be
// constructed dynamically from a constant prefix plus some form of instance
// identifier; but they must still be valid GSettings paths. Paths could also
// be constant and used with a globally installed schema originating from a
// dependency library.
//
// For example, a relocatable schema could be used to store geometry information
// for different windows in an application. If the schema ID was
// `org.foo.MyApp.Window`, it could be instantiated for paths
// `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
// `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known
// they can be specified as &lt;child&gt; elements in the parent schema, e.g.:
// |[
// &lt;schema id="org.foo.MyApp" path="/org/foo/MyApp/"&gt;
//
//	&lt;child name="main" schema="org.foo.MyApp.Window"/&gt;
//
// &lt;/schema&gt;
// ]|
//
// ## Build system integration # {#gsettings-build-system}
//
// GSettings comes with autotools integration to simplify compiling and
// installing schemas. To add GSettings support to an application, add the
// following to your `configure.ac`:
// |[
// GLIB_GSETTINGS
// ]|
//
// In the appropriate `Makefile.am`, use the following snippet to compile and
// install the named schema:
// |[
// gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
// EXTRA_DIST = $(gsettings_SCHEMAS)
//
// @GSETTINGS_RULES@
// ]|
//
// No changes are needed to the build system to mark a schema XML file for
// translation. Assuming it sets the `gettext-domain` attribute, a schema may
// be marked for translation by adding it to `POTFILES.in`, assuming gettext
// 0.19 is in use (the preferred method for translation):
// |[
// data/org.foo.MyApp.gschema.xml
// ]|
//
// Alternatively, if intltool 0.50.1 is in use:
// |[
// [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
// ]|
//
// GSettings will use gettext to look up translations for the &lt;summary&gt; and
// &lt;description&gt; elements, and also any &lt;default&gt; elements which have a `l10n`
// attribute set. Translations must not be included in the `.gschema.xml` file
// by the build system, for example by using intltool XML rules with a
// `.gschema.xml.in` template.
//
// If an enumerated type defined in a C header file is to be used in a GSettings
// schema, it can either be defined manually using an &lt;enum&gt; element in the
// schema XML, or it can be extracted automatically from the C header. This
// approach is preferred, as it ensures the two representations are always
// synchronised. To do so, add the following to the relevant `Makefile.am`:
// |[
// gsettings_ENUM_NAMESPACE = org.foo.MyApp
// gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
// ]|
//
// `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
// which are specified in `gsettings_ENUM_FILES`. This will generate a
// `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
// automatically included in the schema compilation, install and uninstall
// rules. It should not be committed to version control or included in
// `EXTRA_DIST`.
type Settings struct {
	gobject.Object
}

func SettingsNewFromInternalPtr(ptr uintptr) *Settings {
	cls := &Settings{}
	cls.Ptr = ptr
	return cls
}

var xNewSettings func(string) uintptr

// Creates a new #GSettings object with the schema specified by
// @schema_id.
//
// It is an error for the schema to not exist: schemas are an
// essential part of a program, as they provide type information.
// If schemas need to be dynamically loaded (for example, from an
// optional runtime dependency), g_settings_schema_source_lookup()
// can be used to test for their existence before loading them.
//
// Signals on the newly created #GSettings object will be dispatched
// via the thread-default #GMainContext in effect at the time of the
// call to g_settings_new().  The new #GSettings will hold a reference
// on the context.  See g_main_context_push_thread_default().
func NewSettings(SchemaIdVar string) *Settings {
	var cls *Settings

	cret := xNewSettings(SchemaIdVar)

	if cret == 0 {
		return nil
	}
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xNewSettingsFull func(*SettingsSchema, uintptr, string) uintptr

// Creates a new #GSettings object with a given schema, backend and
// path.
//
// It should be extremely rare that you ever want to use this function.
// It is made available for advanced use-cases (such as plugin systems
// that want to provide access to schemas loaded from custom locations,
// etc).
//
// At the most basic level, a #GSettings object is a pure composition of
// 4 things: a #GSettingsSchema, a #GSettingsBackend, a path within that
// backend, and a #GMainContext to which signals are dispatched.
//
// This constructor therefore gives you full control over constructing
// #GSettings instances.  The first 3 parameters are given directly as
// @schema, @backend and @path, and the main context is taken from the
// thread-default (as per g_settings_new()).
//
// If @backend is %NULL then the default backend is used.
//
// If @path is %NULL then the path from the schema is used.  It is an
// error if @path is %NULL and the schema has no path of its own or if
// @path is non-%NULL and not equal to the path that the schema does
// have.
func NewSettingsFull(SchemaVar *SettingsSchema, BackendVar *SettingsBackend, PathVar string) *Settings {
	var cls *Settings

	cret := xNewSettingsFull(SchemaVar, BackendVar.GoPointer(), PathVar)

	if cret == 0 {
		return nil
	}
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xNewSettingsWithBackend func(string, uintptr) uintptr

// Creates a new #GSettings object with the schema specified by
// @schema_id and a given #GSettingsBackend.
//
// Creating a #GSettings object with a different backend allows accessing
// settings from a database other than the usual one. For example, it may make
// sense to pass a backend corresponding to the "defaults" settings database on
// the system to get a settings object that modifies the system default
// settings instead of the settings for this user.
func NewSettingsWithBackend(SchemaIdVar string, BackendVar *SettingsBackend) *Settings {
	var cls *Settings

	cret := xNewSettingsWithBackend(SchemaIdVar, BackendVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xNewSettingsWithBackendAndPath func(string, uintptr, string) uintptr

// Creates a new #GSettings object with the schema specified by
// @schema_id and a given #GSettingsBackend and path.
//
// This is a mix of g_settings_new_with_backend() and
// g_settings_new_with_path().
func NewSettingsWithBackendAndPath(SchemaIdVar string, BackendVar *SettingsBackend, PathVar string) *Settings {
	var cls *Settings

	cret := xNewSettingsWithBackendAndPath(SchemaIdVar, BackendVar.GoPointer(), PathVar)

	if cret == 0 {
		return nil
	}
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xNewSettingsWithPath func(string, string) uintptr

// Creates a new #GSettings object with the relocatable schema specified
// by @schema_id and a given path.
//
// You only need to do this if you want to directly create a settings
// object with a schema that doesn't have a specified path of its own.
// That's quite rare.
//
// It is a programmer error to call this function for a schema that
// has an explicitly specified path.
//
// It is a programmer error if @path is not a valid path.  A valid path
// begins and ends with '/' and does not contain two consecutive '/'
// characters.
func NewSettingsWithPath(SchemaIdVar string, PathVar string) *Settings {
	var cls *Settings

	cret := xNewSettingsWithPath(SchemaIdVar, PathVar)

	if cret == 0 {
		return nil
	}
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xSettingsApply func(uintptr)

// Applies any changes that have been made to the settings.  This
// function does nothing unless @settings is in 'delay-apply' mode;
// see g_settings_delay().  In the normal case settings are always
// applied immediately.
func (x *Settings) Apply() {

	xSettingsApply(x.GoPointer())

}

var xSettingsBind func(uintptr, string, uintptr, string, SettingsBindFlags)

// Create a binding between the @key in the @settings object
// and the property @property of @object.
//
// The binding uses the default GIO mapping functions to map
// between the settings and property values. These functions
// handle booleans, numeric types and string types in a
// straightforward way. Use g_settings_bind_with_mapping() if
// you need a custom mapping, or map between types that are not
// supported by the default mapping functions.
//
// Unless the @flags include %G_SETTINGS_BIND_NO_SENSITIVITY, this
// function also establishes a binding between the writability of
// @key and the "sensitive" property of @object (if @object has
// a boolean property by that name). See g_settings_bind_writable()
// for more details about writable bindings.
//
// Note that the lifecycle of the binding is tied to @object,
// and that you can have only one binding per object property.
// If you bind the same property twice on the same object, the second
// binding overrides the first one.
func (x *Settings) Bind(KeyVar string, ObjectVar *gobject.Object, PropertyVar string, FlagsVar SettingsBindFlags) {

	xSettingsBind(x.GoPointer(), KeyVar, ObjectVar.GoPointer(), PropertyVar, FlagsVar)

}

var xSettingsBindWithMapping func(uintptr, string, uintptr, string, SettingsBindFlags, uintptr, uintptr, uintptr, uintptr)

// Create a binding between the @key in the @settings object
// and the property @property of @object.
//
// The binding uses the provided mapping functions to map between
// settings and property values.
//
// Note that the lifecycle of the binding is tied to @object,
// and that you can have only one binding per object property.
// If you bind the same property twice on the same object, the second
// binding overrides the first one.
func (x *Settings) BindWithMapping(KeyVar string, ObjectVar *gobject.Object, PropertyVar string, FlagsVar SettingsBindFlags, GetMappingVar *SettingsBindGetMapping, SetMappingVar *SettingsBindSetMapping, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	xSettingsBindWithMapping(x.GoPointer(), KeyVar, ObjectVar.GoPointer(), PropertyVar, FlagsVar, glib.NewCallback(GetMappingVar), glib.NewCallback(SetMappingVar), UserDataVar, glib.NewCallback(DestroyVar))

}

var xSettingsBindWritable func(uintptr, string, uintptr, string, bool)

// Create a binding between the writability of @key in the
// @settings object and the property @property of @object.
// The property must be boolean; "sensitive" or "visible"
// properties of widgets are the most likely candidates.
//
// Writable bindings are always uni-directional; changes of the
// writability of the setting will be propagated to the object
// property, not the other way.
//
// When the @inverted argument is %TRUE, the binding inverts the
// value as it passes from the setting to the object, i.e. @property
// will be set to %TRUE if the key is not writable.
//
// Note that the lifecycle of the binding is tied to @object,
// and that you can have only one binding per object property.
// If you bind the same property twice on the same object, the second
// binding overrides the first one.
func (x *Settings) BindWritable(KeyVar string, ObjectVar *gobject.Object, PropertyVar string, InvertedVar bool) {

	xSettingsBindWritable(x.GoPointer(), KeyVar, ObjectVar.GoPointer(), PropertyVar, InvertedVar)

}

var xSettingsCreateAction func(uintptr, string) uintptr

// Creates a #GAction corresponding to a given #GSettings key.
//
// The action has the same name as the key.
//
// The value of the key becomes the state of the action and the action
// is enabled when the key is writable.  Changing the state of the
// action results in the key being written to.  Changes to the value or
// writability of the key cause appropriate change notifications to be
// emitted for the action.
//
// For boolean-valued keys, action activations take no parameter and
// result in the toggling of the value.  For all other types,
// activations take the new value for the key (which must have the
// correct type).
func (x *Settings) CreateAction(KeyVar string) *ActionBase {
	var cls *ActionBase

	cret := xSettingsCreateAction(x.GoPointer(), KeyVar)

	if cret == 0 {
		return nil
	}
	cls = &ActionBase{}
	cls.Ptr = cret
	return cls
}

var xSettingsDelay func(uintptr)

// Changes the #GSettings object into 'delay-apply' mode. In this
// mode, changes to @settings are not immediately propagated to the
// backend, but kept locally until g_settings_apply() is called.
func (x *Settings) Delay() {

	xSettingsDelay(x.GoPointer())

}

var xSettingsGet func(uintptr, string, string, ...interface{})

// Gets the value that is stored at @key in @settings.
//
// A convenience function that combines g_settings_get_value() with
// g_variant_get().
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or for the #GVariantType of @format to mismatch
// the type given in the schema.
func (x *Settings) Get(KeyVar string, FormatVar string, varArgs ...interface{}) {

	xSettingsGet(x.GoPointer(), KeyVar, FormatVar, varArgs...)

}

var xSettingsGetBoolean func(uintptr, string) bool

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for booleans.
//
// It is a programmer error to give a @key that isn't specified as
// having a boolean type in the schema for @settings.
func (x *Settings) GetBoolean(KeyVar string) bool {

	cret := xSettingsGetBoolean(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetChild func(uintptr, string) uintptr

// Creates a child settings object which has a base path of
// `base-path/@name`, where `base-path` is the base path of
// @settings.
//
// The schema for the child settings object must have been declared
// in the schema of @settings using a `&lt;child&gt;` element.
//
// The created child settings object will inherit the #GSettings:delay-apply
// mode from @settings.
func (x *Settings) GetChild(NameVar string) *Settings {
	var cls *Settings

	cret := xSettingsGetChild(x.GoPointer(), NameVar)

	if cret == 0 {
		return nil
	}
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xSettingsGetDefaultValue func(uintptr, string) *glib.Variant

// Gets the "default value" of a key.
//
// This is the value that would be read if g_settings_reset() were to be
// called on the key.
//
// Note that this may be a different value than returned by
// g_settings_schema_key_get_default_value() if the system administrator
// has provided a default value.
//
// Comparing the return values of g_settings_get_default_value() and
// g_settings_get_value() is not sufficient for determining if a value
// has been set because the user may have explicitly set the value to
// something that happens to be equal to the default.  The difference
// here is that if the default changes in the future, the user's key
// will still be set.
//
// This function may be useful for adding an indication to a UI of what
// the default value was before the user set it.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings.
func (x *Settings) GetDefaultValue(KeyVar string) *glib.Variant {

	cret := xSettingsGetDefaultValue(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetDouble func(uintptr, string) float64

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for doubles.
//
// It is a programmer error to give a @key that isn't specified as
// having a 'double' type in the schema for @settings.
func (x *Settings) GetDouble(KeyVar string) float64 {

	cret := xSettingsGetDouble(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetEnum func(uintptr, string) int

// Gets the value that is stored in @settings for @key and converts it
// to the enum value that it represents.
//
// In order to use this function the type of the value must be a string
// and it must be marked in the schema file as an enumerated type.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or is not marked as an enumerated type.
//
// If the value stored in the configuration database is not a valid
// value for the enumerated type then this function will return the
// default value.
func (x *Settings) GetEnum(KeyVar string) int {

	cret := xSettingsGetEnum(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetFlags func(uintptr, string) uint

// Gets the value that is stored in @settings for @key and converts it
// to the flags value that it represents.
//
// In order to use this function the type of the value must be an array
// of strings and it must be marked in the schema file as a flags type.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or is not marked as a flags type.
//
// If the value stored in the configuration database is not a valid
// value for the flags type then this function will return the default
// value.
func (x *Settings) GetFlags(KeyVar string) uint {

	cret := xSettingsGetFlags(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetHasUnapplied func(uintptr) bool

// Returns whether the #GSettings object has any unapplied
// changes.  This can only be the case if it is in 'delayed-apply' mode.
func (x *Settings) GetHasUnapplied() bool {

	cret := xSettingsGetHasUnapplied(x.GoPointer())
	return cret
}

var xSettingsGetInt func(uintptr, string) int

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for 32-bit integers.
//
// It is a programmer error to give a @key that isn't specified as
// having a int32 type in the schema for @settings.
func (x *Settings) GetInt(KeyVar string) int {

	cret := xSettingsGetInt(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetInt64 func(uintptr, string) int64

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for 64-bit integers.
//
// It is a programmer error to give a @key that isn't specified as
// having a int64 type in the schema for @settings.
func (x *Settings) GetInt64(KeyVar string) int64 {

	cret := xSettingsGetInt64(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetMapped func(uintptr, string, uintptr, uintptr) uintptr

// Gets the value that is stored at @key in @settings, subject to
// application-level validation/mapping.
//
// You should use this function when the application needs to perform
// some processing on the value of the key (for example, parsing).  The
// @mapping function performs that processing.  If the function
// indicates that the processing was unsuccessful (due to a parse error,
// for example) then the mapping is tried again with another value.
//
// This allows a robust 'fall back to defaults' behaviour to be
// implemented somewhat automatically.
//
// The first value that is tried is the user's setting for the key.  If
// the mapping function fails to map this value, other values may be
// tried in an unspecified order (system or site defaults, translated
// schema default values, untranslated schema default values, etc).
//
// If the mapping function fails for all possible values, one additional
// attempt is made: the mapping function is called with a %NULL value.
// If the mapping function still indicates failure at this point then
// the application will be aborted.
//
// The result parameter for the @mapping function is pointed to a
// #gpointer which is initially set to %NULL.  The same pointer is given
// to each invocation of @mapping.  The final value of that #gpointer is
// what is returned by this function.  %NULL is valid; it is returned
// just as any other value would be.
func (x *Settings) GetMapped(KeyVar string, MappingVar *SettingsGetMapping, UserDataVar uintptr) uintptr {

	cret := xSettingsGetMapped(x.GoPointer(), KeyVar, glib.NewCallback(MappingVar), UserDataVar)
	return cret
}

var xSettingsGetRange func(uintptr, string) *glib.Variant

// Queries the range of a key.
func (x *Settings) GetRange(KeyVar string) *glib.Variant {

	cret := xSettingsGetRange(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetString func(uintptr, string) string

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for strings.
//
// It is a programmer error to give a @key that isn't specified as
// having a string type in the schema for @settings.
func (x *Settings) GetString(KeyVar string) string {

	cret := xSettingsGetString(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetStrv func(uintptr, string) uintptr

// A convenience variant of g_settings_get() for string arrays.
//
// It is a programmer error to give a @key that isn't specified as
// having an array of strings type in the schema for @settings.
func (x *Settings) GetStrv(KeyVar string) uintptr {

	cret := xSettingsGetStrv(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetUint func(uintptr, string) uint

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for 32-bit unsigned
// integers.
//
// It is a programmer error to give a @key that isn't specified as
// having a uint32 type in the schema for @settings.
func (x *Settings) GetUint(KeyVar string) uint {

	cret := xSettingsGetUint(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetUint64 func(uintptr, string) uint64

// Gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for 64-bit unsigned
// integers.
//
// It is a programmer error to give a @key that isn't specified as
// having a uint64 type in the schema for @settings.
func (x *Settings) GetUint64(KeyVar string) uint64 {

	cret := xSettingsGetUint64(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetUserValue func(uintptr, string) *glib.Variant

// Checks the "user value" of a key, if there is one.
//
// The user value of a key is the last value that was set by the user.
//
// After calling g_settings_reset() this function should always return
// %NULL (assuming something is not wrong with the system
// configuration).
//
// It is possible that g_settings_get_value() will return a different
// value than this function.  This can happen in the case that the user
// set a value for a key that was subsequently locked down by the system
// administrator -- this function will return the user's old value.
//
// This function may be useful for adding a "reset" option to a UI or
// for providing indication that a particular value has been changed.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings.
func (x *Settings) GetUserValue(KeyVar string) *glib.Variant {

	cret := xSettingsGetUserValue(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsGetValue func(uintptr, string) *glib.Variant

// Gets the value that is stored in @settings for @key.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings.
func (x *Settings) GetValue(KeyVar string) *glib.Variant {

	cret := xSettingsGetValue(x.GoPointer(), KeyVar)
	return cret
}

var xSettingsIsWritable func(uintptr, string) bool

// Finds out if a key can be written or not
func (x *Settings) IsWritable(NameVar string) bool {

	cret := xSettingsIsWritable(x.GoPointer(), NameVar)
	return cret
}

var xSettingsListChildren func(uintptr) uintptr

// Gets the list of children on @settings.
//
// The list is exactly the list of strings for which it is not an error
// to call g_settings_get_child().
//
// There is little reason to call this function from "normal" code, since
// you should already know what children are in your schema. This function
// may still be useful there for introspection reasons, however.
//
// You should free the return value with g_strfreev() when you are done
// with it.
func (x *Settings) ListChildren() uintptr {

	cret := xSettingsListChildren(x.GoPointer())
	return cret
}

var xSettingsListKeys func(uintptr) uintptr

// Introspects the list of keys on @settings.
//
// You should probably not be calling this function from "normal" code
// (since you should already know what keys are in your schema).  This
// function is intended for introspection reasons.
//
// You should free the return value with g_strfreev() when you are done
// with it.
func (x *Settings) ListKeys() uintptr {

	cret := xSettingsListKeys(x.GoPointer())
	return cret
}

var xSettingsRangeCheck func(uintptr, string, *glib.Variant) bool

// Checks if the given @value is of the correct type and within the
// permitted range for @key.
func (x *Settings) RangeCheck(KeyVar string, ValueVar *glib.Variant) bool {

	cret := xSettingsRangeCheck(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsReset func(uintptr, string)

// Resets @key to its default value.
//
// This call resets the key, as much as possible, to its default value.
// That might be the value specified in the schema or the one set by the
// administrator.
func (x *Settings) Reset(KeyVar string) {

	xSettingsReset(x.GoPointer(), KeyVar)

}

var xSettingsRevert func(uintptr)

// Reverts all non-applied changes to the settings.  This function
// does nothing unless @settings is in 'delay-apply' mode; see
// g_settings_delay().  In the normal case settings are always applied
// immediately.
//
// Change notifications will be emitted for affected keys.
func (x *Settings) Revert() {

	xSettingsRevert(x.GoPointer())

}

var xSettingsSet func(uintptr, string, string, ...interface{}) bool

// Sets @key in @settings to @value.
//
// A convenience function that combines g_settings_set_value() with
// g_variant_new().
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or for the #GVariantType of @format to mismatch
// the type given in the schema.
func (x *Settings) Set(KeyVar string, FormatVar string, varArgs ...interface{}) bool {

	cret := xSettingsSet(x.GoPointer(), KeyVar, FormatVar, varArgs...)
	return cret
}

var xSettingsSetBoolean func(uintptr, string, bool) bool

// Sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for booleans.
//
// It is a programmer error to give a @key that isn't specified as
// having a boolean type in the schema for @settings.
func (x *Settings) SetBoolean(KeyVar string, ValueVar bool) bool {

	cret := xSettingsSetBoolean(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetDouble func(uintptr, string, float64) bool

// Sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for doubles.
//
// It is a programmer error to give a @key that isn't specified as
// having a 'double' type in the schema for @settings.
func (x *Settings) SetDouble(KeyVar string, ValueVar float64) bool {

	cret := xSettingsSetDouble(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetEnum func(uintptr, string, int) bool

// Looks up the enumerated type nick for @value and writes it to @key,
// within @settings.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or is not marked as an enumerated type, or for
// @value not to be a valid value for the named type.
//
// After performing the write, accessing @key directly with
// g_settings_get_string() will return the 'nick' associated with
// @value.
func (x *Settings) SetEnum(KeyVar string, ValueVar int) bool {

	cret := xSettingsSetEnum(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetFlags func(uintptr, string, uint) bool

// Looks up the flags type nicks for the bits specified by @value, puts
// them in an array of strings and writes the array to @key, within
// @settings.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or is not marked as a flags type, or for @value
// to contain any bits that are not value for the named type.
//
// After performing the write, accessing @key directly with
// g_settings_get_strv() will return an array of 'nicks'; one for each
// bit in @value.
func (x *Settings) SetFlags(KeyVar string, ValueVar uint) bool {

	cret := xSettingsSetFlags(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetInt func(uintptr, string, int) bool

// Sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for 32-bit integers.
//
// It is a programmer error to give a @key that isn't specified as
// having a int32 type in the schema for @settings.
func (x *Settings) SetInt(KeyVar string, ValueVar int) bool {

	cret := xSettingsSetInt(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetInt64 func(uintptr, string, int64) bool

// Sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for 64-bit integers.
//
// It is a programmer error to give a @key that isn't specified as
// having a int64 type in the schema for @settings.
func (x *Settings) SetInt64(KeyVar string, ValueVar int64) bool {

	cret := xSettingsSetInt64(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetString func(uintptr, string, string) bool

// Sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for strings.
//
// It is a programmer error to give a @key that isn't specified as
// having a string type in the schema for @settings.
func (x *Settings) SetString(KeyVar string, ValueVar string) bool {

	cret := xSettingsSetString(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetStrv func(uintptr, string, uintptr) bool

// Sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for string arrays.  If
// @value is %NULL, then @key is set to be the empty array.
//
// It is a programmer error to give a @key that isn't specified as
// having an array of strings type in the schema for @settings.
func (x *Settings) SetStrv(KeyVar string, ValueVar uintptr) bool {

	cret := xSettingsSetStrv(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetUint func(uintptr, string, uint) bool

// Sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for 32-bit unsigned
// integers.
//
// It is a programmer error to give a @key that isn't specified as
// having a uint32 type in the schema for @settings.
func (x *Settings) SetUint(KeyVar string, ValueVar uint) bool {

	cret := xSettingsSetUint(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetUint64 func(uintptr, string, uint64) bool

// Sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for 64-bit unsigned
// integers.
//
// It is a programmer error to give a @key that isn't specified as
// having a uint64 type in the schema for @settings.
func (x *Settings) SetUint64(KeyVar string, ValueVar uint64) bool {

	cret := xSettingsSetUint64(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xSettingsSetValue func(uintptr, string, *glib.Variant) bool

// Sets @key in @settings to @value.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or for @value to have the incorrect type, per
// the schema.
//
// If @value is floating then this function consumes the reference.
func (x *Settings) SetValue(KeyVar string, ValueVar *glib.Variant) bool {

	cret := xSettingsSetValue(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

func (c *Settings) GoPointer() uintptr {
	return c.Ptr
}

func (c *Settings) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// The "change-event" signal is emitted once per change event that
// affects this settings object.  You should connect to this signal
// only if you are interested in viewing groups of changes before they
// are split out into multiple emissions of the "changed" signal.
// For most use cases it is more appropriate to use the "changed" signal.
//
// In the event that the change event applies to one or more specified
// keys, @keys will be an array of #GQuark of length @n_keys.  In the
// event that the change event applies to the #GSettings object as a
// whole (ie: potentially every key has been changed) then @keys will
// be %NULL and @n_keys will be 0.
//
// The default handler for this signal invokes the "changed" signal
// for each affected key.  If any other connected handler returns
// %TRUE then this default functionality will be suppressed.
func (x *Settings) ConnectChangeEvent(cb *func(Settings, uintptr, int) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "change-event", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, KeysVarp uintptr, NKeysVarp int) bool {
		fa := Settings{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, KeysVarp, NKeysVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "change-event", cbRefPtr)
}

// The "changed" signal is emitted when a key has potentially changed.
// You should call one of the g_settings_get() calls to check the new
// value.
//
// This signal supports detailed connections.  You can connect to the
// detailed signal "changed::x" in order to only receive callbacks
// when key "x" changes.
//
// Note that @settings only emits this signal if you have read @key at
// least once while a signal handler was already connected for @key.
func (x *Settings) ConnectChanged(cb *func(Settings, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, KeyVarp string) {
		fa := Settings{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, KeyVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
}

// The "writable-change-event" signal is emitted once per writability
// change event that affects this settings object.  You should connect
// to this signal if you are interested in viewing groups of changes
// before they are split out into multiple emissions of the
// "writable-changed" signal.  For most use cases it is more
// appropriate to use the "writable-changed" signal.
//
// In the event that the writability change applies only to a single
// key, @key will be set to the #GQuark for that key.  In the event
// that the writability change affects the entire settings object,
// @key will be 0.
//
// The default handler for this signal invokes the "writable-changed"
// and "changed" signals for each affected key.  This is done because
// changes in writability might also imply changes in value (if for
// example, a new mandatory setting is introduced).  If any other
// connected handler returns %TRUE then this default functionality
// will be suppressed.
func (x *Settings) ConnectWritableChangeEvent(cb *func(Settings, uint) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "writable-change-event", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, KeyVarp uint) bool {
		fa := Settings{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, KeyVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "writable-change-event", cbRefPtr)
}

// The "writable-changed" signal is emitted when the writability of a
// key has potentially changed.  You should call
// g_settings_is_writable() in order to determine the new status.
//
// This signal supports detailed connections.  You can connect to the
// detailed signal "writable-changed::x" in order to only receive
// callbacks when the writability of "x" changes.
func (x *Settings) ConnectWritableChanged(cb *func(Settings, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "writable-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, KeyVarp string) {
		fa := Settings{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, KeyVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "writable-changed", cbRefPtr)
}

var xSettingsListRelocatableSchemas func() uintptr

// Deprecated.
func SettingsListRelocatableSchemas() uintptr {

	cret := xSettingsListRelocatableSchemas()
	return cret
}

var xSettingsListSchemas func() uintptr

// Deprecated.
func SettingsListSchemas() uintptr {

	cret := xSettingsListSchemas()
	return cret
}

var xSettingsSync func()

// Ensures that all pending operations are complete for the default backend.
//
// Writes made to a #GSettings are handled asynchronously.  For this
// reason, it is very unlikely that the changes have it to disk by the
// time g_settings_set() returns.
//
// This call will block until all of the writes have made it to the
// backend.  Since the mainloop is not running, no change notifications
// will be dispatched during this call (but some may be queued by the
// time the call is done).
func SettingsSync() {

	xSettingsSync()

}

var xSettingsUnbind func(uintptr, string)

// Removes an existing binding for @property on @object.
//
// Note that bindings are automatically removed when the
// object is finalized, so it is rarely necessary to call this
// function.
func SettingsUnbind(ObjectVar *gobject.Object, PropertyVar string) {

	xSettingsUnbind(ObjectVar.GoPointer(), PropertyVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewSettings, lib, "g_settings_new")
	core.PuregoSafeRegister(&xNewSettingsFull, lib, "g_settings_new_full")
	core.PuregoSafeRegister(&xNewSettingsWithBackend, lib, "g_settings_new_with_backend")
	core.PuregoSafeRegister(&xNewSettingsWithBackendAndPath, lib, "g_settings_new_with_backend_and_path")
	core.PuregoSafeRegister(&xNewSettingsWithPath, lib, "g_settings_new_with_path")

	core.PuregoSafeRegister(&xSettingsApply, lib, "g_settings_apply")
	core.PuregoSafeRegister(&xSettingsBind, lib, "g_settings_bind")
	core.PuregoSafeRegister(&xSettingsBindWithMapping, lib, "g_settings_bind_with_mapping")
	core.PuregoSafeRegister(&xSettingsBindWritable, lib, "g_settings_bind_writable")
	core.PuregoSafeRegister(&xSettingsCreateAction, lib, "g_settings_create_action")
	core.PuregoSafeRegister(&xSettingsDelay, lib, "g_settings_delay")
	core.PuregoSafeRegister(&xSettingsGet, lib, "g_settings_get")
	core.PuregoSafeRegister(&xSettingsGetBoolean, lib, "g_settings_get_boolean")
	core.PuregoSafeRegister(&xSettingsGetChild, lib, "g_settings_get_child")
	core.PuregoSafeRegister(&xSettingsGetDefaultValue, lib, "g_settings_get_default_value")
	core.PuregoSafeRegister(&xSettingsGetDouble, lib, "g_settings_get_double")
	core.PuregoSafeRegister(&xSettingsGetEnum, lib, "g_settings_get_enum")
	core.PuregoSafeRegister(&xSettingsGetFlags, lib, "g_settings_get_flags")
	core.PuregoSafeRegister(&xSettingsGetHasUnapplied, lib, "g_settings_get_has_unapplied")
	core.PuregoSafeRegister(&xSettingsGetInt, lib, "g_settings_get_int")
	core.PuregoSafeRegister(&xSettingsGetInt64, lib, "g_settings_get_int64")
	core.PuregoSafeRegister(&xSettingsGetMapped, lib, "g_settings_get_mapped")
	core.PuregoSafeRegister(&xSettingsGetRange, lib, "g_settings_get_range")
	core.PuregoSafeRegister(&xSettingsGetString, lib, "g_settings_get_string")
	core.PuregoSafeRegister(&xSettingsGetStrv, lib, "g_settings_get_strv")
	core.PuregoSafeRegister(&xSettingsGetUint, lib, "g_settings_get_uint")
	core.PuregoSafeRegister(&xSettingsGetUint64, lib, "g_settings_get_uint64")
	core.PuregoSafeRegister(&xSettingsGetUserValue, lib, "g_settings_get_user_value")
	core.PuregoSafeRegister(&xSettingsGetValue, lib, "g_settings_get_value")
	core.PuregoSafeRegister(&xSettingsIsWritable, lib, "g_settings_is_writable")
	core.PuregoSafeRegister(&xSettingsListChildren, lib, "g_settings_list_children")
	core.PuregoSafeRegister(&xSettingsListKeys, lib, "g_settings_list_keys")
	core.PuregoSafeRegister(&xSettingsRangeCheck, lib, "g_settings_range_check")
	core.PuregoSafeRegister(&xSettingsReset, lib, "g_settings_reset")
	core.PuregoSafeRegister(&xSettingsRevert, lib, "g_settings_revert")
	core.PuregoSafeRegister(&xSettingsSet, lib, "g_settings_set")
	core.PuregoSafeRegister(&xSettingsSetBoolean, lib, "g_settings_set_boolean")
	core.PuregoSafeRegister(&xSettingsSetDouble, lib, "g_settings_set_double")
	core.PuregoSafeRegister(&xSettingsSetEnum, lib, "g_settings_set_enum")
	core.PuregoSafeRegister(&xSettingsSetFlags, lib, "g_settings_set_flags")
	core.PuregoSafeRegister(&xSettingsSetInt, lib, "g_settings_set_int")
	core.PuregoSafeRegister(&xSettingsSetInt64, lib, "g_settings_set_int64")
	core.PuregoSafeRegister(&xSettingsSetString, lib, "g_settings_set_string")
	core.PuregoSafeRegister(&xSettingsSetStrv, lib, "g_settings_set_strv")
	core.PuregoSafeRegister(&xSettingsSetUint, lib, "g_settings_set_uint")
	core.PuregoSafeRegister(&xSettingsSetUint64, lib, "g_settings_set_uint64")
	core.PuregoSafeRegister(&xSettingsSetValue, lib, "g_settings_set_value")

	core.PuregoSafeRegister(&xSettingsListRelocatableSchemas, lib, "g_settings_list_relocatable_schemas")
	core.PuregoSafeRegister(&xSettingsListSchemas, lib, "g_settings_list_schemas")
	core.PuregoSafeRegister(&xSettingsSync, lib, "g_settings_sync")
	core.PuregoSafeRegister(&xSettingsUnbind, lib, "g_settings_unbind")

}
