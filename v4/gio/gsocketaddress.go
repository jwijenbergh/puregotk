// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type SocketAddressClass struct {
	_ structs.HostLayout

	ParentClass uintptr
}

func (x *SocketAddressClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GSocketAddress is the equivalent of struct sockaddr in the BSD
// sockets API. This is an abstract class; use #GInetSocketAddress
// for internet sockets, or #GUnixSocketAddress for UNIX domain sockets.
type SocketAddress struct {
	gobject.Object
}

var xSocketAddressGLibType func() types.GType

func SocketAddressGLibType() types.GType {
	return xSocketAddressGLibType()
}

func SocketAddressNewFromInternalPtr(ptr uintptr) *SocketAddress {
	cls := &SocketAddress{}
	cls.Ptr = ptr
	return cls
}

var xNewSocketAddressFromNative func(uintptr, uint) uintptr

// Creates a #GSocketAddress subclass corresponding to the native
// struct sockaddr @native.
func NewSocketAddressFromNative(NativeVar uintptr, LenVar uint) *SocketAddress {
	var cls *SocketAddress

	cret := xNewSocketAddressFromNative(NativeVar, LenVar)

	if cret == 0 {
		return nil
	}
	cls = &SocketAddress{}
	cls.Ptr = cret
	return cls
}

var xSocketAddressGetFamily func(uintptr) SocketFamily

// Gets the socket family type of @address.
func (x *SocketAddress) GetFamily() SocketFamily {

	cret := xSocketAddressGetFamily(x.GoPointer())
	return cret
}

var xSocketAddressGetNativeSize func(uintptr) int

// Gets the size of @address's native struct sockaddr.
// You can use this to allocate memory to pass to
// g_socket_address_to_native().
func (x *SocketAddress) GetNativeSize() int {

	cret := xSocketAddressGetNativeSize(x.GoPointer())
	return cret
}

var xSocketAddressToNative func(uintptr, uintptr, uint, **glib.Error) bool

// Converts a #GSocketAddress to a native struct sockaddr, which can
// be passed to low-level functions like connect() or bind().
//
// If not enough space is available, a %G_IO_ERROR_NO_SPACE error
// is returned. If the address type is not known on the system
// then a %G_IO_ERROR_NOT_SUPPORTED error is returned.
func (x *SocketAddress) ToNative(DestVar uintptr, DestlenVar uint) (bool, error) {
	var cerr *glib.Error

	cret := xSocketAddressToNative(x.GoPointer(), DestVar, DestlenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *SocketAddress) GoPointer() uintptr {
	return c.Ptr
}

func (c *SocketAddress) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Creates a #GSocketAddressEnumerator for @connectable.
func (x *SocketAddress) Enumerate() *SocketAddressEnumerator {
	var cls *SocketAddressEnumerator

	cret := XGSocketConnectableEnumerate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &SocketAddressEnumerator{}
	cls.Ptr = cret
	return cls
}

// Creates a #GSocketAddressEnumerator for @connectable that will
// return a #GProxyAddress for each of its addresses that you must connect
// to via a proxy.
//
// If @connectable does not implement
// g_socket_connectable_proxy_enumerate(), this will fall back to
// calling g_socket_connectable_enumerate().
func (x *SocketAddress) ProxyEnumerate() *SocketAddressEnumerator {
	var cls *SocketAddressEnumerator

	cret := XGSocketConnectableProxyEnumerate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &SocketAddressEnumerator{}
	cls.Ptr = cret
	return cls
}

// Format a #GSocketConnectable as a string. This is a human-readable format for
// use in debugging output, and is not a stable serialization format. It is not
// suitable for use in user interfaces as it exposes too much information for a
// user.
//
// If the #GSocketConnectable implementation does not support string formatting,
// the implementationâ€™s type name will be returned as a fallback.
func (x *SocketAddress) ToString() string {

	cret := XGSocketConnectableToString(x.GoPointer())
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xSocketAddressGLibType, lib, "g_socket_address_get_type")

	core.PuregoSafeRegister(&xNewSocketAddressFromNative, lib, "g_socket_address_new_from_native")

	core.PuregoSafeRegister(&xSocketAddressGetFamily, lib, "g_socket_address_get_family")
	core.PuregoSafeRegister(&xSocketAddressGetNativeSize, lib, "g_socket_address_get_native_size")
	core.PuregoSafeRegister(&xSocketAddressToNative, lib, "g_socket_address_to_native")

}
