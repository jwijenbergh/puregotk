// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type InetAddressMaskClass struct {
	_ structs.HostLayout

	ParentClass uintptr
}

func (x *InetAddressMaskClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type InetAddressMaskPrivate struct {
	_ structs.HostLayout
}

func (x *InetAddressMaskPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GInetAddressMask represents a range of IPv4 or IPv6 addresses
// described by a base address and a length indicating how many bits
// of the base address are relevant for matching purposes. These are
// often given in string form. Eg, "10.0.0.0/8", or "fe80::/10".
type InetAddressMask struct {
	gobject.Object
}

var xInetAddressMaskGLibType func() types.GType

func InetAddressMaskGLibType() types.GType {
	return xInetAddressMaskGLibType()
}

func InetAddressMaskNewFromInternalPtr(ptr uintptr) *InetAddressMask {
	cls := &InetAddressMask{}
	cls.Ptr = ptr
	return cls
}

var xNewInetAddressMask func(uintptr, uint, **glib.Error) uintptr

// Creates a new #GInetAddressMask representing all addresses whose
// first @length bits match @addr.
func NewInetAddressMask(AddrVar *InetAddress, LengthVar uint) (*InetAddressMask, error) {
	var cls *InetAddressMask
	var cerr *glib.Error

	cret := xNewInetAddressMask(AddrVar.GoPointer(), LengthVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &InetAddressMask{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewInetAddressMaskFromString func(string, **glib.Error) uintptr

// Parses @mask_string as an IP address and (optional) length, and
// creates a new #GInetAddressMask. The length, if present, is
// delimited by a "/". If it is not present, then the length is
// assumed to be the full length of the address.
func NewInetAddressMaskFromString(MaskStringVar string) (*InetAddressMask, error) {
	var cls *InetAddressMask
	var cerr *glib.Error

	cret := xNewInetAddressMaskFromString(MaskStringVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &InetAddressMask{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xInetAddressMaskEqual func(uintptr, uintptr) bool

// Tests if @mask and @mask2 are the same mask.
func (x *InetAddressMask) Equal(Mask2Var *InetAddressMask) bool {

	cret := xInetAddressMaskEqual(x.GoPointer(), Mask2Var.GoPointer())
	return cret
}

var xInetAddressMaskGetAddress func(uintptr) uintptr

// Gets @mask's base address
func (x *InetAddressMask) GetAddress() *InetAddress {
	var cls *InetAddress

	cret := xInetAddressMaskGetAddress(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &InetAddress{}
	cls.Ptr = cret
	return cls
}

var xInetAddressMaskGetFamily func(uintptr) SocketFamily

// Gets the #GSocketFamily of @mask's address
func (x *InetAddressMask) GetFamily() SocketFamily {

	cret := xInetAddressMaskGetFamily(x.GoPointer())
	return cret
}

var xInetAddressMaskGetLength func(uintptr) uint

// Gets @mask's length
func (x *InetAddressMask) GetLength() uint {

	cret := xInetAddressMaskGetLength(x.GoPointer())
	return cret
}

var xInetAddressMaskMatches func(uintptr, uintptr) bool

// Tests if @address falls within the range described by @mask.
func (x *InetAddressMask) Matches(AddressVar *InetAddress) bool {

	cret := xInetAddressMaskMatches(x.GoPointer(), AddressVar.GoPointer())
	return cret
}

var xInetAddressMaskToString func(uintptr) string

// Converts @mask back to its corresponding string form.
func (x *InetAddressMask) ToString() string {

	cret := xInetAddressMaskToString(x.GoPointer())
	return cret
}

func (c *InetAddressMask) GoPointer() uintptr {
	return c.Ptr
}

func (c *InetAddressMask) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Initializes the object implementing the interface.
//
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
//
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
//
// Implementations may also support cancellation. If @cancellable is not %NULL,
// then initialization can be cancelled by triggering the cancellable object
// from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
// the object doesn't support cancellable initialization the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// If the object is not initialized, or initialization returns with an
// error, then all operations on the object except g_object_ref() and
// g_object_unref() are considered to be invalid, and have undefined
// behaviour. See the [introduction][ginitable] for more details.
//
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a classâ€™ implementation of init() can assume
// (and assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
//
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes
// the object; further calls return the result of the first call.
//
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a
// #GObjectClass.constructor that sometimes returns an existing instance.
// In this pattern, a caller would expect to be able to call g_initable_init()
// on the result of g_object_new(), regardless of whether it is in fact a new
// instance.
func (x *InetAddressMask) Init(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGInitableInit(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xInetAddressMaskGLibType, lib, "g_inet_address_mask_get_type")

	core.PuregoSafeRegister(&xNewInetAddressMask, lib, "g_inet_address_mask_new")
	core.PuregoSafeRegister(&xNewInetAddressMaskFromString, lib, "g_inet_address_mask_new_from_string")

	core.PuregoSafeRegister(&xInetAddressMaskEqual, lib, "g_inet_address_mask_equal")
	core.PuregoSafeRegister(&xInetAddressMaskGetAddress, lib, "g_inet_address_mask_get_address")
	core.PuregoSafeRegister(&xInetAddressMaskGetFamily, lib, "g_inet_address_mask_get_family")
	core.PuregoSafeRegister(&xInetAddressMaskGetLength, lib, "g_inet_address_mask_get_length")
	core.PuregoSafeRegister(&xInetAddressMaskMatches, lib, "g_inet_address_mask_matches")
	core.PuregoSafeRegister(&xInetAddressMaskToString, lib, "g_inet_address_mask_to_string")

}
