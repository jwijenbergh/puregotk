// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type FileEnumeratorClass struct {
	_ structs.HostLayout

	ParentClass uintptr
}

func (x *FileEnumeratorClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type FileEnumeratorPrivate struct {
	_ structs.HostLayout
}

func (x *FileEnumeratorPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GFileEnumerator allows you to operate on a set of #GFiles,
// returning a #GFileInfo structure for each file enumerated (e.g.
// g_file_enumerate_children() will return a #GFileEnumerator for each
// of the children within a directory).
//
// To get the next file's information from a #GFileEnumerator, use
// g_file_enumerator_next_file() or its asynchronous version,
// g_file_enumerator_next_files_async(). Note that the asynchronous
// version will return a list of #GFileInfos, whereas the
// synchronous will only return the next file in the enumerator.
//
// The ordering of returned files is unspecified for non-Unix
// platforms; for more information, see g_dir_read_name().  On Unix,
// when operating on local files, returned files will be sorted by
// inode number.  Effectively you can assume that the ordering of
// returned files will be stable between successive calls (and
// applications) assuming the directory is unchanged.
//
// If your application needs a specific ordering, such as by name or
// modification time, you will have to implement that in your
// application code.
//
// To close a #GFileEnumerator, use g_file_enumerator_close(), or
// its asynchronous version, g_file_enumerator_close_async(). Once
// a #GFileEnumerator is closed, no further actions may be performed
// on it, and it should be freed with g_object_unref().
type FileEnumerator struct {
	gobject.Object
}

var xFileEnumeratorGLibType func() types.GType

func FileEnumeratorGLibType() types.GType {
	return xFileEnumeratorGLibType()
}

func FileEnumeratorNewFromInternalPtr(ptr uintptr) *FileEnumerator {
	cls := &FileEnumerator{}
	cls.Ptr = ptr
	return cls
}

var xFileEnumeratorClose func(uintptr, uintptr, **glib.Error) bool

// Releases all resources used by this enumerator, making the
// enumerator return %G_IO_ERROR_CLOSED on all calls.
//
// This will be automatically called when the last reference
// is dropped, but you might want to call this function to make
// sure resources are released as early as possible.
func (x *FileEnumerator) Close(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xFileEnumeratorClose(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFileEnumeratorCloseAsync func(uintptr, int, uintptr, uintptr, uintptr)

// Asynchronously closes the file enumerator.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
// g_file_enumerator_close_finish().
func (x *FileEnumerator) CloseAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xFileEnumeratorCloseAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xFileEnumeratorCloseFinish func(uintptr, uintptr, **glib.Error) bool

// Finishes closing a file enumerator, started from g_file_enumerator_close_async().
//
// If the file enumerator was already closed when g_file_enumerator_close_async()
// was called, then this function will report %G_IO_ERROR_CLOSED in @error, and
// return %FALSE. If the file enumerator had pending operation when the close
// operation was started, then this function will report %G_IO_ERROR_PENDING, and
// return %FALSE.  If @cancellable was not %NULL, then the operation may have been
// cancelled by triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
// returned.
func (x *FileEnumerator) CloseFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xFileEnumeratorCloseFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFileEnumeratorGetChild func(uintptr, uintptr) uintptr

// Return a new #GFile which refers to the file named by @info in the source
// directory of @enumerator.  This function is primarily intended to be used
// inside loops with g_file_enumerator_next_file().
//
// To use this, %G_FILE_ATTRIBUTE_STANDARD_NAME must have been listed in the
// attributes list used when creating the #GFileEnumerator.
//
// This is a convenience method that's equivalent to:
// |[&lt;!-- language="C" --&gt;
//
//	gchar *name = g_file_info_get_name (info);
//	GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
//	                                 name);
//
// ]|
func (x *FileEnumerator) GetChild(InfoVar *FileInfo) *FileBase {
	var cls *FileBase

	cret := xFileEnumeratorGetChild(x.GoPointer(), InfoVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileEnumeratorGetContainer func(uintptr) uintptr

// Get the #GFile container which is being enumerated.
func (x *FileEnumerator) GetContainer() *FileBase {
	var cls *FileBase

	cret := xFileEnumeratorGetContainer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileEnumeratorHasPending func(uintptr) bool

// Checks if the file enumerator has pending operations.
func (x *FileEnumerator) HasPending() bool {

	cret := xFileEnumeratorHasPending(x.GoPointer())
	return cret
}

var xFileEnumeratorIsClosed func(uintptr) bool

// Checks if the file enumerator has been closed.
func (x *FileEnumerator) IsClosed() bool {

	cret := xFileEnumeratorIsClosed(x.GoPointer())
	return cret
}

var xFileEnumeratorIterate func(uintptr, *uintptr, *uintptr, uintptr, **glib.Error) bool

// This is a version of g_file_enumerator_next_file() that's easier to
// use correctly from C programs.  With g_file_enumerator_next_file(),
// the gboolean return value signifies "end of iteration or error", which
// requires allocation of a temporary #GError.
//
// In contrast, with this function, a %FALSE return from
// g_file_enumerator_iterate() *always* means
// "error".  End of iteration is signaled by @out_info or @out_child being %NULL.
//
// Another crucial difference is that the references for @out_info and
// @out_child are owned by @direnum (they are cached as hidden
// properties).  You must not unref them in your own code.  This makes
// memory management significantly easier for C code in combination
// with loops.
//
// Finally, this function optionally allows retrieving a #GFile as
// well.
//
// You must specify at least one of @out_info or @out_child.
//
// The code pattern for correctly using g_file_enumerator_iterate() from C
// is:
//
// |[
// direnum = g_file_enumerate_children (file, ...);
// while (TRUE)
//
//	{
//	  GFileInfo *info;
//	  if (!g_file_enumerator_iterate (direnum, &amp;info, NULL, cancellable, error))
//	    goto out;
//	  if (!info)
//	    break;
//	  ... do stuff with "info"; do not unref it! ...
//	}
//
// out:
//
//	g_object_unref (direnum); // Note: frees the last @info
//
// ]|
func (x *FileEnumerator) Iterate(OutInfoVar **FileInfo, OutChildVar *File, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xFileEnumeratorIterate(x.GoPointer(), gobject.ConvertPtr(OutInfoVar), gobject.ConvertPtr(OutChildVar), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFileEnumeratorNextFile func(uintptr, uintptr, **glib.Error) uintptr

// Returns information for the next file in the enumerated object.
// Will block until the information is available. The #GFileInfo
// returned from this function will contain attributes that match the
// attribute string that was passed when the #GFileEnumerator was created.
//
// See the documentation of #GFileEnumerator for information about the
// order of returned files.
//
// On error, returns %NULL and sets @error to the error. If the
// enumerator is at the end, %NULL will be returned and @error will
// be unset.
func (x *FileEnumerator) NextFile(CancellableVar *Cancellable) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := xFileEnumeratorNextFile(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileEnumeratorNextFilesAsync func(uintptr, int, int, uintptr, uintptr, uintptr)

// Request information for a number of files from the enumerator asynchronously.
// When all i/o for the operation is finished the @callback will be called with
// the requested information.
//
// See the documentation of #GFileEnumerator for information about the
// order of returned files.
//
// The callback can be called with less than @num_files files in case of error
// or at the end of the enumerator. In case of a partial error the callback will
// be called with any succeeding items and no error, and on the next request the
// error will be reported. If a request is cancelled the callback will be called
// with %G_IO_ERROR_CANCELLED.
//
// During an async request no other sync and async calls are allowed, and will
// result in %G_IO_ERROR_PENDING errors.
//
// Any outstanding i/o request with higher priority (lower numerical value) will
// be executed before an outstanding request with lower priority. Default
// priority is %G_PRIORITY_DEFAULT.
func (x *FileEnumerator) NextFilesAsync(NumFilesVar int, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xFileEnumeratorNextFilesAsync(x.GoPointer(), NumFilesVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xFileEnumeratorNextFilesFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
func (x *FileEnumerator) NextFilesFinish(ResultVar AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xFileEnumeratorNextFilesFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFileEnumeratorSetPending func(uintptr, bool)

// Sets the file enumerator as having pending operations.
func (x *FileEnumerator) SetPending(PendingVar bool) {

	xFileEnumeratorSetPending(x.GoPointer(), PendingVar)

}

func (c *FileEnumerator) GoPointer() uintptr {
	return c.Ptr
}

func (c *FileEnumerator) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xFileEnumeratorGLibType, lib, "g_file_enumerator_get_type")

	core.PuregoSafeRegister(&xFileEnumeratorClose, lib, "g_file_enumerator_close")
	core.PuregoSafeRegister(&xFileEnumeratorCloseAsync, lib, "g_file_enumerator_close_async")
	core.PuregoSafeRegister(&xFileEnumeratorCloseFinish, lib, "g_file_enumerator_close_finish")
	core.PuregoSafeRegister(&xFileEnumeratorGetChild, lib, "g_file_enumerator_get_child")
	core.PuregoSafeRegister(&xFileEnumeratorGetContainer, lib, "g_file_enumerator_get_container")
	core.PuregoSafeRegister(&xFileEnumeratorHasPending, lib, "g_file_enumerator_has_pending")
	core.PuregoSafeRegister(&xFileEnumeratorIsClosed, lib, "g_file_enumerator_is_closed")
	core.PuregoSafeRegister(&xFileEnumeratorIterate, lib, "g_file_enumerator_iterate")
	core.PuregoSafeRegister(&xFileEnumeratorNextFile, lib, "g_file_enumerator_next_file")
	core.PuregoSafeRegister(&xFileEnumeratorNextFilesAsync, lib, "g_file_enumerator_next_files_async")
	core.PuregoSafeRegister(&xFileEnumeratorNextFilesFinish, lib, "g_file_enumerator_next_files_finish")
	core.PuregoSafeRegister(&xFileEnumeratorSetPending, lib, "g_file_enumerator_set_pending")

}
