// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The virtual function table for #GNetworkMonitor.
type NetworkMonitorInterface struct {
	GIface uintptr
}

func (x *NetworkMonitorInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GNetworkMonitor provides an easy-to-use cross-platform API
// for monitoring network connectivity. On Linux, the available
// implementations are based on the kernel's netlink interface and
// on NetworkManager.
//
// There is also an implementation for use inside Flatpak sandboxes.
type NetworkMonitor interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	CanReach(ConnectableVar SocketConnectable, CancellableVar *Cancellable) bool
	CanReachAsync(ConnectableVar SocketConnectable, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	CanReachFinish(ResultVar AsyncResult) bool
	GetConnectivity() NetworkConnectivity
	GetNetworkAvailable() bool
	GetNetworkMetered() bool
}

var xNetworkMonitorGLibType func() types.GType

func NetworkMonitorGLibType() types.GType {
	return xNetworkMonitorGLibType()
}

type NetworkMonitorBase struct {
	Ptr uintptr
}

func (x *NetworkMonitorBase) GoPointer() uintptr {
	return x.Ptr
}

func (x *NetworkMonitorBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Attempts to determine whether or not the host pointed to by
// @connectable can be reached, without actually trying to connect to
// it.
//
// This may return %TRUE even when #GNetworkMonitor:network-available
// is %FALSE, if, for example, @monitor can determine that
// @connectable refers to a host on a local network.
//
// If @monitor believes that an attempt to connect to @connectable
// will succeed, it will return %TRUE. Otherwise, it will return
// %FALSE and set @error to an appropriate error (such as
// %G_IO_ERROR_HOST_UNREACHABLE).
//
// Note that although this does not attempt to connect to
// @connectable, it may still block for a brief period of time (eg,
// trying to do multicast DNS on the local network), so if you do not
// want to block, you should use g_network_monitor_can_reach_async().
func (x *NetworkMonitorBase) CanReach(ConnectableVar SocketConnectable, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGNetworkMonitorCanReach(x.GoPointer(), ConnectableVar.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously attempts to determine whether or not the host
// pointed to by @connectable can be reached, without actually
// trying to connect to it.
//
// For more details, see g_network_monitor_can_reach().
//
// When the operation is finished, @callback will be called.
// You can then call g_network_monitor_can_reach_finish()
// to get the result of the operation.
func (x *NetworkMonitorBase) CanReachAsync(ConnectableVar SocketConnectable, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGNetworkMonitorCanReachAsync(x.GoPointer(), ConnectableVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an async network connectivity test.
// See g_network_monitor_can_reach_async().
func (x *NetworkMonitorBase) CanReachFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGNetworkMonitorCanReachFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Gets a more detailed networking state than
// g_network_monitor_get_network_available().
//
// If #GNetworkMonitor:network-available is %FALSE, then the
// connectivity state will be %G_NETWORK_CONNECTIVITY_LOCAL.
//
// If #GNetworkMonitor:network-available is %TRUE, then the
// connectivity state will be %G_NETWORK_CONNECTIVITY_FULL (if there
// is full Internet connectivity), %G_NETWORK_CONNECTIVITY_LIMITED (if
// the host has a default route, but appears to be unable to actually
// reach the full Internet), or %G_NETWORK_CONNECTIVITY_PORTAL (if the
// host is trapped behind a "captive portal" that requires some sort
// of login or acknowledgement before allowing full Internet access).
//
// Note that in the case of %G_NETWORK_CONNECTIVITY_LIMITED and
// %G_NETWORK_CONNECTIVITY_PORTAL, it is possible that some sites are
// reachable but others are not. In this case, applications can
// attempt to connect to remote servers, but should gracefully fall
// back to their "offline" behavior if the connection attempt fails.
func (x *NetworkMonitorBase) GetConnectivity() NetworkConnectivity {

	cret := XGNetworkMonitorGetConnectivity(x.GoPointer())
	return cret
}

// Checks if the network is available. "Available" here means that the
// system has a default route available for at least one of IPv4 or
// IPv6. It does not necessarily imply that the public Internet is
// reachable. See #GNetworkMonitor:network-available for more details.
func (x *NetworkMonitorBase) GetNetworkAvailable() bool {

	cret := XGNetworkMonitorGetNetworkAvailable(x.GoPointer())
	return cret
}

// Checks if the network is metered.
// See #GNetworkMonitor:network-metered for more details.
func (x *NetworkMonitorBase) GetNetworkMetered() bool {

	cret := XGNetworkMonitorGetNetworkMetered(x.GoPointer())
	return cret
}

var XGNetworkMonitorCanReach func(uintptr, uintptr, uintptr, **glib.Error) bool
var XGNetworkMonitorCanReachAsync func(uintptr, uintptr, uintptr, uintptr, uintptr)
var XGNetworkMonitorCanReachFinish func(uintptr, uintptr, **glib.Error) bool
var XGNetworkMonitorGetConnectivity func(uintptr) NetworkConnectivity
var XGNetworkMonitorGetNetworkAvailable func(uintptr) bool
var XGNetworkMonitorGetNetworkMetered func(uintptr) bool

const (
	// Extension point for network status monitoring functionality.
	// See [Extending GIO][extending-gio].
	NETWORK_MONITOR_EXTENSION_POINT_NAME string = "gio-network-monitor"
)

var xNetworkMonitorGetDefault func() uintptr

// Gets the default #GNetworkMonitor for the system.
func NetworkMonitorGetDefault() *NetworkMonitorBase {
	var cls *NetworkMonitorBase

	cret := xNetworkMonitorGetDefault()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NetworkMonitorBase{}
	cls.Ptr = cret
	return cls
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNetworkMonitorGetDefault, lib, "g_network_monitor_get_default")

	core.PuregoSafeRegister(&xNetworkMonitorGLibType, lib, "g_network_monitor_get_type")

	core.PuregoSafeRegister(&XGNetworkMonitorCanReach, lib, "g_network_monitor_can_reach")
	core.PuregoSafeRegister(&XGNetworkMonitorCanReachAsync, lib, "g_network_monitor_can_reach_async")
	core.PuregoSafeRegister(&XGNetworkMonitorCanReachFinish, lib, "g_network_monitor_can_reach_finish")
	core.PuregoSafeRegister(&XGNetworkMonitorGetConnectivity, lib, "g_network_monitor_get_connectivity")
	core.PuregoSafeRegister(&XGNetworkMonitorGetNetworkAvailable, lib, "g_network_monitor_get_network_available")
	core.PuregoSafeRegister(&XGNetworkMonitorGetNetworkMetered, lib, "g_network_monitor_get_network_metered")

}
