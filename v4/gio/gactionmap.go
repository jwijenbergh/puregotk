// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// This struct defines a single action.  It is for use with
// g_action_map_add_action_entries().
//
// The order of the items in the structure are intended to reflect
// frequency of use.  It is permissible to use an incomplete initialiser
// in order to leave some of the later values as %NULL.  All values
// after @name are optional.  Additional optional fields may be added in
// the future.
//
// See g_action_map_add_action_entries() for an example.
type ActionEntry struct {
	Name uintptr

	ParameterType uintptr

	State uintptr

	Padding [3]uint
}

func (x *ActionEntry) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// The virtual function table for #GActionMap.
type ActionMapInterface struct {
	GIface uintptr
}

func (x *ActionMapInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// The GActionMap interface is implemented by #GActionGroup
// implementations that operate by containing a number of
// named #GAction instances, such as #GSimpleActionGroup.
//
// One useful application of this interface is to map the
// names of actions from various action groups to unique,
// prefixed names (e.g. by prepending "app." or "win.").
// This is the motivation for the 'Map' part of the interface
// name.
type ActionMap interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	AddAction(ActionVar Action)
	AddActionEntries(EntriesVar []ActionEntry, NEntriesVar int, UserDataVar uintptr)
	LookupAction(ActionNameVar string) *ActionBase
	RemoveAction(ActionNameVar string)
}

var xActionMapGLibType func() types.GType

func ActionMapGLibType() types.GType {
	return xActionMapGLibType()
}

type ActionMapBase struct {
	Ptr uintptr
}

func (x *ActionMapBase) GoPointer() uintptr {
	return x.Ptr
}

func (x *ActionMapBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Adds an action to the @action_map.
//
// If the action map already contains an action with the same name
// as @action then the old action is dropped from the action map.
//
// The action map takes its own reference on @action.
func (x *ActionMapBase) AddAction(ActionVar Action) {

	XGActionMapAddAction(x.GoPointer(), ActionVar.GoPointer())

}

// A convenience function for creating multiple #GSimpleAction instances
// and adding them to a #GActionMap.
//
// Each action is constructed as per one #GActionEntry.
//
// |[&lt;!-- language="C" --&gt;
// static void
// activate_quit (GSimpleAction *simple,
//
//	GVariant      *parameter,
//	gpointer       user_data)
//
//	{
//	  exit (0);
//	}
//
// static void
// activate_print_string (GSimpleAction *simple,
//
//	GVariant      *parameter,
//	gpointer       user_data)
//
//	{
//	  g_print ("%s\n", g_variant_get_string (parameter, NULL));
//	}
//
// static GActionGroup *
// create_action_group (void)
//
//	{
//	  const GActionEntry entries[] = {
//	    { "quit",         activate_quit              },
//	    { "print-string", activate_print_string, "s" }
//	  };
//	  GSimpleActionGroup *group;
//
//	  group = g_simple_action_group_new ();
//	  g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
//
//	  return G_ACTION_GROUP (group);
//	}
//
// ]|
func (x *ActionMapBase) AddActionEntries(EntriesVar []ActionEntry, NEntriesVar int, UserDataVar uintptr) {

	XGActionMapAddActionEntries(x.GoPointer(), EntriesVar, NEntriesVar, UserDataVar)

}

// Looks up the action with the name @action_name in @action_map.
//
// If no such action exists, returns %NULL.
func (x *ActionMapBase) LookupAction(ActionNameVar string) *ActionBase {
	var cls *ActionBase

	cret := XGActionMapLookupAction(x.GoPointer(), ActionNameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ActionBase{}
	cls.Ptr = cret
	return cls
}

// Removes the named action from the action map.
//
// If no action of this name is in the map then nothing happens.
func (x *ActionMapBase) RemoveAction(ActionNameVar string) {

	XGActionMapRemoveAction(x.GoPointer(), ActionNameVar)

}

var XGActionMapAddAction func(uintptr, uintptr)
var XGActionMapAddActionEntries func(uintptr, []ActionEntry, int, uintptr)
var XGActionMapLookupAction func(uintptr, string) uintptr
var XGActionMapRemoveAction func(uintptr, string)

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xActionMapGLibType, lib, "g_action_map_get_type")

	core.PuregoSafeRegister(&XGActionMapAddAction, lib, "g_action_map_add_action")
	core.PuregoSafeRegister(&XGActionMapAddActionEntries, lib, "g_action_map_add_action_entries")
	core.PuregoSafeRegister(&XGActionMapLookupAction, lib, "g_action_map_lookup_action")
	core.PuregoSafeRegister(&XGActionMapRemoveAction, lib, "g_action_map_remove_action")

}
