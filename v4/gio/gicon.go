// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// GIconIface is used to implement GIcon types for various
// different systems. See #GThemedIcon and #GLoadableIcon for
// examples of how to implement this interface.
type IconIface struct {
	_ structs.HostLayout

	GIface uintptr
}

func (x *IconIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GIcon is a very minimal interface for icons. It provides functions
// for checking the equality of two icons, hashing of icons and
// serializing an icon to and from strings.
//
// #GIcon does not provide the actual pixmap for the icon as this is out
// of GIO's scope, however implementations of #GIcon may contain the name
// of an icon (see #GThemedIcon), or the path to an icon (see #GLoadableIcon).
//
// To obtain a hash of a #GIcon, see g_icon_hash().
//
// To check if two #GIcons are equal, see g_icon_equal().
//
// For serializing a #GIcon, use g_icon_serialize() and
// g_icon_deserialize().
//
// If you want to consume #GIcon (for example, in a toolkit) you must
// be prepared to handle at least the three following cases:
// #GLoadableIcon, #GThemedIcon and #GEmblemedIcon.  It may also make
// sense to have fast-paths for other cases (like handling #GdkPixbuf
// directly, for example) but all compliant #GIcon implementations
// outside of GIO must implement #GLoadableIcon.
//
// If your application or library provides one or more #GIcon
// implementations you need to ensure that your new implementation also
// implements #GLoadableIcon.  Additionally, you must provide an
// implementation of g_icon_serialize() that gives a result that is
// understood by g_icon_deserialize(), yielding one of the built-in icon
// types.
type Icon interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	Equal(Icon2Var Icon) bool
	Serialize() *glib.Variant
	ToString() string
}

var xIconGLibType func() types.GType

func IconGLibType() types.GType {
	return xIconGLibType()
}

type IconBase struct {
	Ptr uintptr
}

func (x *IconBase) GoPointer() uintptr {
	return x.Ptr
}

func (x *IconBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Checks if two icons are equal.
func (x *IconBase) Equal(Icon2Var Icon) bool {

	cret := XGIconEqual(x.GoPointer(), Icon2Var.GoPointer())
	return cret
}

// Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
// back by calling g_icon_deserialize() on the returned value.
// As serialization will avoid using raw icon data when possible, it only
// makes sense to transfer the #GVariant between processes on the same machine,
// (as opposed to over the network), and within the same file system namespace.
func (x *IconBase) Serialize() *glib.Variant {

	cret := XGIconSerialize(x.GoPointer())
	return cret
}

// Generates a textual representation of @icon that can be used for
// serialization such as when passing @icon to a different process or
// saving it to persistent storage. Use g_icon_new_for_string() to
// get @icon back from the returned string.
//
// The encoding of the returned string is proprietary to #GIcon except
// in the following two cases
//
//   - If @icon is a #GFileIcon, the returned string is a native path
//     (such as `/path/to/my icon.png`) without escaping
//     if the #GFile for @icon is a native file.  If the file is not
//     native, the returned string is the result of g_file_get_uri()
//     (such as `sftp://path/to/my%20icon.png`).
//
//   - If @icon is a #GThemedIcon with exactly one name and no fallbacks,
//     the encoding is simply the name (such as `network-server`).
func (x *IconBase) ToString() string {

	cret := XGIconToString(x.GoPointer())
	return cret
}

var XGIconEqual func(uintptr, uintptr) bool
var XGIconSerialize func(uintptr) *glib.Variant
var XGIconToString func(uintptr) string

var xIconDeserialize func(*glib.Variant) uintptr

// Deserializes a #GIcon previously serialized using g_icon_serialize().
func IconDeserialize(ValueVar *glib.Variant) *IconBase {
	var cls *IconBase

	cret := xIconDeserialize(ValueVar)

	if cret == 0 {
		return nil
	}
	cls = &IconBase{}
	cls.Ptr = cret
	return cls
}

var xIconHash func(uintptr) uint

// Gets a hash for an icon.
func IconHash(IconVar uintptr) uint {

	cret := xIconHash(IconVar)
	return cret
}

var xIconNewForString func(string, **glib.Error) uintptr

// Generate a #GIcon instance from @str. This function can fail if
// @str is not valid - see g_icon_to_string() for discussion.
//
// If your application or library provides one or more #GIcon
// implementations you need to ensure that each #GType is registered
// with the type system prior to calling g_icon_new_for_string().
func IconNewForString(StrVar string) (*IconBase, error) {
	var cls *IconBase
	var cerr *glib.Error

	cret := xIconNewForString(StrVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &IconBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xIconDeserialize, lib, "g_icon_deserialize")
	core.PuregoSafeRegister(&xIconHash, lib, "g_icon_hash")
	core.PuregoSafeRegister(&xIconNewForString, lib, "g_icon_new_for_string")

	core.PuregoSafeRegister(&xIconGLibType, lib, "g_icon_get_type")

	core.PuregoSafeRegister(&XGIconEqual, lib, "g_icon_equal")
	core.PuregoSafeRegister(&XGIconSerialize, lib, "g_icon_serialize")
	core.PuregoSafeRegister(&XGIconToString, lib, "g_icon_to_string")

}
