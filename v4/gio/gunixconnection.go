// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
)

type UnixConnectionClass struct {
	ParentClass uintptr
}

func (x *UnixConnectionClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type UnixConnectionPrivate struct {
}

func (x *UnixConnectionPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// This is the subclass of #GSocketConnection that is created
// for UNIX domain sockets.
//
// It contains functions to do some of the UNIX socket specific
// functionality like passing file descriptors.
//
// Since GLib 2.72, #GUnixConnection is available on all platforms. It requires
// underlying system support (such as Windows 10 with `AF_UNIX`) at run time.
//
// Before GLib 2.72, `&lt;gio/gunixconnection.h&gt;` belonged to the UNIX-specific GIO
// interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
// using it. This is no longer necessary since GLib 2.72.
type UnixConnection struct {
	SocketConnection
}

func UnixConnectionNewFromInternalPtr(ptr uintptr) *UnixConnection {
	cls := &UnixConnection{}
	cls.Ptr = ptr
	return cls
}

var xUnixConnectionReceiveCredentials func(uintptr, uintptr, **glib.Error) uintptr

// Receives credentials from the sending end of the connection.  The
// sending end has to call g_unix_connection_send_credentials() (or
// similar) for this to work.
//
// As well as reading the credentials this also reads (and discards) a
// single byte from the stream, as this is required for credentials
// passing to work on some implementations.
//
// This method can be expected to be available on the following platforms:
//
// - Linux since GLib 2.26
// - FreeBSD since GLib 2.26
// - GNU/kFreeBSD since GLib 2.36
// - Solaris, Illumos and OpenSolaris since GLib 2.40
// - GNU/Hurd since GLib 2.40
//
// Other ways to exchange credentials with a foreign peer includes the
// #GUnixCredentialsMessage type and g_socket_get_credentials() function.
func (x *UnixConnection) ReceiveCredentials(CancellableVar *Cancellable) (*Credentials, error) {
	var cls *Credentials
	var cerr *glib.Error

	cret := xUnixConnectionReceiveCredentials(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Credentials{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xUnixConnectionReceiveCredentialsAsync func(uintptr, uintptr, uintptr, uintptr)

// Asynchronously receive credentials.
//
// For more details, see g_unix_connection_receive_credentials() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called. You can then call
// g_unix_connection_receive_credentials_finish() to get the result of the operation.
func (x *UnixConnection) ReceiveCredentialsAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xUnixConnectionReceiveCredentialsAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xUnixConnectionReceiveCredentialsFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finishes an asynchronous receive credentials operation started with
// g_unix_connection_receive_credentials_async().
func (x *UnixConnection) ReceiveCredentialsFinish(ResultVar AsyncResult) (*Credentials, error) {
	var cls *Credentials
	var cerr *glib.Error

	cret := xUnixConnectionReceiveCredentialsFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Credentials{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xUnixConnectionReceiveFd func(uintptr, uintptr, **glib.Error) int

// Receives a file descriptor from the sending end of the connection.
// The sending end has to call g_unix_connection_send_fd() for this
// to work.
//
// As well as reading the fd this also reads a single byte from the
// stream, as this is required for fd passing to work on some
// implementations.
func (x *UnixConnection) ReceiveFd(CancellableVar *Cancellable) (int, error) {
	var cerr *glib.Error

	cret := xUnixConnectionReceiveFd(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnixConnectionSendCredentials func(uintptr, uintptr, **glib.Error) bool

// Passes the credentials of the current user the receiving side
// of the connection. The receiving end has to call
// g_unix_connection_receive_credentials() (or similar) to accept the
// credentials.
//
// As well as sending the credentials this also writes a single NUL
// byte to the stream, as this is required for credentials passing to
// work on some implementations.
//
// This method can be expected to be available on the following platforms:
//
// - Linux since GLib 2.26
// - FreeBSD since GLib 2.26
// - GNU/kFreeBSD since GLib 2.36
// - Solaris, Illumos and OpenSolaris since GLib 2.40
// - GNU/Hurd since GLib 2.40
//
// Other ways to exchange credentials with a foreign peer includes the
// #GUnixCredentialsMessage type and g_socket_get_credentials() function.
func (x *UnixConnection) SendCredentials(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xUnixConnectionSendCredentials(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnixConnectionSendCredentialsAsync func(uintptr, uintptr, uintptr, uintptr)

// Asynchronously send credentials.
//
// For more details, see g_unix_connection_send_credentials() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called. You can then call
// g_unix_connection_send_credentials_finish() to get the result of the operation.
func (x *UnixConnection) SendCredentialsAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xUnixConnectionSendCredentialsAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xUnixConnectionSendCredentialsFinish func(uintptr, uintptr, **glib.Error) bool

// Finishes an asynchronous send credentials operation started with
// g_unix_connection_send_credentials_async().
func (x *UnixConnection) SendCredentialsFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xUnixConnectionSendCredentialsFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnixConnectionSendFd func(uintptr, int, uintptr, **glib.Error) bool

// Passes a file descriptor to the receiving side of the
// connection. The receiving end has to call g_unix_connection_receive_fd()
// to accept the file descriptor.
//
// As well as sending the fd this also writes a single byte to the
// stream, as this is required for fd passing to work on some
// implementations.
func (x *UnixConnection) SendFd(FdVar int, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xUnixConnectionSendFd(x.GoPointer(), FdVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *UnixConnection) GoPointer() uintptr {
	return c.Ptr
}

func (c *UnixConnection) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xUnixConnectionReceiveCredentials, lib, "g_unix_connection_receive_credentials")
	core.PuregoSafeRegister(&xUnixConnectionReceiveCredentialsAsync, lib, "g_unix_connection_receive_credentials_async")
	core.PuregoSafeRegister(&xUnixConnectionReceiveCredentialsFinish, lib, "g_unix_connection_receive_credentials_finish")
	core.PuregoSafeRegister(&xUnixConnectionReceiveFd, lib, "g_unix_connection_receive_fd")
	core.PuregoSafeRegister(&xUnixConnectionSendCredentials, lib, "g_unix_connection_send_credentials")
	core.PuregoSafeRegister(&xUnixConnectionSendCredentialsAsync, lib, "g_unix_connection_send_credentials_async")
	core.PuregoSafeRegister(&xUnixConnectionSendCredentialsFinish, lib, "g_unix_connection_send_credentials_finish")
	core.PuregoSafeRegister(&xUnixConnectionSendFd, lib, "g_unix_connection_send_fd")

}
