// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The virtual function table for #GListModel.
type ListModelInterface struct {
	GIface uintptr
}

func (x *ListModelInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GListModel is an interface that represents a mutable list of
// #GObjects. Its main intention is as a model for various widgets in
// user interfaces, such as list views, but it can also be used as a
// convenient method of returning lists of data, with support for
// updates.
//
// Each object in the list may also report changes in itself via some
// mechanism (normally the #GObject::notify signal).  Taken together
// with the #GListModel::items-changed signal, this provides for a list
// that can change its membership, and in which the members can change
// their individual properties.
//
// A good example would be the list of visible wireless network access
// points, where each access point can report dynamic properties such as
// signal strength.
//
// It is important to note that the #GListModel itself does not report
// changes to the individual items.  It only reports changes to the list
// membership.  If you want to observe changes to the objects themselves
// then you need to connect signals to the objects that you are
// interested in.
//
// All items in a #GListModel are of (or derived from) the same type.
// g_list_model_get_item_type() returns that type.  The type may be an
// interface, in which case all objects in the list must implement it.
//
// The semantics are close to that of an array:
// g_list_model_get_n_items() returns the number of items in the list and
// g_list_model_get_item() returns an item at a (0-based) position. In
// order to allow implementations to calculate the list length lazily,
// you can also iterate over items: starting from 0, repeatedly call
// g_list_model_get_item() until it returns %NULL.
//
// An implementation may create objects lazily, but must take care to
// return the same object for a given position until all references to
// it are gone.
//
// On the other side, a consumer is expected only to hold references on
// objects that are currently "user visible", in order to facilitate the
// maximum level of laziness in the implementation of the list and to
// reduce the required number of signal connections at a given time.
//
// This interface is intended only to be used from a single thread.  The
// thread in which it is appropriate to use it depends on the particular
// implementation, but typically it will be from the thread that owns
// the [thread-default main context][g-main-context-push-thread-default]
// in effect at the time that the model was created.
type ListModel interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	GetItem(PositionVar uint) uintptr
	GetItemType() types.GType
	GetNItems() uint
	GetObject(PositionVar uint) *gobject.Object
	ItemsChanged(PositionVar uint, RemovedVar uint, AddedVar uint)
}

var xListModelGLibType func() types.GType

func ListModelGLibType() types.GType {
	return xListModelGLibType()
}

type ListModelBase struct {
	Ptr uintptr
}

func (x *ListModelBase) GoPointer() uintptr {
	return x.Ptr
}

func (x *ListModelBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// See also: g_list_model_get_n_items()
func (x *ListModelBase) GetItem(PositionVar uint) uintptr {

	cret := XGListModelGetItem(x.GoPointer(), PositionVar)
	return cret
}

// Gets the type of the items in @list.
//
// All items returned from g_list_model_get_item() are of the type
// returned by this function, or a subtype, or if the type is an
// interface, they are an implementation of that interface.
//
// The item type of a #GListModel can not change during the life of the
// model.
func (x *ListModelBase) GetItemType() types.GType {

	cret := XGListModelGetItemType(x.GoPointer())
	return cret
}

// Gets the number of items in @list.
//
// Depending on the model implementation, calling this function may be
// less efficient than iterating the list with increasing values for
// @position until g_list_model_get_item() returns %NULL.
func (x *ListModelBase) GetNItems() uint {

	cret := XGListModelGetNItems(x.GoPointer())
	return cret
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// This function is meant to be used by language bindings in place
// of g_list_model_get_item().
//
// See also: g_list_model_get_n_items()
func (x *ListModelBase) GetObject(PositionVar uint) *gobject.Object {
	var cls *gobject.Object

	cret := XGListModelGetObject(x.GoPointer(), PositionVar)

	if cret == 0 {
		return nil
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

// Emits the #GListModel::items-changed signal on @list.
//
// This function should only be called by classes implementing
// #GListModel. It has to be called after the internal representation
// of @list has been updated, because handlers connected to this signal
// might query the new state of the list.
//
// Implementations must only make changes to the model (as visible to
// its consumer) in places that will not cause problems for that
// consumer.  For models that are driven directly by a write API (such
// as #GListStore), changes can be reported in response to uses of that
// API.  For models that represent remote data, changes should only be
// made from a fresh mainloop dispatch.  It is particularly not
// permitted to make changes in response to a call to the #GListModel
// consumer API.
//
// Stated another way: in general, it is assumed that code making a
// series of accesses to the model via the API, without returning to the
// mainloop, and without calling other code, will continue to view the
// same contents of the model.
func (x *ListModelBase) ItemsChanged(PositionVar uint, RemovedVar uint, AddedVar uint) {

	XGListModelItemsChanged(x.GoPointer(), PositionVar, RemovedVar, AddedVar)

}

var XGListModelGetItem func(uintptr, uint) uintptr
var XGListModelGetItemType func(uintptr) types.GType
var XGListModelGetNItems func(uintptr) uint
var XGListModelGetObject func(uintptr, uint) uintptr
var XGListModelItemsChanged func(uintptr, uint, uint, uint)

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xListModelGLibType, lib, "g_list_model_get_type")

	core.PuregoSafeRegister(&XGListModelGetItem, lib, "g_list_model_get_item")
	core.PuregoSafeRegister(&XGListModelGetItemType, lib, "g_list_model_get_item_type")
	core.PuregoSafeRegister(&XGListModelGetNItems, lib, "g_list_model_get_n_items")
	core.PuregoSafeRegister(&XGListModelGetObject, lib, "g_list_model_get_object")
	core.PuregoSafeRegister(&XGListModelItemsChanged, lib, "g_list_model_items_changed")

}
