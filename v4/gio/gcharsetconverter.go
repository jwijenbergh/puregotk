// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type CharsetConverterClass struct {
	ParentClass uintptr
}

func (x *CharsetConverterClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GCharsetConverter is an implementation of #GConverter based on
// GIConv.
type CharsetConverter struct {
	gobject.Object
}

func CharsetConverterNewFromInternalPtr(ptr uintptr) *CharsetConverter {
	cls := &CharsetConverter{}
	cls.Ptr = ptr
	return cls
}

var xNewCharsetConverter func(string, string, **glib.Error) uintptr

// Creates a new #GCharsetConverter.
func NewCharsetConverter(ToCharsetVar string, FromCharsetVar string) (*CharsetConverter, error) {
	var cls *CharsetConverter
	var cerr *glib.Error

	cret := xNewCharsetConverter(ToCharsetVar, FromCharsetVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &CharsetConverter{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xCharsetConverterGetNumFallbacks func(uintptr) uint

// Gets the number of fallbacks that @converter has applied so far.
func (x *CharsetConverter) GetNumFallbacks() uint {

	cret := xCharsetConverterGetNumFallbacks(x.GoPointer())
	return cret
}

var xCharsetConverterGetUseFallback func(uintptr) bool

// Gets the #GCharsetConverter:use-fallback property.
func (x *CharsetConverter) GetUseFallback() bool {

	cret := xCharsetConverterGetUseFallback(x.GoPointer())
	return cret
}

var xCharsetConverterSetUseFallback func(uintptr, bool)

// Sets the #GCharsetConverter:use-fallback property.
func (x *CharsetConverter) SetUseFallback(UseFallbackVar bool) {

	xCharsetConverterSetUseFallback(x.GoPointer(), UseFallbackVar)

}

func (c *CharsetConverter) GoPointer() uintptr {
	return c.Ptr
}

func (c *CharsetConverter) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// This is the main operation used when converting data. It is to be called
// multiple times in a loop, and each time it will do some work, i.e.
// producing some output (in @outbuf) or consuming some input (from @inbuf) or
// both. If its not possible to do any work an error is returned.
//
// Note that a single call may not consume all input (or any input at all).
// Also a call may produce output even if given no input, due to state stored
// in the converter producing output.
//
// If any data was either produced or consumed, and then an error happens, then
// only the successful conversion is reported and the error is returned on the
// next call.
//
// A full conversion loop involves calling this method repeatedly, each time
// giving it new input and space output space. When there is no more input
// data after the data in @inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
// The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
// each time until all data is consumed and all output is produced, then
// %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
// may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
// in a decompression converter where the end of data is detectable from the
// data (and there might even be other data after the end of the compressed data).
//
// When some data has successfully been converted @bytes_read and is set to
// the number of bytes read from @inbuf, and @bytes_written is set to indicate
// how many bytes was written to @outbuf. If there are more data to output
// or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
// %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
// then %G_CONVERTER_FINISHED is returned.
//
// On error %G_CONVERTER_ERROR is returned and @error is set accordingly.
// Some errors need special handling:
//
// %G_IO_ERROR_NO_SPACE is returned if there is not enough space
// to write the resulting converted data, the application should
// call the function again with a larger @outbuf to continue.
//
// %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
// input to fully determine what the conversion should produce,
// and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
// example with an incomplete multibyte sequence when converting text,
// or when a regexp matches up to the end of the input (and may match
// further input). It may also happen when @inbuf_size is zero and
// there is no more data to produce.
//
// When this happens the application should read more input and then
// call the function again. If further input shows that there is no
// more data call the function again with the same data but with
// the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
// to finish as e.g. in the regexp match case (or, to fail again with
// %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
// input is actually partial).
//
// After g_converter_convert() has returned %G_CONVERTER_FINISHED the
// converter object is in an invalid state where its not allowed
// to call g_converter_convert() anymore. At this time you can only
// free the object or call g_converter_reset() to reset it to the
// initial state.
//
// If the flag %G_CONVERTER_FLUSH is set then conversion is modified
// to try to write out all internal state to the output. The application
// has to call the function multiple times with the flag set, and when
// the available input has been consumed and all internal state has
// been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
// really at the end) is returned instead of %G_CONVERTER_CONVERTED.
// This is somewhat similar to what happens at the end of the input stream,
// but done in the middle of the data.
//
// This has different meanings for different conversions. For instance
// in a compression converter it would mean that we flush all the
// compression state into output such that if you uncompress the
// compressed data you get back all the input data. Doing this may
// make the final file larger due to padding though. Another example
// is a regexp conversion, where if you at the end of the flushed data
// have a match, but there is also a potential longer match. In the
// non-flushed case we would ask for more input, but when flushing we
// treat this as the end of input and do the match.
//
// Flushing is not always possible (like if a charset converter flushes
// at a partial multibyte sequence). Converters are supposed to try
// to produce as much output as possible and then return an error
// (typically %G_IO_ERROR_PARTIAL_INPUT).
func (x *CharsetConverter) Convert(InbufVar []byte, InbufSizeVar uint, OutbufVar []byte, OutbufSizeVar uint, FlagsVar ConverterFlags, BytesReadVar uint, BytesWrittenVar uint) (ConverterResult, error) {
	var cerr *glib.Error

	cret := XGConverterConvert(x.GoPointer(), InbufVar, InbufSizeVar, OutbufVar, OutbufSizeVar, FlagsVar, BytesReadVar, BytesWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Resets all internal state in the converter, making it behave
// as if it was just created. If the converter has any internal
// state that would produce output then that output is lost.
func (x *CharsetConverter) Reset() {

	XGConverterReset(x.GoPointer())

}

// Initializes the object implementing the interface.
//
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
//
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
//
// Implementations may also support cancellation. If @cancellable is not %NULL,
// then initialization can be cancelled by triggering the cancellable object
// from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
// the object doesn't support cancellable initialization the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// If the object is not initialized, or initialization returns with an
// error, then all operations on the object except g_object_ref() and
// g_object_unref() are considered to be invalid, and have undefined
// behaviour. See the [introduction][ginitable] for more details.
//
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a classâ€™ implementation of init() can assume
// (and assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
//
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes
// the object; further calls return the result of the first call.
//
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a
// #GObjectClass.constructor that sometimes returns an existing instance.
// In this pattern, a caller would expect to be able to call g_initable_init()
// on the result of g_object_new(), regardless of whether it is in fact a new
// instance.
func (x *CharsetConverter) Init(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGInitableInit(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewCharsetConverter, lib, "g_charset_converter_new")

	core.PuregoSafeRegister(&xCharsetConverterGetNumFallbacks, lib, "g_charset_converter_get_num_fallbacks")
	core.PuregoSafeRegister(&xCharsetConverterGetUseFallback, lib, "g_charset_converter_get_use_fallback")
	core.PuregoSafeRegister(&xCharsetConverterSetUseFallback, lib, "g_charset_converter_set_use_fallback")

}
