// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

var xDbusEscapeObjectPath func(string) string

// This is a language binding friendly version of g_dbus_escape_object_path_bytestring().
func DbusEscapeObjectPath(SVar string) string {

	cret := xDbusEscapeObjectPath(SVar)
	return cret
}

var xDbusEscapeObjectPathBytestring func([]byte) string

// Escapes @bytes for use in a D-Bus object path component.
// @bytes is an array of zero or more nonzero bytes in an
// unspecified encoding, followed by a single zero byte.
//
// The escaping method consists of replacing all non-alphanumeric
// characters (see g_ascii_isalnum()) with their hexadecimal value
// preceded by an underscore (`_`). For example:
// `foo.bar.baz` will become `foo_2ebar_2ebaz`.
//
// This method is appropriate to use when the input is nearly
// a valid object path component but is not when your input
// is far from being a valid object path component.
// Other escaping algorithms are also valid to use with
// D-Bus object paths.
//
// This can be reversed with g_dbus_unescape_object_path().
func DbusEscapeObjectPathBytestring(BytesVar []byte) string {

	cret := xDbusEscapeObjectPathBytestring(BytesVar)
	return cret
}

var xDbusGenerateGuid func() string

// Generate a D-Bus GUID that can be used with
// e.g. g_dbus_connection_new().
//
// See the
// [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#uuids)
// regarding what strings are valid D-Bus GUIDs. The specification refers to
// these as ‘UUIDs’ whereas GLib (for historical reasons) refers to them as
// ‘GUIDs’. The terms are interchangeable.
//
// Note that D-Bus GUIDs do not follow
// [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122).
func DbusGenerateGuid() string {

	cret := xDbusGenerateGuid()
	return cret
}

var xDbusGvalueToGvariant func(*gobject.Value, *glib.VariantType) *glib.Variant

// Converts a #GValue to a #GVariant of the type indicated by the @type
// parameter.
//
// The conversion is using the following rules:
//
// - `G_TYPE_STRING`: 's', 'o', 'g' or 'ay'
// - `G_TYPE_STRV`: 'as', 'ao' or 'aay'
// - `G_TYPE_BOOLEAN`: 'b'
// - `G_TYPE_UCHAR`: 'y'
// - `G_TYPE_INT`: 'i', 'n'
// - `G_TYPE_UINT`: 'u', 'q'
// - `G_TYPE_INT64`: 'x'
// - `G_TYPE_UINT64`: 't'
// - `G_TYPE_DOUBLE`: 'd'
// - `G_TYPE_VARIANT`: Any #GVariantType
//
// This can fail if e.g. @gvalue is of type %G_TYPE_STRING and @type
// is 'i', i.e. %G_VARIANT_TYPE_INT32. It will also fail for any #GType
// (including e.g. %G_TYPE_OBJECT and %G_TYPE_BOXED derived-types) not
// in the table above.
//
// Note that if @gvalue is of type %G_TYPE_VARIANT and its value is
// %NULL, the empty #GVariant instance (never %NULL) for @type is
// returned (e.g. 0 for scalar types, the empty string for string types,
// '/' for object path types, the empty array for any array type and so on).
//
// See the g_dbus_gvariant_to_gvalue() function for how to convert a
// #GVariant to a #GValue.
func DbusGvalueToGvariant(GvalueVar *gobject.Value, TypeVar *glib.VariantType) *glib.Variant {

	cret := xDbusGvalueToGvariant(GvalueVar, TypeVar)
	return cret
}

var xDbusGvariantToGvalue func(*glib.Variant, *gobject.Value)

// Converts a #GVariant to a #GValue. If @value is floating, it is consumed.
//
// The rules specified in the g_dbus_gvalue_to_gvariant() function are
// used - this function is essentially its reverse form. So, a #GVariant
// containing any basic or string array type will be converted to a #GValue
// containing a basic value or string array. Any other #GVariant (handle,
// variant, tuple, dict entry) will be converted to a #GValue containing that
// #GVariant.
//
// The conversion never fails - a valid #GValue is always returned in
// @out_gvalue.
func DbusGvariantToGvalue(ValueVar *glib.Variant, OutGvalueVar *gobject.Value) {

	xDbusGvariantToGvalue(ValueVar, OutGvalueVar)

}

var xDbusIsErrorName func(string) bool

// Check whether @string is a valid D-Bus error name.
//
// This function returns the same result as g_dbus_is_interface_name(),
// because D-Bus error names are defined to have exactly the
// same syntax as interface names.
func DbusIsErrorName(StringVar string) bool {

	cret := xDbusIsErrorName(StringVar)
	return cret
}

var xDbusIsGuid func(string) bool

// Checks if @string is a D-Bus GUID.
//
// See the documentation for g_dbus_generate_guid() for more information about
// the format of a GUID.
func DbusIsGuid(StringVar string) bool {

	cret := xDbusIsGuid(StringVar)
	return cret
}

var xDbusIsInterfaceName func(string) bool

// Checks if @string is a valid D-Bus interface name.
func DbusIsInterfaceName(StringVar string) bool {

	cret := xDbusIsInterfaceName(StringVar)
	return cret
}

var xDbusIsMemberName func(string) bool

// Checks if @string is a valid D-Bus member (e.g. signal or method) name.
func DbusIsMemberName(StringVar string) bool {

	cret := xDbusIsMemberName(StringVar)
	return cret
}

var xDbusIsName func(string) bool

// Checks if @string is a valid D-Bus bus name (either unique or well-known).
func DbusIsName(StringVar string) bool {

	cret := xDbusIsName(StringVar)
	return cret
}

var xDbusIsUniqueName func(string) bool

// Checks if @string is a valid D-Bus unique bus name.
func DbusIsUniqueName(StringVar string) bool {

	cret := xDbusIsUniqueName(StringVar)
	return cret
}

var xDbusUnescapeObjectPath func(string) []byte

// Unescapes an string that was previously escaped with
// g_dbus_escape_object_path(). If the string is in a format that could
// not have been returned by g_dbus_escape_object_path(), this function
// returns %NULL.
//
// Encoding alphanumeric characters which do not need to be
// encoded is not allowed (e.g `_63` is not valid, the string
// should contain `c` instead).
func DbusUnescapeObjectPath(SVar string) []byte {

	cret := xDbusUnescapeObjectPath(SVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xDbusEscapeObjectPath, lib, "g_dbus_escape_object_path")
	core.PuregoSafeRegister(&xDbusEscapeObjectPathBytestring, lib, "g_dbus_escape_object_path_bytestring")
	core.PuregoSafeRegister(&xDbusGenerateGuid, lib, "g_dbus_generate_guid")
	core.PuregoSafeRegister(&xDbusGvalueToGvariant, lib, "g_dbus_gvalue_to_gvariant")
	core.PuregoSafeRegister(&xDbusGvariantToGvalue, lib, "g_dbus_gvariant_to_gvalue")
	core.PuregoSafeRegister(&xDbusIsErrorName, lib, "g_dbus_is_error_name")
	core.PuregoSafeRegister(&xDbusIsGuid, lib, "g_dbus_is_guid")
	core.PuregoSafeRegister(&xDbusIsInterfaceName, lib, "g_dbus_is_interface_name")
	core.PuregoSafeRegister(&xDbusIsMemberName, lib, "g_dbus_is_member_name")
	core.PuregoSafeRegister(&xDbusIsName, lib, "g_dbus_is_name")
	core.PuregoSafeRegister(&xDbusIsUniqueName, lib, "g_dbus_is_unique_name")
	core.PuregoSafeRegister(&xDbusUnescapeObjectPath, lib, "g_dbus_unescape_object_path")

}
