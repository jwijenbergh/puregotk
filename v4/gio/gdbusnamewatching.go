// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// Invoked when the name being watched is known to have to have an owner.
type BusNameAppearedCallback func(uintptr, string, string, uintptr)

// Invoked when the name being watched is known not to have to have an owner.
//
// This is also invoked when the #GDBusConnection on which the watch was
// established has been closed.  In that case, @connection will be
// %NULL.
type BusNameVanishedCallback func(uintptr, string, uintptr)

var xBusUnwatchName func(uint)

// Stops watching a name.
//
// Note that there may still be D-Bus traffic to process (relating to watching
// and unwatching the name) in the current thread-default #GMainContext after
// this function has returned. You should continue to iterate the #GMainContext
// until the #GDestroyNotify function passed to g_bus_watch_name() is called, in
// order to avoid memory leaks through callbacks queued on the #GMainContext
// after itâ€™s stopped being iterated.
func BusUnwatchName(WatcherIdVar uint) {

	xBusUnwatchName(WatcherIdVar)

}

var xBusWatchName func(BusType, string, BusNameWatcherFlags, uintptr, uintptr, uintptr, uintptr) uint

// Starts watching @name on the bus specified by @bus_type and calls
// @name_appeared_handler and @name_vanished_handler when the name is
// known to have an owner respectively known to lose its
// owner. Callbacks will be invoked in the
// [thread-default main context][g-main-context-push-thread-default]
// of the thread you are calling this function from.
//
// You are guaranteed that one of the handlers will be invoked after
// calling this function. When you are done watching the name, just
// call g_bus_unwatch_name() with the watcher id this function
// returns.
//
// If the name vanishes or appears (for example the application owning
// the name could restart), the handlers are also invoked. If the
// #GDBusConnection that is used for watching the name disconnects, then
// @name_vanished_handler is invoked since it is no longer
// possible to access the name.
//
// Another guarantee is that invocations of @name_appeared_handler
// and @name_vanished_handler are guaranteed to alternate; that
// is, if @name_appeared_handler is invoked then you are
// guaranteed that the next time one of the handlers is invoked, it
// will be @name_vanished_handler. The reverse is also true.
//
// This behavior makes it very simple to write applications that want
// to take action when a certain [name exists][gdbus-watching-names].
// Basically, the application should create object proxies in
// @name_appeared_handler and destroy them again (if any) in
// @name_vanished_handler.
func BusWatchName(BusTypeVar BusType, NameVar string, FlagsVar BusNameWatcherFlags, NameAppearedHandlerVar *BusNameAppearedCallback, NameVanishedHandlerVar *BusNameVanishedCallback, UserDataVar uintptr, UserDataFreeFuncVar *glib.DestroyNotify) uint {

	cret := xBusWatchName(BusTypeVar, NameVar, FlagsVar, glib.NewCallback(NameAppearedHandlerVar), glib.NewCallback(NameVanishedHandlerVar), UserDataVar, glib.NewCallback(UserDataFreeFuncVar))
	return cret
}

var xBusWatchNameOnConnection func(uintptr, string, BusNameWatcherFlags, uintptr, uintptr, uintptr, uintptr) uint

// Like g_bus_watch_name() but takes a #GDBusConnection instead of a
// #GBusType.
func BusWatchNameOnConnection(ConnectionVar *DBusConnection, NameVar string, FlagsVar BusNameWatcherFlags, NameAppearedHandlerVar *BusNameAppearedCallback, NameVanishedHandlerVar *BusNameVanishedCallback, UserDataVar uintptr, UserDataFreeFuncVar *glib.DestroyNotify) uint {

	cret := xBusWatchNameOnConnection(ConnectionVar.GoPointer(), NameVar, FlagsVar, glib.NewCallback(NameAppearedHandlerVar), glib.NewCallback(NameVanishedHandlerVar), UserDataVar, glib.NewCallback(UserDataFreeFuncVar))
	return cret
}

var xBusWatchNameOnConnectionWithClosures func(uintptr, string, BusNameWatcherFlags, *gobject.Closure, *gobject.Closure) uint

// Version of g_bus_watch_name_on_connection() using closures instead of callbacks for
// easier binding in other languages.
func BusWatchNameOnConnectionWithClosures(ConnectionVar *DBusConnection, NameVar string, FlagsVar BusNameWatcherFlags, NameAppearedClosureVar *gobject.Closure, NameVanishedClosureVar *gobject.Closure) uint {

	cret := xBusWatchNameOnConnectionWithClosures(ConnectionVar.GoPointer(), NameVar, FlagsVar, NameAppearedClosureVar, NameVanishedClosureVar)
	return cret
}

var xBusWatchNameWithClosures func(BusType, string, BusNameWatcherFlags, *gobject.Closure, *gobject.Closure) uint

// Version of g_bus_watch_name() using closures instead of callbacks for
// easier binding in other languages.
func BusWatchNameWithClosures(BusTypeVar BusType, NameVar string, FlagsVar BusNameWatcherFlags, NameAppearedClosureVar *gobject.Closure, NameVanishedClosureVar *gobject.Closure) uint {

	cret := xBusWatchNameWithClosures(BusTypeVar, NameVar, FlagsVar, NameAppearedClosureVar, NameVanishedClosureVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xBusUnwatchName, lib, "g_bus_unwatch_name")
	core.PuregoSafeRegister(&xBusWatchName, lib, "g_bus_watch_name")
	core.PuregoSafeRegister(&xBusWatchNameOnConnection, lib, "g_bus_watch_name_on_connection")
	core.PuregoSafeRegister(&xBusWatchNameOnConnectionWithClosures, lib, "g_bus_watch_name_on_connection_with_closures")
	core.PuregoSafeRegister(&xBusWatchNameWithClosures, lib, "g_bus_watch_name_with_closures")

}
