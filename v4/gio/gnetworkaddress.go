// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type NetworkAddressClass struct {
	ParentClass uintptr
}

func (x *NetworkAddressClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type NetworkAddressPrivate struct {
}

func (x *NetworkAddressPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GNetworkAddress provides an easy way to resolve a hostname and
// then attempt to connect to that host, handling the possibility of
// multiple IP addresses and multiple address families.
//
// The enumeration results of resolved addresses *may* be cached as long
// as this object is kept alive which may have unexpected results if
// alive for too long.
//
// See #GSocketConnectable for an example of using the connectable
// interface.
type NetworkAddress struct {
	gobject.Object
}

var xNetworkAddressGLibType func() types.GType

func NetworkAddressGLibType() types.GType {
	return xNetworkAddressGLibType()
}

func NetworkAddressNewFromInternalPtr(ptr uintptr) *NetworkAddress {
	cls := &NetworkAddress{}
	cls.Ptr = ptr
	return cls
}

var xNewNetworkAddress func(string, uint16) uintptr

// Creates a new #GSocketConnectable for connecting to the given
// @hostname and @port.
//
// Note that depending on the configuration of the machine, a
// @hostname of `localhost` may refer to the IPv4 loopback address
// only, or to both IPv4 and IPv6; use
// g_network_address_new_loopback() to create a #GNetworkAddress that
// is guaranteed to resolve to both addresses.
func NewNetworkAddress(HostnameVar string, PortVar uint16) *NetworkAddress {
	var cls *NetworkAddress

	cret := xNewNetworkAddress(HostnameVar, PortVar)

	if cret == 0 {
		return nil
	}
	cls = &NetworkAddress{}
	cls.Ptr = cret
	return cls
}

var xNewNetworkAddressLoopback func(uint16) uintptr

// Creates a new #GSocketConnectable for connecting to the local host
// over a loopback connection to the given @port. This is intended for
// use in connecting to local services which may be running on IPv4 or
// IPv6.
//
// The connectable will return IPv4 and IPv6 loopback addresses,
// regardless of how the host resolves `localhost`. By contrast,
// g_network_address_new() will often only return an IPv4 address when
// resolving `localhost`, and an IPv6 address for `localhost6`.
//
// g_network_address_get_hostname() will always return `localhost` for
// a #GNetworkAddress created with this constructor.
func NewNetworkAddressLoopback(PortVar uint16) *NetworkAddress {
	var cls *NetworkAddress

	cret := xNewNetworkAddressLoopback(PortVar)

	if cret == 0 {
		return nil
	}
	cls = &NetworkAddress{}
	cls.Ptr = cret
	return cls
}

var xNetworkAddressGetHostname func(uintptr) string

// Gets @addr's hostname. This might be either UTF-8 or ASCII-encoded,
// depending on what @addr was created with.
func (x *NetworkAddress) GetHostname() string {

	cret := xNetworkAddressGetHostname(x.GoPointer())
	return cret
}

var xNetworkAddressGetPort func(uintptr) uint16

// Gets @addr's port number
func (x *NetworkAddress) GetPort() uint16 {

	cret := xNetworkAddressGetPort(x.GoPointer())
	return cret
}

var xNetworkAddressGetScheme func(uintptr) string

// Gets @addr's scheme
func (x *NetworkAddress) GetScheme() string {

	cret := xNetworkAddressGetScheme(x.GoPointer())
	return cret
}

func (c *NetworkAddress) GoPointer() uintptr {
	return c.Ptr
}

func (c *NetworkAddress) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Creates a #GSocketAddressEnumerator for @connectable.
func (x *NetworkAddress) Enumerate() *SocketAddressEnumerator {
	var cls *SocketAddressEnumerator

	cret := XGSocketConnectableEnumerate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &SocketAddressEnumerator{}
	cls.Ptr = cret
	return cls
}

// Creates a #GSocketAddressEnumerator for @connectable that will
// return a #GProxyAddress for each of its addresses that you must connect
// to via a proxy.
//
// If @connectable does not implement
// g_socket_connectable_proxy_enumerate(), this will fall back to
// calling g_socket_connectable_enumerate().
func (x *NetworkAddress) ProxyEnumerate() *SocketAddressEnumerator {
	var cls *SocketAddressEnumerator

	cret := XGSocketConnectableProxyEnumerate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &SocketAddressEnumerator{}
	cls.Ptr = cret
	return cls
}

// Format a #GSocketConnectable as a string. This is a human-readable format for
// use in debugging output, and is not a stable serialization format. It is not
// suitable for use in user interfaces as it exposes too much information for a
// user.
//
// If the #GSocketConnectable implementation does not support string formatting,
// the implementationâ€™s type name will be returned as a fallback.
func (x *NetworkAddress) ToString() string {

	cret := XGSocketConnectableToString(x.GoPointer())
	return cret
}

var xNetworkAddressParse func(string, uint16, **glib.Error) uintptr

// Creates a new #GSocketConnectable for connecting to the given
// @hostname and @port. May fail and return %NULL in case
// parsing @host_and_port fails.
//
// @host_and_port may be in any of a number of recognised formats; an IPv6
// address, an IPv4 address, or a domain name (in which case a DNS
// lookup is performed). Quoting with [] is supported for all address
// types. A port override may be specified in the usual way with a
// colon.
//
// If no port is specified in @host_and_port then @default_port will be
// used as the port number to connect to.
//
// In general, @host_and_port is expected to be provided by the user
// (allowing them to give the hostname, and a port override if necessary)
// and @default_port is expected to be provided by the application.
//
// (The port component of @host_and_port can also be specified as a
// service name rather than as a numeric port, but this functionality
// is deprecated, because it depends on the contents of /etc/services,
// which is generally quite sparse on platforms other than Linux.)
func NetworkAddressParse(HostAndPortVar string, DefaultPortVar uint16) (*NetworkAddress, error) {
	var cls *NetworkAddress
	var cerr *glib.Error

	cret := xNetworkAddressParse(HostAndPortVar, DefaultPortVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &NetworkAddress{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNetworkAddressParseUri func(string, uint16, **glib.Error) uintptr

// Creates a new #GSocketConnectable for connecting to the given
// @uri. May fail and return %NULL in case parsing @uri fails.
//
// Using this rather than g_network_address_new() or
// g_network_address_parse() allows #GSocketClient to determine
// when to use application-specific proxy protocols.
func NetworkAddressParseUri(UriVar string, DefaultPortVar uint16) (*NetworkAddress, error) {
	var cls *NetworkAddress
	var cerr *glib.Error

	cret := xNetworkAddressParseUri(UriVar, DefaultPortVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &NetworkAddress{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNetworkAddressGLibType, lib, "g_network_address_get_type")

	core.PuregoSafeRegister(&xNewNetworkAddress, lib, "g_network_address_new")
	core.PuregoSafeRegister(&xNewNetworkAddressLoopback, lib, "g_network_address_new_loopback")

	core.PuregoSafeRegister(&xNetworkAddressGetHostname, lib, "g_network_address_get_hostname")
	core.PuregoSafeRegister(&xNetworkAddressGetPort, lib, "g_network_address_get_port")
	core.PuregoSafeRegister(&xNetworkAddressGetScheme, lib, "g_network_address_get_scheme")

	core.PuregoSafeRegister(&xNetworkAddressParse, lib, "g_network_address_parse")
	core.PuregoSafeRegister(&xNetworkAddressParseUri, lib, "g_network_address_parse_uri")

}
