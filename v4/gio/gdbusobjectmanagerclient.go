// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Class structure for #GDBusObjectManagerClient.
type DBusObjectManagerClientClass struct {
	ParentClass uintptr

	Padding [8]uintptr
}

func (x *DBusObjectManagerClientClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type DBusObjectManagerClientPrivate struct {
}

func (x *DBusObjectManagerClientPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GDBusObjectManagerClient is used to create, monitor and delete object
// proxies for remote objects exported by a #GDBusObjectManagerServer (or any
// code implementing the
// [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface).
//
// Once an instance of this type has been created, you can connect to
// the #GDBusObjectManager::object-added and
// #GDBusObjectManager::object-removed signals and inspect the
// #GDBusObjectProxy objects returned by
// g_dbus_object_manager_get_objects().
//
// If the name for a #GDBusObjectManagerClient is not owned by anyone at
// object construction time, the default behavior is to request the
// message bus to launch an owner for the name. This behavior can be
// disabled using the %G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START
// flag. It's also worth noting that this only works if the name of
// interest is activatable in the first place. E.g. in some cases it
// is not possible to launch an owner for the requested name. In this
// case, #GDBusObjectManagerClient object construction still succeeds but
// there will be no object proxies
// (e.g. g_dbus_object_manager_get_objects() returns the empty list) and
// the #GDBusObjectManagerClient:name-owner property is %NULL.
//
// The owner of the requested name can come and go (for example
// consider a system service being restarted) â€“ #GDBusObjectManagerClient
// handles this case too; simply connect to the #GObject::notify
// signal to watch for changes on the #GDBusObjectManagerClient:name-owner
// property. When the name owner vanishes, the behavior is that
// #GDBusObjectManagerClient:name-owner is set to %NULL (this includes
// emission of the #GObject::notify signal) and then
// #GDBusObjectManager::object-removed signals are synthesized
// for all currently existing object proxies. Since
// #GDBusObjectManagerClient:name-owner is %NULL when this happens, you can
// use this information to disambiguate a synthesized signal from a
// genuine signal caused by object removal on the remote
// #GDBusObjectManager. Similarly, when a new name owner appears,
// #GDBusObjectManager::object-added signals are synthesized
// while #GDBusObjectManagerClient:name-owner is still %NULL. Only when all
// object proxies have been added, the #GDBusObjectManagerClient:name-owner
// is set to the new name owner (this includes emission of the
// #GObject::notify signal).  Furthermore, you are guaranteed that
// #GDBusObjectManagerClient:name-owner will alternate between a name owner
// (e.g. `:1.42`) and %NULL even in the case where
// the name of interest is atomically replaced
//
// Ultimately, #GDBusObjectManagerClient is used to obtain #GDBusProxy
// instances. All signals (including the
// org.freedesktop.DBus.Properties::PropertiesChanged signal)
// delivered to #GDBusProxy instances are guaranteed to originate
// from the name owner. This guarantee along with the behavior
// described above, means that certain race conditions including the
// "half the proxy is from the old owner and the other half is from
// the new owner" problem cannot happen.
//
// To avoid having the application connect to signals on the returned
// #GDBusObjectProxy and #GDBusProxy objects, the
// #GDBusObject::interface-added,
// #GDBusObject::interface-removed,
// #GDBusProxy::g-properties-changed and
// #GDBusProxy::g-signal signals
// are also emitted on the #GDBusObjectManagerClient instance managing these
// objects. The signals emitted are
// #GDBusObjectManager::interface-added,
// #GDBusObjectManager::interface-removed,
// #GDBusObjectManagerClient::interface-proxy-properties-changed and
// #GDBusObjectManagerClient::interface-proxy-signal.
//
// Note that all callbacks and signals are emitted in the
// [thread-default main context][g-main-context-push-thread-default]
// that the #GDBusObjectManagerClient object was constructed
// in. Additionally, the #GDBusObjectProxy and #GDBusProxy objects
// originating from the #GDBusObjectManagerClient object will be created in
// the same context and, consequently, will deliver signals in the
// same main loop.
type DBusObjectManagerClient struct {
	gobject.Object
}

var xDBusObjectManagerClientGLibType func() types.GType

func DBusObjectManagerClientGLibType() types.GType {
	return xDBusObjectManagerClientGLibType()
}

func DBusObjectManagerClientNewFromInternalPtr(ptr uintptr) *DBusObjectManagerClient {
	cls := &DBusObjectManagerClient{}
	cls.Ptr = ptr
	return cls
}

var xNewDBusObjectManagerClientFinish func(uintptr, **glib.Error) uintptr

// Finishes an operation started with g_dbus_object_manager_client_new().
func NewDBusObjectManagerClientFinish(ResVar AsyncResult) (*DBusObjectManagerClient, error) {
	var cls *DBusObjectManagerClient
	var cerr *glib.Error

	cret := xNewDBusObjectManagerClientFinish(ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusObjectManagerClient{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewDBusObjectManagerClientForBusFinish func(uintptr, **glib.Error) uintptr

// Finishes an operation started with g_dbus_object_manager_client_new_for_bus().
func NewDBusObjectManagerClientForBusFinish(ResVar AsyncResult) (*DBusObjectManagerClient, error) {
	var cls *DBusObjectManagerClient
	var cerr *glib.Error

	cret := xNewDBusObjectManagerClientForBusFinish(ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusObjectManagerClient{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewDBusObjectManagerClientForBusSync func(BusType, DBusObjectManagerClientFlags, string, string, uintptr, uintptr, uintptr, uintptr, **glib.Error) uintptr

// Like g_dbus_object_manager_client_new_sync() but takes a #GBusType instead
// of a #GDBusConnection.
//
// This is a synchronous failable constructor - the calling thread is
// blocked until a reply is received. See g_dbus_object_manager_client_new_for_bus()
// for the asynchronous version.
func NewDBusObjectManagerClientForBusSync(BusTypeVar BusType, FlagsVar DBusObjectManagerClientFlags, NameVar string, ObjectPathVar string, GetProxyTypeFuncVar *DBusProxyTypeFunc, GetProxyTypeUserDataVar uintptr, GetProxyTypeDestroyNotifyVar *glib.DestroyNotify, CancellableVar *Cancellable) (*DBusObjectManagerClient, error) {
	var cls *DBusObjectManagerClient
	var cerr *glib.Error

	cret := xNewDBusObjectManagerClientForBusSync(BusTypeVar, FlagsVar, NameVar, ObjectPathVar, glib.NewCallback(GetProxyTypeFuncVar), GetProxyTypeUserDataVar, glib.NewCallback(GetProxyTypeDestroyNotifyVar), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusObjectManagerClient{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewDBusObjectManagerClientSync func(uintptr, DBusObjectManagerClientFlags, string, string, uintptr, uintptr, uintptr, uintptr, **glib.Error) uintptr

// Creates a new #GDBusObjectManagerClient object.
//
// This is a synchronous failable constructor - the calling thread is
// blocked until a reply is received. See g_dbus_object_manager_client_new()
// for the asynchronous version.
func NewDBusObjectManagerClientSync(ConnectionVar *DBusConnection, FlagsVar DBusObjectManagerClientFlags, NameVar string, ObjectPathVar string, GetProxyTypeFuncVar *DBusProxyTypeFunc, GetProxyTypeUserDataVar uintptr, GetProxyTypeDestroyNotifyVar *glib.DestroyNotify, CancellableVar *Cancellable) (*DBusObjectManagerClient, error) {
	var cls *DBusObjectManagerClient
	var cerr *glib.Error

	cret := xNewDBusObjectManagerClientSync(ConnectionVar.GoPointer(), FlagsVar, NameVar, ObjectPathVar, glib.NewCallback(GetProxyTypeFuncVar), GetProxyTypeUserDataVar, glib.NewCallback(GetProxyTypeDestroyNotifyVar), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusObjectManagerClient{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDBusObjectManagerClientGetConnection func(uintptr) uintptr

// Gets the #GDBusConnection used by @manager.
func (x *DBusObjectManagerClient) GetConnection() *DBusConnection {
	var cls *DBusConnection

	cret := xDBusObjectManagerClientGetConnection(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &DBusConnection{}
	cls.Ptr = cret
	return cls
}

var xDBusObjectManagerClientGetFlags func(uintptr) DBusObjectManagerClientFlags

// Gets the flags that @manager was constructed with.
func (x *DBusObjectManagerClient) GetFlags() DBusObjectManagerClientFlags {

	cret := xDBusObjectManagerClientGetFlags(x.GoPointer())
	return cret
}

var xDBusObjectManagerClientGetName func(uintptr) string

// Gets the name that @manager is for, or %NULL if not a message bus
// connection.
func (x *DBusObjectManagerClient) GetName() string {

	cret := xDBusObjectManagerClientGetName(x.GoPointer())
	return cret
}

var xDBusObjectManagerClientGetNameOwner func(uintptr) string

// The unique name that owns the name that @manager is for or %NULL if
// no-one currently owns that name. You can connect to the
// #GObject::notify signal to track changes to the
// #GDBusObjectManagerClient:name-owner property.
func (x *DBusObjectManagerClient) GetNameOwner() string {

	cret := xDBusObjectManagerClientGetNameOwner(x.GoPointer())
	return cret
}

func (c *DBusObjectManagerClient) GoPointer() uintptr {
	return c.Ptr
}

func (c *DBusObjectManagerClient) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when one or more D-Bus properties on proxy changes. The
// local cache has already been updated when this signal fires. Note
// that both @changed_properties and @invalidated_properties are
// guaranteed to never be %NULL (either may be empty though).
//
// This signal exists purely as a convenience to avoid having to
// connect signals to all interface proxies managed by @manager.
//
// This signal is emitted in the
// [thread-default main context][g-main-context-push-thread-default]
// that @manager was constructed in.
func (x *DBusObjectManagerClient) ConnectInterfaceProxyPropertiesChanged(cb *func(DBusObjectManagerClient, uintptr, uintptr, uintptr, []string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "interface-proxy-properties-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ObjectProxyVarp uintptr, InterfaceProxyVarp uintptr, ChangedPropertiesVarp uintptr, InvalidatedPropertiesVarp []string) {
		fa := DBusObjectManagerClient{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ObjectProxyVarp, InterfaceProxyVarp, ChangedPropertiesVarp, InvalidatedPropertiesVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "interface-proxy-properties-changed", cbRefPtr)
}

// Emitted when a D-Bus signal is received on @interface_proxy.
//
// This signal exists purely as a convenience to avoid having to
// connect signals to all interface proxies managed by @manager.
//
// This signal is emitted in the
// [thread-default main context][g-main-context-push-thread-default]
// that @manager was constructed in.
func (x *DBusObjectManagerClient) ConnectInterfaceProxySignal(cb *func(DBusObjectManagerClient, uintptr, uintptr, string, string, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "interface-proxy-signal", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ObjectProxyVarp uintptr, InterfaceProxyVarp uintptr, SenderNameVarp string, SignalNameVarp string, ParametersVarp uintptr) {
		fa := DBusObjectManagerClient{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ObjectProxyVarp, InterfaceProxyVarp, SenderNameVarp, SignalNameVarp, ParametersVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "interface-proxy-signal", cbRefPtr)
}

// Starts asynchronous initialization of the object implementing the
// interface. This must be done before any real use of the object after
// initial construction. If the object also implements #GInitable you can
// optionally call g_initable_init() instead.
//
// This method is intended for language bindings. If writing in C,
// g_async_initable_new_async() should typically be used instead.
//
// When the initialization is finished, @callback will be called. You can
// then call g_async_initable_init_finish() to get the result of the
// initialization.
//
// Implementations may also support cancellation. If @cancellable is not
// %NULL, then initialization can be cancelled by triggering the cancellable
// object from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
// the object doesn't support cancellable initialization, the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// As with #GInitable, if the object is not initialized, or initialization
// returns with an error, then all operations on the object except
// g_object_ref() and g_object_unref() are considered to be invalid, and
// have undefined behaviour. They will often fail with g_critical() or
// g_warning(), but this must not be relied on.
//
// Callers should not assume that a class which implements #GAsyncInitable can
// be initialized multiple times; for more information, see g_initable_init().
// If a class explicitly supports being initialized multiple times,
// implementation requires yielding all subsequent calls to init_async() on the
// results of the first call.
//
// For classes that also support the #GInitable interface, the default
// implementation of this method will run the g_initable_init() function
// in a thread, so if you want to support asynchronous initialization via
// threads, just implement the #GAsyncInitable interface without overriding
// any interface methods.
func (x *DBusObjectManagerClient) InitAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGAsyncInitableInitAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes asynchronous initialization and returns the result.
// See g_async_initable_init_async().
func (x *DBusObjectManagerClient) InitFinish(ResVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGAsyncInitableInitFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Finishes the async construction for the various g_async_initable_new
// calls, returning the created object or %NULL on error.
func (x *DBusObjectManagerClient) NewFinish(ResVar AsyncResult) (*gobject.Object, error) {
	var cls *gobject.Object
	var cerr *glib.Error

	cret := XGAsyncInitableNewFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Gets the interface proxy for @interface_name at @object_path, if
// any.
func (x *DBusObjectManagerClient) GetInterface(ObjectPathVar string, InterfaceNameVar string) *DBusInterfaceBase {
	var cls *DBusInterfaceBase

	cret := XGDbusObjectManagerGetInterface(x.GoPointer(), ObjectPathVar, InterfaceNameVar)

	if cret == 0 {
		return nil
	}
	cls = &DBusInterfaceBase{}
	cls.Ptr = cret
	return cls
}

// Gets the #GDBusObject at @object_path, if any.
func (x *DBusObjectManagerClient) GetObject(ObjectPathVar string) *DBusObjectBase {
	var cls *DBusObjectBase

	cret := XGDbusObjectManagerGetObject(x.GoPointer(), ObjectPathVar)

	if cret == 0 {
		return nil
	}
	cls = &DBusObjectBase{}
	cls.Ptr = cret
	return cls
}

// Gets the object path that @manager is for.
func (x *DBusObjectManagerClient) GetObjectPath() string {

	cret := XGDbusObjectManagerGetObjectPath(x.GoPointer())
	return cret
}

// Gets all #GDBusObject objects known to @manager.
func (x *DBusObjectManagerClient) GetObjects() *glib.List {

	cret := XGDbusObjectManagerGetObjects(x.GoPointer())
	return cret
}

// Initializes the object implementing the interface.
//
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
//
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
//
// Implementations may also support cancellation. If @cancellable is not %NULL,
// then initialization can be cancelled by triggering the cancellable object
// from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
// the object doesn't support cancellable initialization the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// If the object is not initialized, or initialization returns with an
// error, then all operations on the object except g_object_ref() and
// g_object_unref() are considered to be invalid, and have undefined
// behaviour. See the [introduction][ginitable] for more details.
//
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a classâ€™ implementation of init() can assume
// (and assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
//
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes
// the object; further calls return the result of the first call.
//
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a
// #GObjectClass.constructor that sometimes returns an existing instance.
// In this pattern, a caller would expect to be able to call g_initable_init()
// on the result of g_object_new(), regardless of whether it is in fact a new
// instance.
func (x *DBusObjectManagerClient) Init(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGInitableInit(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDBusObjectManagerClientNew func(uintptr, DBusObjectManagerClientFlags, string, string, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr)

// Asynchronously creates a new #GDBusObjectManagerClient object.
//
// This is an asynchronous failable constructor. When the result is
// ready, @callback will be invoked in the
// [thread-default main context][g-main-context-push-thread-default]
// of the thread you are calling this method from. You can
// then call g_dbus_object_manager_client_new_finish() to get the result. See
// g_dbus_object_manager_client_new_sync() for the synchronous version.
func DBusObjectManagerClientNew(ConnectionVar *DBusConnection, FlagsVar DBusObjectManagerClientFlags, NameVar string, ObjectPathVar string, GetProxyTypeFuncVar *DBusProxyTypeFunc, GetProxyTypeUserDataVar uintptr, GetProxyTypeDestroyNotifyVar *glib.DestroyNotify, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusObjectManagerClientNew(ConnectionVar.GoPointer(), FlagsVar, NameVar, ObjectPathVar, glib.NewCallback(GetProxyTypeFuncVar), GetProxyTypeUserDataVar, glib.NewCallback(GetProxyTypeDestroyNotifyVar), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xDBusObjectManagerClientNewForBus func(BusType, DBusObjectManagerClientFlags, string, string, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr)

// Like g_dbus_object_manager_client_new() but takes a #GBusType instead of a
// #GDBusConnection.
//
// This is an asynchronous failable constructor. When the result is
// ready, @callback will be invoked in the
// [thread-default main loop][g-main-context-push-thread-default]
// of the thread you are calling this method from. You can
// then call g_dbus_object_manager_client_new_for_bus_finish() to get the result. See
// g_dbus_object_manager_client_new_for_bus_sync() for the synchronous version.
func DBusObjectManagerClientNewForBus(BusTypeVar BusType, FlagsVar DBusObjectManagerClientFlags, NameVar string, ObjectPathVar string, GetProxyTypeFuncVar *DBusProxyTypeFunc, GetProxyTypeUserDataVar uintptr, GetProxyTypeDestroyNotifyVar *glib.DestroyNotify, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDBusObjectManagerClientNewForBus(BusTypeVar, FlagsVar, NameVar, ObjectPathVar, glib.NewCallback(GetProxyTypeFuncVar), GetProxyTypeUserDataVar, glib.NewCallback(GetProxyTypeDestroyNotifyVar), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xDBusObjectManagerClientGLibType, lib, "g_dbus_object_manager_client_get_type")

	core.PuregoSafeRegister(&xNewDBusObjectManagerClientFinish, lib, "g_dbus_object_manager_client_new_finish")
	core.PuregoSafeRegister(&xNewDBusObjectManagerClientForBusFinish, lib, "g_dbus_object_manager_client_new_for_bus_finish")
	core.PuregoSafeRegister(&xNewDBusObjectManagerClientForBusSync, lib, "g_dbus_object_manager_client_new_for_bus_sync")
	core.PuregoSafeRegister(&xNewDBusObjectManagerClientSync, lib, "g_dbus_object_manager_client_new_sync")

	core.PuregoSafeRegister(&xDBusObjectManagerClientGetConnection, lib, "g_dbus_object_manager_client_get_connection")
	core.PuregoSafeRegister(&xDBusObjectManagerClientGetFlags, lib, "g_dbus_object_manager_client_get_flags")
	core.PuregoSafeRegister(&xDBusObjectManagerClientGetName, lib, "g_dbus_object_manager_client_get_name")
	core.PuregoSafeRegister(&xDBusObjectManagerClientGetNameOwner, lib, "g_dbus_object_manager_client_get_name_owner")

	core.PuregoSafeRegister(&xDBusObjectManagerClientNew, lib, "g_dbus_object_manager_client_new")
	core.PuregoSafeRegister(&xDBusObjectManagerClientNewForBus, lib, "g_dbus_object_manager_client_new_for_bus")

}
