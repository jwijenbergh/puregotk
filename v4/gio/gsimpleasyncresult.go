// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type SimpleAsyncResultClass struct {
	_ structs.HostLayout
}

func (x *SimpleAsyncResultClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xSimpleAsyncReportErrorInIdle func(uintptr, uintptr, uintptr, glib.Quark, int, string, ...interface{})

// Reports an error in an asynchronous function in an idle function by
// directly setting the contents of the #GAsyncResult with the given error
// information.
func SimpleAsyncReportErrorInIdle(ObjectVar *gobject.Object, CallbackVar *AsyncReadyCallback, UserDataVar uintptr, DomainVar glib.Quark, CodeVar int, FormatVar string, varArgs ...interface{}) {

	xSimpleAsyncReportErrorInIdle(ObjectVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar, DomainVar, CodeVar, FormatVar, varArgs...)

}

var xSimpleAsyncReportGerrorInIdle func(uintptr, uintptr, uintptr, *glib.Error)

// Reports an error in an idle function. Similar to
// g_simple_async_report_error_in_idle(), but takes a #GError rather
// than building a new one.
func SimpleAsyncReportGerrorInIdle(ObjectVar *gobject.Object, CallbackVar *AsyncReadyCallback, UserDataVar uintptr, ErrorVar *glib.Error) {

	xSimpleAsyncReportGerrorInIdle(ObjectVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar, ErrorVar)

}

var xSimpleAsyncReportTakeGerrorInIdle func(uintptr, uintptr, uintptr, *glib.Error)

// Reports an error in an idle function. Similar to
// g_simple_async_report_gerror_in_idle(), but takes over the caller's
// ownership of @error, so the caller does not have to free it any more.
func SimpleAsyncReportTakeGerrorInIdle(ObjectVar *gobject.Object, CallbackVar *AsyncReadyCallback, UserDataVar uintptr, ErrorVar *glib.Error) {

	xSimpleAsyncReportTakeGerrorInIdle(ObjectVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar, ErrorVar)

}

// As of GLib 2.46, #GSimpleAsyncResult is deprecated in favor of
// #GTask, which provides a simpler API.
//
// #GSimpleAsyncResult implements #GAsyncResult.
//
// GSimpleAsyncResult handles #GAsyncReadyCallbacks, error
// reporting, operation cancellation and the final state of an operation,
// completely transparent to the application. Results can be returned
// as a pointer e.g. for functions that return data that is collected
// asynchronously, a boolean value for checking the success or failure
// of an operation, or a #gssize for operations which return the number
// of bytes modified by the operation; all of the simple return cases
// are covered.
//
// Most of the time, an application will not need to know of the details
// of this API; it is handled transparently, and any necessary operations
// are handled by #GAsyncResult's interface. However, if implementing a
// new GIO module, for writing language bindings, or for complex
// applications that need better control of how asynchronous operations
// are completed, it is important to understand this functionality.
//
// GSimpleAsyncResults are tagged with the calling function to ensure
// that asynchronous functions and their finishing functions are used
// together correctly.
//
// To create a new #GSimpleAsyncResult, call g_simple_async_result_new().
// If the result needs to be created for a #GError, use
// g_simple_async_result_new_from_error() or
// g_simple_async_result_new_take_error(). If a #GError is not available
// (e.g. the asynchronous operation's doesn't take a #GError argument),
// but the result still needs to be created for an error condition, use
// g_simple_async_result_new_error() (or g_simple_async_result_set_error_va()
// if your application or binding requires passing a variable argument list
// directly), and the error can then be propagated through the use of
// g_simple_async_result_propagate_error().
//
// An asynchronous operation can be made to ignore a cancellation event by
// calling g_simple_async_result_set_handle_cancellation() with a
// #GSimpleAsyncResult for the operation and %FALSE. This is useful for
// operations that are dangerous to cancel, such as close (which would
// cause a leak if cancelled before being run).
//
// GSimpleAsyncResult can integrate into GLib's event loop, #GMainLoop,
// or it can use #GThreads.
// g_simple_async_result_complete() will finish an I/O task directly
// from the point where it is called. g_simple_async_result_complete_in_idle()
// will finish it from an idle handler in the
// [thread-default main context][g-main-context-push-thread-default]
// where the #GSimpleAsyncResult was created.
// g_simple_async_result_run_in_thread() will run the job in a
// separate thread and then use
// g_simple_async_result_complete_in_idle() to deliver the result.
//
// To set the results of an asynchronous function,
// g_simple_async_result_set_op_res_gpointer(),
// g_simple_async_result_set_op_res_gboolean(), and
// g_simple_async_result_set_op_res_gssize()
// are provided, setting the operation's result to a gpointer, gboolean, or
// gssize, respectively.
//
// Likewise, to get the result of an asynchronous function,
// g_simple_async_result_get_op_res_gpointer(),
// g_simple_async_result_get_op_res_gboolean(), and
// g_simple_async_result_get_op_res_gssize() are
// provided, getting the operation's result as a gpointer, gboolean, and
// gssize, respectively.
//
// For the details of the requirements implementations must respect, see
// #GAsyncResult.  A typical implementation of an asynchronous operation
// using GSimpleAsyncResult looks something like this:
//
// |[&lt;!-- language="C" --&gt;
// static void
// baked_cb (Cake    *cake,
//
//	gpointer user_data)
//
//	{
//	  // In this example, this callback is not given a reference to the cake,
//	  // so the GSimpleAsyncResult has to take a reference to it.
//	  GSimpleAsyncResult *result = user_data;
//
//	  if (cake == NULL)
//	    g_simple_async_result_set_error (result,
//	                                     BAKER_ERRORS,
//	                                     BAKER_ERROR_NO_FLOUR,
//	                                     "Go to the supermarket");
//	  else
//	    g_simple_async_result_set_op_res_gpointer (result,
//	                                               g_object_ref (cake),
//	                                               g_object_unref);
//
//
//	  // In this example, we assume that baked_cb is called as a callback from
//	  // the mainloop, so it's safe to complete the operation synchronously here.
//	  // If, however, _baker_prepare_cake () might call its callback without
//	  // first returning to the mainloop — inadvisable, but some APIs do so —
//	  // we would need to use g_simple_async_result_complete_in_idle().
//	  g_simple_async_result_complete (result);
//	  g_object_unref (result);
//	}
//
// void
// baker_bake_cake_async (Baker              *self,
//
//	guint               radius,
//	GAsyncReadyCallback callback,
//	gpointer            user_data)
//
//	{
//	  GSimpleAsyncResult *simple;
//	  Cake               *cake;
//
//	  if (radius &lt; 3)
//	    {
//	      g_simple_async_report_error_in_idle (G_OBJECT (self),
//	                                           callback,
//	                                           user_data,
//	                                           BAKER_ERRORS,
//	                                           BAKER_ERROR_TOO_SMALL,
//	                                           "%ucm radius cakes are silly",
//	                                           radius);
//	      return;
//	    }
//
//	  simple = g_simple_async_result_new (G_OBJECT (self),
//	                                      callback,
//	                                      user_data,
//	                                      baker_bake_cake_async);
//	  cake = _baker_get_cached_cake (self, radius);
//
//	  if (cake != NULL)
//	    {
//	      g_simple_async_result_set_op_res_gpointer (simple,
//	                                                 g_object_ref (cake),
//	                                                 g_object_unref);
//	      g_simple_async_result_complete_in_idle (simple);
//	      g_object_unref (simple);
//	      // Drop the reference returned by _baker_get_cached_cake();
//	      // the GSimpleAsyncResult has taken its own reference.
//	      g_object_unref (cake);
//	      return;
//	    }
//
//	  _baker_prepare_cake (self, radius, baked_cb, simple);
//	}
//
// Cake *
// baker_bake_cake_finish (Baker        *self,
//
//	GAsyncResult *result,
//	GError      **error)
//
//	{
//	  GSimpleAsyncResult *simple;
//	  Cake               *cake;
//
//	  g_return_val_if_fail (g_simple_async_result_is_valid (result,
//	                                                        G_OBJECT (self),
//	                                                        baker_bake_cake_async),
//	                        NULL);
//
//	  simple = (GSimpleAsyncResult *) result;
//
//	  if (g_simple_async_result_propagate_error (simple, error))
//	    return NULL;
//
//	  cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
//	  return g_object_ref (cake);
//	}
//
// ]|
type SimpleAsyncResult struct {
	gobject.Object
}

var xSimpleAsyncResultGLibType func() types.GType

func SimpleAsyncResultGLibType() types.GType {
	return xSimpleAsyncResultGLibType()
}

func SimpleAsyncResultNewFromInternalPtr(ptr uintptr) *SimpleAsyncResult {
	cls := &SimpleAsyncResult{}
	cls.Ptr = ptr
	return cls
}

var xNewSimpleAsyncResult func(uintptr, uintptr, uintptr, uintptr) uintptr

// Creates a #GSimpleAsyncResult.
//
// The common convention is to create the #GSimpleAsyncResult in the
// function that starts the asynchronous operation and use that same
// function as the @source_tag.
//
// If your operation supports cancellation with #GCancellable (which it
// probably should) then you should provide the user's cancellable to
// g_simple_async_result_set_check_cancellable() immediately after
// this function returns.
func NewSimpleAsyncResult(SourceObjectVar *gobject.Object, CallbackVar *AsyncReadyCallback, UserDataVar uintptr, SourceTagVar uintptr) *SimpleAsyncResult {
	var cls *SimpleAsyncResult

	cret := xNewSimpleAsyncResult(SourceObjectVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar, SourceTagVar)

	if cret == 0 {
		return nil
	}
	cls = &SimpleAsyncResult{}
	cls.Ptr = cret
	return cls
}

var xNewSimpleAsyncResultError func(uintptr, uintptr, uintptr, glib.Quark, int, string, ...interface{}) uintptr

// Creates a new #GSimpleAsyncResult with a set error.
func NewSimpleAsyncResultError(SourceObjectVar *gobject.Object, CallbackVar *AsyncReadyCallback, UserDataVar uintptr, DomainVar glib.Quark, CodeVar int, FormatVar string, varArgs ...interface{}) *SimpleAsyncResult {
	var cls *SimpleAsyncResult

	cret := xNewSimpleAsyncResultError(SourceObjectVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar, DomainVar, CodeVar, FormatVar, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &SimpleAsyncResult{}
	cls.Ptr = cret
	return cls
}

var xNewSimpleAsyncResultFromError func(uintptr, uintptr, uintptr, *glib.Error) uintptr

// Creates a #GSimpleAsyncResult from an error condition.
func NewSimpleAsyncResultFromError(SourceObjectVar *gobject.Object, CallbackVar *AsyncReadyCallback, UserDataVar uintptr, ErrorVar *glib.Error) *SimpleAsyncResult {
	var cls *SimpleAsyncResult

	cret := xNewSimpleAsyncResultFromError(SourceObjectVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar, ErrorVar)

	if cret == 0 {
		return nil
	}
	cls = &SimpleAsyncResult{}
	cls.Ptr = cret
	return cls
}

var xNewSimpleAsyncResultTakeError func(uintptr, uintptr, uintptr, *glib.Error) uintptr

// Creates a #GSimpleAsyncResult from an error condition, and takes over the
// caller's ownership of @error, so the caller does not need to free it anymore.
func NewSimpleAsyncResultTakeError(SourceObjectVar *gobject.Object, CallbackVar *AsyncReadyCallback, UserDataVar uintptr, ErrorVar *glib.Error) *SimpleAsyncResult {
	var cls *SimpleAsyncResult

	cret := xNewSimpleAsyncResultTakeError(SourceObjectVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar, ErrorVar)

	if cret == 0 {
		return nil
	}
	cls = &SimpleAsyncResult{}
	cls.Ptr = cret
	return cls
}

var xSimpleAsyncResultComplete func(uintptr)

// Completes an asynchronous I/O job immediately. Must be called in
// the thread where the asynchronous result was to be delivered, as it
// invokes the callback directly. If you are in a different thread use
// g_simple_async_result_complete_in_idle().
//
// Calling this function takes a reference to @simple for as long as
// is needed to complete the call.
func (x *SimpleAsyncResult) Complete() {

	xSimpleAsyncResultComplete(x.GoPointer())

}

var xSimpleAsyncResultCompleteInIdle func(uintptr)

// Completes an asynchronous function in an idle handler in the
// [thread-default main context][g-main-context-push-thread-default]
// of the thread that @simple was initially created in
// (and re-pushes that context around the invocation of the callback).
//
// Calling this function takes a reference to @simple for as long as
// is needed to complete the call.
func (x *SimpleAsyncResult) CompleteInIdle() {

	xSimpleAsyncResultCompleteInIdle(x.GoPointer())

}

var xSimpleAsyncResultGetOpResGboolean func(uintptr) bool

// Gets the operation result boolean from within the asynchronous result.
func (x *SimpleAsyncResult) GetOpResGboolean() bool {

	cret := xSimpleAsyncResultGetOpResGboolean(x.GoPointer())
	return cret
}

var xSimpleAsyncResultGetOpResGpointer func(uintptr) uintptr

// Gets a pointer result as returned by the asynchronous function.
func (x *SimpleAsyncResult) GetOpResGpointer() uintptr {

	cret := xSimpleAsyncResultGetOpResGpointer(x.GoPointer())
	return cret
}

var xSimpleAsyncResultGetOpResGssize func(uintptr) int

// Gets a gssize from the asynchronous result.
func (x *SimpleAsyncResult) GetOpResGssize() int {

	cret := xSimpleAsyncResultGetOpResGssize(x.GoPointer())
	return cret
}

var xSimpleAsyncResultGetSourceTag func(uintptr) uintptr

// Gets the source tag for the #GSimpleAsyncResult.
func (x *SimpleAsyncResult) GetSourceTag() uintptr {

	cret := xSimpleAsyncResultGetSourceTag(x.GoPointer())
	return cret
}

var xSimpleAsyncResultPropagateError func(uintptr) bool

// Propagates an error from within the simple asynchronous result to
// a given destination.
//
// If the #GCancellable given to a prior call to
// g_simple_async_result_set_check_cancellable() is cancelled then this
// function will return %TRUE with @dest set appropriately.
func (x *SimpleAsyncResult) PropagateError() (bool, error) {
	var cerr *glib.Error

	cret := xSimpleAsyncResultPropagateError(x.GoPointer())
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSimpleAsyncResultRunInThread func(uintptr, uintptr, int, uintptr)

// Runs the asynchronous job in a separate thread and then calls
// g_simple_async_result_complete_in_idle() on @simple to return
// the result to the appropriate main loop.
//
// Calling this function takes a reference to @simple for as long as
// is needed to run the job and report its completion.
func (x *SimpleAsyncResult) RunInThread(FuncVar *SimpleAsyncThreadFunc, IoPriorityVar int, CancellableVar *Cancellable) {

	xSimpleAsyncResultRunInThread(x.GoPointer(), glib.NewCallback(FuncVar), IoPriorityVar, CancellableVar.GoPointer())

}

var xSimpleAsyncResultSetCheckCancellable func(uintptr, uintptr)

// Sets a #GCancellable to check before dispatching results.
//
// This function has one very specific purpose: the provided cancellable
// is checked at the time of g_simple_async_result_propagate_error() If
// it is cancelled, these functions will return an "Operation was
// cancelled" error (%G_IO_ERROR_CANCELLED).
//
// Implementors of cancellable asynchronous functions should use this in
// order to provide a guarantee to their callers that cancelling an
// async operation will reliably result in an error being returned for
// that operation (even if a positive result for the operation has
// already been sent as an idle to the main context to be dispatched).
//
// The checking described above is done regardless of any call to the
// unrelated g_simple_async_result_set_handle_cancellation() function.
func (x *SimpleAsyncResult) SetCheckCancellable(CheckCancellableVar *Cancellable) {

	xSimpleAsyncResultSetCheckCancellable(x.GoPointer(), CheckCancellableVar.GoPointer())

}

var xSimpleAsyncResultSetError func(uintptr, glib.Quark, int, string, ...interface{})

// Sets an error within the asynchronous result without a #GError.
func (x *SimpleAsyncResult) SetError(DomainVar glib.Quark, CodeVar int, FormatVar string, varArgs ...interface{}) {

	xSimpleAsyncResultSetError(x.GoPointer(), DomainVar, CodeVar, FormatVar, varArgs...)

}

var xSimpleAsyncResultSetErrorVa func(uintptr, glib.Quark, int, string, []interface{})

// Sets an error within the asynchronous result without a #GError.
// Unless writing a binding, see g_simple_async_result_set_error().
func (x *SimpleAsyncResult) SetErrorVa(DomainVar glib.Quark, CodeVar int, FormatVar string, ArgsVar []interface{}) {

	xSimpleAsyncResultSetErrorVa(x.GoPointer(), DomainVar, CodeVar, FormatVar, ArgsVar)

}

var xSimpleAsyncResultSetFromError func(uintptr, *glib.Error)

// Sets the result from a #GError.
func (x *SimpleAsyncResult) SetFromError(ErrorVar *glib.Error) {

	xSimpleAsyncResultSetFromError(x.GoPointer(), ErrorVar)

}

var xSimpleAsyncResultSetHandleCancellation func(uintptr, bool)

// Sets whether to handle cancellation within the asynchronous operation.
//
// This function has nothing to do with
// g_simple_async_result_set_check_cancellable().  It only refers to the
// #GCancellable passed to g_simple_async_result_run_in_thread().
func (x *SimpleAsyncResult) SetHandleCancellation(HandleCancellationVar bool) {

	xSimpleAsyncResultSetHandleCancellation(x.GoPointer(), HandleCancellationVar)

}

var xSimpleAsyncResultSetOpResGboolean func(uintptr, bool)

// Sets the operation result to a boolean within the asynchronous result.
func (x *SimpleAsyncResult) SetOpResGboolean(OpResVar bool) {

	xSimpleAsyncResultSetOpResGboolean(x.GoPointer(), OpResVar)

}

var xSimpleAsyncResultSetOpResGpointer func(uintptr, uintptr, uintptr)

// Sets the operation result within the asynchronous result to a pointer.
func (x *SimpleAsyncResult) SetOpResGpointer(OpResVar uintptr, DestroyOpResVar *glib.DestroyNotify) {

	xSimpleAsyncResultSetOpResGpointer(x.GoPointer(), OpResVar, glib.NewCallback(DestroyOpResVar))

}

var xSimpleAsyncResultSetOpResGssize func(uintptr, int)

// Sets the operation result within the asynchronous result to
// the given @op_res.
func (x *SimpleAsyncResult) SetOpResGssize(OpResVar int) {

	xSimpleAsyncResultSetOpResGssize(x.GoPointer(), OpResVar)

}

var xSimpleAsyncResultTakeError func(uintptr, *glib.Error)

// Sets the result from @error, and takes over the caller's ownership
// of @error, so the caller does not need to free it any more.
func (x *SimpleAsyncResult) TakeError(ErrorVar *glib.Error) {

	xSimpleAsyncResultTakeError(x.GoPointer(), ErrorVar)

}

func (c *SimpleAsyncResult) GoPointer() uintptr {
	return c.Ptr
}

func (c *SimpleAsyncResult) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Gets the source object from a #GAsyncResult.
func (x *SimpleAsyncResult) GetSourceObject() *gobject.Object {
	var cls *gobject.Object

	cret := XGAsyncResultGetSourceObject(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

// Gets the user data from a #GAsyncResult.
func (x *SimpleAsyncResult) GetUserData() uintptr {

	cret := XGAsyncResultGetUserData(x.GoPointer())
	return cret
}

// Checks if @res has the given @source_tag (generally a function
// pointer indicating the function @res was created by).
func (x *SimpleAsyncResult) IsTagged(SourceTagVar uintptr) bool {

	cret := XGAsyncResultIsTagged(x.GoPointer(), SourceTagVar)
	return cret
}

// If @res is a #GSimpleAsyncResult, this is equivalent to
// g_simple_async_result_propagate_error(). Otherwise it returns
// %FALSE.
//
// This can be used for legacy error handling in async *_finish()
// wrapper functions that traditionally handled #GSimpleAsyncResult
// error returns themselves rather than calling into the virtual method.
// This should not be used in new code; #GAsyncResult errors that are
// set by virtual methods should also be extracted by virtual methods,
// to enable subclasses to chain up correctly.
func (x *SimpleAsyncResult) LegacyPropagateError() (bool, error) {
	var cerr *glib.Error

	cret := XGAsyncResultLegacyPropagateError(x.GoPointer())
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSimpleAsyncResultIsValid func(uintptr, uintptr, uintptr) bool

// Ensures that the data passed to the _finish function of an async
// operation is consistent.  Three checks are performed.
//
// First, @result is checked to ensure that it is really a
// #GSimpleAsyncResult.  Second, @source is checked to ensure that it
// matches the source object of @result.  Third, @source_tag is
// checked to ensure that it is equal to the @source_tag argument given
// to g_simple_async_result_new() (which, by convention, is a pointer
// to the _async function corresponding to the _finish function from
// which this function is called).  (Alternatively, if either
// @source_tag or @result's source tag is %NULL, then the source tag
// check is skipped.)
func SimpleAsyncResultIsValid(ResultVar AsyncResult, SourceVar *gobject.Object, SourceTagVar uintptr) bool {

	cret := xSimpleAsyncResultIsValid(ResultVar.GoPointer(), SourceVar.GoPointer(), SourceTagVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xSimpleAsyncReportErrorInIdle, lib, "g_simple_async_report_error_in_idle")
	core.PuregoSafeRegister(&xSimpleAsyncReportGerrorInIdle, lib, "g_simple_async_report_gerror_in_idle")
	core.PuregoSafeRegister(&xSimpleAsyncReportTakeGerrorInIdle, lib, "g_simple_async_report_take_gerror_in_idle")

	core.PuregoSafeRegister(&xSimpleAsyncResultGLibType, lib, "g_simple_async_result_get_type")

	core.PuregoSafeRegister(&xNewSimpleAsyncResult, lib, "g_simple_async_result_new")
	core.PuregoSafeRegister(&xNewSimpleAsyncResultError, lib, "g_simple_async_result_new_error")
	core.PuregoSafeRegister(&xNewSimpleAsyncResultFromError, lib, "g_simple_async_result_new_from_error")
	core.PuregoSafeRegister(&xNewSimpleAsyncResultTakeError, lib, "g_simple_async_result_new_take_error")

	core.PuregoSafeRegister(&xSimpleAsyncResultComplete, lib, "g_simple_async_result_complete")
	core.PuregoSafeRegister(&xSimpleAsyncResultCompleteInIdle, lib, "g_simple_async_result_complete_in_idle")
	core.PuregoSafeRegister(&xSimpleAsyncResultGetOpResGboolean, lib, "g_simple_async_result_get_op_res_gboolean")
	core.PuregoSafeRegister(&xSimpleAsyncResultGetOpResGpointer, lib, "g_simple_async_result_get_op_res_gpointer")
	core.PuregoSafeRegister(&xSimpleAsyncResultGetOpResGssize, lib, "g_simple_async_result_get_op_res_gssize")
	core.PuregoSafeRegister(&xSimpleAsyncResultGetSourceTag, lib, "g_simple_async_result_get_source_tag")
	core.PuregoSafeRegister(&xSimpleAsyncResultPropagateError, lib, "g_simple_async_result_propagate_error")
	core.PuregoSafeRegister(&xSimpleAsyncResultRunInThread, lib, "g_simple_async_result_run_in_thread")
	core.PuregoSafeRegister(&xSimpleAsyncResultSetCheckCancellable, lib, "g_simple_async_result_set_check_cancellable")
	core.PuregoSafeRegister(&xSimpleAsyncResultSetError, lib, "g_simple_async_result_set_error")
	core.PuregoSafeRegister(&xSimpleAsyncResultSetErrorVa, lib, "g_simple_async_result_set_error_va")
	core.PuregoSafeRegister(&xSimpleAsyncResultSetFromError, lib, "g_simple_async_result_set_from_error")
	core.PuregoSafeRegister(&xSimpleAsyncResultSetHandleCancellation, lib, "g_simple_async_result_set_handle_cancellation")
	core.PuregoSafeRegister(&xSimpleAsyncResultSetOpResGboolean, lib, "g_simple_async_result_set_op_res_gboolean")
	core.PuregoSafeRegister(&xSimpleAsyncResultSetOpResGpointer, lib, "g_simple_async_result_set_op_res_gpointer")
	core.PuregoSafeRegister(&xSimpleAsyncResultSetOpResGssize, lib, "g_simple_async_result_set_op_res_gssize")
	core.PuregoSafeRegister(&xSimpleAsyncResultTakeError, lib, "g_simple_async_result_take_error")

	core.PuregoSafeRegister(&xSimpleAsyncResultIsValid, lib, "g_simple_async_result_is_valid")

}
