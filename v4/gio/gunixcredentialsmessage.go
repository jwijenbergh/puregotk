// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// Class structure for #GUnixCredentialsMessage.
type UnixCredentialsMessageClass struct {
	ParentClass uintptr
}

func (x *UnixCredentialsMessageClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type UnixCredentialsMessagePrivate struct {
}

func (x *UnixCredentialsMessagePrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// This #GSocketControlMessage contains a #GCredentials instance.  It
// may be sent using g_socket_send_message() and received using
// g_socket_receive_message() over UNIX sockets (ie: sockets in the
// %G_SOCKET_FAMILY_UNIX family).
//
// For an easier way to send and receive credentials over
// stream-oriented UNIX sockets, see
// g_unix_connection_send_credentials() and
// g_unix_connection_receive_credentials(). To receive credentials of
// a foreign process connected to a socket, use
// g_socket_get_credentials().
//
// Since GLib 2.72, #GUnixCredentialMessage is available on all platforms. It
// requires underlying system support (such as Windows 10 with `AF_UNIX`) at run
// time.
//
// Before GLib 2.72, `&lt;gio/gunixcredentialsmessage.h&gt;` belonged to the UNIX-specific
// GIO interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file
// when using it. This is no longer necessary since GLib 2.72.
type UnixCredentialsMessage struct {
	SocketControlMessage
}

func UnixCredentialsMessageNewFromInternalPtr(ptr uintptr) *UnixCredentialsMessage {
	cls := &UnixCredentialsMessage{}
	cls.Ptr = ptr
	return cls
}

var xNewUnixCredentialsMessage func() uintptr

// Creates a new #GUnixCredentialsMessage with credentials matching the current processes.
func NewUnixCredentialsMessage() *UnixCredentialsMessage {
	var cls *UnixCredentialsMessage

	cret := xNewUnixCredentialsMessage()

	if cret == 0 {
		return nil
	}
	cls = &UnixCredentialsMessage{}
	cls.Ptr = cret
	return cls
}

var xNewUnixCredentialsMessageWithCredentials func(uintptr) uintptr

// Creates a new #GUnixCredentialsMessage holding @credentials.
func NewUnixCredentialsMessageWithCredentials(CredentialsVar *Credentials) *UnixCredentialsMessage {
	var cls *UnixCredentialsMessage

	cret := xNewUnixCredentialsMessageWithCredentials(CredentialsVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &UnixCredentialsMessage{}
	cls.Ptr = cret
	return cls
}

var xUnixCredentialsMessageGetCredentials func(uintptr) uintptr

// Gets the credentials stored in @message.
func (x *UnixCredentialsMessage) GetCredentials() *Credentials {
	var cls *Credentials

	cret := xUnixCredentialsMessageGetCredentials(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Credentials{}
	cls.Ptr = cret
	return cls
}

func (c *UnixCredentialsMessage) GoPointer() uintptr {
	return c.Ptr
}

func (c *UnixCredentialsMessage) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

var xUnixCredentialsMessageIsSupported func() bool

// Checks if passing #GCredentials on a #GSocket is supported on this platform.
func UnixCredentialsMessageIsSupported() bool {

	cret := xUnixCredentialsMessageIsSupported()
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewUnixCredentialsMessage, lib, "g_unix_credentials_message_new")
	core.PuregoSafeRegister(&xNewUnixCredentialsMessageWithCredentials, lib, "g_unix_credentials_message_new_with_credentials")

	core.PuregoSafeRegister(&xUnixCredentialsMessageGetCredentials, lib, "g_unix_credentials_message_get_credentials")

	core.PuregoSafeRegister(&xUnixCredentialsMessageIsSupported, lib, "g_unix_credentials_message_is_supported")

}
