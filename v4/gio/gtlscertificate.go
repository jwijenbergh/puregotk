// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type TlsCertificateClass struct {
	ParentClass uintptr

	Padding [8]uintptr
}

func (x *TlsCertificateClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type TlsCertificatePrivate struct {
}

func (x *TlsCertificatePrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A certificate used for TLS authentication and encryption.
// This can represent either a certificate only (eg, the certificate
// received by a client from a server), or the combination of
// a certificate and a private key (which is needed when acting as a
// #GTlsServerConnection).
type TlsCertificate struct {
	gobject.Object
}

func TlsCertificateNewFromInternalPtr(ptr uintptr) *TlsCertificate {
	cls := &TlsCertificate{}
	cls.Ptr = ptr
	return cls
}

var xNewTlsCertificateFromFile func(string, **glib.Error) uintptr

// Creates a #GTlsCertificate from the data in @file.
//
// As of 2.72, if the filename ends in `.p12` or `.pfx` the data is loaded by
// g_tls_certificate_new_from_pkcs12() otherwise it is loaded by
// g_tls_certificate_new_from_pem(). See those functions for
// exact details.
//
// If @file cannot be read or parsed, the function will return %NULL and
// set @error.
func NewTlsCertificateFromFile(FileVar string) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xNewTlsCertificateFromFile(FileVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewTlsCertificateFromFileWithPassword func(string, string, **glib.Error) uintptr

// Creates a #GTlsCertificate from the data in @file.
//
// If @file cannot be read or parsed, the function will return %NULL and
// set @error.
//
// Any unknown file types will error with %G_IO_ERROR_NOT_SUPPORTED.
// Currently only `.p12` and `.pfx` files are supported.
// See g_tls_certificate_new_from_pkcs12() for more details.
func NewTlsCertificateFromFileWithPassword(FileVar string, PasswordVar string) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xNewTlsCertificateFromFileWithPassword(FileVar, PasswordVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewTlsCertificateFromFiles func(string, string, **glib.Error) uintptr

// Creates a #GTlsCertificate from the PEM-encoded data in @cert_file
// and @key_file. The returned certificate will be the first certificate
// found in @cert_file. As of GLib 2.44, if @cert_file contains more
// certificates it will try to load a certificate chain. All
// certificates will be verified in the order found (top-level
// certificate should be the last one in the file) and the
// #GTlsCertificate:issuer property of each certificate will be set
// accordingly if the verification succeeds. If any certificate in the
// chain cannot be verified, the first certificate in the file will
// still be returned.
//
// If either file cannot be read or parsed, the function will return
// %NULL and set @error. Otherwise, this behaves like
// g_tls_certificate_new_from_pem().
func NewTlsCertificateFromFiles(CertFileVar string, KeyFileVar string) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xNewTlsCertificateFromFiles(CertFileVar, KeyFileVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewTlsCertificateFromPem func(string, int, **glib.Error) uintptr

// Creates a #GTlsCertificate from the PEM-encoded data in @data. If
// @data includes both a certificate and a private key, then the
// returned certificate will include the private key data as well. (See
// the #GTlsCertificate:private-key-pem property for information about
// supported formats.)
//
// The returned certificate will be the first certificate found in
// @data. As of GLib 2.44, if @data contains more certificates it will
// try to load a certificate chain. All certificates will be verified in
// the order found (top-level certificate should be the last one in the
// file) and the #GTlsCertificate:issuer property of each certificate
// will be set accordingly if the verification succeeds. If any
// certificate in the chain cannot be verified, the first certificate in
// the file will still be returned.
func NewTlsCertificateFromPem(DataVar string, LengthVar int) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xNewTlsCertificateFromPem(DataVar, LengthVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewTlsCertificateFromPkcs11Uris func(string, string, **glib.Error) uintptr

// Creates a #GTlsCertificate from a
// [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html) URI.
//
// An example @pkcs11_uri would be `pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01`
//
// Where the tokenâ€™s layout is:
//
// |[
// Object 0:
//
//	URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=private%20key;type=private
//	Type: Private key (RSA-2048)
//	ID: 01
//
// Object 1:
//
//	URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=Certificate%20for%20Authentication;type=cert
//	Type: X.509 Certificate (RSA-2048)
//	ID: 01
//
// ]|
//
// In this case the certificate and private key would both be detected and used as expected.
// @pkcs_uri may also just reference an X.509 certificate object and then optionally
// @private_key_pkcs11_uri allows using a private key exposed under a different URI.
//
// Note that the private key is not accessed until usage and may fail or require a PIN later.
func NewTlsCertificateFromPkcs11Uris(Pkcs11UriVar string, PrivateKeyPkcs11UriVar string) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xNewTlsCertificateFromPkcs11Uris(Pkcs11UriVar, PrivateKeyPkcs11UriVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewTlsCertificateFromPkcs12 func([]byte, uint, string, **glib.Error) uintptr

// Creates a #GTlsCertificate from the data in @data. It must contain
// a certificate and matching private key.
//
// If extra certificates are included they will be verified as a chain
// and the #GTlsCertificate:issuer property will be set.
// All other data will be ignored.
//
// You can pass as single password for all of the data which will be
// used both for the PKCS #12 container as well as encrypted
// private keys. If decryption fails it will error with
// %G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD.
//
// This constructor requires support in the current #GTlsBackend.
// If support is missing it will error with
// %G_IO_ERROR_NOT_SUPPORTED.
//
// Other parsing failures will error with %G_TLS_ERROR_BAD_CERTIFICATE.
func NewTlsCertificateFromPkcs12(DataVar []byte, LengthVar uint, PasswordVar string) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xNewTlsCertificateFromPkcs12(DataVar, LengthVar, PasswordVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xTlsCertificateGetDnsNames func(uintptr) []glib.Bytes

// Gets the value of #GTlsCertificate:dns-names.
func (x *TlsCertificate) GetDnsNames() []glib.Bytes {

	cret := xTlsCertificateGetDnsNames(x.GoPointer())
	return cret
}

var xTlsCertificateGetIpAddresses func(uintptr) []InetAddress

// Gets the value of #GTlsCertificate:ip-addresses.
func (x *TlsCertificate) GetIpAddresses() []InetAddress {

	cret := xTlsCertificateGetIpAddresses(x.GoPointer())
	return cret
}

var xTlsCertificateGetIssuer func(uintptr) uintptr

// Gets the #GTlsCertificate representing @cert's issuer, if known
func (x *TlsCertificate) GetIssuer() *TlsCertificate {
	var cls *TlsCertificate

	cret := xTlsCertificateGetIssuer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TlsCertificate{}
	cls.Ptr = cret
	return cls
}

var xTlsCertificateGetIssuerName func(uintptr) string

// Returns the issuer name from the certificate.
func (x *TlsCertificate) GetIssuerName() string {

	cret := xTlsCertificateGetIssuerName(x.GoPointer())
	return cret
}

var xTlsCertificateGetNotValidAfter func(uintptr) *glib.DateTime

// Returns the time at which the certificate became or will become invalid.
func (x *TlsCertificate) GetNotValidAfter() *glib.DateTime {

	cret := xTlsCertificateGetNotValidAfter(x.GoPointer())
	return cret
}

var xTlsCertificateGetNotValidBefore func(uintptr) *glib.DateTime

// Returns the time at which the certificate became or will become valid.
func (x *TlsCertificate) GetNotValidBefore() *glib.DateTime {

	cret := xTlsCertificateGetNotValidBefore(x.GoPointer())
	return cret
}

var xTlsCertificateGetSubjectName func(uintptr) string

// Returns the subject name from the certificate.
func (x *TlsCertificate) GetSubjectName() string {

	cret := xTlsCertificateGetSubjectName(x.GoPointer())
	return cret
}

var xTlsCertificateIsSame func(uintptr, uintptr) bool

// Check if two #GTlsCertificate objects represent the same certificate.
// The raw DER byte data of the two certificates are checked for equality.
// This has the effect that two certificates may compare equal even if
// their #GTlsCertificate:issuer, #GTlsCertificate:private-key, or
// #GTlsCertificate:private-key-pem properties differ.
func (x *TlsCertificate) IsSame(CertTwoVar *TlsCertificate) bool {

	cret := xTlsCertificateIsSame(x.GoPointer(), CertTwoVar.GoPointer())
	return cret
}

var xTlsCertificateVerify func(uintptr, uintptr, uintptr) TlsCertificateFlags

// This verifies @cert and returns a set of #GTlsCertificateFlags
// indicating any problems found with it. This can be used to verify a
// certificate outside the context of making a connection, or to
// check a certificate against a CA that is not part of the system
// CA database.
//
// If @identity is not %NULL, @cert's name(s) will be compared against
// it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
// value if it does not match. If @identity is %NULL, that bit will
// never be set in the return value.
//
// If @trusted_ca is not %NULL, then @cert (or one of the certificates
// in its chain) must be signed by it, or else
// %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
// @trusted_ca is %NULL, that bit will never be set in the return
// value.
//
// GLib guarantees that if certificate verification fails, at least one
// error will be set in the return value, but it does not guarantee
// that all possible errors will be set. Accordingly, you may not safely
// decide to ignore any particular type of error. For example, it would
// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
// expired certificates, because this could potentially be the only
// error flag set even if other problems exist with the certificate.
//
// Because TLS session context is not used, #GTlsCertificate may not
// perform as many checks on the certificates as #GTlsConnection would.
// For example, certificate constraints may not be honored, and
// revocation checks may not be performed. The best way to verify TLS
// certificates used by a TLS connection is to let #GTlsConnection
// handle the verification.
func (x *TlsCertificate) Verify(IdentityVar SocketConnectable, TrustedCaVar *TlsCertificate) TlsCertificateFlags {

	cret := xTlsCertificateVerify(x.GoPointer(), IdentityVar.GoPointer(), TrustedCaVar.GoPointer())
	return cret
}

func (c *TlsCertificate) GoPointer() uintptr {
	return c.Ptr
}

func (c *TlsCertificate) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

var xTlsCertificateListNewFromFile func(string, **glib.Error) *glib.List

// Creates one or more #GTlsCertificates from the PEM-encoded
// data in @file. If @file cannot be read or parsed, the function will
// return %NULL and set @error. If @file does not contain any
// PEM-encoded certificates, this will return an empty list and not
// set @error.
func TlsCertificateListNewFromFile(FileVar string) (*glib.List, error) {
	var cerr *glib.Error

	cret := xTlsCertificateListNewFromFile(FileVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewTlsCertificateFromFile, lib, "g_tls_certificate_new_from_file")
	core.PuregoSafeRegister(&xNewTlsCertificateFromFileWithPassword, lib, "g_tls_certificate_new_from_file_with_password")
	core.PuregoSafeRegister(&xNewTlsCertificateFromFiles, lib, "g_tls_certificate_new_from_files")
	core.PuregoSafeRegister(&xNewTlsCertificateFromPem, lib, "g_tls_certificate_new_from_pem")
	core.PuregoSafeRegister(&xNewTlsCertificateFromPkcs11Uris, lib, "g_tls_certificate_new_from_pkcs11_uris")
	core.PuregoSafeRegister(&xNewTlsCertificateFromPkcs12, lib, "g_tls_certificate_new_from_pkcs12")

	core.PuregoSafeRegister(&xTlsCertificateGetDnsNames, lib, "g_tls_certificate_get_dns_names")
	core.PuregoSafeRegister(&xTlsCertificateGetIpAddresses, lib, "g_tls_certificate_get_ip_addresses")
	core.PuregoSafeRegister(&xTlsCertificateGetIssuer, lib, "g_tls_certificate_get_issuer")
	core.PuregoSafeRegister(&xTlsCertificateGetIssuerName, lib, "g_tls_certificate_get_issuer_name")
	core.PuregoSafeRegister(&xTlsCertificateGetNotValidAfter, lib, "g_tls_certificate_get_not_valid_after")
	core.PuregoSafeRegister(&xTlsCertificateGetNotValidBefore, lib, "g_tls_certificate_get_not_valid_before")
	core.PuregoSafeRegister(&xTlsCertificateGetSubjectName, lib, "g_tls_certificate_get_subject_name")
	core.PuregoSafeRegister(&xTlsCertificateIsSame, lib, "g_tls_certificate_is_same")
	core.PuregoSafeRegister(&xTlsCertificateVerify, lib, "g_tls_certificate_verify")

	core.PuregoSafeRegister(&xTlsCertificateListNewFromFile, lib, "g_tls_certificate_list_new_from_file")

}
