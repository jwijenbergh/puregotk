// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// Type definition for a function that will be called back when an asynchronous
// operation within GIO has been completed. #GAsyncReadyCallback
// callbacks from #GTask are guaranteed to be invoked in a later
// iteration of the
// [thread-default main context][g-main-context-push-thread-default]
// where the #GTask was created. All other users of
// #GAsyncReadyCallback must likewise call it asynchronously in a
// later iteration of the main context.
//
// The asynchronous operation is guaranteed to have held a reference to
// @source_object from the time when the `*_async()` function was called, until
// after this callback returns.
type AsyncReadyCallback func(uintptr, uintptr, uintptr)

// This is the function type of the callback used for the #GSource
// returned by g_cancellable_source_new().
type CancellableSourceFunc func(uintptr, uintptr) bool

// Function signature for a function used to determine the #GType to
// use for an interface proxy (if @interface_name is not %NULL) or
// object proxy (if @interface_name is %NULL).
//
// This function is called in the
// [thread-default main loop][g-main-context-push-thread-default]
// that @manager was constructed in.
type DBusProxyTypeFunc func(uintptr, string, string, uintptr) []interface{}

// This is the function type of the callback used for the #GSource
// returned by g_datagram_based_create_source().
type DatagramBasedSourceFunc func(uintptr, glib.IOCondition, uintptr) bool

// This callback type is used by g_file_measure_disk_usage() to make
// periodic progress reports when measuring the amount of disk spaced
// used by a directory.
//
// These calls are made on a best-effort basis and not all types of
// #GFile will support them.  At the minimum, however, one call will
// always be made immediately.
//
// In the case that there is no support, @reporting will be set to
// %FALSE (and the other values undefined) and no further calls will be
// made.  Otherwise, the @reporting will be %TRUE and the other values
// all-zeros during the first (immediate) call.  In this way, you can
// know which type of progress UI to show without a delay.
//
// For g_file_measure_disk_usage() the callback is made directly.  For
// g_file_measure_disk_usage_async() the callback is made via the
// default main context of the calling thread (ie: the same way that the
// final async result would be reported).
//
// @current_size is in the same units as requested by the operation (see
// %G_FILE_MEASURE_APPARENT_SIZE).
//
// The frequency of the updates is implementation defined, but is
// ideally about once every 200ms.
//
// The last progress callback may or may not be equal to the final
// result.  Always check the async result to get the final value.
type FileMeasureProgressCallback func(bool, uint64, uint64, uint64, uintptr)

// When doing file operations that may take a while, such as moving
// a file or copying a file, a progress callback is used to pass how
// far along that operation is to the application.
type FileProgressCallback func(int64, int64, uintptr)

// When loading the partial contents of a file with g_file_load_partial_contents_async(),
// it may become necessary to determine if any more data from the file should be loaded.
// A #GFileReadMoreCallback function facilitates this by returning %TRUE if more data
// should be read, or %FALSE otherwise.
type FileReadMoreCallback func(string, int64, uintptr) bool

// I/O Job function.
//
// Long-running jobs should periodically check the @cancellable
// to see if they have been cancelled.
type IOSchedulerJobFunc func(*IOSchedulerJob, uintptr, uintptr) bool

// This is the function type of the callback used for the #GSource
// returned by g_pollable_input_stream_create_source() and
// g_pollable_output_stream_create_source().
type PollableSourceFunc func(uintptr, uintptr) bool

// Simple thread function that runs an asynchronous operation and
// checks for cancellation.
type SimpleAsyncThreadFunc func(uintptr, uintptr, uintptr)

// This is the function type of the callback used for the #GSource
// returned by g_socket_create_source().
type SocketSourceFunc func(uintptr, glib.IOCondition, uintptr) bool

// Determines if a string matches a file attribute.
type FileAttributeMatcher struct {
}

func (x *FileAttributeMatcher) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewFileAttributeMatcher func(string) *FileAttributeMatcher

// Creates a new file attribute matcher, which matches attributes
// against a given string. #GFileAttributeMatchers are reference
// counted structures, and are created with a reference count of 1. If
// the number of references falls to 0, the #GFileAttributeMatcher is
// automatically destroyed.
//
// The @attributes string should be formatted with specific keys separated
// from namespaces with a double colon. Several "namespace::key" strings may be
// concatenated with a single comma (e.g. "standard::type,standard::is-hidden").
// The wildcard "*" may be used to match all keys and namespaces, or
// "namespace::*" will match all keys in a given namespace.
//
// ## Examples of file attribute matcher strings and results
//
//   - `"*"`: matches all attributes.
//   - `"standard::is-hidden"`: matches only the key is-hidden in the
//     standard namespace.
//   - `"standard::type,unix::*"`: matches the type key in the standard
//     namespace and all keys in the unix namespace.
func NewFileAttributeMatcher(AttributesVar string) *FileAttributeMatcher {

	cret := xNewFileAttributeMatcher(AttributesVar)
	return cret
}

var xFileAttributeMatcherEnumerateNamespace func(uintptr, string) bool

// Checks if the matcher will match all of the keys in a given namespace.
// This will always return %TRUE if a wildcard character is in use (e.g. if
// matcher was created with "standard::*" and @ns is "standard", or if matcher was created
// using "*" and namespace is anything.)
//
// TODO: this is awkwardly worded.
func (x *FileAttributeMatcher) EnumerateNamespace(NsVar string) bool {

	cret := xFileAttributeMatcherEnumerateNamespace(x.GoPointer(), NsVar)
	return cret
}

var xFileAttributeMatcherEnumerateNext func(uintptr) string

// Gets the next matched attribute from a #GFileAttributeMatcher.
func (x *FileAttributeMatcher) EnumerateNext() string {

	cret := xFileAttributeMatcherEnumerateNext(x.GoPointer())
	return cret
}

var xFileAttributeMatcherMatches func(uintptr, string) bool

// Checks if an attribute will be matched by an attribute matcher. If
// the matcher was created with the "*" matching string, this function
// will always return %TRUE.
func (x *FileAttributeMatcher) Matches(AttributeVar string) bool {

	cret := xFileAttributeMatcherMatches(x.GoPointer(), AttributeVar)
	return cret
}

var xFileAttributeMatcherMatchesOnly func(uintptr, string) bool

// Checks if a attribute matcher only matches a given attribute. Always
// returns %FALSE if "*" was used when creating the matcher.
func (x *FileAttributeMatcher) MatchesOnly(AttributeVar string) bool {

	cret := xFileAttributeMatcherMatchesOnly(x.GoPointer(), AttributeVar)
	return cret
}

var xFileAttributeMatcherRef func(uintptr) *FileAttributeMatcher

// References a file attribute matcher.
func (x *FileAttributeMatcher) Ref() *FileAttributeMatcher {

	cret := xFileAttributeMatcherRef(x.GoPointer())
	return cret
}

var xFileAttributeMatcherSubtract func(uintptr, *FileAttributeMatcher) *FileAttributeMatcher

// Subtracts all attributes of @subtract from @matcher and returns
// a matcher that supports those attributes.
//
// Note that currently it is not possible to remove a single
// attribute when the @matcher matches the whole namespace - or remove
// a namespace or attribute when the matcher matches everything. This
// is a limitation of the current implementation, but may be fixed
// in the future.
func (x *FileAttributeMatcher) Subtract(SubtractVar *FileAttributeMatcher) *FileAttributeMatcher {

	cret := xFileAttributeMatcherSubtract(x.GoPointer(), SubtractVar)
	return cret
}

var xFileAttributeMatcherToString func(uintptr) string

// Prints what the matcher is matching against. The format will be
// equal to the format passed to g_file_attribute_matcher_new().
// The output however, might not be identical, as the matcher may
// decide to use a different order or omit needless parts.
func (x *FileAttributeMatcher) ToString() string {

	cret := xFileAttributeMatcherToString(x.GoPointer())
	return cret
}

var xFileAttributeMatcherUnref func(uintptr)

// Unreferences @matcher. If the reference count falls below 1,
// the @matcher is automatically freed.
func (x *FileAttributeMatcher) Unref() {

	xFileAttributeMatcherUnref(x.GoPointer())

}

// #GIOExtension is an opaque data structure and can only be accessed
// using the following functions.
type IOExtension struct {
}

func (x *IOExtension) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xIOExtensionGetName func(uintptr) string

// Gets the name under which @extension was registered.
//
// Note that the same type may be registered as extension
// for multiple extension points, under different names.
func (x *IOExtension) GetName() string {

	cret := xIOExtensionGetName(x.GoPointer())
	return cret
}

var xIOExtensionGetPriority func(uintptr) int

// Gets the priority with which @extension was registered.
func (x *IOExtension) GetPriority() int {

	cret := xIOExtensionGetPriority(x.GoPointer())
	return cret
}

var xIOExtensionGetType func(uintptr) []interface{}

// Gets the type associated with @extension.
func (x *IOExtension) GetType() []interface{} {

	cret := xIOExtensionGetType(x.GoPointer())
	return cret
}

var xIOExtensionRefClass func(uintptr) *gobject.TypeClass

// Gets a reference to the class for the type that is
// associated with @extension.
func (x *IOExtension) RefClass() *gobject.TypeClass {

	cret := xIOExtensionRefClass(x.GoPointer())
	return cret
}

// #GIOExtensionPoint is an opaque data structure and can only be accessed
// using the following functions.
type IOExtensionPoint struct {
}

func (x *IOExtensionPoint) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xIOExtensionPointGetExtensionByName func(uintptr, string) *IOExtension

// Finds a #GIOExtension for an extension point by name.
func (x *IOExtensionPoint) GetExtensionByName(NameVar string) *IOExtension {

	cret := xIOExtensionPointGetExtensionByName(x.GoPointer(), NameVar)
	return cret
}

var xIOExtensionPointGetExtensions func(uintptr) *glib.List

// Gets a list of all extensions that implement this extension point.
// The list is sorted by priority, beginning with the highest priority.
func (x *IOExtensionPoint) GetExtensions() *glib.List {

	cret := xIOExtensionPointGetExtensions(x.GoPointer())
	return cret
}

var xIOExtensionPointGetRequiredType func(uintptr) []interface{}

// Gets the required type for @extension_point.
func (x *IOExtensionPoint) GetRequiredType() []interface{} {

	cret := xIOExtensionPointGetRequiredType(x.GoPointer())
	return cret
}

var xIOExtensionPointSetRequiredType func(uintptr, []interface{})

// Sets the required type for @extension_point to @type.
// All implementations must henceforth have this type.
func (x *IOExtensionPoint) SetRequiredType(TypeVar []interface{}) {

	xIOExtensionPointSetRequiredType(x.GoPointer(), TypeVar)

}

// Opaque class for defining and scheduling IO jobs.
type IOSchedulerJob struct {
}

func (x *IOSchedulerJob) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xIOSchedulerJobSendToMainloop func(uintptr, uintptr, uintptr, uintptr) bool

// Used from an I/O job to send a callback to be run in the thread
// that the job was started from, waiting for the result (and thus
// blocking the I/O job).
func (x *IOSchedulerJob) SendToMainloop(FuncVar *glib.SourceFunc, UserDataVar uintptr, NotifyVar *glib.DestroyNotify) bool {

	cret := xIOSchedulerJobSendToMainloop(x.GoPointer(), glib.NewCallback(FuncVar), UserDataVar, glib.NewCallback(NotifyVar))
	return cret
}

var xIOSchedulerJobSendToMainloopAsync func(uintptr, uintptr, uintptr, uintptr)

// Used from an I/O job to send a callback to be run asynchronously in
// the thread that the job was started from. The callback will be run
// when the main loop is available, but at that time the I/O job might
// have finished. The return value from the callback is ignored.
//
// Note that if you are passing the @user_data from g_io_scheduler_push_job()
// on to this function you have to ensure that it is not freed before
// @func is called, either by passing %NULL as @notify to
// g_io_scheduler_push_job() or by using refcounting for @user_data.
func (x *IOSchedulerJob) SendToMainloopAsync(FuncVar *glib.SourceFunc, UserDataVar uintptr, NotifyVar *glib.DestroyNotify) {

	xIOSchedulerJobSendToMainloopAsync(x.GoPointer(), glib.NewCallback(FuncVar), UserDataVar, glib.NewCallback(NotifyVar))

}

type IOStreamAdapter struct {
}

func (x *IOStreamAdapter) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Structure used for scatter/gather data input when receiving multiple
// messages or packets in one go. You generally pass in an array of empty
// #GInputVectors and the operation will use all the buffers as if they
// were one buffer, and will set @bytes_received to the total number of bytes
// received across all #GInputVectors.
//
// This structure closely mirrors `struct mmsghdr` and `struct msghdr` from
// the POSIX sockets API (see `man 2 recvmmsg`).
//
// If @address is non-%NULL then it is set to the source address the message
// was received from, and the caller must free it afterwards.
//
// If @control_messages is non-%NULL then it is set to an array of control
// messages received with the message (if any), and the caller must free it
// afterwards. @num_control_messages is set to the number of elements in
// this array, which may be zero.
//
// Flags relevant to this message will be returned in @flags. For example,
// `MSG_EOR` or `MSG_TRUNC`.
type InputMessage struct {
	Address **SocketAddress

	Vectors uintptr

	NumVectors uint

	BytesReceived uint

	Flags int32

	ControlMessages uintptr

	NumControlMessages uint
}

func (x *InputMessage) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Structure used for scatter/gather data input.
// You generally pass in an array of #GInputVectors
// and the operation will store the read data starting in the
// first buffer, switching to the next as needed.
type InputVector struct {
	Buffer uintptr

	Size uint
}

func (x *InputVector) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Structure used for scatter/gather data output when sending multiple
// messages or packets in one go. You generally pass in an array of
// #GOutputVectors and the operation will use all the buffers as if they
// were one buffer.
//
// If @address is %NULL then the message is sent to the default receiver
// (as previously set by g_socket_connect()).
type OutputMessage struct {
	Address *SocketAddress

	Vectors *OutputVector

	NumVectors uint

	BytesSent uint

	ControlMessages uintptr

	NumControlMessages uint
}

func (x *OutputMessage) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Structure used for scatter/gather data output.
// You generally pass in an array of #GOutputVectors
// and the operation will use all the buffers as if they were
// one buffer.
type OutputVector struct {
	Buffer uintptr

	Size uint
}

func (x *OutputVector) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Applications and libraries often contain binary or textual data that is
// really part of the application, rather than user data. For instance
// #GtkBuilder .ui files, splashscreen images, GMenu markup XML, CSS files,
// icons, etc. These are often shipped as files in `$datadir/appname`, or
// manually included as literal strings in the code.
//
// The #GResource API and the [glib-compile-resources][glib-compile-resources] program
// provide a convenient and efficient alternative to this which has some nice properties. You
// maintain the files as normal files, so its easy to edit them, but during the build the files
// are combined into a binary bundle that is linked into the executable. This means that loading
// the resource files are efficient (as they are already in memory, shared with other instances) and
// simple (no need to check for things like I/O errors or locate the files in the filesystem). It
// also makes it easier to create relocatable applications.
//
// Resource files can also be marked as compressed. Such files will be included in the resource bundle
// in a compressed form, but will be automatically uncompressed when the resource is used. This
// is very useful e.g. for larger text files that are parsed once (or rarely) and then thrown away.
//
// Resource files can also be marked to be preprocessed, by setting the value of the
// `preprocess` attribute to a comma-separated list of preprocessing options.
// The only options currently supported are:
//
// `xml-stripblanks` which will use the xmllint command
// to strip ignorable whitespace from the XML file. For this to work,
// the `XMLLINT` environment variable must be set to the full path to
// the xmllint executable, or xmllint must be in the `PATH`; otherwise
// the preprocessing step is skipped.
//
// `to-pixdata` (deprecated since gdk-pixbuf 2.32) which will use the
// `gdk-pixbuf-pixdata` command to convert images to the #GdkPixdata format,
// which allows you to create pixbufs directly using the data inside the
// resource file, rather than an (uncompressed) copy of it. For this, the
// `gdk-pixbuf-pixdata` program must be in the `PATH`, or the
// `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to the
// `gdk-pixbuf-pixdata` executable; otherwise the resource compiler will abort.
// `to-pixdata` has been deprecated since gdk-pixbuf 2.32, as #GResource
// supports embedding modern image formats just as well. Instead of using it,
// embed a PNG or SVG file in your #GResource.
//
// `json-stripblanks` which will use the `json-glib-format` command to strip
// ignorable whitespace from the JSON file. For this to work, the
// `JSON_GLIB_FORMAT` environment variable must be set to the full path to the
// `json-glib-format` executable, or it must be in the `PATH`;
// otherwise the preprocessing step is skipped. In addition, at least version
// 1.6 of `json-glib-format` is required.
//
// Resource files will be exported in the GResource namespace using the
// combination of the given `prefix` and the filename from the `file` element.
// The `alias` attribute can be used to alter the filename to expose them at a
// different location in the resource namespace. Typically, this is used to
// include files from a different source directory without exposing the source
// directory in the resource namespace, as in the example below.
//
// Resource bundles are created by the [glib-compile-resources][glib-compile-resources] program
// which takes an XML file that describes the bundle, and a set of files that the XML references. These
// are combined into a binary resource bundle.
//
// An example resource description:
// |[
// &lt;?xml version="1.0" encoding="UTF-8"?&gt;
// &lt;gresources&gt;
//
//	&lt;gresource prefix="/org/gtk/Example"&gt;
//	  &lt;file&gt;data/splashscreen.png&lt;/file&gt;
//	  &lt;file compressed="true"&gt;dialog.ui&lt;/file&gt;
//	  &lt;file preprocess="xml-stripblanks"&gt;menumarkup.xml&lt;/file&gt;
//	  &lt;file alias="example.css"&gt;data/example.css&lt;/file&gt;
//	&lt;/gresource&gt;
//
// &lt;/gresources&gt;
// ]|
//
// This will create a resource bundle with the following files:
// |[
// /org/gtk/Example/data/splashscreen.png
// /org/gtk/Example/dialog.ui
// /org/gtk/Example/menumarkup.xml
// /org/gtk/Example/example.css
// ]|
//
// Note that all resources in the process share the same namespace, so use Java-style
// path prefixes (like in the above example) to avoid conflicts.
//
// You can then use [glib-compile-resources][glib-compile-resources] to compile the XML to a
// binary bundle that you can load with g_resource_load(). However, its more common to use the --generate-source and
// --generate-header arguments to create a source file and header to link directly into your application.
// This will generate `get_resource()`, `register_resource()` and
// `unregister_resource()` functions, prefixed by the `--c-name` argument passed
// to [glib-compile-resources][glib-compile-resources]. `get_resource()` returns
// the generated #GResource object. The register and unregister functions
// register the resource so its files can be accessed using
// g_resources_lookup_data().
//
// Once a #GResource has been created and registered all the data in it can be accessed globally in the process by
// using API calls like g_resources_open_stream() to stream the data or g_resources_lookup_data() to get a direct pointer
// to the data. You can also use URIs like "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access
// the resource data.
//
// Some higher-level APIs, such as #GtkApplication, will automatically load
// resources from certain well-known paths in the resource namespace as a
// convenience. See the documentation for those APIs for details.
//
// There are two forms of the generated source, the default version uses the compiler support for constructor
// and destructor functions (where available) to automatically create and register the #GResource on startup
// or library load time. If you pass `--manual-register`, two functions to register/unregister the resource are created
// instead. This requires an explicit initialization call in your application/library, but it works on all platforms,
// even on the minor ones where constructors are not supported. (Constructor support is available for at least Win32, Mac OS and Linux.)
//
// Note that resource data can point directly into the data segment of e.g. a library, so if you are unloading libraries
// during runtime you need to be very careful with keeping around pointers to data from a resource, as this goes away
// when the library is unloaded. However, in practice this is not generally a problem, since most resource accesses
// are for your own resources, and resource data is often used once, during parsing, and then released.
//
// When debugging a program or testing a change to an installed version, it is often useful to be able to
// replace resources in the program or library, without recompiling, for debugging or quick hacking and testing
// purposes. Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment variable to selectively overlay
// resources with replacements from the filesystem.  It is a %G_SEARCHPATH_SEPARATOR-separated list of substitutions to perform
// during resource lookups. It is ignored when running in a setuid process.
//
// # A substitution has the form
//
// |[
//
//	/org/gtk/libgtk=/home/desrt/gtk-overlay
//
// ]|
//
// The part before the `=` is the resource subpath for which the overlay applies.  The part after is a
// filesystem path which contains files and subdirectories as you would like to be loaded as resources with the
// equivalent names.
//
// In the example above, if an application tried to load a resource with the resource path
// `/org/gtk/libgtk/ui/gtkdialog.ui` then GResource would check the filesystem path
// `/home/desrt/gtk-overlay/ui/gtkdialog.ui`.  If a file was found there, it would be used instead.  This is an
// overlay, not an outright replacement, which means that if a file is not found at that path, the built-in
// version will be used instead.  Whiteouts are not currently supported.
//
// Substitutions must start with a slash, and must not contain a trailing slash before the '='.  The path after
// the slash should ideally be absolute, but this is not strictly required.  It is possible to overlay the
// location of a single resource with an individual file.
type Resource struct {
}

func (x *Resource) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewResourceFromData func(*glib.Bytes, **glib.Error) *Resource

// Creates a GResource from a reference to the binary resource bundle.
// This will keep a reference to @data while the resource lives, so
// the data should not be modified or freed.
//
// If you want to use this resource in the global resource namespace you need
// to register it with g_resources_register().
//
// Note: @data must be backed by memory that is at least pointer aligned.
// Otherwise this function will internally create a copy of the memory since
// GLib 2.56, or in older versions fail and exit the process.
//
// If @data is empty or corrupt, %G_RESOURCE_ERROR_INTERNAL will be returned.
func NewResourceFromData(DataVar *glib.Bytes) (*Resource, error) {
	var cerr *glib.Error

	cret := xNewResourceFromData(DataVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResourceRegister func(uintptr)

// Registers the resource with the process-global set of resources.
// Once a resource is registered the files in it can be accessed
// with the global resource lookup functions like g_resources_lookup_data().
func (x *Resource) Register() {

	xResourceRegister(x.GoPointer())

}

var xResourceUnregister func(uintptr)

// Unregisters the resource from the process-global set of resources.
func (x *Resource) Unregister() {

	xResourceUnregister(x.GoPointer())

}

var xResourceEnumerateChildren func(uintptr, string, ResourceLookupFlags, **glib.Error) []string

// Returns all the names of children at the specified @path in the resource.
// The return result is a %NULL terminated list of strings which should
// be released with g_strfreev().
//
// If @path is invalid or does not exist in the #GResource,
// %G_RESOURCE_ERROR_NOT_FOUND will be returned.
//
// @lookup_flags controls the behaviour of the lookup.
func (x *Resource) EnumerateChildren(PathVar string, LookupFlagsVar ResourceLookupFlags) ([]string, error) {
	var cerr *glib.Error

	cret := xResourceEnumerateChildren(x.GoPointer(), PathVar, LookupFlagsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResourceGetInfo func(uintptr, string, ResourceLookupFlags, uint, uint32, **glib.Error) bool

// Looks for a file at the specified @path in the resource and
// if found returns information about it.
//
// @lookup_flags controls the behaviour of the lookup.
func (x *Resource) GetInfo(PathVar string, LookupFlagsVar ResourceLookupFlags, SizeVar uint, FlagsVar uint32) (bool, error) {
	var cerr *glib.Error

	cret := xResourceGetInfo(x.GoPointer(), PathVar, LookupFlagsVar, SizeVar, FlagsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResourceLookupData func(uintptr, string, ResourceLookupFlags, **glib.Error) *glib.Bytes

// Looks for a file at the specified @path in the resource and
// returns a #GBytes that lets you directly access the data in
// memory.
//
// The data is always followed by a zero byte, so you
// can safely use the data as a C string. However, that byte
// is not included in the size of the GBytes.
//
// For uncompressed resource files this is a pointer directly into
// the resource bundle, which is typically in some readonly data section
// in the program binary. For compressed files we allocate memory on
// the heap and automatically uncompress the data.
//
// @lookup_flags controls the behaviour of the lookup.
func (x *Resource) LookupData(PathVar string, LookupFlagsVar ResourceLookupFlags) (*glib.Bytes, error) {
	var cerr *glib.Error

	cret := xResourceLookupData(x.GoPointer(), PathVar, LookupFlagsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResourceOpenStream func(uintptr, string, ResourceLookupFlags, **glib.Error) uintptr

// Looks for a file at the specified @path in the resource and
// returns a #GInputStream that lets you read the data.
//
// @lookup_flags controls the behaviour of the lookup.
func (x *Resource) OpenStream(PathVar string, LookupFlagsVar ResourceLookupFlags) (*InputStream, error) {
	var cls *InputStream
	var cerr *glib.Error

	cret := xResourceOpenStream(x.GoPointer(), PathVar, LookupFlagsVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &InputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xResourceRef func(uintptr) *Resource

// Atomically increments the reference count of @resource by one. This
// function is MT-safe and may be called from any thread.
func (x *Resource) Ref() *Resource {

	cret := xResourceRef(x.GoPointer())
	return cret
}

var xResourceUnref func(uintptr)

// Atomically decrements the reference count of @resource by one. If the
// reference count drops to 0, all memory allocated by the resource is
// released. This function is MT-safe and may be called from any
// thread.
func (x *Resource) Unref() {

	xResourceUnref(x.GoPointer())

}

// SRV (service) records are used by some network protocols to provide
// service-specific aliasing and load-balancing. For example, XMPP
// (Jabber) uses SRV records to locate the XMPP server for a domain;
// rather than connecting directly to "example.com" or assuming a
// specific server hostname like "xmpp.example.com", an XMPP client
// would look up the "xmpp-client" SRV record for "example.com", and
// then connect to whatever host was pointed to by that record.
//
// You can use g_resolver_lookup_service() or
// g_resolver_lookup_service_async() to find the #GSrvTargets
// for a given service. However, if you are simply planning to connect
// to the remote service, you can use #GNetworkService's
// #GSocketConnectable interface and not need to worry about
// #GSrvTarget at all.
type SrvTarget struct {
}

func (x *SrvTarget) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewSrvTarget func(string, uint16, uint16, uint16) *SrvTarget

// Creates a new #GSrvTarget with the given parameters.
//
// You should not need to use this; normally #GSrvTargets are
// created by #GResolver.
func NewSrvTarget(HostnameVar string, PortVar uint16, PriorityVar uint16, WeightVar uint16) *SrvTarget {

	cret := xNewSrvTarget(HostnameVar, PortVar, PriorityVar, WeightVar)
	return cret
}

var xSrvTargetCopy func(uintptr) *SrvTarget

// Copies @target
func (x *SrvTarget) Copy() *SrvTarget {

	cret := xSrvTargetCopy(x.GoPointer())
	return cret
}

var xSrvTargetFree func(uintptr)

// Frees @target
func (x *SrvTarget) Free() {

	xSrvTargetFree(x.GoPointer())

}

var xSrvTargetGetHostname func(uintptr) string

// Gets @target's hostname (in ASCII form; if you are going to present
// this to the user, you should use g_hostname_is_ascii_encoded() to
// check if it contains encoded Unicode segments, and use
// g_hostname_to_unicode() to convert it if it does.)
func (x *SrvTarget) GetHostname() string {

	cret := xSrvTargetGetHostname(x.GoPointer())
	return cret
}

var xSrvTargetGetPort func(uintptr) uint16

// Gets @target's port
func (x *SrvTarget) GetPort() uint16 {

	cret := xSrvTargetGetPort(x.GoPointer())
	return cret
}

var xSrvTargetGetPriority func(uintptr) uint16

// Gets @target's priority. You should not need to look at this;
// #GResolver already sorts the targets according to the algorithm in
// RFC 2782.
func (x *SrvTarget) GetPriority() uint16 {

	cret := xSrvTargetGetPriority(x.GoPointer())
	return cret
}

var xSrvTargetGetWeight func(uintptr) uint16

// Gets @target's weight. You should not need to look at this;
// #GResolver already sorts the targets according to the algorithm in
// RFC 2782.
func (x *SrvTarget) GetWeight() uint16 {

	cret := xSrvTargetGetWeight(x.GoPointer())
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewFileAttributeMatcher, lib, "g_file_attribute_matcher_new")

	core.PuregoSafeRegister(&xFileAttributeMatcherEnumerateNamespace, lib, "g_file_attribute_matcher_enumerate_namespace")
	core.PuregoSafeRegister(&xFileAttributeMatcherEnumerateNext, lib, "g_file_attribute_matcher_enumerate_next")
	core.PuregoSafeRegister(&xFileAttributeMatcherMatches, lib, "g_file_attribute_matcher_matches")
	core.PuregoSafeRegister(&xFileAttributeMatcherMatchesOnly, lib, "g_file_attribute_matcher_matches_only")
	core.PuregoSafeRegister(&xFileAttributeMatcherRef, lib, "g_file_attribute_matcher_ref")
	core.PuregoSafeRegister(&xFileAttributeMatcherSubtract, lib, "g_file_attribute_matcher_subtract")
	core.PuregoSafeRegister(&xFileAttributeMatcherToString, lib, "g_file_attribute_matcher_to_string")
	core.PuregoSafeRegister(&xFileAttributeMatcherUnref, lib, "g_file_attribute_matcher_unref")

	core.PuregoSafeRegister(&xIOExtensionGetName, lib, "g_io_extension_get_name")
	core.PuregoSafeRegister(&xIOExtensionGetPriority, lib, "g_io_extension_get_priority")
	core.PuregoSafeRegister(&xIOExtensionGetType, lib, "g_io_extension_get_type")
	core.PuregoSafeRegister(&xIOExtensionRefClass, lib, "g_io_extension_ref_class")

	core.PuregoSafeRegister(&xIOExtensionPointGetExtensionByName, lib, "g_io_extension_point_get_extension_by_name")
	core.PuregoSafeRegister(&xIOExtensionPointGetExtensions, lib, "g_io_extension_point_get_extensions")
	core.PuregoSafeRegister(&xIOExtensionPointGetRequiredType, lib, "g_io_extension_point_get_required_type")
	core.PuregoSafeRegister(&xIOExtensionPointSetRequiredType, lib, "g_io_extension_point_set_required_type")

	core.PuregoSafeRegister(&xIOSchedulerJobSendToMainloop, lib, "g_io_scheduler_job_send_to_mainloop")
	core.PuregoSafeRegister(&xIOSchedulerJobSendToMainloopAsync, lib, "g_io_scheduler_job_send_to_mainloop_async")

	core.PuregoSafeRegister(&xNewResourceFromData, lib, "g_resource_new_from_data")

	core.PuregoSafeRegister(&xResourceRegister, lib, "g_resources_register")
	core.PuregoSafeRegister(&xResourceUnregister, lib, "g_resources_unregister")
	core.PuregoSafeRegister(&xResourceEnumerateChildren, lib, "g_resource_enumerate_children")
	core.PuregoSafeRegister(&xResourceGetInfo, lib, "g_resource_get_info")
	core.PuregoSafeRegister(&xResourceLookupData, lib, "g_resource_lookup_data")
	core.PuregoSafeRegister(&xResourceOpenStream, lib, "g_resource_open_stream")
	core.PuregoSafeRegister(&xResourceRef, lib, "g_resource_ref")
	core.PuregoSafeRegister(&xResourceUnref, lib, "g_resource_unref")

	core.PuregoSafeRegister(&xNewSrvTarget, lib, "g_srv_target_new")

	core.PuregoSafeRegister(&xSrvTargetCopy, lib, "g_srv_target_copy")
	core.PuregoSafeRegister(&xSrvTargetFree, lib, "g_srv_target_free")
	core.PuregoSafeRegister(&xSrvTargetGetHostname, lib, "g_srv_target_get_hostname")
	core.PuregoSafeRegister(&xSrvTargetGetPort, lib, "g_srv_target_get_port")
	core.PuregoSafeRegister(&xSrvTargetGetPriority, lib, "g_srv_target_get_priority")
	core.PuregoSafeRegister(&xSrvTargetGetWeight, lib, "g_srv_target_get_weight")

}
