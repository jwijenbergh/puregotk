// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
)

// The type of the @get_property function in #GDBusInterfaceVTable.
type DBusInterfaceGetPropertyFunc func(uintptr, string, string, string, string, **glib.Error, uintptr) *glib.Variant

// The type of the @method_call function in #GDBusInterfaceVTable.
type DBusInterfaceMethodCallFunc func(uintptr, string, string, string, string, *glib.Variant, uintptr, uintptr)

// The type of the @set_property function in #GDBusInterfaceVTable.
type DBusInterfaceSetPropertyFunc func(uintptr, string, string, string, string, *glib.Variant, **glib.Error, uintptr) bool

// Signature for function used in g_dbus_connection_add_filter().
//
// A filter function is passed a #GDBusMessage and expected to return
// a #GDBusMessage too. Passive filter functions that don't modify the
// message can simply return the @message object:
// |[
// static GDBusMessage *
// passive_filter (GDBusConnection *connection
//
//	GDBusMessage    *message,
//	gboolean         incoming,
//	gpointer         user_data)
//
//	{
//	  // inspect @message
//	  return message;
//	}
//
// ]|
// Filter functions that wants to drop a message can simply return %NULL:
// |[
// static GDBusMessage *
// drop_filter (GDBusConnection *connection
//
//	GDBusMessage    *message,
//	gboolean         incoming,
//	gpointer         user_data)
//
//	{
//	  if (should_drop_message)
//	    {
//	      g_object_unref (message);
//	      message = NULL;
//	    }
//	  return message;
//	}
//
// ]|
// Finally, a filter function may modify a message by copying it:
// |[
// static GDBusMessage *
// modifying_filter (GDBusConnection *connection
//
//	GDBusMessage    *message,
//	gboolean         incoming,
//	gpointer         user_data)
//
//	{
//	  GDBusMessage *copy;
//	  GError *error;
//
//	  error = NULL;
//	  copy = g_dbus_message_copy (message, &amp;error);
//	  // handle @error being set
//	  g_object_unref (message);
//
//	  // modify @copy
//
//	  return copy;
//	}
//
// ]|
// If the returned #GDBusMessage is different from @message and cannot
// be sent on @connection (it could use features, such as file
// descriptors, not compatible with @connection), then a warning is
// logged to standard error. Applications can
// check this ahead of time using g_dbus_message_to_blob() passing a
// #GDBusCapabilityFlags value obtained from @connection.
type DBusMessageFilterFunction func(uintptr, uintptr, bool, uintptr) uintptr

// Signature for callback function used in g_dbus_connection_signal_subscribe().
type DBusSignalCallback func(uintptr, string, string, string, string, *glib.Variant, uintptr)

// The type of the @dispatch function in #GDBusSubtreeVTable.
//
// Subtrees are flat.  @node, if non-%NULL, is always exactly one
// segment of the object path (ie: it never contains a slash).
type DBusSubtreeDispatchFunc func(uintptr, string, string, string, string, uintptr, uintptr) *DBusInterfaceVTable

// The type of the @enumerate function in #GDBusSubtreeVTable.
//
// This function is called when generating introspection data and also
// when preparing to dispatch incoming messages in the event that the
// %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not
// specified (ie: to verify that the object path is valid).
//
// Hierarchies are not supported; the items that you return should not
// contain the `/` character.
//
// The return value will be freed with g_strfreev().
type DBusSubtreeEnumerateFunc func(uintptr, string, string, uintptr) []string

// The type of the @introspect function in #GDBusSubtreeVTable.
//
// Subtrees are flat.  @node, if non-%NULL, is always exactly one
// segment of the object path (ie: it never contains a slash).
//
// This function should return %NULL to indicate that there is no object
// at this node.
//
// If this function returns non-%NULL, the return value is expected to
// be a %NULL-terminated array of pointers to #GDBusInterfaceInfo
// structures describing the interfaces implemented by @node.  This
// array will have g_dbus_interface_info_unref() called on each item
// before being freed with g_free().
//
// The difference between returning %NULL and an array containing zero
// items is that the standard DBus interfaces will returned to the
// remote introspector in the empty array case, but not in the %NULL
// case.
type DBusSubtreeIntrospectFunc func(uintptr, string, string, string, uintptr) uintptr

// Virtual table for handling properties and method calls for a D-Bus
// interface.
//
// Since 2.38, if you want to handle getting/setting D-Bus properties
// asynchronously, give %NULL as your get_property() or set_property()
// function. The D-Bus call will be directed to your @method_call function,
// with the provided @interface_name set to "org.freedesktop.DBus.Properties".
//
// Ownership of the #GDBusMethodInvocation object passed to the
// method_call() function is transferred to your handler; you must
// call one of the methods of #GDBusMethodInvocation to return a reply
// (possibly empty), or an error. These functions also take ownership
// of the passed-in invocation object, so unless the invocation
// object has otherwise been referenced, it will be then be freed.
// Calling one of these functions may be done within your
// method_call() implementation but it also can be done at a later
// point to handle the method asynchronously.
//
// The usual checks on the validity of the calls is performed. For
// `Get` calls, an error is automatically returned if the property does
// not exist or the permissions do not allow access. The same checks are
// performed for `Set` calls, and the provided value is also checked for
// being the correct type.
//
// For both `Get` and `Set` calls, the #GDBusMethodInvocation
// passed to the @method_call handler can be queried with
// g_dbus_method_invocation_get_property_info() to get a pointer
// to the #GDBusPropertyInfo of the property.
//
// If you have readable properties specified in your interface info,
// you must ensure that you either provide a non-%NULL @get_property()
// function or provide implementations of both the `Get` and `GetAll`
// methods on org.freedesktop.DBus.Properties interface in your @method_call
// function. Note that the required return type of the `Get` call is
// `(v)`, not the type of the property. `GetAll` expects a return value
// of type `a{sv}`.
//
// If you have writable properties specified in your interface info,
// you must ensure that you either provide a non-%NULL @set_property()
// function or provide an implementation of the `Set` call. If implementing
// the call, you must return the value of type %G_VARIANT_TYPE_UNIT.
type DBusInterfaceVTable struct {
	_ structs.HostLayout

	MethodCall DBusInterfaceMethodCallFunc

	GetProperty DBusInterfaceGetPropertyFunc

	SetProperty DBusInterfaceSetPropertyFunc

	Padding [8]uintptr
}

func (x *DBusInterfaceVTable) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().
type DBusSubtreeVTable struct {
	_ structs.HostLayout

	Enumerate DBusSubtreeEnumerateFunc

	Introspect DBusSubtreeIntrospectFunc

	Dispatch DBusSubtreeDispatchFunc

	Padding [8]uintptr
}

func (x *DBusSubtreeVTable) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xBusGet func(BusType, uintptr, uintptr, uintptr)

// Asynchronously connects to the message bus specified by @bus_type.
//
// When the operation is finished, @callback will be invoked. You can
// then call g_bus_get_finish() to get the result of the operation.
//
// This is an asynchronous failable function. See g_bus_get_sync() for
// the synchronous version.
func BusGet(BusTypeVar BusType, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xBusGet(BusTypeVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xBusGetFinish func(uintptr, **glib.Error) uintptr

// Finishes an operation started with g_bus_get().
//
// The returned object is a singleton, that is, shared with other
// callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the
// event that you need a private message bus connection, use
// g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address() with
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
// G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
//
// Note that the returned #GDBusConnection object will (usually) have
// the #GDBusConnection:exit-on-close property set to %TRUE.
func BusGetFinish(ResVar AsyncResult) (*DBusConnection, error) {
	var cls *DBusConnection
	var cerr *glib.Error

	cret := xBusGetFinish(ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xBusGetSync func(BusType, uintptr, **glib.Error) uintptr

// Synchronously connects to the message bus specified by @bus_type.
// Note that the returned object may shared with other callers,
// e.g. if two separate parts of a process calls this function with
// the same @bus_type, they will share the same object.
//
// This is a synchronous failable function. See g_bus_get() and
// g_bus_get_finish() for the asynchronous version.
//
// The returned object is a singleton, that is, shared with other
// callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the
// event that you need a private message bus connection, use
// g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address() with
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
// G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
//
// Note that the returned #GDBusConnection object will (usually) have
// the #GDBusConnection:exit-on-close property set to %TRUE.
func BusGetSync(BusTypeVar BusType, CancellableVar *Cancellable) (*DBusConnection, error) {
	var cls *DBusConnection
	var cerr *glib.Error

	cret := xBusGetSync(BusTypeVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &DBusConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xBusGet, lib, "g_bus_get")
	core.PuregoSafeRegister(&xBusGetFinish, lib, "g_bus_get_finish")
	core.PuregoSafeRegister(&xBusGetSync, lib, "g_bus_get_sync")

}
