// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type ResolverClass struct {
	ParentClass uintptr
}

func (x *ResolverClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type ResolverPrivate struct {
}

func (x *ResolverPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Flags to modify lookup behavior.
type ResolverNameLookupFlags int

const (

	// default behavior (same as g_resolver_lookup_by_name())
	GResolverNameLookupFlagsDefaultValue ResolverNameLookupFlags = 0
	// only resolve ipv4 addresses
	GResolverNameLookupFlagsIpv4OnlyValue ResolverNameLookupFlags = 1
	// only resolve ipv6 addresses
	GResolverNameLookupFlagsIpv6OnlyValue ResolverNameLookupFlags = 2
)

// #GResolver provides cancellable synchronous and asynchronous DNS
// resolution, for hostnames (g_resolver_lookup_by_address(),
// g_resolver_lookup_by_name() and their async variants) and SRV
// (service) records (g_resolver_lookup_service()).
//
// #GNetworkAddress and #GNetworkService provide wrappers around
// #GResolver functionality that also implement #GSocketConnectable,
// making it easy to connect to a remote host/service.
type Resolver struct {
	gobject.Object
}

func ResolverNewFromInternalPtr(ptr uintptr) *Resolver {
	cls := &Resolver{}
	cls.Ptr = ptr
	return cls
}

var xResolverLookupByAddress func(uintptr, uintptr, uintptr, **glib.Error) string

// Synchronously reverse-resolves @address to determine its
// associated hostname.
//
// If the DNS resolution fails, @error (if non-%NULL) will be set to
// a value from #GResolverError.
//
// If @cancellable is non-%NULL, it can be used to cancel the
// operation, in which case @error (if non-%NULL) will be set to
// %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupByAddress(AddressVar *InetAddress, CancellableVar *Cancellable) (string, error) {
	var cerr *glib.Error

	cret := xResolverLookupByAddress(x.GoPointer(), AddressVar.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupByAddressAsync func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Begins asynchronously reverse-resolving @address to determine its
// associated hostname, and eventually calls @callback, which must
// call g_resolver_lookup_by_address_finish() to get the final result.
func (x *Resolver) LookupByAddressAsync(AddressVar *InetAddress, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xResolverLookupByAddressAsync(x.GoPointer(), AddressVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xResolverLookupByAddressFinish func(uintptr, uintptr, **glib.Error) string

// Retrieves the result of a previous call to
// g_resolver_lookup_by_address_async().
//
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupByAddressFinish(ResultVar AsyncResult) (string, error) {
	var cerr *glib.Error

	cret := xResolverLookupByAddressFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupByName func(uintptr, string, uintptr, **glib.Error) *glib.List

// Synchronously resolves @hostname to determine its associated IP
// address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
// the textual form of an IP address (in which case this just becomes
// a wrapper around g_inet_address_new_from_string()).
//
// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
// #GInetAddress, sorted in order of preference and guaranteed to not
// contain duplicates. That is, if using the result to connect to
// @hostname, you should attempt to connect to the first address
// first, then the second if the first fails, etc. If you are using
// the result to listen on a socket, it is appropriate to add each
// result using e.g. g_socket_listener_add_address().
//
// If the DNS resolution fails, @error (if non-%NULL) will be set to a
// value from #GResolverError and %NULL will be returned.
//
// If @cancellable is non-%NULL, it can be used to cancel the
// operation, in which case @error (if non-%NULL) will be set to
// %G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to a socket on the resolved IP
// address, it may be easier to create a #GNetworkAddress and use its
// #GSocketConnectable interface.
func (x *Resolver) LookupByName(HostnameVar string, CancellableVar *Cancellable) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupByName(x.GoPointer(), HostnameVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupByNameAsync func(uintptr, string, uintptr, uintptr, uintptr)

// Begins asynchronously resolving @hostname to determine its
// associated IP address(es), and eventually calls @callback, which
// must call g_resolver_lookup_by_name_finish() to get the result.
// See g_resolver_lookup_by_name() for more details.
func (x *Resolver) LookupByNameAsync(HostnameVar string, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xResolverLookupByNameAsync(x.GoPointer(), HostnameVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xResolverLookupByNameFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Retrieves the result of a call to
// g_resolver_lookup_by_name_async().
//
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupByNameFinish(ResultVar AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupByNameFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupByNameWithFlags func(uintptr, string, ResolverNameLookupFlags, uintptr, **glib.Error) *glib.List

// This differs from g_resolver_lookup_by_name() in that you can modify
// the lookup behavior with @flags. For example this can be used to limit
// results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
func (x *Resolver) LookupByNameWithFlags(HostnameVar string, FlagsVar ResolverNameLookupFlags, CancellableVar *Cancellable) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupByNameWithFlags(x.GoPointer(), HostnameVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupByNameWithFlagsAsync func(uintptr, string, ResolverNameLookupFlags, uintptr, uintptr, uintptr)

// Begins asynchronously resolving @hostname to determine its
// associated IP address(es), and eventually calls @callback, which
// must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
// See g_resolver_lookup_by_name() for more details.
func (x *Resolver) LookupByNameWithFlagsAsync(HostnameVar string, FlagsVar ResolverNameLookupFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xResolverLookupByNameWithFlagsAsync(x.GoPointer(), HostnameVar, FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xResolverLookupByNameWithFlagsFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Retrieves the result of a call to
// g_resolver_lookup_by_name_with_flags_async().
//
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupByNameWithFlagsFinish(ResultVar AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupByNameWithFlagsFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupRecords func(uintptr, string, ResolverRecordType, uintptr, **glib.Error) *glib.List

// Synchronously performs a DNS record lookup for the given @rrname and returns
// a list of records as #GVariant tuples. See #GResolverRecordType for
// information on what the records contain for each @record_type.
//
// If the DNS resolution fails, @error (if non-%NULL) will be set to
// a value from #GResolverError and %NULL will be returned.
//
// If @cancellable is non-%NULL, it can be used to cancel the
// operation, in which case @error (if non-%NULL) will be set to
// %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupRecords(RrnameVar string, RecordTypeVar ResolverRecordType, CancellableVar *Cancellable) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupRecords(x.GoPointer(), RrnameVar, RecordTypeVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupRecordsAsync func(uintptr, string, ResolverRecordType, uintptr, uintptr, uintptr)

// Begins asynchronously performing a DNS lookup for the given
// @rrname, and eventually calls @callback, which must call
// g_resolver_lookup_records_finish() to get the final result. See
// g_resolver_lookup_records() for more details.
func (x *Resolver) LookupRecordsAsync(RrnameVar string, RecordTypeVar ResolverRecordType, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xResolverLookupRecordsAsync(x.GoPointer(), RrnameVar, RecordTypeVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xResolverLookupRecordsFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Retrieves the result of a previous call to
// g_resolver_lookup_records_async(). Returns a non-empty list of records as
// #GVariant tuples. See #GResolverRecordType for information on what the
// records contain.
//
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupRecordsFinish(ResultVar AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupRecordsFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupService func(uintptr, string, string, string, uintptr, **glib.Error) *glib.List

// Synchronously performs a DNS SRV lookup for the given @service and
// @protocol in the given @domain and returns an array of #GSrvTarget.
// @domain may be an ASCII-only or UTF-8 hostname. Note also that the
// @service and @protocol arguments do not include the leading underscore
// that appears in the actual DNS entry.
//
// On success, g_resolver_lookup_service() will return a non-empty #GList of
// #GSrvTarget, sorted in order of preference. (That is, you should
// attempt to connect to the first target first, then the second if
// the first fails, etc.)
//
// If the DNS resolution fails, @error (if non-%NULL) will be set to
// a value from #GResolverError and %NULL will be returned.
//
// If @cancellable is non-%NULL, it can be used to cancel the
// operation, in which case @error (if non-%NULL) will be set to
// %G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to the service, it is usually easier
// to create a #GNetworkService and use its #GSocketConnectable
// interface.
func (x *Resolver) LookupService(ServiceVar string, ProtocolVar string, DomainVar string, CancellableVar *Cancellable) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupService(x.GoPointer(), ServiceVar, ProtocolVar, DomainVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverLookupServiceAsync func(uintptr, string, string, string, uintptr, uintptr, uintptr)

// Begins asynchronously performing a DNS SRV lookup for the given
// @service and @protocol in the given @domain, and eventually calls
// @callback, which must call g_resolver_lookup_service_finish() to
// get the final result. See g_resolver_lookup_service() for more
// details.
func (x *Resolver) LookupServiceAsync(ServiceVar string, ProtocolVar string, DomainVar string, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xResolverLookupServiceAsync(x.GoPointer(), ServiceVar, ProtocolVar, DomainVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xResolverLookupServiceFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Retrieves the result of a previous call to
// g_resolver_lookup_service_async().
//
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (x *Resolver) LookupServiceFinish(ResultVar AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xResolverLookupServiceFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xResolverSetDefault func(uintptr)

// Sets @resolver to be the application's default resolver (reffing
// @resolver, and unreffing the previous default resolver, if any).
// Future calls to g_resolver_get_default() will return this resolver.
//
// This can be used if an application wants to perform any sort of DNS
// caching or "pinning"; it can implement its own #GResolver that
// calls the original default resolver for DNS operations, and
// implements its own cache policies on top of that, and then set
// itself as the default resolver for all later code to use.
func (x *Resolver) SetDefault() {

	xResolverSetDefault(x.GoPointer())

}

func (c *Resolver) GoPointer() uintptr {
	return c.Ptr
}

func (c *Resolver) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the resolver notices that the system resolver
// configuration has changed.
func (x *Resolver) ConnectReload(cb *func(Resolver)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "reload", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Resolver{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "reload", cbRefPtr)
}

var xResolverFreeAddresses func(*glib.List)

// Frees @addresses (which should be the return value from
// g_resolver_lookup_by_name() or g_resolver_lookup_by_name_finish()).
// (This is a convenience method; you can also simply free the results
// by hand.)
func ResolverFreeAddresses(AddressesVar *glib.List) {

	xResolverFreeAddresses(AddressesVar)

}

var xResolverFreeTargets func(*glib.List)

// Frees @targets (which should be the return value from
// g_resolver_lookup_service() or g_resolver_lookup_service_finish()).
// (This is a convenience method; you can also simply free the
// results by hand.)
func ResolverFreeTargets(TargetsVar *glib.List) {

	xResolverFreeTargets(TargetsVar)

}

var xResolverGetDefault func() uintptr

// Gets the default #GResolver. You should unref it when you are done
// with it. #GResolver may use its reference count as a hint about how
// many threads it should allocate for concurrent DNS resolutions.
func ResolverGetDefault() *Resolver {
	var cls *Resolver

	cret := xResolverGetDefault()

	if cret == 0 {
		return nil
	}
	cls = &Resolver{}
	cls.Ptr = cret
	return cls
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xResolverLookupByAddress, lib, "g_resolver_lookup_by_address")
	core.PuregoSafeRegister(&xResolverLookupByAddressAsync, lib, "g_resolver_lookup_by_address_async")
	core.PuregoSafeRegister(&xResolverLookupByAddressFinish, lib, "g_resolver_lookup_by_address_finish")
	core.PuregoSafeRegister(&xResolverLookupByName, lib, "g_resolver_lookup_by_name")
	core.PuregoSafeRegister(&xResolverLookupByNameAsync, lib, "g_resolver_lookup_by_name_async")
	core.PuregoSafeRegister(&xResolverLookupByNameFinish, lib, "g_resolver_lookup_by_name_finish")
	core.PuregoSafeRegister(&xResolverLookupByNameWithFlags, lib, "g_resolver_lookup_by_name_with_flags")
	core.PuregoSafeRegister(&xResolverLookupByNameWithFlagsAsync, lib, "g_resolver_lookup_by_name_with_flags_async")
	core.PuregoSafeRegister(&xResolverLookupByNameWithFlagsFinish, lib, "g_resolver_lookup_by_name_with_flags_finish")
	core.PuregoSafeRegister(&xResolverLookupRecords, lib, "g_resolver_lookup_records")
	core.PuregoSafeRegister(&xResolverLookupRecordsAsync, lib, "g_resolver_lookup_records_async")
	core.PuregoSafeRegister(&xResolverLookupRecordsFinish, lib, "g_resolver_lookup_records_finish")
	core.PuregoSafeRegister(&xResolverLookupService, lib, "g_resolver_lookup_service")
	core.PuregoSafeRegister(&xResolverLookupServiceAsync, lib, "g_resolver_lookup_service_async")
	core.PuregoSafeRegister(&xResolverLookupServiceFinish, lib, "g_resolver_lookup_service_finish")
	core.PuregoSafeRegister(&xResolverSetDefault, lib, "g_resolver_set_default")

	core.PuregoSafeRegister(&xResolverFreeAddresses, lib, "g_resolver_free_addresses")
	core.PuregoSafeRegister(&xResolverFreeTargets, lib, "g_resolver_free_targets")
	core.PuregoSafeRegister(&xResolverGetDefault, lib, "g_resolver_get_default")

}
