// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Interface for creating #GDrive implementations.
type DriveIface struct {
	_ structs.HostLayout

	GIface uintptr
}

func (x *DriveIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GDrive - this represent a piece of hardware connected to the machine.
// It's generally only created for removable hardware or hardware with
// removable media.
//
// #GDrive is a container class for #GVolume objects that stem from
// the same piece of media. As such, #GDrive abstracts a drive with
// (or without) removable media and provides operations for querying
// whether media is available, determining whether media change is
// automatically detected and ejecting the media.
//
// If the #GDrive reports that media isn't automatically detected, one
// can poll for media; typically one should not do this periodically
// as a poll for media operation is potentially expensive and may
// spin up the drive creating noise.
//
// #GDrive supports starting and stopping drives with authentication
// support for the former. This can be used to support a diverse set
// of use cases including connecting/disconnecting iSCSI devices,
// powering down external disk enclosures and starting/stopping
// multi-disk devices such as RAID devices. Note that the actual
// semantics and side-effects of starting/stopping a #GDrive may vary
// according to implementation. To choose the correct verbs in e.g. a
// file manager, use g_drive_get_start_stop_type().
//
// For porting from GnomeVFS note that there is no equivalent of
// #GDrive in that API.
type Drive interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	CanEject() bool
	CanPollForMedia() bool
	CanStart() bool
	CanStartDegraded() bool
	CanStop() bool
	Eject(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EjectFinish(ResultVar AsyncResult) bool
	EjectWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EjectWithOperationFinish(ResultVar AsyncResult) bool
	EnumerateIdentifiers() []string
	GetIcon() *IconBase
	GetIdentifier(KindVar string) string
	GetName() string
	GetSortKey() string
	GetStartStopType() DriveStartStopType
	GetSymbolicIcon() *IconBase
	GetVolumes() *glib.List
	HasMedia() bool
	HasVolumes() bool
	IsMediaCheckAutomatic() bool
	IsMediaRemovable() bool
	IsRemovable() bool
	PollForMedia(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	PollForMediaFinish(ResultVar AsyncResult) bool
	Start(FlagsVar DriveStartFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	StartFinish(ResultVar AsyncResult) bool
	Stop(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	StopFinish(ResultVar AsyncResult) bool
}

var xDriveGLibType func() types.GType

func DriveGLibType() types.GType {
	return xDriveGLibType()
}

type DriveBase struct {
	Ptr uintptr
}

func (x *DriveBase) GoPointer() uintptr {
	return x.Ptr
}

func (x *DriveBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Checks if a drive can be ejected.
func (x *DriveBase) CanEject() bool {

	cret := XGDriveCanEject(x.GoPointer())
	return cret
}

// Checks if a drive can be polled for media changes.
func (x *DriveBase) CanPollForMedia() bool {

	cret := XGDriveCanPollForMedia(x.GoPointer())
	return cret
}

// Checks if a drive can be started.
func (x *DriveBase) CanStart() bool {

	cret := XGDriveCanStart(x.GoPointer())
	return cret
}

// Checks if a drive can be started degraded.
func (x *DriveBase) CanStartDegraded() bool {

	cret := XGDriveCanStartDegraded(x.GoPointer())
	return cret
}

// Checks if a drive can be stopped.
func (x *DriveBase) CanStop() bool {

	cret := XGDriveCanStop(x.GoPointer())
	return cret
}

// Asynchronously ejects a drive.
//
// When the operation is finished, @callback will be called.
// You can then call g_drive_eject_finish() to obtain the
// result of the operation.
func (x *DriveBase) Eject(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGDriveEject(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes ejecting a drive.
func (x *DriveBase) EjectFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGDriveEjectFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Ejects a drive. This is an asynchronous operation, and is
// finished by calling g_drive_eject_with_operation_finish() with the @drive
// and #GAsyncResult data returned in the @callback.
func (x *DriveBase) EjectWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGDriveEjectWithOperation(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes ejecting a drive. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (x *DriveBase) EjectWithOperationFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGDriveEjectWithOperationFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Gets the kinds of identifiers that @drive has.
// Use g_drive_get_identifier() to obtain the identifiers
// themselves.
func (x *DriveBase) EnumerateIdentifiers() []string {

	cret := XGDriveEnumerateIdentifiers(x.GoPointer())
	return cret
}

// Gets the icon for @drive.
func (x *DriveBase) GetIcon() *IconBase {
	var cls *IconBase

	cret := XGDriveGetIcon(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &IconBase{}
	cls.Ptr = cret
	return cls
}

// Gets the identifier of the given kind for @drive. The only
// identifier currently available is
// %G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
func (x *DriveBase) GetIdentifier(KindVar string) string {

	cret := XGDriveGetIdentifier(x.GoPointer(), KindVar)
	return cret
}

// Gets the name of @drive.
func (x *DriveBase) GetName() string {

	cret := XGDriveGetName(x.GoPointer())
	return cret
}

// Gets the sort key for @drive, if any.
func (x *DriveBase) GetSortKey() string {

	cret := XGDriveGetSortKey(x.GoPointer())
	return cret
}

// Gets a hint about how a drive can be started/stopped.
func (x *DriveBase) GetStartStopType() DriveStartStopType {

	cret := XGDriveGetStartStopType(x.GoPointer())
	return cret
}

// Gets the icon for @drive.
func (x *DriveBase) GetSymbolicIcon() *IconBase {
	var cls *IconBase

	cret := XGDriveGetSymbolicIcon(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &IconBase{}
	cls.Ptr = cret
	return cls
}

// Get a list of mountable volumes for @drive.
//
// The returned list should be freed with g_list_free(), after
// its elements have been unreffed with g_object_unref().
func (x *DriveBase) GetVolumes() *glib.List {

	cret := XGDriveGetVolumes(x.GoPointer())
	return cret
}

// Checks if the @drive has media. Note that the OS may not be polling
// the drive for media changes; see g_drive_is_media_check_automatic()
// for more details.
func (x *DriveBase) HasMedia() bool {

	cret := XGDriveHasMedia(x.GoPointer())
	return cret
}

// Check if @drive has any mountable volumes.
func (x *DriveBase) HasVolumes() bool {

	cret := XGDriveHasVolumes(x.GoPointer())
	return cret
}

// Checks if @drive is capable of automatically detecting media changes.
func (x *DriveBase) IsMediaCheckAutomatic() bool {

	cret := XGDriveIsMediaCheckAutomatic(x.GoPointer())
	return cret
}

// Checks if the @drive supports removable media.
func (x *DriveBase) IsMediaRemovable() bool {

	cret := XGDriveIsMediaRemovable(x.GoPointer())
	return cret
}

// Checks if the #GDrive and/or its media is considered removable by the user.
// See g_drive_is_media_removable().
func (x *DriveBase) IsRemovable() bool {

	cret := XGDriveIsRemovable(x.GoPointer())
	return cret
}

// Asynchronously polls @drive to see if media has been inserted or removed.
//
// When the operation is finished, @callback will be called.
// You can then call g_drive_poll_for_media_finish() to obtain the
// result of the operation.
func (x *DriveBase) PollForMedia(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGDrivePollForMedia(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an operation started with g_drive_poll_for_media() on a drive.
func (x *DriveBase) PollForMediaFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGDrivePollForMediaFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously starts a drive.
//
// When the operation is finished, @callback will be called.
// You can then call g_drive_start_finish() to obtain the
// result of the operation.
func (x *DriveBase) Start(FlagsVar DriveStartFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGDriveStart(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes starting a drive.
func (x *DriveBase) StartFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGDriveStartFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously stops a drive.
//
// When the operation is finished, @callback will be called.
// You can then call g_drive_stop_finish() to obtain the
// result of the operation.
func (x *DriveBase) Stop(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGDriveStop(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes stopping a drive.
func (x *DriveBase) StopFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGDriveStopFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var XGDriveCanEject func(uintptr) bool
var XGDriveCanPollForMedia func(uintptr) bool
var XGDriveCanStart func(uintptr) bool
var XGDriveCanStartDegraded func(uintptr) bool
var XGDriveCanStop func(uintptr) bool
var XGDriveEject func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr)
var XGDriveEjectFinish func(uintptr, uintptr, **glib.Error) bool
var XGDriveEjectWithOperation func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr, uintptr)
var XGDriveEjectWithOperationFinish func(uintptr, uintptr, **glib.Error) bool
var XGDriveEnumerateIdentifiers func(uintptr) []string
var XGDriveGetIcon func(uintptr) uintptr
var XGDriveGetIdentifier func(uintptr, string) string
var XGDriveGetName func(uintptr) string
var XGDriveGetSortKey func(uintptr) string
var XGDriveGetStartStopType func(uintptr) DriveStartStopType
var XGDriveGetSymbolicIcon func(uintptr) uintptr
var XGDriveGetVolumes func(uintptr) *glib.List
var XGDriveHasMedia func(uintptr) bool
var XGDriveHasVolumes func(uintptr) bool
var XGDriveIsMediaCheckAutomatic func(uintptr) bool
var XGDriveIsMediaRemovable func(uintptr) bool
var XGDriveIsRemovable func(uintptr) bool
var XGDrivePollForMedia func(uintptr, uintptr, uintptr, uintptr)
var XGDrivePollForMediaFinish func(uintptr, uintptr, **glib.Error) bool
var XGDriveStart func(uintptr, DriveStartFlags, uintptr, uintptr, uintptr, uintptr)
var XGDriveStartFinish func(uintptr, uintptr, **glib.Error) bool
var XGDriveStop func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr, uintptr)
var XGDriveStopFinish func(uintptr, uintptr, **glib.Error) bool

const (
	// The string used to obtain a Unix device path with g_drive_get_identifier().
	DRIVE_IDENTIFIER_KIND_UNIX_DEVICE string = "unix-device"
)

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xDriveGLibType, lib, "g_drive_get_type")

	core.PuregoSafeRegister(&XGDriveCanEject, lib, "g_drive_can_eject")
	core.PuregoSafeRegister(&XGDriveCanPollForMedia, lib, "g_drive_can_poll_for_media")
	core.PuregoSafeRegister(&XGDriveCanStart, lib, "g_drive_can_start")
	core.PuregoSafeRegister(&XGDriveCanStartDegraded, lib, "g_drive_can_start_degraded")
	core.PuregoSafeRegister(&XGDriveCanStop, lib, "g_drive_can_stop")
	core.PuregoSafeRegister(&XGDriveEject, lib, "g_drive_eject")
	core.PuregoSafeRegister(&XGDriveEjectFinish, lib, "g_drive_eject_finish")
	core.PuregoSafeRegister(&XGDriveEjectWithOperation, lib, "g_drive_eject_with_operation")
	core.PuregoSafeRegister(&XGDriveEjectWithOperationFinish, lib, "g_drive_eject_with_operation_finish")
	core.PuregoSafeRegister(&XGDriveEnumerateIdentifiers, lib, "g_drive_enumerate_identifiers")
	core.PuregoSafeRegister(&XGDriveGetIcon, lib, "g_drive_get_icon")
	core.PuregoSafeRegister(&XGDriveGetIdentifier, lib, "g_drive_get_identifier")
	core.PuregoSafeRegister(&XGDriveGetName, lib, "g_drive_get_name")
	core.PuregoSafeRegister(&XGDriveGetSortKey, lib, "g_drive_get_sort_key")
	core.PuregoSafeRegister(&XGDriveGetStartStopType, lib, "g_drive_get_start_stop_type")
	core.PuregoSafeRegister(&XGDriveGetSymbolicIcon, lib, "g_drive_get_symbolic_icon")
	core.PuregoSafeRegister(&XGDriveGetVolumes, lib, "g_drive_get_volumes")
	core.PuregoSafeRegister(&XGDriveHasMedia, lib, "g_drive_has_media")
	core.PuregoSafeRegister(&XGDriveHasVolumes, lib, "g_drive_has_volumes")
	core.PuregoSafeRegister(&XGDriveIsMediaCheckAutomatic, lib, "g_drive_is_media_check_automatic")
	core.PuregoSafeRegister(&XGDriveIsMediaRemovable, lib, "g_drive_is_media_removable")
	core.PuregoSafeRegister(&XGDriveIsRemovable, lib, "g_drive_is_removable")
	core.PuregoSafeRegister(&XGDrivePollForMedia, lib, "g_drive_poll_for_media")
	core.PuregoSafeRegister(&XGDrivePollForMediaFinish, lib, "g_drive_poll_for_media_finish")
	core.PuregoSafeRegister(&XGDriveStart, lib, "g_drive_start")
	core.PuregoSafeRegister(&XGDriveStartFinish, lib, "g_drive_start_finish")
	core.PuregoSafeRegister(&XGDriveStop, lib, "g_drive_stop")
	core.PuregoSafeRegister(&XGDriveStopFinish, lib, "g_drive_stop_finish")

}
