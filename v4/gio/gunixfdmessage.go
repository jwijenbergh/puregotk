// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type UnixFDMessageClass struct {
	ParentClass uintptr
}

func (x *UnixFDMessageClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type UnixFDMessagePrivate struct {
}

func (x *UnixFDMessagePrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// This #GSocketControlMessage contains a #GUnixFDList.
// It may be sent using g_socket_send_message() and received using
// g_socket_receive_message() over UNIX sockets (ie: sockets in the
// %G_SOCKET_FAMILY_UNIX family). The file descriptors are copied
// between processes by the kernel.
//
// For an easier way to send and receive file descriptors over
// stream-oriented UNIX sockets, see g_unix_connection_send_fd() and
// g_unix_connection_receive_fd().
//
// Note that `&lt;gio/gunixfdmessage.h&gt;` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
// file when using it.
type UnixFDMessage struct {
	SocketControlMessage
}

func UnixFDMessageNewFromInternalPtr(ptr uintptr) *UnixFDMessage {
	cls := &UnixFDMessage{}
	cls.Ptr = ptr
	return cls
}

var xNewUnixFDMessage func() uintptr

// Creates a new #GUnixFDMessage containing an empty file descriptor
// list.
func NewUnixFDMessage() *UnixFDMessage {
	var cls *UnixFDMessage

	cret := xNewUnixFDMessage()

	if cret == 0 {
		return nil
	}
	cls = &UnixFDMessage{}
	cls.Ptr = cret
	return cls
}

var xNewUnixFDMessageWithFdList func(uintptr) uintptr

// Creates a new #GUnixFDMessage containing @list.
func NewUnixFDMessageWithFdList(FdListVar *UnixFDList) *UnixFDMessage {
	var cls *UnixFDMessage

	cret := xNewUnixFDMessageWithFdList(FdListVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &UnixFDMessage{}
	cls.Ptr = cret
	return cls
}

var xUnixFDMessageAppendFd func(uintptr, int, **glib.Error) bool

// Adds a file descriptor to @message.
//
// The file descriptor is duplicated using dup(). You keep your copy
// of the descriptor and the copy contained in @message will be closed
// when @message is finalized.
//
// A possible cause of failure is exceeding the per-process or
// system-wide file descriptor limit.
func (x *UnixFDMessage) AppendFd(FdVar int) (bool, error) {
	var cerr *glib.Error

	cret := xUnixFDMessageAppendFd(x.GoPointer(), FdVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnixFDMessageGetFdList func(uintptr) uintptr

// Gets the #GUnixFDList contained in @message.  This function does not
// return a reference to the caller, but the returned list is valid for
// the lifetime of @message.
func (x *UnixFDMessage) GetFdList() *UnixFDList {
	var cls *UnixFDList

	cret := xUnixFDMessageGetFdList(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &UnixFDList{}
	cls.Ptr = cret
	return cls
}

var xUnixFDMessageStealFds func(uintptr, int) uintptr

// Returns the array of file descriptors that is contained in this
// object.
//
// After this call, the descriptors are no longer contained in
// @message. Further calls will return an empty list (unless more
// descriptors have been added).
//
// The return result of this function must be freed with g_free().
// The caller is also responsible for closing all of the file
// descriptors.
//
// If @length is non-%NULL then it is set to the number of file
// descriptors in the returned array. The returned array is also
// terminated with -1.
//
// This function never returns %NULL. In case there are no file
// descriptors contained in @message, an empty array is returned.
func (x *UnixFDMessage) StealFds(LengthVar int) uintptr {

	cret := xUnixFDMessageStealFds(x.GoPointer(), LengthVar)
	return cret
}

func (c *UnixFDMessage) GoPointer() uintptr {
	return c.Ptr
}

func (c *UnixFDMessage) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewUnixFDMessage, lib, "g_unix_fd_message_new")
	core.PuregoSafeRegister(&xNewUnixFDMessageWithFdList, lib, "g_unix_fd_message_new_with_fd_list")

	core.PuregoSafeRegister(&xUnixFDMessageAppendFd, lib, "g_unix_fd_message_append_fd")
	core.PuregoSafeRegister(&xUnixFDMessageGetFdList, lib, "g_unix_fd_message_get_fd_list")
	core.PuregoSafeRegister(&xUnixFDMessageStealFds, lib, "g_unix_fd_message_steal_fds")

}
