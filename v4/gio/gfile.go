// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// An interface for writing VFS file handles.
type FileIface struct {
	GIface uintptr

	SupportsThreadContexts bool
}

func (x *FileIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GFile is a high level abstraction for manipulating files on a
// virtual file system. #GFiles are lightweight, immutable objects
// that do no I/O upon creation. It is necessary to understand that
// #GFile objects do not represent files, merely an identifier for a
// file. All file content I/O is implemented as streaming operations
// (see #GInputStream and #GOutputStream).
//
// To construct a #GFile, you can use:
// - g_file_new_for_path() if you have a path.
// - g_file_new_for_uri() if you have a URI.
// - g_file_new_for_commandline_arg() for a command line argument.
// - g_file_new_tmp() to create a temporary file from a template.
// - g_file_parse_name() from a UTF-8 string gotten from g_file_get_parse_name().
// - g_file_new_build_filename() to create a file from path elements.
//
// One way to think of a #GFile is as an abstraction of a pathname. For
// normal files the system pathname is what is stored internally, but as
// #GFiles are extensible it could also be something else that corresponds
// to a pathname in a userspace implementation of a filesystem.
//
// #GFiles make up hierarchies of directories and files that correspond to
// the files on a filesystem. You can move through the file system with
// #GFile using g_file_get_parent() to get an identifier for the parent
// directory, g_file_get_child() to get a child within a directory,
// g_file_resolve_relative_path() to resolve a relative path between two
// #GFiles. There can be multiple hierarchies, so you may not end up at
// the same root if you repeatedly call g_file_get_parent() on two different
// files.
//
// All #GFiles have a basename (get with g_file_get_basename()). These names
// are byte strings that are used to identify the file on the filesystem
// (relative to its parent directory) and there is no guarantees that they
// have any particular charset encoding or even make any sense at all. If
// you want to use filenames in a user interface you should use the display
// name that you can get by requesting the
// %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with g_file_query_info().
// This is guaranteed to be in UTF-8 and can be used in a user interface.
// But always store the real basename or the #GFile to use to actually
// access the file, because there is no way to go from a display name to
// the actual name.
//
// Using #GFile as an identifier has the same weaknesses as using a path
// in that there may be multiple aliases for the same file. For instance,
// hard or soft links may cause two different #GFiles to refer to the same
// file. Other possible causes for aliases are: case insensitive filesystems,
// short and long names on FAT/NTFS, or bind mounts in Linux. If you want to
// check if two #GFiles point to the same file you can query for the
// %G_FILE_ATTRIBUTE_ID_FILE attribute. Note that #GFile does some trivial
// canonicalization of pathnames passed in, so that trivial differences in
// the path string used at creation (duplicated slashes, slash at end of
// path, "." or ".." path segments, etc) does not create different #GFiles.
//
// Many #GFile operations have both synchronous and asynchronous versions
// to suit your application. Asynchronous versions of synchronous functions
// simply have _async() appended to their function names. The asynchronous
// I/O functions call a #GAsyncReadyCallback which is then used to finalize
// the operation, producing a GAsyncResult which is then passed to the
// function's matching _finish() operation.
//
// It is highly recommended to use asynchronous calls when running within a
// shared main loop, such as in the main thread of an application. This avoids
// I/O operations blocking other sources on the main loop from being dispatched.
// Synchronous I/O operations should be performed from worker threads. See the
// [introduction to asynchronous programming section][async-programming] for
// more.
//
// Some #GFile operations almost always take a noticeable amount of time, and
// so do not have synchronous analogs. Notable cases include:
// - g_file_mount_mountable() to mount a mountable file.
// - g_file_unmount_mountable_with_operation() to unmount a mountable file.
// - g_file_eject_mountable_with_operation() to eject a mountable file.
//
// ## Entity Tags # {#gfile-etag}
//
// One notable feature of #GFiles are entity tags, or "etags" for
// short. Entity tags are somewhat like a more abstract version of the
// traditional mtime, and can be used to quickly determine if the file
// has been modified from the version on the file system. See the
// HTTP 1.1
// [specification](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
// for HTTP Etag headers, which are a very similar concept.
type File interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	AppendTo(FlagsVar FileCreateFlags, CancellableVar *Cancellable) *FileOutputStream
	AppendToAsync(FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	AppendToFinish(ResVar AsyncResult) *FileOutputStream
	BuildAttributeListForCopy(FlagsVar FileCopyFlags, CancellableVar *Cancellable) string
	Copy(DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr) bool
	CopyAsync(DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	CopyAttributes(DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable) bool
	CopyFinish(ResVar AsyncResult) bool
	Create(FlagsVar FileCreateFlags, CancellableVar *Cancellable) *FileOutputStream
	CreateAsync(FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	CreateFinish(ResVar AsyncResult) *FileOutputStream
	CreateReadwrite(FlagsVar FileCreateFlags, CancellableVar *Cancellable) *FileIOStream
	CreateReadwriteAsync(FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	CreateReadwriteFinish(ResVar AsyncResult) *FileIOStream
	Delete(CancellableVar *Cancellable) bool
	DeleteAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	DeleteFinish(ResultVar AsyncResult) bool
	Dup() *FileBase
	EjectMountable(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EjectMountableFinish(ResultVar AsyncResult) bool
	EjectMountableWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EjectMountableWithOperationFinish(ResultVar AsyncResult) bool
	EnumerateChildren(AttributesVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) *FileEnumerator
	EnumerateChildrenAsync(AttributesVar string, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	EnumerateChildrenFinish(ResVar AsyncResult) *FileEnumerator
	Equal(File2Var File) bool
	FindEnclosingMount(CancellableVar *Cancellable) *MountBase
	FindEnclosingMountAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	FindEnclosingMountFinish(ResVar AsyncResult) *MountBase
	GetBasename() string
	GetChild(NameVar string) *FileBase
	GetChildForDisplayName(DisplayNameVar string) *FileBase
	GetParent() *FileBase
	GetParseName() string
	GetPath() string
	GetRelativePath(DescendantVar File) string
	GetUri() string
	GetUriScheme() string
	HasParent(ParentVar File) bool
	HasPrefix(PrefixVar File) bool
	HasUriScheme(UriSchemeVar string) bool
	Hash() uint
	IsNative() bool
	LoadBytes(CancellableVar *Cancellable, EtagOutVar string) *glib.Bytes
	LoadBytesAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	LoadBytesFinish(ResultVar AsyncResult, EtagOutVar string) *glib.Bytes
	LoadContents(CancellableVar *Cancellable, ContentsVar []string, LengthVar uint, EtagOutVar string) bool
	LoadContentsAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	LoadContentsFinish(ResVar AsyncResult, ContentsVar []string, LengthVar uint, EtagOutVar string) bool
	LoadPartialContentsAsync(CancellableVar *Cancellable, ReadMoreCallbackVar *FileReadMoreCallback, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	LoadPartialContentsFinish(ResVar AsyncResult, ContentsVar []string, LengthVar uint, EtagOutVar string) bool
	MakeDirectory(CancellableVar *Cancellable) bool
	MakeDirectoryAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	MakeDirectoryFinish(ResultVar AsyncResult) bool
	MakeDirectoryWithParents(CancellableVar *Cancellable) bool
	MakeSymbolicLink(SymlinkValueVar string, CancellableVar *Cancellable) bool
	MeasureDiskUsage(FlagsVar FileMeasureFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileMeasureProgressCallback, ProgressDataVar uintptr, DiskUsageVar uint64, NumDirsVar uint64, NumFilesVar uint64) bool
	MeasureDiskUsageAsync(FlagsVar FileMeasureFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileMeasureProgressCallback, ProgressDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	MeasureDiskUsageFinish(ResultVar AsyncResult, DiskUsageVar uint64, NumDirsVar uint64, NumFilesVar uint64) bool
	Monitor(FlagsVar FileMonitorFlags, CancellableVar *Cancellable) *FileMonitor
	MonitorDirectory(FlagsVar FileMonitorFlags, CancellableVar *Cancellable) *FileMonitor
	MonitorFile(FlagsVar FileMonitorFlags, CancellableVar *Cancellable) *FileMonitor
	MountEnclosingVolume(FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	MountEnclosingVolumeFinish(ResultVar AsyncResult) bool
	MountMountable(FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	MountMountableFinish(ResultVar AsyncResult) *FileBase
	Move(DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr) bool
	MoveAsync(DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	MoveFinish(ResultVar AsyncResult) bool
	OpenReadwrite(CancellableVar *Cancellable) *FileIOStream
	OpenReadwriteAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	OpenReadwriteFinish(ResVar AsyncResult) *FileIOStream
	PeekPath() string
	PollMountable(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	PollMountableFinish(ResultVar AsyncResult) bool
	QueryDefaultHandler(CancellableVar *Cancellable) *AppInfoBase
	QueryDefaultHandlerAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	QueryDefaultHandlerFinish(ResultVar AsyncResult) *AppInfoBase
	QueryExists(CancellableVar *Cancellable) bool
	QueryFileType(FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) FileType
	QueryFilesystemInfo(AttributesVar string, CancellableVar *Cancellable) *FileInfo
	QueryFilesystemInfoAsync(AttributesVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	QueryFilesystemInfoFinish(ResVar AsyncResult) *FileInfo
	QueryInfo(AttributesVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) *FileInfo
	QueryInfoAsync(AttributesVar string, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	QueryInfoFinish(ResVar AsyncResult) *FileInfo
	QuerySettableAttributes(CancellableVar *Cancellable) *FileAttributeInfoList
	QueryWritableNamespaces(CancellableVar *Cancellable) *FileAttributeInfoList
	Read(CancellableVar *Cancellable) *FileInputStream
	ReadAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	ReadFinish(ResVar AsyncResult) *FileInputStream
	Replace(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable) *FileOutputStream
	ReplaceAsync(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	ReplaceContents(ContentsVar string, LengthVar uint, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, NewEtagVar string, CancellableVar *Cancellable) bool
	ReplaceContentsAsync(ContentsVar string, LengthVar uint, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	ReplaceContentsBytesAsync(ContentsVar *glib.Bytes, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	ReplaceContentsFinish(ResVar AsyncResult, NewEtagVar string) bool
	ReplaceFinish(ResVar AsyncResult) *FileOutputStream
	ReplaceReadwrite(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable) *FileIOStream
	ReplaceReadwriteAsync(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	ReplaceReadwriteFinish(ResVar AsyncResult) *FileIOStream
	ResolveRelativePath(RelativePathVar string) *FileBase
	SetAttribute(AttributeVar string, TypeVar FileAttributeType, ValuePVar uintptr, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) bool
	SetAttributeByteString(AttributeVar string, ValueVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) bool
	SetAttributeInt32(AttributeVar string, ValueVar int32, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) bool
	SetAttributeInt64(AttributeVar string, ValueVar int64, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) bool
	SetAttributeString(AttributeVar string, ValueVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) bool
	SetAttributeUint32(AttributeVar string, ValueVar uint32, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) bool
	SetAttributeUint64(AttributeVar string, ValueVar uint64, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) bool
	SetAttributesAsync(InfoVar *FileInfo, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	SetAttributesFinish(ResultVar AsyncResult, InfoVar **FileInfo) bool
	SetAttributesFromInfo(InfoVar *FileInfo, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) bool
	SetDisplayName(DisplayNameVar string, CancellableVar *Cancellable) *FileBase
	SetDisplayNameAsync(DisplayNameVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	SetDisplayNameFinish(ResVar AsyncResult) *FileBase
	StartMountable(FlagsVar DriveStartFlags, StartOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	StartMountableFinish(ResultVar AsyncResult) bool
	StopMountable(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	StopMountableFinish(ResultVar AsyncResult) bool
	SupportsThreadContexts() bool
	Trash(CancellableVar *Cancellable) bool
	TrashAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	TrashFinish(ResultVar AsyncResult) bool
	UnmountMountable(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	UnmountMountableFinish(ResultVar AsyncResult) bool
	UnmountMountableWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr)
	UnmountMountableWithOperationFinish(ResultVar AsyncResult) bool
}

var xFileGLibType func() types.GType

func FileGLibType() types.GType {
	return xFileGLibType()
}

type FileBase struct {
	Ptr uintptr
}

func (x *FileBase) GoPointer() uintptr {
	return x.Ptr
}

func (x *FileBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Gets an output stream for appending data to the file.
// If the file doesn't already exist it is created.
//
// By default files created are generally readable by everyone,
// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
// will be made readable only to the current user, to the level that
// is supported on the target filesystem.
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// Some file systems don't allow all file names, and may return an
// %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
// %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
// possible too, and depend on what kind of filesystem the file is on.
func (x *FileBase) AppendTo(FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileOutputStream, error) {
	var cls *FileOutputStream
	var cerr *glib.Error

	cret := XGFileAppendTo(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileOutputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously opens @file for appending.
//
// For more details, see g_file_append_to() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_append_to_finish() to get the result
// of the operation.
func (x *FileBase) AppendToAsync(FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileAppendToAsync(x.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file append operation started with
// g_file_append_to_async().
func (x *FileBase) AppendToFinish(ResVar AsyncResult) (*FileOutputStream, error) {
	var cls *FileOutputStream
	var cerr *glib.Error

	cret := XGFileAppendToFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileOutputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Prepares the file attribute query string for copying to @file.
//
// This function prepares an attribute query string to be
// passed to g_file_query_info() to get a list of attributes
// normally copied with the file (see g_file_copy_attributes()
// for the detailed description). This function is used by the
// implementation of g_file_copy_attributes() and is useful
// when one needs to query and set the attributes in two
// stages (e.g., for recursive move of a directory).
func (x *FileBase) BuildAttributeListForCopy(FlagsVar FileCopyFlags, CancellableVar *Cancellable) (string, error) {
	var cerr *glib.Error

	cret := XGFileBuildAttributeListForCopy(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Copies the file @source to the location specified by @destination.
// Can not handle recursive copies of directories.
//
// If the flag %G_FILE_COPY_OVERWRITE is specified an already
// existing @destination file is overwritten.
//
// If the flag %G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
// will be copied as symlinks, otherwise the target of the
// @source symlink will be copied.
//
// If the flag %G_FILE_COPY_ALL_METADATA is specified then all the metadata
// that is possible to copy is copied, not just the default subset (which,
// for instance, does not include the owner, see #GFileInfo).
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// If @progress_callback is not %NULL, then the operation can be monitored
// by setting this to a #GFileProgressCallback function.
// @progress_callback_data will be passed to this function. It is guaranteed
// that this callback will be called after all data has been transferred with
// the total number of bytes copied during the operation.
//
// If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND error
// is returned, independent on the status of the @destination.
//
// If %G_FILE_COPY_OVERWRITE is not specified and the target exists, then
// the error %G_IO_ERROR_EXISTS is returned.
//
// If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
// error is returned. If trying to overwrite a directory with a directory the
// %G_IO_ERROR_WOULD_MERGE error is returned.
//
// If the source is a directory and the target does not exist, or
// %G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
// %G_IO_ERROR_WOULD_RECURSE error is returned.
//
// If you are interested in copying the #GFile object itself (not the on-disk
// file), see g_file_dup().
func (x *FileBase) Copy(DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr) (bool, error) {
	var cerr *glib.Error

	cret := XGFileCopy(x.GoPointer(), DestinationVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(ProgressCallbackVar), ProgressCallbackDataVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Copies the file @source to the location specified by @destination
// asynchronously. For details of the behaviour, see g_file_copy().
//
// If @progress_callback is not %NULL, then that function that will be called
// just like in g_file_copy(). The callback will run in the default main context
// of the thread calling g_file_copy_async() — the same context as @callback is
// run in.
//
// When the operation is finished, @callback will be called. You can then call
// g_file_copy_finish() to get the result of the operation.
func (x *FileBase) CopyAsync(DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileCopyAsync(x.GoPointer(), DestinationVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(ProgressCallbackVar), ProgressCallbackDataVar, glib.NewCallback(CallbackVar), UserDataVar)

}

// Copies the file attributes from @source to @destination.
//
// Normally only a subset of the file attributes are copied,
// those that are copies in a normal file copy operation
// (which for instance does not include e.g. owner). However
// if %G_FILE_COPY_ALL_METADATA is specified in @flags, then
// all the metadata that is possible to copy is copied. This
// is useful when implementing move by copy + delete source.
func (x *FileBase) CopyAttributes(DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileCopyAttributes(x.GoPointer(), DestinationVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Finishes copying the file started with g_file_copy_async().
func (x *FileBase) CopyFinish(ResVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileCopyFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Creates a new file and returns an output stream for writing to it.
// The file must not already exist.
//
// By default files created are generally readable by everyone,
// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
// will be made readable only to the current user, to the level
// that is supported on the target filesystem.
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// If a file or directory with this name already exists the
// %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
// allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
// error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
// be returned. Other errors are possible too, and depend on what kind
// of filesystem the file is on.
func (x *FileBase) Create(FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileOutputStream, error) {
	var cls *FileOutputStream
	var cerr *glib.Error

	cret := XGFileCreate(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileOutputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously creates a new file and returns an output stream
// for writing to it. The file must not already exist.
//
// For more details, see g_file_create() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_create_finish() to get the result
// of the operation.
func (x *FileBase) CreateAsync(FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileCreateAsync(x.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file create operation started with
// g_file_create_async().
func (x *FileBase) CreateFinish(ResVar AsyncResult) (*FileOutputStream, error) {
	var cls *FileOutputStream
	var cerr *glib.Error

	cret := XGFileCreateFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileOutputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Creates a new file and returns a stream for reading and
// writing to it. The file must not already exist.
//
// By default files created are generally readable by everyone,
// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
// will be made readable only to the current user, to the level
// that is supported on the target filesystem.
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// If a file or directory with this name already exists, the
// %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
// allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
// error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
// will be returned. Other errors are possible too, and depend on what
// kind of filesystem the file is on.
//
// Note that in many non-local file cases read and write streams are
// not supported, so make sure you really need to do read and write
// streaming, rather than just opening for reading or writing.
func (x *FileBase) CreateReadwrite(FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileIOStream, error) {
	var cls *FileIOStream
	var cerr *glib.Error

	cret := XGFileCreateReadwrite(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileIOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously creates a new file and returns a stream
// for reading and writing to it. The file must not already exist.
//
// For more details, see g_file_create_readwrite() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_create_readwrite_finish() to get
// the result of the operation.
func (x *FileBase) CreateReadwriteAsync(FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileCreateReadwriteAsync(x.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file create operation started with
// g_file_create_readwrite_async().
func (x *FileBase) CreateReadwriteFinish(ResVar AsyncResult) (*FileIOStream, error) {
	var cls *FileIOStream
	var cerr *glib.Error

	cret := XGFileCreateReadwriteFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileIOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Deletes a file. If the @file is a directory, it will only be
// deleted if it is empty. This has the same semantics as g_unlink().
//
// If @file doesn’t exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
// for deletion to be implemented avoiding
// [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
// |[
// g_autoptr(GError) local_error = NULL;
// if (!g_file_delete (my_file, my_cancellable, &amp;local_error) &amp;&amp;
//
//	  !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
//	{
//	  // deletion failed for some reason other than the file not existing:
//	  // so report the error
//	  g_warning ("Failed to delete %s: %s",
//	             g_file_peek_path (my_file), local_error-&gt;message);
//	}
//
// ]|
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) Delete(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileDelete(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously delete a file. If the @file is a directory, it will
// only be deleted if it is empty.  This has the same semantics as
// g_unlink().
func (x *FileBase) DeleteAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileDeleteAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes deleting a file started with g_file_delete_async().
func (x *FileBase) DeleteFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileDeleteFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Duplicates a #GFile handle. This operation does not duplicate
// the actual file or directory represented by the #GFile; see
// g_file_copy() if attempting to copy a file.
//
// g_file_dup() is useful when a second handle is needed to the same underlying
// file, for use in a separate thread (#GFile is not thread-safe). For use
// within the same thread, use g_object_ref() to increment the existing object’s
// reference count.
//
// This call does no blocking I/O.
func (x *FileBase) Dup() *FileBase {
	var cls *FileBase

	cret := XGFileDup(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

// Starts an asynchronous eject on a mountable.
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_eject_mountable_finish().
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) EjectMountable(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileEjectMountable(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous eject operation started by
// g_file_eject_mountable().
func (x *FileBase) EjectMountableFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileEjectMountableFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Starts an asynchronous eject on a mountable.
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_eject_mountable_with_operation_finish().
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) EjectMountableWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileEjectMountableWithOperation(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous eject operation started by
// g_file_eject_mountable_with_operation().
func (x *FileBase) EjectMountableWithOperationFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileEjectMountableWithOperationFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Gets the requested information about the files in a directory.
// The result is a #GFileEnumerator object that will give out
// #GFileInfo objects for all the files in the directory.
//
// The @attributes value is a string that specifies the file
// attributes that should be gathered. It is not an error if
// it's not possible to read a particular requested attribute
// from a file - it just won't be set. @attributes should
// be a comma-separated list of attributes or attribute wildcards.
// The wildcard "*" means all attributes, and a wildcard like
// "standard::*" means all attributes in the standard namespace.
// An example attribute query be "standard::*,owner::user".
// The standard attributes are available as defines, like
// %G_FILE_ATTRIBUTE_STANDARD_NAME. %G_FILE_ATTRIBUTE_STANDARD_NAME should
// always be specified if you plan to call g_file_enumerator_get_child() or
// g_file_enumerator_iterate() on the returned enumerator.
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
// be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
// error will be returned. Other errors are possible too.
func (x *FileBase) EnumerateChildren(AttributesVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (*FileEnumerator, error) {
	var cls *FileEnumerator
	var cerr *glib.Error

	cret := XGFileEnumerateChildren(x.GoPointer(), AttributesVar, FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileEnumerator{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously gets the requested information about the files
// in a directory. The result is a #GFileEnumerator object that will
// give out #GFileInfo objects for all the files in the directory.
//
// For more details, see g_file_enumerate_children() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called. You can
// then call g_file_enumerate_children_finish() to get the result of
// the operation.
func (x *FileBase) EnumerateChildrenAsync(AttributesVar string, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileEnumerateChildrenAsync(x.GoPointer(), AttributesVar, FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an async enumerate children operation.
// See g_file_enumerate_children_async().
func (x *FileBase) EnumerateChildrenFinish(ResVar AsyncResult) (*FileEnumerator, error) {
	var cls *FileEnumerator
	var cerr *glib.Error

	cret := XGFileEnumerateChildrenFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileEnumerator{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Checks if the two given #GFiles refer to the same file.
//
// Note that two #GFiles that differ can still refer to the same
// file on the filesystem due to various forms of filename
// aliasing.
//
// This call does no blocking I/O.
func (x *FileBase) Equal(File2Var File) bool {

	cret := XGFileEqual(x.GoPointer(), File2Var.GoPointer())
	return cret
}

// Gets a #GMount for the #GFile.
//
// #GMount is returned only for user interesting locations, see
// #GVolumeMonitor. If the #GFileIface for @file does not have a #mount,
// @error will be set to %G_IO_ERROR_NOT_FOUND and %NULL #will be returned.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) FindEnclosingMount(CancellableVar *Cancellable) (*MountBase, error) {
	var cls *MountBase
	var cerr *glib.Error

	cret := XGFileFindEnclosingMount(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &MountBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously gets the mount for the file.
//
// For more details, see g_file_find_enclosing_mount() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_find_enclosing_mount_finish() to
// get the result of the operation.
func (x *FileBase) FindEnclosingMountAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileFindEnclosingMountAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous find mount request.
// See g_file_find_enclosing_mount_async().
func (x *FileBase) FindEnclosingMountFinish(ResVar AsyncResult) (*MountBase, error) {
	var cls *MountBase
	var cerr *glib.Error

	cret := XGFileFindEnclosingMountFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &MountBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Gets the base name (the last component of the path) for a given #GFile.
//
// If called for the top level of a system (such as the filesystem root
// or a uri like sftp://host/) it will return a single directory separator
// (and on Windows, possibly a drive letter).
//
// The base name is a byte string (not UTF-8). It has no defined encoding
// or rules other than it may not contain zero bytes.  If you want to use
// filenames in a user interface you should use the display name that you
// can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
// attribute with g_file_query_info().
//
// This call does no blocking I/O.
func (x *FileBase) GetBasename() string {

	cret := XGFileGetBasename(x.GoPointer())
	return cret
}

// Gets a child of @file with basename equal to @name.
//
// Note that the file with that specific name might not exist, but
// you can still have a #GFile that points to it. You can use this
// for instance to create that file.
//
// This call does no blocking I/O.
func (x *FileBase) GetChild(NameVar string) *FileBase {
	var cls *FileBase

	cret := XGFileGetChild(x.GoPointer(), NameVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

// Gets the child of @file for a given @display_name (i.e. a UTF-8
// version of the name). If this function fails, it returns %NULL
// and @error will be set. This is very useful when constructing a
// #GFile for a new file and the user entered the filename in the
// user interface, for instance when you select a directory and
// type a filename in the file selector.
//
// This call does no blocking I/O.
func (x *FileBase) GetChildForDisplayName(DisplayNameVar string) (*FileBase, error) {
	var cls *FileBase
	var cerr *glib.Error

	cret := XGFileGetChildForDisplayName(x.GoPointer(), DisplayNameVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Gets the parent directory for the @file.
// If the @file represents the root directory of the
// file system, then %NULL will be returned.
//
// This call does no blocking I/O.
func (x *FileBase) GetParent() *FileBase {
	var cls *FileBase

	cret := XGFileGetParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

// Gets the parse name of the @file.
// A parse name is a UTF-8 string that describes the
// file such that one can get the #GFile back using
// g_file_parse_name().
//
// This is generally used to show the #GFile as a nice
// full-pathname kind of string in a user interface,
// like in a location entry.
//
// For local files with names that can safely be converted
// to UTF-8 the pathname is used, otherwise the IRI is used
// (a form of URI that allows UTF-8 characters unescaped).
//
// This call does no blocking I/O.
func (x *FileBase) GetParseName() string {

	cret := XGFileGetParseName(x.GoPointer())
	return cret
}

// Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
// guaranteed to be an absolute, canonical path. It might contain symlinks.
//
// This call does no blocking I/O.
func (x *FileBase) GetPath() string {

	cret := XGFileGetPath(x.GoPointer())
	return cret
}

// Gets the path for @descendant relative to @parent.
//
// This call does no blocking I/O.
func (x *FileBase) GetRelativePath(DescendantVar File) string {

	cret := XGFileGetRelativePath(x.GoPointer(), DescendantVar.GoPointer())
	return cret
}

// Gets the URI for the @file.
//
// This call does no blocking I/O.
func (x *FileBase) GetUri() string {

	cret := XGFileGetUri(x.GoPointer())
	return cret
}

// Gets the URI scheme for a #GFile.
// RFC 3986 decodes the scheme as:
// |[
// URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
// ]|
// Common schemes include "file", "http", "ftp", etc.
//
// The scheme can be different from the one used to construct the #GFile,
// in that it might be replaced with one that is logically equivalent to the #GFile.
//
// This call does no blocking I/O.
func (x *FileBase) GetUriScheme() string {

	cret := XGFileGetUriScheme(x.GoPointer())
	return cret
}

// Checks if @file has a parent, and optionally, if it is @parent.
//
// If @parent is %NULL then this function returns %TRUE if @file has any
// parent at all.  If @parent is non-%NULL then %TRUE is only returned
// if @file is an immediate child of @parent.
func (x *FileBase) HasParent(ParentVar File) bool {

	cret := XGFileHasParent(x.GoPointer(), ParentVar.GoPointer())
	return cret
}

// Checks whether @file has the prefix specified by @prefix.
//
// In other words, if the names of initial elements of @file's
// pathname match @prefix. Only full pathname elements are matched,
// so a path like /foo is not considered a prefix of /foobar, only
// of /foo/bar.
//
// A #GFile is not a prefix of itself. If you want to check for
// equality, use g_file_equal().
//
// This call does no I/O, as it works purely on names. As such it can
// sometimes return %FALSE even if @file is inside a @prefix (from a
// filesystem point of view), because the prefix of @file is an alias
// of @prefix.
func (x *FileBase) HasPrefix(PrefixVar File) bool {

	cret := XGFileHasPrefix(x.GoPointer(), PrefixVar.GoPointer())
	return cret
}

// Checks to see if a #GFile has a given URI scheme.
//
// This call does no blocking I/O.
func (x *FileBase) HasUriScheme(UriSchemeVar string) bool {

	cret := XGFileHasUriScheme(x.GoPointer(), UriSchemeVar)
	return cret
}

// Creates a hash value for a #GFile.
//
// This call does no blocking I/O.
func (x *FileBase) Hash() uint {

	cret := XGFileHash(x.GoPointer())
	return cret
}

// Checks to see if a file is native to the platform.
//
// A native file is one expressed in the platform-native filename format,
// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
// as it might be on a locally mounted remote filesystem.
//
// On some systems non-native files may be available using the native
// filesystem via a userspace filesystem (FUSE), in these cases this call
// will return %FALSE, but g_file_get_path() will still return a native path.
//
// This call does no blocking I/O.
func (x *FileBase) IsNative() bool {

	cret := XGFileIsNative(x.GoPointer())
	return cret
}

// Loads the contents of @file and returns it as #GBytes.
//
// If @file is a resource:// based URI, the resulting bytes will reference the
// embedded resource instead of a copy. Otherwise, this is equivalent to calling
// g_file_load_contents() and g_bytes_new_take().
//
// For resources, @etag_out will be set to %NULL.
//
// The data contained in the resulting #GBytes is always zero-terminated, but
// this is not included in the #GBytes length. The resulting #GBytes should be
// freed with g_bytes_unref() when no longer in use.
func (x *FileBase) LoadBytes(CancellableVar *Cancellable, EtagOutVar string) (*glib.Bytes, error) {
	var cerr *glib.Error

	cret := XGFileLoadBytes(x.GoPointer(), CancellableVar.GoPointer(), EtagOutVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously loads the contents of @file as #GBytes.
//
// If @file is a resource:// based URI, the resulting bytes will reference the
// embedded resource instead of a copy. Otherwise, this is equivalent to calling
// g_file_load_contents_async() and g_bytes_new_take().
//
// @callback should call g_file_load_bytes_finish() to get the result of this
// asynchronous operation.
//
// See g_file_load_bytes() for more information.
func (x *FileBase) LoadBytesAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileLoadBytesAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Completes an asynchronous request to g_file_load_bytes_async().
//
// For resources, @etag_out will be set to %NULL.
//
// The data contained in the resulting #GBytes is always zero-terminated, but
// this is not included in the #GBytes length. The resulting #GBytes should be
// freed with g_bytes_unref() when no longer in use.
//
// See g_file_load_bytes() for more information.
func (x *FileBase) LoadBytesFinish(ResultVar AsyncResult, EtagOutVar string) (*glib.Bytes, error) {
	var cerr *glib.Error

	cret := XGFileLoadBytesFinish(x.GoPointer(), ResultVar.GoPointer(), EtagOutVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Loads the content of the file into memory. The data is always
// zero-terminated, but this is not included in the resultant @length.
// The returned @contents should be freed with g_free() when no longer
// needed.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) LoadContents(CancellableVar *Cancellable, ContentsVar []string, LengthVar uint, EtagOutVar string) (bool, error) {
	var cerr *glib.Error

	cret := XGFileLoadContents(x.GoPointer(), CancellableVar.GoPointer(), ContentsVar, LengthVar, EtagOutVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Starts an asynchronous load of the @file's contents.
//
// For more details, see g_file_load_contents() which is
// the synchronous version of this call.
//
// When the load operation has completed, @callback will be called
// with @user data. To finish the operation, call
// g_file_load_contents_finish() with the #GAsyncResult returned by
// the @callback.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) LoadContentsAsync(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileLoadContentsAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous load of the @file's contents.
// The contents are placed in @contents, and @length is set to the
// size of the @contents string. The @contents should be freed with
// g_free() when no longer needed. If @etag_out is present, it will be
// set to the new entity tag for the @file.
func (x *FileBase) LoadContentsFinish(ResVar AsyncResult, ContentsVar []string, LengthVar uint, EtagOutVar string) (bool, error) {
	var cerr *glib.Error

	cret := XGFileLoadContentsFinish(x.GoPointer(), ResVar.GoPointer(), ContentsVar, LengthVar, EtagOutVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Reads the partial contents of a file. A #GFileReadMoreCallback should
// be used to stop reading from the file when appropriate, else this
// function will behave exactly as g_file_load_contents_async(). This
// operation can be finished by g_file_load_partial_contents_finish().
//
// Users of this function should be aware that @user_data is passed to
// both the @read_more_callback and the @callback.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) LoadPartialContentsAsync(CancellableVar *Cancellable, ReadMoreCallbackVar *FileReadMoreCallback, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileLoadPartialContentsAsync(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(ReadMoreCallbackVar), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous partial load operation that was started
// with g_file_load_partial_contents_async(). The data is always
// zero-terminated, but this is not included in the resultant @length.
// The returned @contents should be freed with g_free() when no longer
// needed.
func (x *FileBase) LoadPartialContentsFinish(ResVar AsyncResult, ContentsVar []string, LengthVar uint, EtagOutVar string) (bool, error) {
	var cerr *glib.Error

	cret := XGFileLoadPartialContentsFinish(x.GoPointer(), ResVar.GoPointer(), ContentsVar, LengthVar, EtagOutVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Creates a directory. Note that this will only create a child directory
// of the immediate parent directory of the path or URI given by the #GFile.
// To recursively create directories, see g_file_make_directory_with_parents().
// This function will fail if the parent directory does not exist, setting
// @error to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
// creating directories, this function will fail, setting @error to
// %G_IO_ERROR_NOT_SUPPORTED.
//
// For a local #GFile the newly created directory will have the default
// (current) ownership and permissions of the current process.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) MakeDirectory(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMakeDirectory(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously creates a directory.
func (x *FileBase) MakeDirectoryAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileMakeDirectoryAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous directory creation, started with
// g_file_make_directory_async().
func (x *FileBase) MakeDirectoryFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMakeDirectoryFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Creates a directory and any parent directories that may not
// exist similar to 'mkdir -p'. If the file system does not support
// creating directories, this function will fail, setting @error to
// %G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists,
// this function will fail setting @error to %G_IO_ERROR_EXISTS, unlike
// the similar g_mkdir_with_parents().
//
// For a local #GFile the newly created directories will have the default
// (current) ownership and permissions of the current process.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) MakeDirectoryWithParents(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMakeDirectoryWithParents(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Creates a symbolic link named @file which contains the string
// @symlink_value.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) MakeSymbolicLink(SymlinkValueVar string, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMakeSymbolicLink(x.GoPointer(), SymlinkValueVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Recursively measures the disk usage of @file.
//
// This is essentially an analog of the 'du' command, but it also
// reports the number of directories and non-directory files encountered
// (including things like symbolic links).
//
// By default, errors are only reported against the toplevel file
// itself.  Errors found while recursing are silently ignored, unless
// %G_FILE_MEASURE_REPORT_ANY_ERROR is given in @flags.
//
// The returned size, @disk_usage, is in bytes and should be formatted
// with g_format_size() in order to get something reasonable for showing
// in a user interface.
//
// @progress_callback and @progress_data can be given to request
// periodic progress updates while scanning.  See the documentation for
// #GFileMeasureProgressCallback for information about when and how the
// callback will be invoked.
func (x *FileBase) MeasureDiskUsage(FlagsVar FileMeasureFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileMeasureProgressCallback, ProgressDataVar uintptr, DiskUsageVar uint64, NumDirsVar uint64, NumFilesVar uint64) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMeasureDiskUsage(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(ProgressCallbackVar), ProgressDataVar, DiskUsageVar, NumDirsVar, NumFilesVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Recursively measures the disk usage of @file.
//
// This is the asynchronous version of g_file_measure_disk_usage().  See
// there for more information.
func (x *FileBase) MeasureDiskUsageAsync(FlagsVar FileMeasureFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileMeasureProgressCallback, ProgressDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileMeasureDiskUsageAsync(x.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(ProgressCallbackVar), ProgressDataVar, glib.NewCallback(CallbackVar), UserDataVar)

}

// Collects the results from an earlier call to
// g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
// more information.
func (x *FileBase) MeasureDiskUsageFinish(ResultVar AsyncResult, DiskUsageVar uint64, NumDirsVar uint64, NumFilesVar uint64) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMeasureDiskUsageFinish(x.GoPointer(), ResultVar.GoPointer(), DiskUsageVar, NumDirsVar, NumFilesVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Obtains a file or directory monitor for the given file,
// depending on the type of the file.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) Monitor(FlagsVar FileMonitorFlags, CancellableVar *Cancellable) (*FileMonitor, error) {
	var cls *FileMonitor
	var cerr *glib.Error

	cret := XGFileMonitor(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileMonitor{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Obtains a directory monitor for the given file.
// This may fail if directory monitoring is not supported.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// It does not make sense for @flags to contain
// %G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
// directories.  It is not possible to monitor all the files in a
// directory for changes made via hard links; if you want to do this then
// you must register individual watches with g_file_monitor().
func (x *FileBase) MonitorDirectory(FlagsVar FileMonitorFlags, CancellableVar *Cancellable) (*FileMonitor, error) {
	var cls *FileMonitor
	var cerr *glib.Error

	cret := XGFileMonitorDirectory(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileMonitor{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Obtains a file monitor for the given file. If no file notification
// mechanism exists, then regular polling of the file is used.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// If @flags contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
// will also attempt to report changes made to the file via another
// filename (ie, a hard link). Without this flag, you can only rely on
// changes made through the filename contained in @file to be
// reported. Using this flag may result in an increase in resource
// usage, and may not have any effect depending on the #GFileMonitor
// backend and/or filesystem type.
func (x *FileBase) MonitorFile(FlagsVar FileMonitorFlags, CancellableVar *Cancellable) (*FileMonitor, error) {
	var cls *FileMonitor
	var cerr *glib.Error

	cret := XGFileMonitorFile(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileMonitor{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Starts a @mount_operation, mounting the volume that contains
// the file @location.
//
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_mount_enclosing_volume_finish().
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) MountEnclosingVolume(FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileMountEnclosingVolume(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes a mount operation started by g_file_mount_enclosing_volume().
func (x *FileBase) MountEnclosingVolumeFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMountEnclosingVolumeFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Mounts a file of type G_FILE_TYPE_MOUNTABLE.
// Using @mount_operation, you can request callbacks when, for instance,
// passwords are needed during authentication.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_mount_mountable_finish() to get
// the result of the operation.
func (x *FileBase) MountMountable(FlagsVar MountMountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileMountMountable(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes a mount operation. See g_file_mount_mountable() for details.
//
// Finish an asynchronous mount operation that was started
// with g_file_mount_mountable().
func (x *FileBase) MountMountableFinish(ResultVar AsyncResult) (*FileBase, error) {
	var cls *FileBase
	var cerr *glib.Error

	cret := XGFileMountMountableFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Tries to move the file or directory @source to the location specified
// by @destination. If native move operations are supported then this is
// used, otherwise a copy + delete fallback is used. The native
// implementation may support moving directories (for instance on moves
// inside the same filesystem), but the fallback code does not.
//
// If the flag %G_FILE_COPY_OVERWRITE is specified an already
// existing @destination file is overwritten.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// If @progress_callback is not %NULL, then the operation can be monitored
// by setting this to a #GFileProgressCallback function.
// @progress_callback_data will be passed to this function. It is
// guaranteed that this callback will be called after all data has been
// transferred with the total number of bytes copied during the operation.
//
// If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND
// error is returned, independent on the status of the @destination.
//
// If %G_FILE_COPY_OVERWRITE is not specified and the target exists,
// then the error %G_IO_ERROR_EXISTS is returned.
//
// If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
// error is returned. If trying to overwrite a directory with a directory the
// %G_IO_ERROR_WOULD_MERGE error is returned.
//
// If the source is a directory and the target does not exist, or
// %G_FILE_COPY_OVERWRITE is specified and the target is a file, then
// the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
// move operation isn't available).
func (x *FileBase) Move(DestinationVar File, FlagsVar FileCopyFlags, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMove(x.GoPointer(), DestinationVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(ProgressCallbackVar), ProgressCallbackDataVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously moves a file @source to the location of @destination. For details of the behaviour, see g_file_move().
//
// If @progress_callback is not %NULL, then that function that will be called
// just like in g_file_move(). The callback will run in the default main context
// of the thread calling g_file_move_async() — the same context as @callback is
// run in.
//
// When the operation is finished, @callback will be called. You can then call
// g_file_move_finish() to get the result of the operation.
func (x *FileBase) MoveAsync(DestinationVar File, FlagsVar FileCopyFlags, IoPriorityVar int, CancellableVar *Cancellable, ProgressCallbackVar *FileProgressCallback, ProgressCallbackDataVar uintptr, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileMoveAsync(x.GoPointer(), DestinationVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(ProgressCallbackVar), ProgressCallbackDataVar, glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file movement, started with
// g_file_move_async().
func (x *FileBase) MoveFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileMoveFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Opens an existing file for reading and writing. The result is
// a #GFileIOStream that can be used to read and write the contents
// of the file.
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
// be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
// error will be returned. Other errors are possible too, and depend on
// what kind of filesystem the file is on. Note that in many non-local
// file cases read and write streams are not supported, so make sure you
// really need to do read and write streaming, rather than just opening
// for reading or writing.
func (x *FileBase) OpenReadwrite(CancellableVar *Cancellable) (*FileIOStream, error) {
	var cls *FileIOStream
	var cerr *glib.Error

	cret := XGFileOpenReadwrite(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileIOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously opens @file for reading and writing.
//
// For more details, see g_file_open_readwrite() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_open_readwrite_finish() to get
// the result of the operation.
func (x *FileBase) OpenReadwriteAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileOpenReadwriteAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file read operation started with
// g_file_open_readwrite_async().
func (x *FileBase) OpenReadwriteFinish(ResVar AsyncResult) (*FileIOStream, error) {
	var cls *FileIOStream
	var cerr *glib.Error

	cret := XGFileOpenReadwriteFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileIOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Exactly like g_file_get_path(), but caches the result via
// g_object_set_qdata_full().  This is useful for example in C
// applications which mix `g_file_*` APIs with native ones.  It
// also avoids an extra duplicated string when possible, so will be
// generally more efficient.
//
// This call does no blocking I/O.
func (x *FileBase) PeekPath() string {

	cret := XGFilePeekPath(x.GoPointer())
	return cret
}

// Polls a file of type %G_FILE_TYPE_MOUNTABLE.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_mount_mountable_finish() to get
// the result of the operation.
func (x *FileBase) PollMountable(CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFilePollMountable(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes a poll operation. See g_file_poll_mountable() for details.
//
// Finish an asynchronous poll operation that was polled
// with g_file_poll_mountable().
func (x *FileBase) PollMountableFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFilePollMountableFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Returns the #GAppInfo that is registered as the default
// application to handle the file specified by @file.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) QueryDefaultHandler(CancellableVar *Cancellable) (*AppInfoBase, error) {
	var cls *AppInfoBase
	var cerr *glib.Error

	cret := XGFileQueryDefaultHandler(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &AppInfoBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Async version of g_file_query_default_handler().
func (x *FileBase) QueryDefaultHandlerAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileQueryDefaultHandlerAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes a g_file_query_default_handler_async() operation.
func (x *FileBase) QueryDefaultHandlerFinish(ResultVar AsyncResult) (*AppInfoBase, error) {
	var cls *AppInfoBase
	var cerr *glib.Error

	cret := XGFileQueryDefaultHandlerFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &AppInfoBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Utility function to check if a particular file exists. This is
// implemented using g_file_query_info() and as such does blocking I/O.
//
// Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
// and then execute something based on the outcome of that, because the
// file might have been created or removed in between the operations. The
// general approach to handling that is to not check, but just do the
// operation and handle the errors as they come.
//
// As an example of race-free checking, take the case of reading a file,
// and if it doesn't exist, creating it. There are two racy versions: read
// it, and on error create it; and: check if it exists, if not create it.
// These can both result in two processes creating the file (with perhaps
// a partially written file as the result). The correct approach is to
// always try to create the file with g_file_create() which will either
// atomically create the file or fail with a %G_IO_ERROR_EXISTS error.
//
// However, in many cases an existence check is useful in a user interface,
// for instance to make a menu item sensitive/insensitive, so that you don't
// have to fool users that something is possible and then just show an error
// dialog. If you do this, you should make sure to also handle the errors
// that can happen due to races when you execute the operation.
func (x *FileBase) QueryExists(CancellableVar *Cancellable) bool {

	cret := XGFileQueryExists(x.GoPointer(), CancellableVar.GoPointer())
	return cret
}

// Utility function to inspect the #GFileType of a file. This is
// implemented using g_file_query_info() and as such does blocking I/O.
//
// The primary use case of this method is to check if a file is
// a regular file, directory, or symlink.
func (x *FileBase) QueryFileType(FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) FileType {

	cret := XGFileQueryFileType(x.GoPointer(), FlagsVar, CancellableVar.GoPointer())
	return cret
}

// Similar to g_file_query_info(), but obtains information
// about the filesystem the @file is on, rather than the file itself.
// For instance the amount of space available and the type of
// the filesystem.
//
// The @attributes value is a string that specifies the attributes
// that should be gathered. It is not an error if it's not possible
// to read a particular requested attribute from a file - it just
// won't be set. @attributes should be a comma-separated list of
// attributes or attribute wildcards. The wildcard "*" means all
// attributes, and a wildcard like "filesystem::*" means all attributes
// in the filesystem namespace. The standard namespace for filesystem
// attributes is "filesystem". Common attributes of interest are
// %G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
// in bytes), %G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
// and %G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
// be returned. Other errors are possible too, and depend on what
// kind of filesystem the file is on.
func (x *FileBase) QueryFilesystemInfo(AttributesVar string, CancellableVar *Cancellable) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := XGFileQueryFilesystemInfo(x.GoPointer(), AttributesVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously gets the requested information about the filesystem
// that the specified @file is on. The result is a #GFileInfo object
// that contains key-value attributes (such as type or size for the
// file).
//
// For more details, see g_file_query_filesystem_info() which is the
// synchronous version of this call.
//
// When the operation is finished, @callback will be called. You can
// then call g_file_query_info_finish() to get the result of the
// operation.
func (x *FileBase) QueryFilesystemInfoAsync(AttributesVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileQueryFilesystemInfoAsync(x.GoPointer(), AttributesVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous filesystem info query.
// See g_file_query_filesystem_info_async().
func (x *FileBase) QueryFilesystemInfoFinish(ResVar AsyncResult) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := XGFileQueryFilesystemInfoFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Gets the requested information about specified @file.
// The result is a #GFileInfo object that contains key-value
// attributes (such as the type or size of the file).
//
// The @attributes value is a string that specifies the file
// attributes that should be gathered. It is not an error if
// it's not possible to read a particular requested attribute
// from a file - it just won't be set. @attributes should be a
// comma-separated list of attributes or attribute wildcards.
// The wildcard "*" means all attributes, and a wildcard like
// "standard::*" means all attributes in the standard namespace.
// An example attribute query be "standard::*,owner::user".
// The standard attributes are available as defines, like
// %G_FILE_ATTRIBUTE_STANDARD_NAME.
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// For symlinks, normally the information about the target of the
// symlink is returned, rather than information about the symlink
// itself. However if you pass %G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
// in @flags the information about the symlink itself will be returned.
// Also, for symlinks that point to non-existing files the information
// about the symlink itself will be returned.
//
// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on.
func (x *FileBase) QueryInfo(AttributesVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := XGFileQueryInfo(x.GoPointer(), AttributesVar, FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously gets the requested information about specified @file.
// The result is a #GFileInfo object that contains key-value attributes
// (such as type or size for the file).
//
// For more details, see g_file_query_info() which is the synchronous
// version of this call.
//
// When the operation is finished, @callback will be called. You can
// then call g_file_query_info_finish() to get the result of the operation.
func (x *FileBase) QueryInfoAsync(AttributesVar string, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileQueryInfoAsync(x.GoPointer(), AttributesVar, FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file info query.
// See g_file_query_info_async().
func (x *FileBase) QueryInfoFinish(ResVar AsyncResult) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := XGFileQueryInfoFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Obtain the list of settable attributes for the file.
//
// Returns the type and full attribute name of all the attributes
// that can be set on this file. This doesn't mean setting it will
// always succeed though, you might get an access failure, or some
// specific file may not support a specific attribute.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) QuerySettableAttributes(CancellableVar *Cancellable) (*FileAttributeInfoList, error) {
	var cerr *glib.Error

	cret := XGFileQuerySettableAttributes(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Obtain the list of attribute namespaces where new attributes
// can be created by a user. An example of this is extended
// attributes (in the "xattr" namespace).
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) QueryWritableNamespaces(CancellableVar *Cancellable) (*FileAttributeInfoList, error) {
	var cerr *glib.Error

	cret := XGFileQueryWritableNamespaces(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Opens a file for reading. The result is a #GFileInputStream that
// can be used to read the contents of the file.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
// returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
// error will be returned. Other errors are possible too, and depend
// on what kind of filesystem the file is on.
func (x *FileBase) Read(CancellableVar *Cancellable) (*FileInputStream, error) {
	var cls *FileInputStream
	var cerr *glib.Error

	cret := XGFileRead(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously opens @file for reading.
//
// For more details, see g_file_read() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_read_finish() to get the result
// of the operation.
func (x *FileBase) ReadAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileReadAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file read operation started with
// g_file_read_async().
func (x *FileBase) ReadFinish(ResVar AsyncResult) (*FileInputStream, error) {
	var cls *FileInputStream
	var cerr *glib.Error

	cret := XGFileReadFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Returns an output stream for overwriting the file, possibly
// creating a backup copy of the file first. If the file doesn't exist,
// it will be created.
//
// This will try to replace the file in the safest way possible so
// that any errors during the writing will not affect an already
// existing copy of the file. For instance, for local files it
// may write to a temporary file and then atomically rename over
// the destination when the stream is closed.
//
// By default files created are generally readable by everyone,
// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
// will be made readable only to the current user, to the level that
// is supported on the target filesystem.
//
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
//
// If you pass in a non-%NULL @etag value and @file already exists, then
// this value is compared to the current entity tag of the file, and if
// they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
// generally means that the file has been changed since you last read
// it. You can get the new etag from g_file_output_stream_get_etag()
// after you've finished writing and closed the #GFileOutputStream. When
// you load a new file you can use g_file_input_stream_query_info() to
// get the etag of the file.
//
// If @make_backup is %TRUE, this function will attempt to make a
// backup of the current file before overwriting it. If this fails
// a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
// want to replace anyway, try again with @make_backup set to %FALSE.
//
// If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
// be returned, and if the file is some other form of non-regular file
// then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
// file systems don't allow all file names, and may return an
// %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
// %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
// possible too, and depend on what kind of filesystem the file is on.
func (x *FileBase) Replace(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileOutputStream, error) {
	var cls *FileOutputStream
	var cerr *glib.Error

	cret := XGFileReplace(x.GoPointer(), EtagVar, MakeBackupVar, FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileOutputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously overwrites the file, replacing the contents,
// possibly creating a backup copy of the file first.
//
// For more details, see g_file_replace() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_replace_finish() to get the result
// of the operation.
func (x *FileBase) ReplaceAsync(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileReplaceAsync(x.GoPointer(), EtagVar, MakeBackupVar, FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Replaces the contents of @file with @contents of @length bytes.
//
// If @etag is specified (not %NULL), any existing file must have that etag,
// or the error %G_IO_ERROR_WRONG_ETAG will be returned.
//
// If @make_backup is %TRUE, this function will attempt to make a backup
// of @file. Internally, it uses g_file_replace(), so will try to replace the
// file contents in the safest way possible. For example, atomic renames are
// used when replacing local files’ contents.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// The returned @new_etag can be used to verify that the file hasn't
// changed the next time it is saved over.
func (x *FileBase) ReplaceContents(ContentsVar string, LengthVar uint, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, NewEtagVar string, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileReplaceContents(x.GoPointer(), ContentsVar, LengthVar, EtagVar, MakeBackupVar, FlagsVar, NewEtagVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Starts an asynchronous replacement of @file with the given
// @contents of @length bytes. @etag will replace the document's
// current entity tag.
//
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_replace_contents_finish().
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// If @make_backup is %TRUE, this function will attempt to
// make a backup of @file.
//
// Note that no copy of @contents will be made, so it must stay valid
// until @callback is called. See g_file_replace_contents_bytes_async()
// for a #GBytes version that will automatically hold a reference to the
// contents (without copying) for the duration of the call.
func (x *FileBase) ReplaceContentsAsync(ContentsVar string, LengthVar uint, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileReplaceContentsAsync(x.GoPointer(), ContentsVar, LengthVar, EtagVar, MakeBackupVar, FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Same as g_file_replace_contents_async() but takes a #GBytes input instead.
// This function will keep a ref on @contents until the operation is done.
// Unlike g_file_replace_contents_async() this allows forgetting about the
// content without waiting for the callback.
//
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_replace_contents_finish().
func (x *FileBase) ReplaceContentsBytesAsync(ContentsVar *glib.Bytes, EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileReplaceContentsBytesAsync(x.GoPointer(), ContentsVar, EtagVar, MakeBackupVar, FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous replace of the given @file. See
// g_file_replace_contents_async(). Sets @new_etag to the new entity
// tag for the document, if present.
func (x *FileBase) ReplaceContentsFinish(ResVar AsyncResult, NewEtagVar string) (bool, error) {
	var cerr *glib.Error

	cret := XGFileReplaceContentsFinish(x.GoPointer(), ResVar.GoPointer(), NewEtagVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Finishes an asynchronous file replace operation started with
// g_file_replace_async().
func (x *FileBase) ReplaceFinish(ResVar AsyncResult) (*FileOutputStream, error) {
	var cls *FileOutputStream
	var cerr *glib.Error

	cret := XGFileReplaceFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileOutputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Returns an output stream for overwriting the file in readwrite mode,
// possibly creating a backup copy of the file first. If the file doesn't
// exist, it will be created.
//
// For details about the behaviour, see g_file_replace() which does the
// same thing but returns an output stream only.
//
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
func (x *FileBase) ReplaceReadwrite(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, CancellableVar *Cancellable) (*FileIOStream, error) {
	var cls *FileIOStream
	var cerr *glib.Error

	cret := XGFileReplaceReadwrite(x.GoPointer(), EtagVar, MakeBackupVar, FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileIOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously overwrites the file in read-write mode,
// replacing the contents, possibly creating a backup copy
// of the file first.
//
// For more details, see g_file_replace_readwrite() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_replace_readwrite_finish() to get
// the result of the operation.
func (x *FileBase) ReplaceReadwriteAsync(EtagVar string, MakeBackupVar bool, FlagsVar FileCreateFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileReplaceReadwriteAsync(x.GoPointer(), EtagVar, MakeBackupVar, FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file replace operation started with
// g_file_replace_readwrite_async().
func (x *FileBase) ReplaceReadwriteFinish(ResVar AsyncResult) (*FileIOStream, error) {
	var cls *FileIOStream
	var cerr *glib.Error

	cret := XGFileReplaceReadwriteFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileIOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Resolves a relative path for @file to an absolute path.
//
// This call does no blocking I/O.
//
// If the @relative_path is an absolute path name, the resolution
// is done absolutely (without taking @file path as base).
func (x *FileBase) ResolveRelativePath(RelativePathVar string) *FileBase {
	var cls *FileBase

	cret := XGFileResolveRelativePath(x.GoPointer(), RelativePathVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

// Sets an attribute in the file with attribute name @attribute to @value_p.
//
// Some attributes can be unset by setting @type to
// %G_FILE_ATTRIBUTE_TYPE_INVALID and @value_p to %NULL.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttribute(AttributeVar string, TypeVar FileAttributeType, ValuePVar uintptr, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttribute(x.GoPointer(), AttributeVar, TypeVar, ValuePVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to @value.
// If @attribute is of a different type, this operation will fail,
// returning %FALSE.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributeByteString(AttributeVar string, ValueVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributeByteString(x.GoPointer(), AttributeVar, ValueVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT32 to @value.
// If @attribute is of a different type, this operation will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributeInt32(AttributeVar string, ValueVar int32, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributeInt32(x.GoPointer(), AttributeVar, ValueVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT64 to @value.
// If @attribute is of a different type, this operation will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributeInt64(AttributeVar string, ValueVar int64, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributeInt64(x.GoPointer(), AttributeVar, ValueVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_STRING to @value.
// If @attribute is of a different type, this operation will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributeString(AttributeVar string, ValueVar string, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributeString(x.GoPointer(), AttributeVar, ValueVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT32 to @value.
// If @attribute is of a different type, this operation will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributeUint32(AttributeVar string, ValueVar uint32, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributeUint32(x.GoPointer(), AttributeVar, ValueVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT64 to @value.
// If @attribute is of a different type, this operation will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributeUint64(AttributeVar string, ValueVar uint64, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributeUint64(x.GoPointer(), AttributeVar, ValueVar, FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously sets the attributes of @file with @info.
//
// For more details, see g_file_set_attributes_from_info(),
// which is the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_set_attributes_finish() to get
// the result of the operation.
func (x *FileBase) SetAttributesAsync(InfoVar *FileInfo, FlagsVar FileQueryInfoFlags, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileSetAttributesAsync(x.GoPointer(), InfoVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes setting an attribute started in g_file_set_attributes_async().
func (x *FileBase) SetAttributesFinish(ResultVar AsyncResult, InfoVar **FileInfo) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributesFinish(x.GoPointer(), ResultVar.GoPointer(), gobject.ConvertPtr(InfoVar), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Tries to set all attributes in the #GFileInfo on the target
// values, not stopping on the first error.
//
// If there is any error during this operation then @error will
// be set to the first error. Error on particular fields are flagged
// by setting the "status" field in the attribute value to
// %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
// also detect further errors.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetAttributesFromInfo(InfoVar *FileInfo, FlagsVar FileQueryInfoFlags, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileSetAttributesFromInfo(x.GoPointer(), InfoVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Renames @file to the specified display name.
//
// The display name is converted from UTF-8 to the correct encoding
// for the target filesystem if possible and the @file is renamed to this.
//
// If you want to implement a rename operation in the user interface the
// edit name (%G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
// initial value in the rename widget, and then the result after editing
// should be passed to g_file_set_display_name().
//
// On success the resulting converted filename is returned.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) SetDisplayName(DisplayNameVar string, CancellableVar *Cancellable) (*FileBase, error) {
	var cls *FileBase
	var cerr *glib.Error

	cret := XGFileSetDisplayName(x.GoPointer(), DisplayNameVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Asynchronously sets the display name for a given #GFile.
//
// For more details, see g_file_set_display_name() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_set_display_name_finish() to get
// the result of the operation.
func (x *FileBase) SetDisplayNameAsync(DisplayNameVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileSetDisplayNameAsync(x.GoPointer(), DisplayNameVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes setting a display name started with
// g_file_set_display_name_async().
func (x *FileBase) SetDisplayNameFinish(ResVar AsyncResult) (*FileBase, error) {
	var cls *FileBase
	var cerr *glib.Error

	cret := XGFileSetDisplayNameFinish(x.GoPointer(), ResVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Starts a file of type %G_FILE_TYPE_MOUNTABLE.
// Using @start_operation, you can request callbacks when, for instance,
// passwords are needed during authentication.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_mount_mountable_finish() to get
// the result of the operation.
func (x *FileBase) StartMountable(FlagsVar DriveStartFlags, StartOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileStartMountable(x.GoPointer(), FlagsVar, StartOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes a start operation. See g_file_start_mountable() for details.
//
// Finish an asynchronous start operation that was started
// with g_file_start_mountable().
func (x *FileBase) StartMountableFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileStartMountableFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Stops a file of type %G_FILE_TYPE_MOUNTABLE.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_stop_mountable_finish() to get
// the result of the operation.
func (x *FileBase) StopMountable(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileStopMountable(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes a stop operation, see g_file_stop_mountable() for details.
//
// Finish an asynchronous stop operation that was started
// with g_file_stop_mountable().
func (x *FileBase) StopMountableFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileStopMountableFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Checks if @file supports
// [thread-default contexts][g-main-context-push-thread-default-context].
// If this returns %FALSE, you cannot perform asynchronous operations on
// @file in a thread that has a thread-default context.
func (x *FileBase) SupportsThreadContexts() bool {

	cret := XGFileSupportsThreadContexts(x.GoPointer())
	return cret
}

// Sends @file to the "Trashcan", if possible. This is similar to
// deleting it, but the user can recover it before emptying the trashcan.
// Not all file systems support trashing, so this call can return the
// %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
// mount option can be used to disable g_file_trash() support for certain
// mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileBase) Trash(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGFileTrash(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Asynchronously sends @file to the Trash location, if possible.
func (x *FileBase) TrashAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileTrashAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous file trashing operation, started with
// g_file_trash_async().
func (x *FileBase) TrashFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileTrashFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_unmount_mountable_finish() to get
// the result of the operation.
func (x *FileBase) UnmountMountable(FlagsVar MountUnmountFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileUnmountMountable(x.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an unmount operation, see g_file_unmount_mountable() for details.
//
// Finish an asynchronous unmount operation that was started
// with g_file_unmount_mountable().
func (x *FileBase) UnmountMountableFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileUnmountMountableFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called.
// You can then call g_file_unmount_mountable_finish() to get
// the result of the operation.
func (x *FileBase) UnmountMountableWithOperation(FlagsVar MountUnmountFlags, MountOperationVar *MountOperation, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	XGFileUnmountMountableWithOperation(x.GoPointer(), FlagsVar, MountOperationVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an unmount operation,
// see g_file_unmount_mountable_with_operation() for details.
//
// Finish an asynchronous unmount operation that was started
// with g_file_unmount_mountable_with_operation().
func (x *FileBase) UnmountMountableWithOperationFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := XGFileUnmountMountableWithOperationFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var XGFileAppendTo func(uintptr, FileCreateFlags, uintptr, **glib.Error) uintptr
var XGFileAppendToAsync func(uintptr, FileCreateFlags, int, uintptr, uintptr, uintptr)
var XGFileAppendToFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileBuildAttributeListForCopy func(uintptr, FileCopyFlags, uintptr, **glib.Error) string
var XGFileCopy func(uintptr, uintptr, FileCopyFlags, uintptr, uintptr, uintptr, **glib.Error) bool
var XGFileCopyAsync func(uintptr, uintptr, FileCopyFlags, int, uintptr, uintptr, uintptr, uintptr, uintptr)
var XGFileCopyAttributes func(uintptr, uintptr, FileCopyFlags, uintptr, **glib.Error) bool
var XGFileCopyFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileCreate func(uintptr, FileCreateFlags, uintptr, **glib.Error) uintptr
var XGFileCreateAsync func(uintptr, FileCreateFlags, int, uintptr, uintptr, uintptr)
var XGFileCreateFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileCreateReadwrite func(uintptr, FileCreateFlags, uintptr, **glib.Error) uintptr
var XGFileCreateReadwriteAsync func(uintptr, FileCreateFlags, int, uintptr, uintptr, uintptr)
var XGFileCreateReadwriteFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileDelete func(uintptr, uintptr, **glib.Error) bool
var XGFileDeleteAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileDeleteFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileDup func(uintptr) uintptr
var XGFileEjectMountable func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr)
var XGFileEjectMountableFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileEjectMountableWithOperation func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr, uintptr)
var XGFileEjectMountableWithOperationFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileEnumerateChildren func(uintptr, string, FileQueryInfoFlags, uintptr, **glib.Error) uintptr
var XGFileEnumerateChildrenAsync func(uintptr, string, FileQueryInfoFlags, int, uintptr, uintptr, uintptr)
var XGFileEnumerateChildrenFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileEqual func(uintptr, uintptr) bool
var XGFileFindEnclosingMount func(uintptr, uintptr, **glib.Error) uintptr
var XGFileFindEnclosingMountAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileFindEnclosingMountFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileGetBasename func(uintptr) string
var XGFileGetChild func(uintptr, string) uintptr
var XGFileGetChildForDisplayName func(uintptr, string, **glib.Error) uintptr
var XGFileGetParent func(uintptr) uintptr
var XGFileGetParseName func(uintptr) string
var XGFileGetPath func(uintptr) string
var XGFileGetRelativePath func(uintptr, uintptr) string
var XGFileGetUri func(uintptr) string
var XGFileGetUriScheme func(uintptr) string
var XGFileHasParent func(uintptr, uintptr) bool
var XGFileHasPrefix func(uintptr, uintptr) bool
var XGFileHasUriScheme func(uintptr, string) bool
var XGFileHash func(uintptr) uint
var XGFileIsNative func(uintptr) bool
var XGFileLoadBytes func(uintptr, uintptr, string, **glib.Error) *glib.Bytes
var XGFileLoadBytesAsync func(uintptr, uintptr, uintptr, uintptr)
var XGFileLoadBytesFinish func(uintptr, uintptr, string, **glib.Error) *glib.Bytes
var XGFileLoadContents func(uintptr, uintptr, []string, uint, string, **glib.Error) bool
var XGFileLoadContentsAsync func(uintptr, uintptr, uintptr, uintptr)
var XGFileLoadContentsFinish func(uintptr, uintptr, []string, uint, string, **glib.Error) bool
var XGFileLoadPartialContentsAsync func(uintptr, uintptr, uintptr, uintptr, uintptr)
var XGFileLoadPartialContentsFinish func(uintptr, uintptr, []string, uint, string, **glib.Error) bool
var XGFileMakeDirectory func(uintptr, uintptr, **glib.Error) bool
var XGFileMakeDirectoryAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileMakeDirectoryFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileMakeDirectoryWithParents func(uintptr, uintptr, **glib.Error) bool
var XGFileMakeSymbolicLink func(uintptr, string, uintptr, **glib.Error) bool
var XGFileMeasureDiskUsage func(uintptr, FileMeasureFlags, uintptr, uintptr, uintptr, uint64, uint64, uint64, **glib.Error) bool
var XGFileMeasureDiskUsageAsync func(uintptr, FileMeasureFlags, int, uintptr, uintptr, uintptr, uintptr, uintptr)
var XGFileMeasureDiskUsageFinish func(uintptr, uintptr, uint64, uint64, uint64, **glib.Error) bool
var XGFileMonitor func(uintptr, FileMonitorFlags, uintptr, **glib.Error) uintptr
var XGFileMonitorDirectory func(uintptr, FileMonitorFlags, uintptr, **glib.Error) uintptr
var XGFileMonitorFile func(uintptr, FileMonitorFlags, uintptr, **glib.Error) uintptr
var XGFileMountEnclosingVolume func(uintptr, MountMountFlags, uintptr, uintptr, uintptr, uintptr)
var XGFileMountEnclosingVolumeFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileMountMountable func(uintptr, MountMountFlags, uintptr, uintptr, uintptr, uintptr)
var XGFileMountMountableFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileMove func(uintptr, uintptr, FileCopyFlags, uintptr, uintptr, uintptr, **glib.Error) bool
var XGFileMoveAsync func(uintptr, uintptr, FileCopyFlags, int, uintptr, uintptr, uintptr, uintptr, uintptr)
var XGFileMoveFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileOpenReadwrite func(uintptr, uintptr, **glib.Error) uintptr
var XGFileOpenReadwriteAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileOpenReadwriteFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFilePeekPath func(uintptr) string
var XGFilePollMountable func(uintptr, uintptr, uintptr, uintptr)
var XGFilePollMountableFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileQueryDefaultHandler func(uintptr, uintptr, **glib.Error) uintptr
var XGFileQueryDefaultHandlerAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileQueryDefaultHandlerFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileQueryExists func(uintptr, uintptr) bool
var XGFileQueryFileType func(uintptr, FileQueryInfoFlags, uintptr) FileType
var XGFileQueryFilesystemInfo func(uintptr, string, uintptr, **glib.Error) uintptr
var XGFileQueryFilesystemInfoAsync func(uintptr, string, int, uintptr, uintptr, uintptr)
var XGFileQueryFilesystemInfoFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileQueryInfo func(uintptr, string, FileQueryInfoFlags, uintptr, **glib.Error) uintptr
var XGFileQueryInfoAsync func(uintptr, string, FileQueryInfoFlags, int, uintptr, uintptr, uintptr)
var XGFileQueryInfoFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileQuerySettableAttributes func(uintptr, uintptr, **glib.Error) *FileAttributeInfoList
var XGFileQueryWritableNamespaces func(uintptr, uintptr, **glib.Error) *FileAttributeInfoList
var XGFileRead func(uintptr, uintptr, **glib.Error) uintptr
var XGFileReadAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileReadFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileReplace func(uintptr, string, bool, FileCreateFlags, uintptr, **glib.Error) uintptr
var XGFileReplaceAsync func(uintptr, string, bool, FileCreateFlags, int, uintptr, uintptr, uintptr)
var XGFileReplaceContents func(uintptr, string, uint, string, bool, FileCreateFlags, string, uintptr, **glib.Error) bool
var XGFileReplaceContentsAsync func(uintptr, string, uint, string, bool, FileCreateFlags, uintptr, uintptr, uintptr)
var XGFileReplaceContentsBytesAsync func(uintptr, *glib.Bytes, string, bool, FileCreateFlags, uintptr, uintptr, uintptr)
var XGFileReplaceContentsFinish func(uintptr, uintptr, string, **glib.Error) bool
var XGFileReplaceFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileReplaceReadwrite func(uintptr, string, bool, FileCreateFlags, uintptr, **glib.Error) uintptr
var XGFileReplaceReadwriteAsync func(uintptr, string, bool, FileCreateFlags, int, uintptr, uintptr, uintptr)
var XGFileReplaceReadwriteFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileResolveRelativePath func(uintptr, string) uintptr
var XGFileSetAttribute func(uintptr, string, FileAttributeType, uintptr, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributeByteString func(uintptr, string, string, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributeInt32 func(uintptr, string, int32, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributeInt64 func(uintptr, string, int64, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributeString func(uintptr, string, string, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributeUint32 func(uintptr, string, uint32, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributeUint64 func(uintptr, string, uint64, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetAttributesAsync func(uintptr, uintptr, FileQueryInfoFlags, int, uintptr, uintptr, uintptr)
var XGFileSetAttributesFinish func(uintptr, uintptr, *uintptr, **glib.Error) bool
var XGFileSetAttributesFromInfo func(uintptr, uintptr, FileQueryInfoFlags, uintptr, **glib.Error) bool
var XGFileSetDisplayName func(uintptr, string, uintptr, **glib.Error) uintptr
var XGFileSetDisplayNameAsync func(uintptr, string, int, uintptr, uintptr, uintptr)
var XGFileSetDisplayNameFinish func(uintptr, uintptr, **glib.Error) uintptr
var XGFileStartMountable func(uintptr, DriveStartFlags, uintptr, uintptr, uintptr, uintptr)
var XGFileStartMountableFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileStopMountable func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr, uintptr)
var XGFileStopMountableFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileSupportsThreadContexts func(uintptr) bool
var XGFileTrash func(uintptr, uintptr, **glib.Error) bool
var XGFileTrashAsync func(uintptr, int, uintptr, uintptr, uintptr)
var XGFileTrashFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileUnmountMountable func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr)
var XGFileUnmountMountableFinish func(uintptr, uintptr, **glib.Error) bool
var XGFileUnmountMountableWithOperation func(uintptr, MountUnmountFlags, uintptr, uintptr, uintptr, uintptr)
var XGFileUnmountMountableWithOperationFinish func(uintptr, uintptr, **glib.Error) bool

var xFileNewForCommandlineArg func(string) uintptr

// Creates a #GFile with the given argument from the command line.
// The value of @arg can be either a URI, an absolute path or a
// relative path resolved relative to the current working directory.
// This operation never fails, but the returned object might not
// support any I/O operation if @arg points to a malformed path.
//
// Note that on Windows, this function expects its argument to be in
// UTF-8 -- not the system code page.  This means that you
// should not use this function with string from argv as it is passed
// to main().  g_win32_get_command_line() will return a UTF-8 version of
// the commandline.  #GApplication also uses UTF-8 but
// g_application_command_line_create_file_for_arg() may be more useful
// for you there.  It is also always possible to use this function with
// #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
func FileNewForCommandlineArg(ArgVar string) *FileBase {
	var cls *FileBase

	cret := xFileNewForCommandlineArg(ArgVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileNewForCommandlineArgAndCwd func(string, string) uintptr

// Creates a #GFile with the given argument from the command line.
//
// This function is similar to g_file_new_for_commandline_arg() except
// that it allows for passing the current working directory as an
// argument instead of using the current working directory of the
// process.
//
// This is useful if the commandline argument was given in a context
// other than the invocation of the current process.
//
// See also g_application_command_line_create_file_for_arg().
func FileNewForCommandlineArgAndCwd(ArgVar string, CwdVar string) *FileBase {
	var cls *FileBase

	cret := xFileNewForCommandlineArgAndCwd(ArgVar, CwdVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileNewForPath func(string) uintptr

// Constructs a #GFile for a given path. This operation never
// fails, but the returned object might not support any I/O
// operation if @path is malformed.
func FileNewForPath(PathVar string) *FileBase {
	var cls *FileBase

	cret := xFileNewForPath(PathVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileNewForUri func(string) uintptr

// Constructs a #GFile for a given URI. This operation never
// fails, but the returned object might not support any I/O
// operation if @uri is malformed or if the uri type is
// not supported.
func FileNewForUri(UriVar string) *FileBase {
	var cls *FileBase

	cret := xFileNewForUri(UriVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

var xFileNewTmp func(string, *uintptr, **glib.Error) uintptr

// Opens a file in the preferred directory for temporary files (as
// returned by g_get_tmp_dir()) and returns a #GFile and
// #GFileIOStream pointing to it.
//
// @tmpl should be a string in the GLib file name encoding
// containing a sequence of six 'X' characters, and containing no
// directory components. If it is %NULL, a default template is used.
//
// Unlike the other #GFile constructors, this will return %NULL if
// a temporary file could not be created.
func FileNewTmp(TmplVar string, IostreamVar **FileIOStream) (*FileBase, error) {
	var cls *FileBase
	var cerr *glib.Error

	cret := xFileNewTmp(TmplVar, gobject.ConvertPtr(IostreamVar), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileBase{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileParseName func(string) uintptr

// Constructs a #GFile with the given @parse_name (i.e. something
// given by g_file_get_parse_name()). This operation never fails,
// but the returned object might not support any I/O operation if
// the @parse_name cannot be parsed.
func FileParseName(ParseNameVar string) *FileBase {
	var cls *FileBase

	cret := xFileParseName(ParseNameVar)

	if cret == 0 {
		return nil
	}
	cls = &FileBase{}
	cls.Ptr = cret
	return cls
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xFileNewForCommandlineArg, lib, "g_file_new_for_commandline_arg")
	core.PuregoSafeRegister(&xFileNewForCommandlineArgAndCwd, lib, "g_file_new_for_commandline_arg_and_cwd")
	core.PuregoSafeRegister(&xFileNewForPath, lib, "g_file_new_for_path")
	core.PuregoSafeRegister(&xFileNewForUri, lib, "g_file_new_for_uri")
	core.PuregoSafeRegister(&xFileNewTmp, lib, "g_file_new_tmp")
	core.PuregoSafeRegister(&xFileParseName, lib, "g_file_parse_name")

	core.PuregoSafeRegister(&xFileGLibType, lib, "g_file_get_type")

	core.PuregoSafeRegister(&XGFileAppendTo, lib, "g_file_append_to")
	core.PuregoSafeRegister(&XGFileAppendToAsync, lib, "g_file_append_to_async")
	core.PuregoSafeRegister(&XGFileAppendToFinish, lib, "g_file_append_to_finish")
	core.PuregoSafeRegister(&XGFileBuildAttributeListForCopy, lib, "g_file_build_attribute_list_for_copy")
	core.PuregoSafeRegister(&XGFileCopy, lib, "g_file_copy")
	core.PuregoSafeRegister(&XGFileCopyAsync, lib, "g_file_copy_async")
	core.PuregoSafeRegister(&XGFileCopyAttributes, lib, "g_file_copy_attributes")
	core.PuregoSafeRegister(&XGFileCopyFinish, lib, "g_file_copy_finish")
	core.PuregoSafeRegister(&XGFileCreate, lib, "g_file_create")
	core.PuregoSafeRegister(&XGFileCreateAsync, lib, "g_file_create_async")
	core.PuregoSafeRegister(&XGFileCreateFinish, lib, "g_file_create_finish")
	core.PuregoSafeRegister(&XGFileCreateReadwrite, lib, "g_file_create_readwrite")
	core.PuregoSafeRegister(&XGFileCreateReadwriteAsync, lib, "g_file_create_readwrite_async")
	core.PuregoSafeRegister(&XGFileCreateReadwriteFinish, lib, "g_file_create_readwrite_finish")
	core.PuregoSafeRegister(&XGFileDelete, lib, "g_file_delete")
	core.PuregoSafeRegister(&XGFileDeleteAsync, lib, "g_file_delete_async")
	core.PuregoSafeRegister(&XGFileDeleteFinish, lib, "g_file_delete_finish")
	core.PuregoSafeRegister(&XGFileDup, lib, "g_file_dup")
	core.PuregoSafeRegister(&XGFileEjectMountable, lib, "g_file_eject_mountable")
	core.PuregoSafeRegister(&XGFileEjectMountableFinish, lib, "g_file_eject_mountable_finish")
	core.PuregoSafeRegister(&XGFileEjectMountableWithOperation, lib, "g_file_eject_mountable_with_operation")
	core.PuregoSafeRegister(&XGFileEjectMountableWithOperationFinish, lib, "g_file_eject_mountable_with_operation_finish")
	core.PuregoSafeRegister(&XGFileEnumerateChildren, lib, "g_file_enumerate_children")
	core.PuregoSafeRegister(&XGFileEnumerateChildrenAsync, lib, "g_file_enumerate_children_async")
	core.PuregoSafeRegister(&XGFileEnumerateChildrenFinish, lib, "g_file_enumerate_children_finish")
	core.PuregoSafeRegister(&XGFileEqual, lib, "g_file_equal")
	core.PuregoSafeRegister(&XGFileFindEnclosingMount, lib, "g_file_find_enclosing_mount")
	core.PuregoSafeRegister(&XGFileFindEnclosingMountAsync, lib, "g_file_find_enclosing_mount_async")
	core.PuregoSafeRegister(&XGFileFindEnclosingMountFinish, lib, "g_file_find_enclosing_mount_finish")
	core.PuregoSafeRegister(&XGFileGetBasename, lib, "g_file_get_basename")
	core.PuregoSafeRegister(&XGFileGetChild, lib, "g_file_get_child")
	core.PuregoSafeRegister(&XGFileGetChildForDisplayName, lib, "g_file_get_child_for_display_name")
	core.PuregoSafeRegister(&XGFileGetParent, lib, "g_file_get_parent")
	core.PuregoSafeRegister(&XGFileGetParseName, lib, "g_file_get_parse_name")
	core.PuregoSafeRegister(&XGFileGetPath, lib, "g_file_get_path")
	core.PuregoSafeRegister(&XGFileGetRelativePath, lib, "g_file_get_relative_path")
	core.PuregoSafeRegister(&XGFileGetUri, lib, "g_file_get_uri")
	core.PuregoSafeRegister(&XGFileGetUriScheme, lib, "g_file_get_uri_scheme")
	core.PuregoSafeRegister(&XGFileHasParent, lib, "g_file_has_parent")
	core.PuregoSafeRegister(&XGFileHasPrefix, lib, "g_file_has_prefix")
	core.PuregoSafeRegister(&XGFileHasUriScheme, lib, "g_file_has_uri_scheme")
	core.PuregoSafeRegister(&XGFileHash, lib, "g_file_hash")
	core.PuregoSafeRegister(&XGFileIsNative, lib, "g_file_is_native")
	core.PuregoSafeRegister(&XGFileLoadBytes, lib, "g_file_load_bytes")
	core.PuregoSafeRegister(&XGFileLoadBytesAsync, lib, "g_file_load_bytes_async")
	core.PuregoSafeRegister(&XGFileLoadBytesFinish, lib, "g_file_load_bytes_finish")
	core.PuregoSafeRegister(&XGFileLoadContents, lib, "g_file_load_contents")
	core.PuregoSafeRegister(&XGFileLoadContentsAsync, lib, "g_file_load_contents_async")
	core.PuregoSafeRegister(&XGFileLoadContentsFinish, lib, "g_file_load_contents_finish")
	core.PuregoSafeRegister(&XGFileLoadPartialContentsAsync, lib, "g_file_load_partial_contents_async")
	core.PuregoSafeRegister(&XGFileLoadPartialContentsFinish, lib, "g_file_load_partial_contents_finish")
	core.PuregoSafeRegister(&XGFileMakeDirectory, lib, "g_file_make_directory")
	core.PuregoSafeRegister(&XGFileMakeDirectoryAsync, lib, "g_file_make_directory_async")
	core.PuregoSafeRegister(&XGFileMakeDirectoryFinish, lib, "g_file_make_directory_finish")
	core.PuregoSafeRegister(&XGFileMakeDirectoryWithParents, lib, "g_file_make_directory_with_parents")
	core.PuregoSafeRegister(&XGFileMakeSymbolicLink, lib, "g_file_make_symbolic_link")
	core.PuregoSafeRegister(&XGFileMeasureDiskUsage, lib, "g_file_measure_disk_usage")
	core.PuregoSafeRegister(&XGFileMeasureDiskUsageAsync, lib, "g_file_measure_disk_usage_async")
	core.PuregoSafeRegister(&XGFileMeasureDiskUsageFinish, lib, "g_file_measure_disk_usage_finish")
	core.PuregoSafeRegister(&XGFileMonitor, lib, "g_file_monitor")
	core.PuregoSafeRegister(&XGFileMonitorDirectory, lib, "g_file_monitor_directory")
	core.PuregoSafeRegister(&XGFileMonitorFile, lib, "g_file_monitor_file")
	core.PuregoSafeRegister(&XGFileMountEnclosingVolume, lib, "g_file_mount_enclosing_volume")
	core.PuregoSafeRegister(&XGFileMountEnclosingVolumeFinish, lib, "g_file_mount_enclosing_volume_finish")
	core.PuregoSafeRegister(&XGFileMountMountable, lib, "g_file_mount_mountable")
	core.PuregoSafeRegister(&XGFileMountMountableFinish, lib, "g_file_mount_mountable_finish")
	core.PuregoSafeRegister(&XGFileMove, lib, "g_file_move")
	core.PuregoSafeRegister(&XGFileMoveAsync, lib, "g_file_move_async")
	core.PuregoSafeRegister(&XGFileMoveFinish, lib, "g_file_move_finish")
	core.PuregoSafeRegister(&XGFileOpenReadwrite, lib, "g_file_open_readwrite")
	core.PuregoSafeRegister(&XGFileOpenReadwriteAsync, lib, "g_file_open_readwrite_async")
	core.PuregoSafeRegister(&XGFileOpenReadwriteFinish, lib, "g_file_open_readwrite_finish")
	core.PuregoSafeRegister(&XGFilePeekPath, lib, "g_file_peek_path")
	core.PuregoSafeRegister(&XGFilePollMountable, lib, "g_file_poll_mountable")
	core.PuregoSafeRegister(&XGFilePollMountableFinish, lib, "g_file_poll_mountable_finish")
	core.PuregoSafeRegister(&XGFileQueryDefaultHandler, lib, "g_file_query_default_handler")
	core.PuregoSafeRegister(&XGFileQueryDefaultHandlerAsync, lib, "g_file_query_default_handler_async")
	core.PuregoSafeRegister(&XGFileQueryDefaultHandlerFinish, lib, "g_file_query_default_handler_finish")
	core.PuregoSafeRegister(&XGFileQueryExists, lib, "g_file_query_exists")
	core.PuregoSafeRegister(&XGFileQueryFileType, lib, "g_file_query_file_type")
	core.PuregoSafeRegister(&XGFileQueryFilesystemInfo, lib, "g_file_query_filesystem_info")
	core.PuregoSafeRegister(&XGFileQueryFilesystemInfoAsync, lib, "g_file_query_filesystem_info_async")
	core.PuregoSafeRegister(&XGFileQueryFilesystemInfoFinish, lib, "g_file_query_filesystem_info_finish")
	core.PuregoSafeRegister(&XGFileQueryInfo, lib, "g_file_query_info")
	core.PuregoSafeRegister(&XGFileQueryInfoAsync, lib, "g_file_query_info_async")
	core.PuregoSafeRegister(&XGFileQueryInfoFinish, lib, "g_file_query_info_finish")
	core.PuregoSafeRegister(&XGFileQuerySettableAttributes, lib, "g_file_query_settable_attributes")
	core.PuregoSafeRegister(&XGFileQueryWritableNamespaces, lib, "g_file_query_writable_namespaces")
	core.PuregoSafeRegister(&XGFileRead, lib, "g_file_read")
	core.PuregoSafeRegister(&XGFileReadAsync, lib, "g_file_read_async")
	core.PuregoSafeRegister(&XGFileReadFinish, lib, "g_file_read_finish")
	core.PuregoSafeRegister(&XGFileReplace, lib, "g_file_replace")
	core.PuregoSafeRegister(&XGFileReplaceAsync, lib, "g_file_replace_async")
	core.PuregoSafeRegister(&XGFileReplaceContents, lib, "g_file_replace_contents")
	core.PuregoSafeRegister(&XGFileReplaceContentsAsync, lib, "g_file_replace_contents_async")
	core.PuregoSafeRegister(&XGFileReplaceContentsBytesAsync, lib, "g_file_replace_contents_bytes_async")
	core.PuregoSafeRegister(&XGFileReplaceContentsFinish, lib, "g_file_replace_contents_finish")
	core.PuregoSafeRegister(&XGFileReplaceFinish, lib, "g_file_replace_finish")
	core.PuregoSafeRegister(&XGFileReplaceReadwrite, lib, "g_file_replace_readwrite")
	core.PuregoSafeRegister(&XGFileReplaceReadwriteAsync, lib, "g_file_replace_readwrite_async")
	core.PuregoSafeRegister(&XGFileReplaceReadwriteFinish, lib, "g_file_replace_readwrite_finish")
	core.PuregoSafeRegister(&XGFileResolveRelativePath, lib, "g_file_resolve_relative_path")
	core.PuregoSafeRegister(&XGFileSetAttribute, lib, "g_file_set_attribute")
	core.PuregoSafeRegister(&XGFileSetAttributeByteString, lib, "g_file_set_attribute_byte_string")
	core.PuregoSafeRegister(&XGFileSetAttributeInt32, lib, "g_file_set_attribute_int32")
	core.PuregoSafeRegister(&XGFileSetAttributeInt64, lib, "g_file_set_attribute_int64")
	core.PuregoSafeRegister(&XGFileSetAttributeString, lib, "g_file_set_attribute_string")
	core.PuregoSafeRegister(&XGFileSetAttributeUint32, lib, "g_file_set_attribute_uint32")
	core.PuregoSafeRegister(&XGFileSetAttributeUint64, lib, "g_file_set_attribute_uint64")
	core.PuregoSafeRegister(&XGFileSetAttributesAsync, lib, "g_file_set_attributes_async")
	core.PuregoSafeRegister(&XGFileSetAttributesFinish, lib, "g_file_set_attributes_finish")
	core.PuregoSafeRegister(&XGFileSetAttributesFromInfo, lib, "g_file_set_attributes_from_info")
	core.PuregoSafeRegister(&XGFileSetDisplayName, lib, "g_file_set_display_name")
	core.PuregoSafeRegister(&XGFileSetDisplayNameAsync, lib, "g_file_set_display_name_async")
	core.PuregoSafeRegister(&XGFileSetDisplayNameFinish, lib, "g_file_set_display_name_finish")
	core.PuregoSafeRegister(&XGFileStartMountable, lib, "g_file_start_mountable")
	core.PuregoSafeRegister(&XGFileStartMountableFinish, lib, "g_file_start_mountable_finish")
	core.PuregoSafeRegister(&XGFileStopMountable, lib, "g_file_stop_mountable")
	core.PuregoSafeRegister(&XGFileStopMountableFinish, lib, "g_file_stop_mountable_finish")
	core.PuregoSafeRegister(&XGFileSupportsThreadContexts, lib, "g_file_supports_thread_contexts")
	core.PuregoSafeRegister(&XGFileTrash, lib, "g_file_trash")
	core.PuregoSafeRegister(&XGFileTrashAsync, lib, "g_file_trash_async")
	core.PuregoSafeRegister(&XGFileTrashFinish, lib, "g_file_trash_finish")
	core.PuregoSafeRegister(&XGFileUnmountMountable, lib, "g_file_unmount_mountable")
	core.PuregoSafeRegister(&XGFileUnmountMountableFinish, lib, "g_file_unmount_mountable_finish")
	core.PuregoSafeRegister(&XGFileUnmountMountableWithOperation, lib, "g_file_unmount_mountable_with_operation")
	core.PuregoSafeRegister(&XGFileUnmountMountableWithOperationFinish, lib, "g_file_unmount_mountable_with_operation_finish")

}
