// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Virtual function table for #GApplication.
type ApplicationClass struct {
	ParentClass uintptr

	Padding [7]uintptr
}

func (x *ApplicationClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type ApplicationPrivate struct {
}

func (x *ApplicationPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A #GApplication is the foundation of an application.  It wraps some
// low-level platform-specific services and is intended to act as the
// foundation for higher-level application classes such as
// #GtkApplication or #MxApplication.  In general, you should not use
// this class outside of a higher level framework.
//
// GApplication provides convenient life cycle management by maintaining
// a "use count" for the primary application instance. The use count can
// be changed using g_application_hold() and g_application_release(). If
// it drops to zero, the application exits. Higher-level classes such as
// #GtkApplication employ the use count to ensure that the application
// stays alive as long as it has any opened windows.
//
// Another feature that GApplication (optionally) provides is process
// uniqueness. Applications can make use of this functionality by
// providing a unique application ID. If given, only one application
// with this ID can be running at a time per session. The session
// concept is platform-dependent, but corresponds roughly to a graphical
// desktop login. When your application is launched again, its
// arguments are passed through platform communication to the already
// running program. The already running instance of the program is
// called the "primary instance"; for non-unique applications this is
// always the current instance. On Linux, the D-Bus session bus
// is used for communication.
//
// The use of #GApplication differs from some other commonly-used
// uniqueness libraries (such as libunique) in important ways. The
// application is not expected to manually register itself and check
// if it is the primary instance. Instead, the main() function of a
// #GApplication should do very little more than instantiating the
// application instance, possibly connecting signal handlers, then
// calling g_application_run(). All checks for uniqueness are done
// internally. If the application is the primary instance then the
// startup signal is emitted and the mainloop runs. If the application
// is not the primary instance then a signal is sent to the primary
// instance and g_application_run() promptly returns. See the code
// examples below.
//
// If used, the expected form of an application identifier is the same as
// that of of a
// [D-Bus well-known bus name](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// Examples include: `com.example.MyApp`, `org.example.internal_apps.Calculator`,
// `org._7_zip.Archiver`.
// For details on valid application identifiers, see g_application_id_is_valid().
//
// On Linux, the application identifier is claimed as a well-known bus name
// on the user's session bus.  This means that the uniqueness of your
// application is scoped to the current session.  It also means that your
// application may provide additional services (through registration of other
// object paths) at that bus name.  The registration of these object paths
// should be done with the shared GDBus session bus.  Note that due to the
// internal architecture of GDBus, method calls can be dispatched at any time
// (even if a main loop is not running).  For this reason, you must ensure that
// any object paths that you wish to register are registered before #GApplication
// attempts to acquire the bus name of your application (which happens in
// g_application_register()).  Unfortunately, this means that you cannot use
// g_application_get_is_remote() to decide if you want to register object paths.
//
// GApplication also implements the #GActionGroup and #GActionMap
// interfaces and lets you easily export actions by adding them with
// g_action_map_add_action(). When invoking an action by calling
// g_action_group_activate_action() on the application, it is always
// invoked in the primary instance. The actions are also exported on
// the session bus, and GIO provides the #GDBusActionGroup wrapper to
// conveniently access them remotely. GIO provides a #GDBusMenuModel wrapper
// for remote access to exported #GMenuModels.
//
// There is a number of different entry points into a GApplication:
//
// - via 'Activate' (i.e. just starting the application)
//
// - via 'Open' (i.e. opening some files)
//
// - by handling a command-line
//
// - via activating an action
//
// The #GApplication::startup signal lets you handle the application
// initialization for all of these in a single place.
//
// Regardless of which of these entry points is used to start the
// application, GApplication passes some ‘platform data’ from the
// launching instance to the primary instance, in the form of a
// #GVariant dictionary mapping strings to variants. To use platform
// data, override the @before_emit or @after_emit virtual functions
// in your #GApplication subclass. When dealing with
// #GApplicationCommandLine objects, the platform data is
// directly available via g_application_command_line_get_cwd(),
// g_application_command_line_get_environ() and
// g_application_command_line_get_platform_data().
//
// As the name indicates, the platform data may vary depending on the
// operating system, but it always includes the current directory (key
// "cwd"), and optionally the environment (ie the set of environment
// variables and their values) of the calling process (key "environ").
// The environment is only added to the platform data if the
// %G_APPLICATION_SEND_ENVIRONMENT flag is set. #GApplication subclasses
// can add their own platform data by overriding the @add_platform_data
// virtual function. For instance, #GtkApplication adds startup notification
// data in this way.
//
// To parse commandline arguments you may handle the
// #GApplication::command-line signal or override the local_command_line()
// vfunc, to parse them in either the primary instance or the local instance,
// respectively.
//
// For an example of opening files with a GApplication, see
// [gapplication-example-open.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-open.c).
//
// For an example of using actions with GApplication, see
// [gapplication-example-actions.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-actions.c).
//
// For an example of using extra D-Bus hooks with GApplication, see
// [gapplication-example-dbushooks.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-dbushooks.c).
type Application struct {
	gobject.Object
}

var xApplicationGLibType func() types.GType

func ApplicationGLibType() types.GType {
	return xApplicationGLibType()
}

func ApplicationNewFromInternalPtr(ptr uintptr) *Application {
	cls := &Application{}
	cls.Ptr = ptr
	return cls
}

var xNewApplication func(string, ApplicationFlags) uintptr

// Creates a new #GApplication instance.
//
// If non-%NULL, the application id must be valid.  See
// g_application_id_is_valid().
//
// If no application ID is given then some features of #GApplication
// (most notably application uniqueness) will be disabled.
func NewApplication(ApplicationIdVar string, FlagsVar ApplicationFlags) *Application {
	var cls *Application

	cret := xNewApplication(ApplicationIdVar, FlagsVar)

	if cret == 0 {
		return nil
	}
	cls = &Application{}
	cls.Ptr = cret
	return cls
}

var xApplicationActivate func(uintptr)

// Activates the application.
//
// In essence, this results in the #GApplication::activate signal being
// emitted in the primary instance.
//
// The application must be registered before calling this function.
func (x *Application) Activate() {

	xApplicationActivate(x.GoPointer())

}

var xApplicationAddMainOption func(uintptr, string, byte, glib.OptionFlags, glib.OptionArg, string, string)

// Add an option to be handled by @application.
//
// Calling this function is the equivalent of calling
// g_application_add_main_option_entries() with a single #GOptionEntry
// that has its arg_data member set to %NULL.
//
// The parsed arguments will be packed into a #GVariantDict which
// is passed to #GApplication::handle-local-options. If
// %G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also
// be sent to the primary instance. See
// g_application_add_main_option_entries() for more details.
//
// See #GOptionEntry for more documentation of the arguments.
func (x *Application) AddMainOption(LongNameVar string, ShortNameVar byte, FlagsVar glib.OptionFlags, ArgVar glib.OptionArg, DescriptionVar string, ArgDescriptionVar string) {

	xApplicationAddMainOption(x.GoPointer(), LongNameVar, ShortNameVar, FlagsVar, ArgVar, DescriptionVar, ArgDescriptionVar)

}

var xApplicationAddMainOptionEntries func(uintptr, []glib.OptionEntry)

// Adds main option entries to be handled by @application.
//
// This function is comparable to g_option_context_add_main_entries().
//
// After the commandline arguments are parsed, the
// #GApplication::handle-local-options signal will be emitted.  At this
// point, the application can inspect the values pointed to by @arg_data
// in the given #GOptionEntrys.
//
// Unlike #GOptionContext, #GApplication supports giving a %NULL
// @arg_data for a non-callback #GOptionEntry.  This results in the
// argument in question being packed into a #GVariantDict which is also
// passed to #GApplication::handle-local-options, where it can be
// inspected and modified.  If %G_APPLICATION_HANDLES_COMMAND_LINE is
// set, then the resulting dictionary is sent to the primary instance,
// where g_application_command_line_get_options_dict() will return it.
// This "packing" is done according to the type of the argument --
// booleans for normal flags, strings for strings, bytestrings for
// filenames, etc.  The packing only occurs if the flag is given (ie: we
// do not pack a "false" #GVariant in the case that a flag is missing).
//
// In general, it is recommended that all commandline arguments are
// parsed locally.  The options dictionary should then be used to
// transmit the result of the parsing to the primary instance, where
// g_variant_dict_lookup() can be used.  For local options, it is
// possible to either use @arg_data in the usual way, or to consult (and
// potentially remove) the option from the options dictionary.
//
// This function is new in GLib 2.40.  Before then, the only real choice
// was to send all of the commandline arguments (options and all) to the
// primary instance for handling.  #GApplication ignored them completely
// on the local side.  Calling this function "opts in" to the new
// behaviour, and in particular, means that unrecognised options will be
// treated as errors.  Unrecognised options have never been ignored when
// %G_APPLICATION_HANDLES_COMMAND_LINE is unset.
//
// If #GApplication::handle-local-options needs to see the list of
// filenames, then the use of %G_OPTION_REMAINING is recommended.  If
// @arg_data is %NULL then %G_OPTION_REMAINING can be used as a key into
// the options dictionary.  If you do use %G_OPTION_REMAINING then you
// need to handle these arguments for yourself because once they are
// consumed, they will no longer be visible to the default handling
// (which treats them as filenames to be opened).
//
// It is important to use the proper GVariant format when retrieving
// the options with g_variant_dict_lookup():
// - for %G_OPTION_ARG_NONE, use `b`
// - for %G_OPTION_ARG_STRING, use `&amp;s`
// - for %G_OPTION_ARG_INT, use `i`
// - for %G_OPTION_ARG_INT64, use `x`
// - for %G_OPTION_ARG_DOUBLE, use `d`
// - for %G_OPTION_ARG_FILENAME, use `^&amp;ay`
// - for %G_OPTION_ARG_STRING_ARRAY, use `^a&amp;s`
// - for %G_OPTION_ARG_FILENAME_ARRAY, use `^a&amp;ay`
func (x *Application) AddMainOptionEntries(EntriesVar []glib.OptionEntry) {

	xApplicationAddMainOptionEntries(x.GoPointer(), EntriesVar)

}

var xApplicationAddOptionGroup func(uintptr, *glib.OptionGroup)

// Adds a #GOptionGroup to the commandline handling of @application.
//
// This function is comparable to g_option_context_add_group().
//
// Unlike g_application_add_main_option_entries(), this function does
// not deal with %NULL @arg_data and never transmits options to the
// primary instance.
//
// The reason for that is because, by the time the options arrive at the
// primary instance, it is typically too late to do anything with them.
// Taking the GTK option group as an example: GTK will already have been
// initialised by the time the #GApplication::command-line handler runs.
// In the case that this is not the first-running instance of the
// application, the existing instance may already have been running for
// a very long time.
//
// This means that the options from #GOptionGroup are only really usable
// in the case that the instance of the application being run is the
// first instance.  Passing options like `--display=` or `--gdk-debug=`
// on future runs will have no effect on the existing primary instance.
//
// Calling this function will cause the options in the supplied option
// group to be parsed, but it does not cause you to be "opted in" to the
// new functionality whereby unrecognised options are rejected even if
// %G_APPLICATION_HANDLES_COMMAND_LINE was given.
func (x *Application) AddOptionGroup(GroupVar *glib.OptionGroup) {

	xApplicationAddOptionGroup(x.GoPointer(), GroupVar)

}

var xApplicationBindBusyProperty func(uintptr, uintptr, string)

// Marks @application as busy (see g_application_mark_busy()) while
// @property on @object is %TRUE.
//
// The binding holds a reference to @application while it is active, but
// not to @object. Instead, the binding is destroyed when @object is
// finalized.
func (x *Application) BindBusyProperty(ObjectVar *gobject.Object, PropertyVar string) {

	xApplicationBindBusyProperty(x.GoPointer(), ObjectVar.GoPointer(), PropertyVar)

}

var xApplicationGetApplicationId func(uintptr) string

// Gets the unique identifier for @application.
func (x *Application) GetApplicationId() string {

	cret := xApplicationGetApplicationId(x.GoPointer())
	return cret
}

var xApplicationGetDbusConnection func(uintptr) uintptr

// Gets the #GDBusConnection being used by the application, or %NULL.
//
// If #GApplication is using its D-Bus backend then this function will
// return the #GDBusConnection being used for uniqueness and
// communication with the desktop environment and other instances of the
// application.
//
// If #GApplication is not using D-Bus then this function will return
// %NULL.  This includes the situation where the D-Bus backend would
// normally be in use but we were unable to connect to the bus.
//
// This function must not be called before the application has been
// registered.  See g_application_get_is_registered().
func (x *Application) GetDbusConnection() *DBusConnection {
	var cls *DBusConnection

	cret := xApplicationGetDbusConnection(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &DBusConnection{}
	cls.Ptr = cret
	return cls
}

var xApplicationGetDbusObjectPath func(uintptr) string

// Gets the D-Bus object path being used by the application, or %NULL.
//
// If #GApplication is using its D-Bus backend then this function will
// return the D-Bus object path that #GApplication is using.  If the
// application is the primary instance then there is an object published
// at this path.  If the application is not the primary instance then
// the result of this function is undefined.
//
// If #GApplication is not using D-Bus then this function will return
// %NULL.  This includes the situation where the D-Bus backend would
// normally be in use but we were unable to connect to the bus.
//
// This function must not be called before the application has been
// registered.  See g_application_get_is_registered().
func (x *Application) GetDbusObjectPath() string {

	cret := xApplicationGetDbusObjectPath(x.GoPointer())
	return cret
}

var xApplicationGetFlags func(uintptr) ApplicationFlags

// Gets the flags for @application.
//
// See #GApplicationFlags.
func (x *Application) GetFlags() ApplicationFlags {

	cret := xApplicationGetFlags(x.GoPointer())
	return cret
}

var xApplicationGetInactivityTimeout func(uintptr) uint

// Gets the current inactivity timeout for the application.
//
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
func (x *Application) GetInactivityTimeout() uint {

	cret := xApplicationGetInactivityTimeout(x.GoPointer())
	return cret
}

var xApplicationGetIsBusy func(uintptr) bool

// Gets the application's current busy state, as set through
// g_application_mark_busy() or g_application_bind_busy_property().
func (x *Application) GetIsBusy() bool {

	cret := xApplicationGetIsBusy(x.GoPointer())
	return cret
}

var xApplicationGetIsRegistered func(uintptr) bool

// Checks if @application is registered.
//
// An application is registered if g_application_register() has been
// successfully called.
func (x *Application) GetIsRegistered() bool {

	cret := xApplicationGetIsRegistered(x.GoPointer())
	return cret
}

var xApplicationGetIsRemote func(uintptr) bool

// Checks if @application is remote.
//
// If @application is remote then it means that another instance of
// application already exists (the 'primary' instance).  Calls to
// perform actions on @application will result in the actions being
// performed by the primary instance.
//
// The value of this property cannot be accessed before
// g_application_register() has been called.  See
// g_application_get_is_registered().
func (x *Application) GetIsRemote() bool {

	cret := xApplicationGetIsRemote(x.GoPointer())
	return cret
}

var xApplicationGetResourceBasePath func(uintptr) string

// Gets the resource base path of @application.
//
// See g_application_set_resource_base_path() for more information.
func (x *Application) GetResourceBasePath() string {

	cret := xApplicationGetResourceBasePath(x.GoPointer())
	return cret
}

var xApplicationHold func(uintptr)

// Increases the use count of @application.
//
// Use this function to indicate that the application has a reason to
// continue to run.  For example, g_application_hold() is called by GTK+
// when a toplevel window is on the screen.
//
// To cancel the hold, call g_application_release().
func (x *Application) Hold() {

	xApplicationHold(x.GoPointer())

}

var xApplicationMarkBusy func(uintptr)

// Increases the busy count of @application.
//
// Use this function to indicate that the application is busy, for instance
// while a long running operation is pending.
//
// The busy state will be exposed to other processes, so a session shell will
// use that information to indicate the state to the user (e.g. with a
// spinner).
//
// To cancel the busy indication, use g_application_unmark_busy().
//
// The application must be registered before calling this function.
func (x *Application) MarkBusy() {

	xApplicationMarkBusy(x.GoPointer())

}

var xApplicationOpen func(uintptr, uintptr, int, string)

// Opens the given files.
//
// In essence, this results in the #GApplication::open signal being emitted
// in the primary instance.
//
// @n_files must be greater than zero.
//
// @hint is simply passed through to the ::open signal.  It is
// intended to be used by applications that have multiple modes for
// opening files (eg: "view" vs "edit", etc).  Unless you have a need
// for this functionality, you should use "".
//
// The application must be registered before calling this function
// and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
func (x *Application) Open(FilesVar uintptr, NFilesVar int, HintVar string) {

	xApplicationOpen(x.GoPointer(), FilesVar, NFilesVar, HintVar)

}

var xApplicationQuit func(uintptr)

// Immediately quits the application.
//
// Upon return to the mainloop, g_application_run() will return,
// calling only the 'shutdown' function before doing so.
//
// The hold count is ignored.
// Take care if your code has called g_application_hold() on the application and
// is therefore still expecting it to exist.
// (Note that you may have called g_application_hold() indirectly, for example
// through gtk_application_add_window().)
//
// The result of calling g_application_run() again after it returns is
// unspecified.
func (x *Application) Quit() {

	xApplicationQuit(x.GoPointer())

}

var xApplicationRegister func(uintptr, uintptr, **glib.Error) bool

// Attempts registration of the application.
//
// This is the point at which the application discovers if it is the
// primary instance or merely acting as a remote for an already-existing
// primary instance.  This is implemented by attempting to acquire the
// application identifier as a unique bus name on the session bus using
// GDBus.
//
// If there is no application ID or if %G_APPLICATION_NON_UNIQUE was
// given, then this process will always become the primary instance.
//
// Due to the internal architecture of GDBus, method calls can be
// dispatched at any time (even if a main loop is not running).  For
// this reason, you must ensure that any object paths that you wish to
// register are registered before calling this function.
//
// If the application has already been registered then %TRUE is
// returned with no work performed.
//
// The #GApplication::startup signal is emitted if registration succeeds
// and @application is the primary instance (including the non-unique
// case).
//
// In the event of an error (such as @cancellable being cancelled, or a
// failure to connect to the session bus), %FALSE is returned and @error
// is set appropriately.
//
// Note: the return value of this function is not an indicator that this
// instance is or is not the primary instance of the application.  See
// g_application_get_is_remote() for that.
func (x *Application) Register(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xApplicationRegister(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xApplicationRelease func(uintptr)

// Decrease the use count of @application.
//
// When the use count reaches zero, the application will stop running.
//
// Never call this function except to cancel the effect of a previous
// call to g_application_hold().
func (x *Application) Release() {

	xApplicationRelease(x.GoPointer())

}

var xApplicationRun func(uintptr, int, []string) int

// Runs the application.
//
// This function is intended to be run from main() and its return value
// is intended to be returned by main(). Although you are expected to pass
// the @argc, @argv parameters from main() to this function, it is possible
// to pass %NULL if @argv is not available or commandline handling is not
// required.  Note that on Windows, @argc and @argv are ignored, and
// g_win32_get_command_line() is called internally (for proper support
// of Unicode commandline arguments).
//
// #GApplication will attempt to parse the commandline arguments.  You
// can add commandline flags to the list of recognised options by way of
// g_application_add_main_option_entries().  After this, the
// #GApplication::handle-local-options signal is emitted, from which the
// application can inspect the values of its #GOptionEntrys.
//
// #GApplication::handle-local-options is a good place to handle options
// such as `--version`, where an immediate reply from the local process is
// desired (instead of communicating with an already-running instance).
// A #GApplication::handle-local-options handler can stop further processing
// by returning a non-negative value, which then becomes the exit status of
// the process.
//
// What happens next depends on the flags: if
// %G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
// commandline arguments are sent to the primary instance, where a
// #GApplication::command-line signal is emitted.  Otherwise, the
// remaining commandline arguments are assumed to be a list of files.
// If there are no files listed, the application is activated via the
// #GApplication::activate signal.  If there are one or more files, and
// %G_APPLICATION_HANDLES_OPEN was specified then the files are opened
// via the #GApplication::open signal.
//
// If you are interested in doing more complicated local handling of the
// commandline then you should implement your own #GApplication subclass
// and override local_command_line(). In this case, you most likely want
// to return %TRUE from your local_command_line() implementation to
// suppress the default handling. See
// [gapplication-example-cmdline2.c][https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c]
// for an example.
//
// If, after the above is done, the use count of the application is zero
// then the exit status is returned immediately.  If the use count is
// non-zero then the default main context is iterated until the use count
// falls to zero, at which point 0 is returned.
//
// If the %G_APPLICATION_IS_SERVICE flag is set, then the service will
// run for as much as 10 seconds with a use count of zero while waiting
// for the message that caused the activation to arrive.  After that,
// if the use count falls to zero the application will exit immediately,
// except in the case that g_application_set_inactivity_timeout() is in
// use.
//
// This function sets the prgname (g_set_prgname()), if not already set,
// to the basename of argv[0].
//
// Much like g_main_loop_run(), this function will acquire the main context
// for the duration that the application is running.
//
// Since 2.40, applications that are not explicitly flagged as services
// or launchers (ie: neither %G_APPLICATION_IS_SERVICE or
// %G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
// default handler for local_command_line) if "--gapplication-service"
// was given in the command line.  If this flag is present then normal
// commandline processing is interrupted and the
// %G_APPLICATION_IS_SERVICE flag is set.  This provides a "compromise"
// solution whereby running an application directly from the commandline
// will invoke it in the normal way (which can be useful for debugging)
// while still allowing applications to be D-Bus activated in service
// mode.  The D-Bus service file should invoke the executable with
// "--gapplication-service" as the sole commandline argument.  This
// approach is suitable for use by most graphical applications but
// should not be used from applications like editors that need precise
// control over when processes invoked via the commandline will exit and
// what their exit status will be.
func (x *Application) Run(ArgcVar int, ArgvVar []string) int {

	cret := xApplicationRun(x.GoPointer(), ArgcVar, ArgvVar)
	return cret
}

var xApplicationSendNotification func(uintptr, string, uintptr)

// Sends a notification on behalf of @application to the desktop shell.
// There is no guarantee that the notification is displayed immediately,
// or even at all.
//
// Notifications may persist after the application exits. It will be
// D-Bus-activated when the notification or one of its actions is
// activated.
//
// Modifying @notification after this call has no effect. However, the
// object can be reused for a later call to this function.
//
// @id may be any string that uniquely identifies the event for the
// application. It does not need to be in any special format. For
// example, "new-message" might be appropriate for a notification about
// new messages.
//
// If a previous notification was sent with the same @id, it will be
// replaced with @notification and shown again as if it was a new
// notification. This works even for notifications sent from a previous
// execution of the application, as long as @id is the same string.
//
// @id may be %NULL, but it is impossible to replace or withdraw
// notifications without an id.
//
// If @notification is no longer relevant, it can be withdrawn with
// g_application_withdraw_notification().
func (x *Application) SendNotification(IdVar string, NotificationVar *Notification) {

	xApplicationSendNotification(x.GoPointer(), IdVar, NotificationVar.GoPointer())

}

var xApplicationSetActionGroup func(uintptr, uintptr)

// This used to be how actions were associated with a #GApplication.
// Now there is #GActionMap for that.
func (x *Application) SetActionGroup(ActionGroupVar ActionGroup) {

	xApplicationSetActionGroup(x.GoPointer(), ActionGroupVar.GoPointer())

}

var xApplicationSetApplicationId func(uintptr, string)

// Sets the unique identifier for @application.
//
// The application id can only be modified if @application has not yet
// been registered.
//
// If non-%NULL, the application id must be valid.  See
// g_application_id_is_valid().
func (x *Application) SetApplicationId(ApplicationIdVar string) {

	xApplicationSetApplicationId(x.GoPointer(), ApplicationIdVar)

}

var xApplicationSetDefault func(uintptr)

// Sets or unsets the default application for the process, as returned
// by g_application_get_default().
//
// This function does not take its own reference on @application.  If
// @application is destroyed then the default application will revert
// back to %NULL.
func (x *Application) SetDefault() {

	xApplicationSetDefault(x.GoPointer())

}

var xApplicationSetFlags func(uintptr, ApplicationFlags)

// Sets the flags for @application.
//
// The flags can only be modified if @application has not yet been
// registered.
//
// See #GApplicationFlags.
func (x *Application) SetFlags(FlagsVar ApplicationFlags) {

	xApplicationSetFlags(x.GoPointer(), FlagsVar)

}

var xApplicationSetInactivityTimeout func(uintptr, uint)

// Sets the current inactivity timeout for the application.
//
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
//
// This call has no side effects of its own.  The value set here is only
// used for next time g_application_release() drops the use count to
// zero.  Any timeouts currently in progress are not impacted.
func (x *Application) SetInactivityTimeout(InactivityTimeoutVar uint) {

	xApplicationSetInactivityTimeout(x.GoPointer(), InactivityTimeoutVar)

}

var xApplicationSetOptionContextDescription func(uintptr, string)

// Adds a description to the @application option context.
//
// See g_option_context_set_description() for more information.
func (x *Application) SetOptionContextDescription(DescriptionVar string) {

	xApplicationSetOptionContextDescription(x.GoPointer(), DescriptionVar)

}

var xApplicationSetOptionContextParameterString func(uintptr, string)

// Sets the parameter string to be used by the commandline handling of @application.
//
// This function registers the argument to be passed to g_option_context_new()
// when the internal #GOptionContext of @application is created.
//
// See g_option_context_new() for more information about @parameter_string.
func (x *Application) SetOptionContextParameterString(ParameterStringVar string) {

	xApplicationSetOptionContextParameterString(x.GoPointer(), ParameterStringVar)

}

var xApplicationSetOptionContextSummary func(uintptr, string)

// Adds a summary to the @application option context.
//
// See g_option_context_set_summary() for more information.
func (x *Application) SetOptionContextSummary(SummaryVar string) {

	xApplicationSetOptionContextSummary(x.GoPointer(), SummaryVar)

}

var xApplicationSetResourceBasePath func(uintptr, string)

// Sets (or unsets) the base resource path of @application.
//
// The path is used to automatically load various [application
// resources][gresource] such as menu layouts and action descriptions.
// The various types of resources will be found at fixed names relative
// to the given base path.
//
// By default, the resource base path is determined from the application
// ID by prefixing '/' and replacing each '.' with '/'.  This is done at
// the time that the #GApplication object is constructed.  Changes to
// the application ID after that point will not have an impact on the
// resource base path.
//
// As an example, if the application has an ID of "org.example.app" then
// the default resource base path will be "/org/example/app".  If this
// is a #GtkApplication (and you have not manually changed the path)
// then Gtk will then search for the menus of the application at
// "/org/example/app/gtk/menus.ui".
//
// See #GResource for more information about adding resources to your
// application.
//
// You can disable automatic resource loading functionality by setting
// the path to %NULL.
//
// Changing the resource base path once the application is running is
// not recommended.  The point at which the resource path is consulted
// for forming paths for various purposes is unspecified.  When writing
// a sub-class of #GApplication you should either set the
// #GApplication:resource-base-path property at construction time, or call
// this function during the instance initialization. Alternatively, you
// can call this function in the #GApplicationClass.startup virtual function,
// before chaining up to the parent implementation.
func (x *Application) SetResourceBasePath(ResourcePathVar string) {

	xApplicationSetResourceBasePath(x.GoPointer(), ResourcePathVar)

}

var xApplicationUnbindBusyProperty func(uintptr, uintptr, string)

// Destroys a binding between @property and the busy state of
// @application that was previously created with
// g_application_bind_busy_property().
func (x *Application) UnbindBusyProperty(ObjectVar *gobject.Object, PropertyVar string) {

	xApplicationUnbindBusyProperty(x.GoPointer(), ObjectVar.GoPointer(), PropertyVar)

}

var xApplicationUnmarkBusy func(uintptr)

// Decreases the busy count of @application.
//
// When the busy count reaches zero, the new state will be propagated
// to other processes.
//
// This function must only be called to cancel the effect of a previous
// call to g_application_mark_busy().
func (x *Application) UnmarkBusy() {

	xApplicationUnmarkBusy(x.GoPointer())

}

var xApplicationWithdrawNotification func(uintptr, string)

// Withdraws a notification that was sent with
// g_application_send_notification().
//
// This call does nothing if a notification with @id doesn't exist or
// the notification was never sent.
//
// This function works even for notifications sent in previous
// executions of this application, as long @id is the same as it was for
// the sent notification.
//
// Note that notifications are dismissed when the user clicks on one
// of the buttons in a notification or triggers its default action, so
// there is no need to explicitly withdraw the notification in that case.
func (x *Application) WithdrawNotification(IdVar string) {

	xApplicationWithdrawNotification(x.GoPointer(), IdVar)

}

func (c *Application) GoPointer() uintptr {
	return c.Ptr
}

func (c *Application) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// The ::activate signal is emitted on the primary instance when an
// activation occurs. See g_application_activate().
func (x *Application) ConnectActivate(cb *func(Application)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Application{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
}

// The ::command-line signal is emitted on the primary instance when
// a commandline is not handled locally. See g_application_run() and
// the #GApplicationCommandLine documentation for more information.
func (x *Application) ConnectCommandLine(cb *func(Application, uintptr) int) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "command-line", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, CommandLineVarp uintptr) int {
		fa := Application{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, CommandLineVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "command-line", cbRefPtr)
}

// The ::handle-local-options signal is emitted on the local instance
// after the parsing of the commandline options has occurred.
//
// You can add options to be recognised during commandline option
// parsing using g_application_add_main_option_entries() and
// g_application_add_option_group().
//
// Signal handlers can inspect @options (along with values pointed to
// from the @arg_data of an installed #GOptionEntrys) in order to
// decide to perform certain actions, including direct local handling
// (which may be useful for options like --version).
//
// In the event that the application is marked
// %G_APPLICATION_HANDLES_COMMAND_LINE the "normal processing" will
// send the @options dictionary to the primary instance where it can be
// read with g_application_command_line_get_options_dict().  The signal
// handler can modify the dictionary before returning, and the
// modified dictionary will be sent.
//
// In the event that %G_APPLICATION_HANDLES_COMMAND_LINE is not set,
// "normal processing" will treat the remaining uncollected command
// line arguments as filenames or URIs.  If there are no arguments,
// the application is activated by g_application_activate().  One or
// more arguments results in a call to g_application_open().
//
// If you want to handle the local commandline arguments for yourself
// by converting them to calls to g_application_open() or
// g_action_group_activate_action() then you must be sure to register
// the application first.  You should probably not call
// g_application_activate() for yourself, however: just return -1 and
// allow the default handler to do it for you.  This will ensure that
// the `--gapplication-service` switch works properly (i.e. no activation
// in that case).
//
// Note that this signal is emitted from the default implementation of
// local_command_line().  If you override that function and don't
// chain up then this signal will never be emitted.
//
// You can override local_command_line() if you need more powerful
// capabilities than what is provided here, but this should not
// normally be required.
func (x *Application) ConnectHandleLocalOptions(cb *func(Application, uintptr) int) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "handle-local-options", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, OptionsVarp uintptr) int {
		fa := Application{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, OptionsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "handle-local-options", cbRefPtr)
}

// The ::name-lost signal is emitted only on the registered primary instance
// when a new instance has taken over. This can only happen if the application
// is using the %G_APPLICATION_ALLOW_REPLACEMENT flag.
//
// The default handler for this signal calls g_application_quit().
func (x *Application) ConnectNameLost(cb *func(Application) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "name-lost", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := Application{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "name-lost", cbRefPtr)
}

// The ::open signal is emitted on the primary instance when there are
// files to open. See g_application_open() for more information.
func (x *Application) ConnectOpen(cb *func(Application, uintptr, int, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "open", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, FilesVarp uintptr, NFilesVarp int, HintVarp string) {
		fa := Application{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, FilesVarp, NFilesVarp, HintVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "open", cbRefPtr)
}

// The ::shutdown signal is emitted only on the registered primary instance
// immediately after the main loop terminates.
func (x *Application) ConnectShutdown(cb *func(Application)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "shutdown", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Application{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "shutdown", cbRefPtr)
}

// The ::startup signal is emitted on the primary instance immediately
// after registration. See g_application_register().
func (x *Application) ConnectStartup(cb *func(Application)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "startup", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Application{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "startup", cbRefPtr)
}

// Emits the #GActionGroup::action-added signal on @action_group.
//
// This function should only be called by #GActionGroup implementations.
func (x *Application) ActionAdded(ActionNameVar string) {

	XGActionGroupActionAdded(x.GoPointer(), ActionNameVar)

}

// Emits the #GActionGroup::action-enabled-changed signal on @action_group.
//
// This function should only be called by #GActionGroup implementations.
func (x *Application) ActionEnabledChanged(ActionNameVar string, EnabledVar bool) {

	XGActionGroupActionEnabledChanged(x.GoPointer(), ActionNameVar, EnabledVar)

}

// Emits the #GActionGroup::action-removed signal on @action_group.
//
// This function should only be called by #GActionGroup implementations.
func (x *Application) ActionRemoved(ActionNameVar string) {

	XGActionGroupActionRemoved(x.GoPointer(), ActionNameVar)

}

// Emits the #GActionGroup::action-state-changed signal on @action_group.
//
// This function should only be called by #GActionGroup implementations.
func (x *Application) ActionStateChanged(ActionNameVar string, StateVar *glib.Variant) {

	XGActionGroupActionStateChanged(x.GoPointer(), ActionNameVar, StateVar)

}

// Activate the named action within @action_group.
//
// If the action is expecting a parameter, then the correct type of
// parameter must be given as @parameter.  If the action is expecting no
// parameters then @parameter must be %NULL.  See
// g_action_group_get_action_parameter_type().
//
// If the #GActionGroup implementation supports asynchronous remote
// activation over D-Bus, this call may return before the relevant
// D-Bus traffic has been sent, or any replies have been received. In
// order to block on such asynchronous activation calls,
// g_dbus_connection_flush() should be called prior to the code, which
// depends on the result of the action activation. Without flushing
// the D-Bus connection, there is no guarantee that the action would
// have been activated.
//
// The following code which runs in a remote app instance, shows an
// example of a "quit" action being activated on the primary app
// instance over D-Bus. Here g_dbus_connection_flush() is called
// before `exit()`. Without g_dbus_connection_flush(), the "quit" action
// may fail to be activated on the primary instance.
//
// |[&lt;!-- language="C" --&gt;
// // call "quit" action on primary instance
// g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
//
// // make sure the action is activated now
// g_dbus_connection_flush (...);
//
// g_debug ("application has been terminated. exiting.");
//
// exit (0);
// ]|
func (x *Application) ActivateAction(ActionNameVar string, ParameterVar *glib.Variant) {

	XGActionGroupActivateAction(x.GoPointer(), ActionNameVar, ParameterVar)

}

// Request for the state of the named action within @action_group to be
// changed to @value.
//
// The action must be stateful and @value must be of the correct type.
// See g_action_group_get_action_state_type().
//
// This call merely requests a change.  The action may refuse to change
// its state or may change its state to something other than @value.
// See g_action_group_get_action_state_hint().
//
// If the @value GVariant is floating, it is consumed.
func (x *Application) ChangeActionState(ActionNameVar string, ValueVar *glib.Variant) {

	XGActionGroupChangeActionState(x.GoPointer(), ActionNameVar, ValueVar)

}

// Checks if the named action within @action_group is currently enabled.
//
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
func (x *Application) GetActionEnabled(ActionNameVar string) bool {

	cret := XGActionGroupGetActionEnabled(x.GoPointer(), ActionNameVar)
	return cret
}

// Queries the type of the parameter that must be given when activating
// the named action within @action_group.
//
// When activating the action using g_action_group_activate_action(),
// the #GVariant given to that function must be of the type returned
// by this function.
//
// In the case that this function returns %NULL, you must not give any
// #GVariant, but %NULL instead.
//
// The parameter type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added
// with the same name but a different parameter type.
func (x *Application) GetActionParameterType(ActionNameVar string) *glib.VariantType {

	cret := XGActionGroupGetActionParameterType(x.GoPointer(), ActionNameVar)
	return cret
}

// Queries the current state of the named action within @action_group.
//
// If the action is not stateful then %NULL will be returned.  If the
// action is stateful then the type of the return value is the type
// given by g_action_group_get_action_state_type().
//
// The return value (if non-%NULL) should be freed with
// g_variant_unref() when it is no longer required.
func (x *Application) GetActionState(ActionNameVar string) *glib.Variant {

	cret := XGActionGroupGetActionState(x.GoPointer(), ActionNameVar)
	return cret
}

// Requests a hint about the valid range of values for the state of the
// named action within @action_group.
//
// If %NULL is returned it either means that the action is not stateful
// or that there is no hint about the valid range of values for the
// state of the action.
//
// If a #GVariant array is returned then each item in the array is a
// possible value for the state.  If a #GVariant pair (ie: two-tuple) is
// returned then the tuple specifies the inclusive lower and upper bound
// of valid values for the state.
//
// In any case, the information is merely a hint.  It may be possible to
// have a state value outside of the hinted range and setting a value
// within the range may fail.
//
// The return value (if non-%NULL) should be freed with
// g_variant_unref() when it is no longer required.
func (x *Application) GetActionStateHint(ActionNameVar string) *glib.Variant {

	cret := XGActionGroupGetActionStateHint(x.GoPointer(), ActionNameVar)
	return cret
}

// Queries the type of the state of the named action within
// @action_group.
//
// If the action is stateful then this function returns the
// #GVariantType of the state.  All calls to
// g_action_group_change_action_state() must give a #GVariant of this
// type and g_action_group_get_action_state() will return a #GVariant
// of the same type.
//
// If the action is not stateful then this function will return %NULL.
// In that case, g_action_group_get_action_state() will return %NULL
// and you must not call g_action_group_change_action_state().
//
// The state type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added
// with the same name but a different state type.
func (x *Application) GetActionStateType(ActionNameVar string) *glib.VariantType {

	cret := XGActionGroupGetActionStateType(x.GoPointer(), ActionNameVar)
	return cret
}

// Checks if the named action exists within @action_group.
func (x *Application) HasAction(ActionNameVar string) bool {

	cret := XGActionGroupHasAction(x.GoPointer(), ActionNameVar)
	return cret
}

// Lists the actions contained within @action_group.
//
// The caller is responsible for freeing the list with g_strfreev() when
// it is no longer required.
func (x *Application) ListActions() []string {

	cret := XGActionGroupListActions(x.GoPointer())
	return cret
}

// Queries all aspects of the named action within an @action_group.
//
// This function acquires the information available from
// g_action_group_has_action(), g_action_group_get_action_enabled(),
// g_action_group_get_action_parameter_type(),
// g_action_group_get_action_state_type(),
// g_action_group_get_action_state_hint() and
// g_action_group_get_action_state() with a single function call.
//
// This provides two main benefits.
//
// The first is the improvement in efficiency that comes with not having
// to perform repeated lookups of the action in order to discover
// different things about it.  The second is that implementing
// #GActionGroup can now be done by only overriding this one virtual
// function.
//
// The interface provides a default implementation of this function that
// calls the individual functions, as required, to fetch the
// information.  The interface also provides default implementations of
// those functions that call this function.  All implementations,
// therefore, must override either this function or all of the others.
//
// If the action exists, %TRUE is returned and any of the requested
// fields (as indicated by having a non-%NULL reference passed in) are
// filled.  If the action doesn't exist, %FALSE is returned and the
// fields may or may not have been modified.
func (x *Application) QueryAction(ActionNameVar string, EnabledVar bool, ParameterTypeVar **glib.VariantType, StateTypeVar **glib.VariantType, StateHintVar **glib.Variant, StateVar **glib.Variant) bool {

	cret := XGActionGroupQueryAction(x.GoPointer(), ActionNameVar, EnabledVar, ParameterTypeVar, StateTypeVar, StateHintVar, StateVar)
	return cret
}

// Adds an action to the @action_map.
//
// If the action map already contains an action with the same name
// as @action then the old action is dropped from the action map.
//
// The action map takes its own reference on @action.
func (x *Application) AddAction(ActionVar Action) {

	XGActionMapAddAction(x.GoPointer(), ActionVar.GoPointer())

}

// A convenience function for creating multiple #GSimpleAction instances
// and adding them to a #GActionMap.
//
// Each action is constructed as per one #GActionEntry.
//
// |[&lt;!-- language="C" --&gt;
// static void
// activate_quit (GSimpleAction *simple,
//
//	GVariant      *parameter,
//	gpointer       user_data)
//
//	{
//	  exit (0);
//	}
//
// static void
// activate_print_string (GSimpleAction *simple,
//
//	GVariant      *parameter,
//	gpointer       user_data)
//
//	{
//	  g_print ("%s\n", g_variant_get_string (parameter, NULL));
//	}
//
// static GActionGroup *
// create_action_group (void)
//
//	{
//	  const GActionEntry entries[] = {
//	    { "quit",         activate_quit              },
//	    { "print-string", activate_print_string, "s" }
//	  };
//	  GSimpleActionGroup *group;
//
//	  group = g_simple_action_group_new ();
//	  g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
//
//	  return G_ACTION_GROUP (group);
//	}
//
// ]|
func (x *Application) AddActionEntries(EntriesVar []ActionEntry, NEntriesVar int, UserDataVar uintptr) {

	XGActionMapAddActionEntries(x.GoPointer(), EntriesVar, NEntriesVar, UserDataVar)

}

// Looks up the action with the name @action_name in @action_map.
//
// If no such action exists, returns %NULL.
func (x *Application) LookupAction(ActionNameVar string) *ActionBase {
	var cls *ActionBase

	cret := XGActionMapLookupAction(x.GoPointer(), ActionNameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ActionBase{}
	cls.Ptr = cret
	return cls
}

// Removes the named action from the action map.
//
// If no action of this name is in the map then nothing happens.
func (x *Application) RemoveAction(ActionNameVar string) {

	XGActionMapRemoveAction(x.GoPointer(), ActionNameVar)

}

var xApplicationGetDefault func() uintptr

// Returns the default #GApplication instance for this process.
//
// Normally there is only one #GApplication per process and it becomes
// the default when it is created.  You can exercise more control over
// this by using g_application_set_default().
//
// If there is no default application then %NULL is returned.
func ApplicationGetDefault() *Application {
	var cls *Application

	cret := xApplicationGetDefault()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Application{}
	cls.Ptr = cret
	return cls
}

var xApplicationIdIsValid func(string) bool

// Checks if @application_id is a valid application identifier.
//
// A valid ID is required for calls to g_application_new() and
// g_application_set_application_id().
//
// Application identifiers follow the same format as
// [D-Bus well-known bus names](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// For convenience, the restrictions on application identifiers are
// reproduced here:
//
//   - Application identifiers are composed of 1 or more elements separated by a
//     period (`.`) character. All elements must contain at least one character.
//
//   - Each element must only contain the ASCII characters `[A-Z][a-z][0-9]_-`,
//     with `-` discouraged in new application identifiers. Each element must not
//     begin with a digit.
//
//   - Application identifiers must contain at least one `.` (period) character
//     (and thus at least two elements).
//
// - Application identifiers must not begin with a `.` (period) character.
//
// - Application identifiers must not exceed 255 characters.
//
// Note that the hyphen (`-`) character is allowed in application identifiers,
// but is problematic or not allowed in various specifications and APIs that
// refer to D-Bus, such as
// [Flatpak application IDs](http://docs.flatpak.org/en/latest/introduction.html#identifiers),
// the
// [`DBusActivatable` interface in the Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
// and the convention that an application's "main" interface and object path
// resemble its application identifier and bus name. To avoid situations that
// require special-case handling, it is recommended that new application
// identifiers consistently replace hyphens with underscores.
//
// Like D-Bus interface names, application identifiers should start with the
// reversed DNS domain name of the author of the interface (in lower-case), and
// it is conventional for the rest of the application identifier to consist of
// words run together, with initial capital letters.
//
// As with D-Bus interface names, if the author's DNS domain name contains
// hyphen/minus characters they should be replaced by underscores, and if it
// contains leading digits they should be escaped by prepending an underscore.
// For example, if the owner of 7-zip.org used an application identifier for an
// archiving application, it might be named `org._7_zip.Archiver`.
func ApplicationIdIsValid(ApplicationIdVar string) bool {

	cret := xApplicationIdIsValid(ApplicationIdVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xApplicationGLibType, lib, "g_application_get_type")

	core.PuregoSafeRegister(&xNewApplication, lib, "g_application_new")

	core.PuregoSafeRegister(&xApplicationActivate, lib, "g_application_activate")
	core.PuregoSafeRegister(&xApplicationAddMainOption, lib, "g_application_add_main_option")
	core.PuregoSafeRegister(&xApplicationAddMainOptionEntries, lib, "g_application_add_main_option_entries")
	core.PuregoSafeRegister(&xApplicationAddOptionGroup, lib, "g_application_add_option_group")
	core.PuregoSafeRegister(&xApplicationBindBusyProperty, lib, "g_application_bind_busy_property")
	core.PuregoSafeRegister(&xApplicationGetApplicationId, lib, "g_application_get_application_id")
	core.PuregoSafeRegister(&xApplicationGetDbusConnection, lib, "g_application_get_dbus_connection")
	core.PuregoSafeRegister(&xApplicationGetDbusObjectPath, lib, "g_application_get_dbus_object_path")
	core.PuregoSafeRegister(&xApplicationGetFlags, lib, "g_application_get_flags")
	core.PuregoSafeRegister(&xApplicationGetInactivityTimeout, lib, "g_application_get_inactivity_timeout")
	core.PuregoSafeRegister(&xApplicationGetIsBusy, lib, "g_application_get_is_busy")
	core.PuregoSafeRegister(&xApplicationGetIsRegistered, lib, "g_application_get_is_registered")
	core.PuregoSafeRegister(&xApplicationGetIsRemote, lib, "g_application_get_is_remote")
	core.PuregoSafeRegister(&xApplicationGetResourceBasePath, lib, "g_application_get_resource_base_path")
	core.PuregoSafeRegister(&xApplicationHold, lib, "g_application_hold")
	core.PuregoSafeRegister(&xApplicationMarkBusy, lib, "g_application_mark_busy")
	core.PuregoSafeRegister(&xApplicationOpen, lib, "g_application_open")
	core.PuregoSafeRegister(&xApplicationQuit, lib, "g_application_quit")
	core.PuregoSafeRegister(&xApplicationRegister, lib, "g_application_register")
	core.PuregoSafeRegister(&xApplicationRelease, lib, "g_application_release")
	core.PuregoSafeRegister(&xApplicationRun, lib, "g_application_run")
	core.PuregoSafeRegister(&xApplicationSendNotification, lib, "g_application_send_notification")
	core.PuregoSafeRegister(&xApplicationSetActionGroup, lib, "g_application_set_action_group")
	core.PuregoSafeRegister(&xApplicationSetApplicationId, lib, "g_application_set_application_id")
	core.PuregoSafeRegister(&xApplicationSetDefault, lib, "g_application_set_default")
	core.PuregoSafeRegister(&xApplicationSetFlags, lib, "g_application_set_flags")
	core.PuregoSafeRegister(&xApplicationSetInactivityTimeout, lib, "g_application_set_inactivity_timeout")
	core.PuregoSafeRegister(&xApplicationSetOptionContextDescription, lib, "g_application_set_option_context_description")
	core.PuregoSafeRegister(&xApplicationSetOptionContextParameterString, lib, "g_application_set_option_context_parameter_string")
	core.PuregoSafeRegister(&xApplicationSetOptionContextSummary, lib, "g_application_set_option_context_summary")
	core.PuregoSafeRegister(&xApplicationSetResourceBasePath, lib, "g_application_set_resource_base_path")
	core.PuregoSafeRegister(&xApplicationUnbindBusyProperty, lib, "g_application_unbind_busy_property")
	core.PuregoSafeRegister(&xApplicationUnmarkBusy, lib, "g_application_unmark_busy")
	core.PuregoSafeRegister(&xApplicationWithdrawNotification, lib, "g_application_withdraw_notification")

	core.PuregoSafeRegister(&xApplicationGetDefault, lib, "g_application_get_default")
	core.PuregoSafeRegister(&xApplicationIdIsValid, lib, "g_application_id_is_valid")

}
