// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
)

var xDbusAddressEscapeValue func(string) string

// Escape @string so it can appear in a D-Bus address as the value
// part of a key-value pair.
//
// For instance, if @string is `/run/bus-for-:0`,
// this function would return `/run/bus-for-%3A0`,
// which could be used in a D-Bus address like
// `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-%3A0`.
func DbusAddressEscapeValue(StringVar string) string {

	cret := xDbusAddressEscapeValue(StringVar)
	return cret
}

var xDbusAddressGetForBusSync func(BusType, uintptr, **glib.Error) string

// Synchronously looks up the D-Bus address for the well-known message
// bus instance specified by @bus_type. This may involve using various
// platform specific mechanisms.
//
// The returned address will be in the
// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DbusAddressGetForBusSync(BusTypeVar BusType, CancellableVar *Cancellable) (string, error) {
	var cerr *glib.Error

	cret := xDbusAddressGetForBusSync(BusTypeVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDbusAddressGetStream func(string, uintptr, uintptr, uintptr)

// Asynchronously connects to an endpoint specified by @address and
// sets up the connection so it is in a state to run the client-side
// of the D-Bus authentication conversation. @address must be in the
// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// When the operation is finished, @callback will be invoked. You can
// then call g_dbus_address_get_stream_finish() to get the result of
// the operation.
//
// This is an asynchronous failable function. See
// g_dbus_address_get_stream_sync() for the synchronous version.
func DbusAddressGetStream(AddressVar string, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xDbusAddressGetStream(AddressVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xDbusAddressGetStreamFinish func(uintptr, string, **glib.Error) uintptr

// Finishes an operation started with g_dbus_address_get_stream().
//
// A server is not required to set a GUID, so @out_guid may be set to %NULL
// even on success.
func DbusAddressGetStreamFinish(ResVar AsyncResult, OutGuidVar string) (*IOStream, error) {
	var cls *IOStream
	var cerr *glib.Error

	cret := xDbusAddressGetStreamFinish(ResVar.GoPointer(), OutGuidVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &IOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDbusAddressGetStreamSync func(string, string, uintptr, **glib.Error) uintptr

// Synchronously connects to an endpoint specified by @address and
// sets up the connection so it is in a state to run the client-side
// of the D-Bus authentication conversation. @address must be in the
// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// A server is not required to set a GUID, so @out_guid may be set to %NULL
// even on success.
//
// This is a synchronous failable function. See
// g_dbus_address_get_stream() for the asynchronous version.
func DbusAddressGetStreamSync(AddressVar string, OutGuidVar string, CancellableVar *Cancellable) (*IOStream, error) {
	var cls *IOStream
	var cerr *glib.Error

	cret := xDbusAddressGetStreamSync(AddressVar, OutGuidVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &IOStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDbusIsAddress func(string) bool

// Checks if @string is a
// [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This doesn't check if @string is actually supported by #GDBusServer
// or #GDBusConnection - use g_dbus_is_supported_address() to do more
// checks.
func DbusIsAddress(StringVar string) bool {

	cret := xDbusIsAddress(StringVar)
	return cret
}

var xDbusIsSupportedAddress func(string, **glib.Error) bool

// Like g_dbus_is_address() but also checks if the library supports the
// transports in @string and that key/value pairs for each transport
// are valid. See the specification of the
// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DbusIsSupportedAddress(StringVar string) (bool, error) {
	var cerr *glib.Error

	cret := xDbusIsSupportedAddress(StringVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xDbusAddressEscapeValue, lib, "g_dbus_address_escape_value")
	core.PuregoSafeRegister(&xDbusAddressGetForBusSync, lib, "g_dbus_address_get_for_bus_sync")
	core.PuregoSafeRegister(&xDbusAddressGetStream, lib, "g_dbus_address_get_stream")
	core.PuregoSafeRegister(&xDbusAddressGetStreamFinish, lib, "g_dbus_address_get_stream_finish")
	core.PuregoSafeRegister(&xDbusAddressGetStreamSync, lib, "g_dbus_address_get_stream_sync")
	core.PuregoSafeRegister(&xDbusIsAddress, lib, "g_dbus_is_address")
	core.PuregoSafeRegister(&xDbusIsSupportedAddress, lib, "g_dbus_is_supported_address")

}
