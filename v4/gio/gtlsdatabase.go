// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The class for #GTlsDatabase. Derived classes should implement the various
// virtual methods. _async and _finish methods have a default
// implementation that runs the corresponding sync method in a thread.
type TlsDatabaseClass struct {
	_ structs.HostLayout

	ParentClass uintptr

	Padding [16]uintptr
}

func (x *TlsDatabaseClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type TlsDatabasePrivate struct {
	_ structs.HostLayout
}

func (x *TlsDatabasePrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

const (
	// The purpose used to verify the client certificate in a TLS connection.
	// Used by TLS servers.
	TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT string = "1.3.6.1.5.5.7.3.2"
	// The purpose used to verify the server certificate in a TLS connection. This
	// is the most common purpose in use. Used by TLS clients.
	TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER string = "1.3.6.1.5.5.7.3.1"
)

// #GTlsDatabase is used to look up certificates and other information
// from a certificate or key store. It is an abstract base class which
// TLS library specific subtypes override.
//
// A #GTlsDatabase may be accessed from multiple threads by the TLS backend.
// All implementations are required to be fully thread-safe.
//
// Most common client applications will not directly interact with
// #GTlsDatabase. It is used internally by #GTlsConnection.
type TlsDatabase struct {
	gobject.Object
}

var xTlsDatabaseGLibType func() types.GType

func TlsDatabaseGLibType() types.GType {
	return xTlsDatabaseGLibType()
}

func TlsDatabaseNewFromInternalPtr(ptr uintptr) *TlsDatabase {
	cls := &TlsDatabase{}
	cls.Ptr = ptr
	return cls
}

var xTlsDatabaseCreateCertificateHandle func(uintptr, uintptr) string

// Create a handle string for the certificate. The database will only be able
// to create a handle for certificates that originate from the database. In
// cases where the database cannot create a handle for a certificate, %NULL
// will be returned.
//
// This handle should be stable across various instances of the application,
// and between applications. If a certificate is modified in the database,
// then it is not guaranteed that this handle will continue to point to it.
func (x *TlsDatabase) CreateCertificateHandle(CertificateVar *TlsCertificate) string {

	cret := xTlsDatabaseCreateCertificateHandle(x.GoPointer(), CertificateVar.GoPointer())
	return cret
}

var xTlsDatabaseLookupCertificateForHandle func(uintptr, string, uintptr, TlsDatabaseLookupFlags, uintptr, **glib.Error) uintptr

// Look up a certificate by its handle.
//
// The handle should have been created by calling
// g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
// the same TLS backend. The handle is designed to remain valid across
// instantiations of the database.
//
// If the handle is no longer valid, or does not point to a certificate in
// this database, then %NULL will be returned.
//
// This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
// the lookup operation asynchronously.
func (x *TlsDatabase) LookupCertificateForHandle(HandleVar string, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xTlsDatabaseLookupCertificateForHandle(x.GoPointer(), HandleVar, InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xTlsDatabaseLookupCertificateForHandleAsync func(uintptr, string, uintptr, TlsDatabaseLookupFlags, uintptr, uintptr, uintptr)

// Asynchronously look up a certificate by its handle in the database. See
// g_tls_database_lookup_certificate_for_handle() for more information.
func (x *TlsDatabase) LookupCertificateForHandleAsync(HandleVar string, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xTlsDatabaseLookupCertificateForHandleAsync(x.GoPointer(), HandleVar, InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xTlsDatabaseLookupCertificateForHandleFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finish an asynchronous lookup of a certificate by its handle. See
// g_tls_database_lookup_certificate_for_handle() for more information.
//
// If the handle is no longer valid, or does not point to a certificate in
// this database, then %NULL will be returned.
func (x *TlsDatabase) LookupCertificateForHandleFinish(ResultVar AsyncResult) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xTlsDatabaseLookupCertificateForHandleFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xTlsDatabaseLookupCertificateIssuer func(uintptr, uintptr, uintptr, TlsDatabaseLookupFlags, uintptr, **glib.Error) uintptr

// Look up the issuer of @certificate in the database. The
// #GTlsCertificate:issuer property of @certificate is not modified, and
// the two certificates are not hooked into a chain.
//
// This function can block. Use g_tls_database_lookup_certificate_issuer_async()
// to perform the lookup operation asynchronously.
//
// Beware this function cannot be used to build certification paths. The
// issuer certificate returned by this function may not be the same as
// the certificate that would actually be used to construct a valid
// certification path during certificate verification.
// [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
// why an issuer certificate cannot be naively assumed to be part of the
// the certification path (though GLib's TLS backends may not follow the
// path building strategies outlined in this RFC). Due to the complexity
// of certification path building, GLib does not provide any way to know
// which certification path will actually be used when verifying a TLS
// certificate. Accordingly, this function cannot be used to make
// security-related decisions. Only GLib itself should make security
// decisions about TLS certificates.
func (x *TlsDatabase) LookupCertificateIssuer(CertificateVar *TlsCertificate, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xTlsDatabaseLookupCertificateIssuer(x.GoPointer(), CertificateVar.GoPointer(), InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xTlsDatabaseLookupCertificateIssuerAsync func(uintptr, uintptr, uintptr, TlsDatabaseLookupFlags, uintptr, uintptr, uintptr)

// Asynchronously look up the issuer of @certificate in the database. See
// g_tls_database_lookup_certificate_issuer() for more information.
func (x *TlsDatabase) LookupCertificateIssuerAsync(CertificateVar *TlsCertificate, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xTlsDatabaseLookupCertificateIssuerAsync(x.GoPointer(), CertificateVar.GoPointer(), InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xTlsDatabaseLookupCertificateIssuerFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finish an asynchronous lookup issuer operation. See
// g_tls_database_lookup_certificate_issuer() for more information.
func (x *TlsDatabase) LookupCertificateIssuerFinish(ResultVar AsyncResult) (*TlsCertificate, error) {
	var cls *TlsCertificate
	var cerr *glib.Error

	cret := xTlsDatabaseLookupCertificateIssuerFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &TlsCertificate{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xTlsDatabaseLookupCertificatesIssuedBy func(uintptr, []byte, uintptr, TlsDatabaseLookupFlags, uintptr, **glib.Error) *glib.List

// Look up certificates issued by this issuer in the database.
//
// This function can block, use g_tls_database_lookup_certificates_issued_by_async() to perform
// the lookup operation asynchronously.
func (x *TlsDatabase) LookupCertificatesIssuedBy(IssuerRawDnVar []byte, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable) (*glib.List, error) {
	var cerr *glib.Error

	cret := xTlsDatabaseLookupCertificatesIssuedBy(x.GoPointer(), IssuerRawDnVar, InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsDatabaseLookupCertificatesIssuedByAsync func(uintptr, []byte, uintptr, TlsDatabaseLookupFlags, uintptr, uintptr, uintptr)

// Asynchronously look up certificates issued by this issuer in the database. See
// g_tls_database_lookup_certificates_issued_by() for more information.
//
// The database may choose to hold a reference to the issuer byte array for the duration
// of of this asynchronous operation. The byte array should not be modified during
// this time.
func (x *TlsDatabase) LookupCertificatesIssuedByAsync(IssuerRawDnVar []byte, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseLookupFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xTlsDatabaseLookupCertificatesIssuedByAsync(x.GoPointer(), IssuerRawDnVar, InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xTlsDatabaseLookupCertificatesIssuedByFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Finish an asynchronous lookup of certificates. See
// g_tls_database_lookup_certificates_issued_by() for more information.
func (x *TlsDatabase) LookupCertificatesIssuedByFinish(ResultVar AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xTlsDatabaseLookupCertificatesIssuedByFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsDatabaseVerifyChain func(uintptr, uintptr, string, uintptr, uintptr, TlsDatabaseVerifyFlags, uintptr, **glib.Error) TlsCertificateFlags

// Determines the validity of a certificate chain, outside the context
// of a TLS session.
//
// @chain is a chain of #GTlsCertificate objects each pointing to the next
// certificate in the chain by its #GTlsCertificate:issuer property.
//
// @purpose describes the purpose (or usage) for which the certificate
// is being used. Typically @purpose will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
// which means that the certificate is being used to authenticate a server
// (and we are acting as the client).
//
// The @identity is used to ensure the server certificate is valid for
// the expected peer identity. If the identity does not match the
// certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
// return value. If @identity is %NULL, that bit will never be set in
// the return value. The peer identity may also be used to check for
// pinned certificates (trust exceptions) in the database. These may
// override the normal verification process on a host-by-host basis.
//
// Currently there are no @flags, and %G_TLS_DATABASE_VERIFY_NONE should be
// used.
//
// If @chain is found to be valid, then the return value will be 0. If
// @chain is found to be invalid, then the return value will indicate at
// least one problem found. If the function is unable to determine
// whether @chain is valid (for example, because @cancellable is
// triggered before it completes) then the return value will be
// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set accordingly.
// @error is not set when @chain is successfully analyzed but found to
// be invalid.
//
// GLib guarantees that if certificate verification fails, at least one
// error will be set in the return value, but it does not guarantee
// that all possible errors will be set. Accordingly, you may not safely
// decide to ignore any particular type of error. For example, it would
// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
// expired certificates, because this could potentially be the only
// error flag set even if other problems exist with the certificate.
//
// Prior to GLib 2.48, GLib's default TLS backend modified @chain to
// represent the certification path built by #GTlsDatabase during
// certificate verification by adjusting the #GTlsCertificate:issuer
// property of each certificate in @chain. Since GLib 2.48, this no
// longer occurs, so you cannot rely on #GTlsCertificate:issuer to
// represent the actual certification path used during certificate
// verification.
//
// Because TLS session context is not used, #GTlsDatabase may not
// perform as many checks on the certificates as #GTlsConnection would.
// For example, certificate constraints may not be honored, and
// revocation checks may not be performed. The best way to verify TLS
// certificates used by a TLS connection is to let #GTlsConnection
// handle the verification.
//
// The TLS backend may attempt to look up and add missing certificates
// to the chain. This may involve HTTP requests to download missing
// certificates.
//
// This function can block. Use g_tls_database_verify_chain_async() to
// perform the verification operation asynchronously.
func (x *TlsDatabase) VerifyChain(ChainVar *TlsCertificate, PurposeVar string, IdentityVar SocketConnectable, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseVerifyFlags, CancellableVar *Cancellable) (TlsCertificateFlags, error) {
	var cerr *glib.Error

	cret := xTlsDatabaseVerifyChain(x.GoPointer(), ChainVar.GoPointer(), PurposeVar, IdentityVar.GoPointer(), InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsDatabaseVerifyChainAsync func(uintptr, uintptr, string, uintptr, uintptr, TlsDatabaseVerifyFlags, uintptr, uintptr, uintptr)

// Asynchronously determines the validity of a certificate chain after
// looking up and adding any missing certificates to the chain. See
// g_tls_database_verify_chain() for more information.
func (x *TlsDatabase) VerifyChainAsync(ChainVar *TlsCertificate, PurposeVar string, IdentityVar SocketConnectable, InteractionVar *TlsInteraction, FlagsVar TlsDatabaseVerifyFlags, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xTlsDatabaseVerifyChainAsync(x.GoPointer(), ChainVar.GoPointer(), PurposeVar, IdentityVar.GoPointer(), InteractionVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xTlsDatabaseVerifyChainFinish func(uintptr, uintptr, **glib.Error) TlsCertificateFlags

// Finish an asynchronous verify chain operation. See
// g_tls_database_verify_chain() for more information.
//
// If @chain is found to be valid, then the return value will be 0. If
// @chain is found to be invalid, then the return value will indicate
// the problems found. If the function is unable to determine whether
// @chain is valid or not (eg, because @cancellable is triggered
// before it completes) then the return value will be
// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set
// accordingly. @error is not set when @chain is successfully analyzed
// but found to be invalid.
func (x *TlsDatabase) VerifyChainFinish(ResultVar AsyncResult) (TlsCertificateFlags, error) {
	var cerr *glib.Error

	cret := xTlsDatabaseVerifyChainFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *TlsDatabase) GoPointer() uintptr {
	return c.Ptr
}

func (c *TlsDatabase) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xTlsDatabaseGLibType, lib, "g_tls_database_get_type")

	core.PuregoSafeRegister(&xTlsDatabaseCreateCertificateHandle, lib, "g_tls_database_create_certificate_handle")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificateForHandle, lib, "g_tls_database_lookup_certificate_for_handle")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificateForHandleAsync, lib, "g_tls_database_lookup_certificate_for_handle_async")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificateForHandleFinish, lib, "g_tls_database_lookup_certificate_for_handle_finish")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificateIssuer, lib, "g_tls_database_lookup_certificate_issuer")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificateIssuerAsync, lib, "g_tls_database_lookup_certificate_issuer_async")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificateIssuerFinish, lib, "g_tls_database_lookup_certificate_issuer_finish")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificatesIssuedBy, lib, "g_tls_database_lookup_certificates_issued_by")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificatesIssuedByAsync, lib, "g_tls_database_lookup_certificates_issued_by_async")
	core.PuregoSafeRegister(&xTlsDatabaseLookupCertificatesIssuedByFinish, lib, "g_tls_database_lookup_certificates_issued_by_finish")
	core.PuregoSafeRegister(&xTlsDatabaseVerifyChain, lib, "g_tls_database_verify_chain")
	core.PuregoSafeRegister(&xTlsDatabaseVerifyChainAsync, lib, "g_tls_database_verify_chain_async")
	core.PuregoSafeRegister(&xTlsDatabaseVerifyChainFinish, lib, "g_tls_database_verify_chain_finish")

}
