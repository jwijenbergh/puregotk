// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type FileIOStreamClass struct {
	_ structs.HostLayout

	ParentClass uintptr
}

func (x *FileIOStreamClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type FileIOStreamPrivate struct {
	_ structs.HostLayout
}

func (x *FileIOStreamPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// GFileIOStream provides io streams that both read and write to the same
// file handle.
//
// GFileIOStream implements #GSeekable, which allows the io
// stream to jump to arbitrary positions in the file and to truncate
// the file, provided the filesystem of the file supports these
// operations.
//
// To find the position of a file io stream, use
// g_seekable_tell().
//
// To find out if a file io stream supports seeking, use g_seekable_can_seek().
// To position a file io stream, use g_seekable_seek().
// To find out if a file io stream supports truncating, use
// g_seekable_can_truncate(). To truncate a file io
// stream, use g_seekable_truncate().
//
// The default implementation of all the #GFileIOStream operations
// and the implementation of #GSeekable just call into the same operations
// on the output stream.
type FileIOStream struct {
	IOStream
}

var xFileIOStreamGLibType func() types.GType

func FileIOStreamGLibType() types.GType {
	return xFileIOStreamGLibType()
}

func FileIOStreamNewFromInternalPtr(ptr uintptr) *FileIOStream {
	cls := &FileIOStream{}
	cls.Ptr = ptr
	return cls
}

var xFileIOStreamGetEtag func(uintptr) string

// Gets the entity tag for the file when it has been written.
// This must be called after the stream has been written
// and closed, as the etag can change while writing.
func (x *FileIOStream) GetEtag() string {

	cret := xFileIOStreamGetEtag(x.GoPointer())
	return cret
}

var xFileIOStreamQueryInfo func(uintptr, string, uintptr, **glib.Error) uintptr

// Queries a file io stream for the given @attributes.
// This function blocks while querying the stream. For the asynchronous
// version of this function, see g_file_io_stream_query_info_async().
// While the stream is blocked, the stream will set the pending flag
// internally, and any other operations on the stream will fail with
// %G_IO_ERROR_PENDING.
//
// Can fail if the stream was already closed (with @error being set to
// %G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
// set to %G_IO_ERROR_PENDING), or if querying info is not supported for
// the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). I
// all cases of failure, %NULL will be returned.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
// be returned.
func (x *FileIOStream) QueryInfo(AttributesVar string, CancellableVar *Cancellable) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := xFileIOStreamQueryInfo(x.GoPointer(), AttributesVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileIOStreamQueryInfoAsync func(uintptr, string, int, uintptr, uintptr, uintptr)

// Asynchronously queries the @stream for a #GFileInfo. When completed,
// @callback will be called with a #GAsyncResult which can be used to
// finish the operation with g_file_io_stream_query_info_finish().
//
// For the synchronous version of this function, see
// g_file_io_stream_query_info().
func (x *FileIOStream) QueryInfoAsync(AttributesVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xFileIOStreamQueryInfoAsync(x.GoPointer(), AttributesVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xFileIOStreamQueryInfoFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finalizes the asynchronous query started
// by g_file_io_stream_query_info_async().
func (x *FileIOStream) QueryInfoFinish(ResultVar AsyncResult) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := xFileIOStreamQueryInfoFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

func (c *FileIOStream) GoPointer() uintptr {
	return c.Ptr
}

func (c *FileIOStream) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Tests if the stream supports the #GSeekableIface.
func (x *FileIOStream) CanSeek() bool {

	cret := XGSeekableCanSeek(x.GoPointer())
	return cret
}

// Tests if the length of the stream can be adjusted with
// g_seekable_truncate().
func (x *FileIOStream) CanTruncate() bool {

	cret := XGSeekableCanTruncate(x.GoPointer())
	return cret
}

// Seeks in the stream by the given @offset, modified by @type.
//
// Attempting to seek past the end of the stream will have different
// results depending on if the stream is fixed-sized or resizable.  If
// the stream is resizable then seeking past the end and then writing
// will result in zeros filling the empty space.  Seeking past the end
// of a resizable stream and reading will result in EOF.  Seeking past
// the end of a fixed-sized stream will fail.
//
// Any operation that would result in a negative offset will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileIOStream) Seek(OffsetVar int64, TypeVar glib.SeekType, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGSeekableSeek(x.GoPointer(), OffsetVar, TypeVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Tells the current position within the stream.
func (x *FileIOStream) Tell() int64 {

	cret := XGSeekableTell(x.GoPointer())
	return cret
}

// Sets the length of the stream to @offset. If the stream was previously
// larger than @offset, the extra data is discarded. If the stream was
// previously shorter than @offset, it is extended with NUL ('\0') bytes.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
func (x *FileIOStream) Truncate(OffsetVar int64, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGSeekableTruncate(x.GoPointer(), OffsetVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xFileIOStreamGLibType, lib, "g_file_io_stream_get_type")

	core.PuregoSafeRegister(&xFileIOStreamGetEtag, lib, "g_file_io_stream_get_etag")
	core.PuregoSafeRegister(&xFileIOStreamQueryInfo, lib, "g_file_io_stream_query_info")
	core.PuregoSafeRegister(&xFileIOStreamQueryInfoAsync, lib, "g_file_io_stream_query_info_async")
	core.PuregoSafeRegister(&xFileIOStreamQueryInfoFinish, lib, "g_file_io_stream_query_info_finish")

}
