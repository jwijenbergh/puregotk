// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// The class structure for the #GTlsConnection type.
type TlsConnectionClass struct {
	ParentClass uintptr

	Padding [6]uintptr
}

func (x *TlsConnectionClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type TlsConnectionPrivate struct {
}

func (x *TlsConnectionPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GTlsConnection is the base TLS connection class type, which wraps
// a #GIOStream and provides TLS encryption on top of it. Its
// subclasses, #GTlsClientConnection and #GTlsServerConnection,
// implement client-side and server-side TLS, respectively.
//
// For DTLS (Datagram TLS) support, see #GDtlsConnection.
type TlsConnection struct {
	IOStream
}

func TlsConnectionNewFromInternalPtr(ptr uintptr) *TlsConnection {
	cls := &TlsConnection{}
	cls.Ptr = ptr
	return cls
}

var xTlsConnectionEmitAcceptCertificate func(uintptr, uintptr, TlsCertificateFlags) bool

// Used by #GTlsConnection implementations to emit the
// #GTlsConnection::accept-certificate signal.
func (x *TlsConnection) EmitAcceptCertificate(PeerCertVar *TlsCertificate, ErrorsVar TlsCertificateFlags) bool {

	cret := xTlsConnectionEmitAcceptCertificate(x.GoPointer(), PeerCertVar.GoPointer(), ErrorsVar)
	return cret
}

var xTlsConnectionGetCertificate func(uintptr) uintptr

// Gets @conn's certificate, as set by
// g_tls_connection_set_certificate().
func (x *TlsConnection) GetCertificate() *TlsCertificate {
	var cls *TlsCertificate

	cret := xTlsConnectionGetCertificate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TlsCertificate{}
	cls.Ptr = cret
	return cls
}

var xTlsConnectionGetChannelBindingData func(uintptr, TlsChannelBindingType, []byte, **glib.Error) bool

// Query the TLS backend for TLS channel binding data of @type for @conn.
//
// This call retrieves TLS channel binding data as specified in RFC
// [5056](https://tools.ietf.org/html/rfc5056), RFC
// [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
// binding data is returned in @data.  The @data is resized by the callee
// using #GByteArray buffer management and will be freed when the @data
// is destroyed by g_byte_array_unref(). If @data is %NULL, it will only
// check whether TLS backend is able to fetch the data (e.g. whether @type
// is supported by the TLS backend). It does not guarantee that the data
// will be available though.  That could happen if TLS connection does not
// support @type or the binding data is not available yet due to additional
// negotiation or input required.
func (x *TlsConnection) GetChannelBindingData(TypeVar TlsChannelBindingType, DataVar []byte) (bool, error) {
	var cerr *glib.Error

	cret := xTlsConnectionGetChannelBindingData(x.GoPointer(), TypeVar, DataVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsConnectionGetCiphersuiteName func(uintptr) string

// Returns the name of the current TLS ciphersuite, or %NULL if the
// connection has not handshaked or has been closed. Beware that the TLS
// backend may use any of multiple different naming conventions, because
// OpenSSL and GnuTLS have their own ciphersuite naming conventions that
// are different from each other and different from the standard, IANA-
// registered ciphersuite names. The ciphersuite name is intended to be
// displayed to the user for informative purposes only, and parsing it
// is not recommended.
func (x *TlsConnection) GetCiphersuiteName() string {

	cret := xTlsConnectionGetCiphersuiteName(x.GoPointer())
	return cret
}

var xTlsConnectionGetDatabase func(uintptr) uintptr

// Gets the certificate database that @conn uses to verify
// peer certificates. See g_tls_connection_set_database().
func (x *TlsConnection) GetDatabase() *TlsDatabase {
	var cls *TlsDatabase

	cret := xTlsConnectionGetDatabase(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TlsDatabase{}
	cls.Ptr = cret
	return cls
}

var xTlsConnectionGetInteraction func(uintptr) uintptr

// Get the object that will be used to interact with the user. It will be used
// for things like prompting the user for passwords. If %NULL is returned, then
// no user interaction will occur for this connection.
func (x *TlsConnection) GetInteraction() *TlsInteraction {
	var cls *TlsInteraction

	cret := xTlsConnectionGetInteraction(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TlsInteraction{}
	cls.Ptr = cret
	return cls
}

var xTlsConnectionGetNegotiatedProtocol func(uintptr) string

// Gets the name of the application-layer protocol negotiated during
// the handshake.
//
// If the peer did not use the ALPN extension, or did not advertise a
// protocol that matched one of @conn's protocols, or the TLS backend
// does not support ALPN, then this will be %NULL. See
// g_tls_connection_set_advertised_protocols().
func (x *TlsConnection) GetNegotiatedProtocol() string {

	cret := xTlsConnectionGetNegotiatedProtocol(x.GoPointer())
	return cret
}

var xTlsConnectionGetPeerCertificate func(uintptr) uintptr

// Gets @conn's peer's certificate after the handshake has completed
// or failed. (It is not set during the emission of
// #GTlsConnection::accept-certificate.)
func (x *TlsConnection) GetPeerCertificate() *TlsCertificate {
	var cls *TlsCertificate

	cret := xTlsConnectionGetPeerCertificate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TlsCertificate{}
	cls.Ptr = cret
	return cls
}

var xTlsConnectionGetPeerCertificateErrors func(uintptr) TlsCertificateFlags

// Gets the errors associated with validating @conn's peer's
// certificate, after the handshake has completed or failed. (It is
// not set during the emission of #GTlsConnection::accept-certificate.)
//
// See #GTlsConnection:peer-certificate-errors for more information.
func (x *TlsConnection) GetPeerCertificateErrors() TlsCertificateFlags {

	cret := xTlsConnectionGetPeerCertificateErrors(x.GoPointer())
	return cret
}

var xTlsConnectionGetProtocolVersion func(uintptr) TlsProtocolVersion

// Returns the current TLS protocol version, which may be
// %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
// has been closed, or if the TLS backend has implemented a protocol version
// that is not a recognized #GTlsProtocolVersion.
func (x *TlsConnection) GetProtocolVersion() TlsProtocolVersion {

	cret := xTlsConnectionGetProtocolVersion(x.GoPointer())
	return cret
}

var xTlsConnectionGetRehandshakeMode func(uintptr) TlsRehandshakeMode

// Gets @conn rehandshaking mode. See
// g_tls_connection_set_rehandshake_mode() for details.
func (x *TlsConnection) GetRehandshakeMode() TlsRehandshakeMode {

	cret := xTlsConnectionGetRehandshakeMode(x.GoPointer())
	return cret
}

var xTlsConnectionGetRequireCloseNotify func(uintptr) bool

// Tests whether or not @conn expects a proper TLS close notification
// when the connection is closed. See
// g_tls_connection_set_require_close_notify() for details.
func (x *TlsConnection) GetRequireCloseNotify() bool {

	cret := xTlsConnectionGetRequireCloseNotify(x.GoPointer())
	return cret
}

var xTlsConnectionGetUseSystemCertdb func(uintptr) bool

// Gets whether @conn uses the system certificate database to verify
// peer certificates. See g_tls_connection_set_use_system_certdb().
func (x *TlsConnection) GetUseSystemCertdb() bool {

	cret := xTlsConnectionGetUseSystemCertdb(x.GoPointer())
	return cret
}

var xTlsConnectionHandshake func(uintptr, uintptr, **glib.Error) bool

// Attempts a TLS handshake on @conn.
//
// On the client side, it is never necessary to call this method;
// although the connection needs to perform a handshake after
// connecting (or after sending a "STARTTLS"-type command),
// #GTlsConnection will handle this for you automatically when you try
// to send or receive data on the connection. You can call
// g_tls_connection_handshake() manually if you want to know whether
// the initial handshake succeeded or failed (as opposed to just
// immediately trying to use @conn to read or write, in which case,
// if it fails, it may not be possible to tell if it failed before or
// after completing the handshake), but beware that servers may reject
// client authentication after the handshake has completed, so a
// successful handshake does not indicate the connection will be usable.
//
// Likewise, on the server side, although a handshake is necessary at
// the beginning of the communication, you do not need to call this
// function explicitly unless you want clearer error reporting.
//
// Previously, calling g_tls_connection_handshake() after the initial
// handshake would trigger a rehandshake; however, this usage was
// deprecated in GLib 2.60 because rehandshaking was removed from the
// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
// the initial handshake will no longer do anything.
//
// When using a #GTlsConnection created by #GSocketClient, the
// #GSocketClient performs the initial handshake, so calling this
// function manually is not recommended.
//
// #GTlsConnection::accept_certificate may be emitted during the
// handshake.
func (x *TlsConnection) Handshake(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xTlsConnectionHandshake(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsConnectionHandshakeAsync func(uintptr, int, uintptr, uintptr, uintptr)

// Asynchronously performs a TLS handshake on @conn. See
// g_tls_connection_handshake() for more information.
func (x *TlsConnection) HandshakeAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xTlsConnectionHandshakeAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xTlsConnectionHandshakeFinish func(uintptr, uintptr, **glib.Error) bool

// Finish an asynchronous TLS handshake operation. See
// g_tls_connection_handshake() for more information.
func (x *TlsConnection) HandshakeFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xTlsConnectionHandshakeFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xTlsConnectionSetAdvertisedProtocols func(uintptr, []string)

// Sets the list of application-layer protocols to advertise that the
// caller is willing to speak on this connection. The
// Application-Layer Protocol Negotiation (ALPN) extension will be
// used to negotiate a compatible protocol with the peer; use
// g_tls_connection_get_negotiated_protocol() to find the negotiated
// protocol after the handshake.  Specifying %NULL for the the value
// of @protocols will disable ALPN negotiation.
//
// See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
// for a list of registered protocol IDs.
func (x *TlsConnection) SetAdvertisedProtocols(ProtocolsVar []string) {

	xTlsConnectionSetAdvertisedProtocols(x.GoPointer(), ProtocolsVar)

}

var xTlsConnectionSetCertificate func(uintptr, uintptr)

// This sets the certificate that @conn will present to its peer
// during the TLS handshake. For a #GTlsServerConnection, it is
// mandatory to set this, and that will normally be done at construct
// time.
//
// For a #GTlsClientConnection, this is optional. If a handshake fails
// with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
// requires a certificate, and if you try connecting again, you should
// call this method first. You can call
// g_tls_client_connection_get_accepted_cas() on the failed connection
// to get a list of Certificate Authorities that the server will
// accept certificates from.
//
// (It is also possible that a server will allow the connection with
// or without a certificate; in that case, if you don't provide a
// certificate, you can tell that the server requested one by the fact
// that g_tls_client_connection_get_accepted_cas() will return
// non-%NULL.)
func (x *TlsConnection) SetCertificate(CertificateVar *TlsCertificate) {

	xTlsConnectionSetCertificate(x.GoPointer(), CertificateVar.GoPointer())

}

var xTlsConnectionSetDatabase func(uintptr, uintptr)

// Sets the certificate database that is used to verify peer certificates.
// This is set to the default database by default. See
// g_tls_backend_get_default_database(). If set to %NULL, then
// peer certificate validation will always set the
// %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
// #GTlsConnection::accept-certificate will always be emitted on
// client-side connections, unless that bit is not set in
// #GTlsClientConnection:validation-flags).
//
// There are nonintuitive security implications when using a non-default
// database. See #GDtlsConnection:database for details.
func (x *TlsConnection) SetDatabase(DatabaseVar *TlsDatabase) {

	xTlsConnectionSetDatabase(x.GoPointer(), DatabaseVar.GoPointer())

}

var xTlsConnectionSetInteraction func(uintptr, uintptr)

// Set the object that will be used to interact with the user. It will be used
// for things like prompting the user for passwords.
//
// The @interaction argument will normally be a derived subclass of
// #GTlsInteraction. %NULL can also be provided if no user interaction
// should occur for this connection.
func (x *TlsConnection) SetInteraction(InteractionVar *TlsInteraction) {

	xTlsConnectionSetInteraction(x.GoPointer(), InteractionVar.GoPointer())

}

var xTlsConnectionSetRehandshakeMode func(uintptr, TlsRehandshakeMode)

// Since GLib 2.64, changing the rehandshake mode is no longer supported
// and will have no effect. With TLS 1.3, rehandshaking has been removed from
// the TLS protocol, replaced by separate post-handshake authentication and
// rekey operations.
func (x *TlsConnection) SetRehandshakeMode(ModeVar TlsRehandshakeMode) {

	xTlsConnectionSetRehandshakeMode(x.GoPointer(), ModeVar)

}

var xTlsConnectionSetRequireCloseNotify func(uintptr, bool)

// Sets whether or not @conn expects a proper TLS close notification
// before the connection is closed. If this is %TRUE (the default),
// then @conn will expect to receive a TLS close notification from its
// peer before the connection is closed, and will return a
// %G_TLS_ERROR_EOF error if the connection is closed without proper
// notification (since this may indicate a network error, or
// man-in-the-middle attack).
//
// In some protocols, the application will know whether or not the
// connection was closed cleanly based on application-level data
// (because the application-level data includes a length field, or is
// somehow self-delimiting); in this case, the close notify is
// redundant and sometimes omitted. (TLS 1.1 explicitly allows this;
// in TLS 1.0 it is technically an error, but often done anyway.) You
// can use g_tls_connection_set_require_close_notify() to tell @conn
// to allow an "unannounced" connection close, in which case the close
// will show up as a 0-length read, as in a non-TLS
// #GSocketConnection, and it is up to the application to check that
// the data has been fully received.
//
// Note that this only affects the behavior when the peer closes the
// connection; when the application calls g_io_stream_close() itself
// on @conn, this will send a close notification regardless of the
// setting of this property. If you explicitly want to do an unclean
// close, you can close @conn's #GTlsConnection:base-io-stream rather
// than closing @conn itself, but note that this may only be done when no other
// operations are pending on @conn or the base I/O stream.
func (x *TlsConnection) SetRequireCloseNotify(RequireCloseNotifyVar bool) {

	xTlsConnectionSetRequireCloseNotify(x.GoPointer(), RequireCloseNotifyVar)

}

var xTlsConnectionSetUseSystemCertdb func(uintptr, bool)

// Sets whether @conn uses the system certificate database to verify
// peer certificates. This is %TRUE by default. If set to %FALSE, then
// peer certificate validation will always set the
// %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
// #GTlsConnection::accept-certificate will always be emitted on
// client-side connections, unless that bit is not set in
// #GTlsClientConnection:validation-flags).
func (x *TlsConnection) SetUseSystemCertdb(UseSystemCertdbVar bool) {

	xTlsConnectionSetUseSystemCertdb(x.GoPointer(), UseSystemCertdbVar)

}

func (c *TlsConnection) GoPointer() uintptr {
	return c.Ptr
}

func (c *TlsConnection) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted during the TLS handshake after the peer certificate has
// been received. You can examine @peer_cert's certification path by
// calling g_tls_certificate_get_issuer() on it.
//
// For a client-side connection, @peer_cert is the server's
// certificate, and the signal will only be emitted if the
// certificate was not acceptable according to @conn's
// #GTlsClientConnection:validation_flags. If you would like the
// certificate to be accepted despite @errors, return %TRUE from the
// signal handler. Otherwise, if no handler accepts the certificate,
// the handshake will fail with %G_TLS_ERROR_BAD_CERTIFICATE.
//
// GLib guarantees that if certificate verification fails, this signal
// will be emitted with at least one error will be set in @errors, but
// it does not guarantee that all possible errors will be set.
// Accordingly, you may not safely decide to ignore any particular
// type of error. For example, it would be incorrect to ignore
// %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired
// certificates, because this could potentially be the only error flag
// set even if other problems exist with the certificate.
//
// For a server-side connection, @peer_cert is the certificate
// presented by the client, if this was requested via the server's
// #GTlsServerConnection:authentication_mode. On the server side,
// the signal is always emitted when the client presents a
// certificate, and the certificate will only be accepted if a
// handler returns %TRUE.
//
// Note that if this signal is emitted as part of asynchronous I/O
// in the main thread, then you should not attempt to interact with
// the user before returning from the signal handler. If you want to
// let the user decide whether or not to accept the certificate, you
// would have to return %FALSE from the signal handler on the first
// attempt, and then after the connection attempt returns a
// %G_TLS_ERROR_BAD_CERTIFICATE, you can interact with the user, and
// if the user decides to accept the certificate, remember that fact,
// create a new connection, and return %TRUE from the signal handler
// the next time.
//
// If you are doing I/O in another thread, you do not
// need to worry about this, and can simply block in the signal
// handler until the UI thread returns an answer.
func (x *TlsConnection) ConnectAcceptCertificate(cb *func(TlsConnection, uintptr, TlsCertificateFlags) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "accept-certificate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PeerCertVarp uintptr, ErrorsVarp TlsCertificateFlags) bool {
		fa := TlsConnection{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, PeerCertVarp, ErrorsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "accept-certificate", cbRefPtr)
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xTlsConnectionEmitAcceptCertificate, lib, "g_tls_connection_emit_accept_certificate")
	core.PuregoSafeRegister(&xTlsConnectionGetCertificate, lib, "g_tls_connection_get_certificate")
	core.PuregoSafeRegister(&xTlsConnectionGetChannelBindingData, lib, "g_tls_connection_get_channel_binding_data")
	core.PuregoSafeRegister(&xTlsConnectionGetCiphersuiteName, lib, "g_tls_connection_get_ciphersuite_name")
	core.PuregoSafeRegister(&xTlsConnectionGetDatabase, lib, "g_tls_connection_get_database")
	core.PuregoSafeRegister(&xTlsConnectionGetInteraction, lib, "g_tls_connection_get_interaction")
	core.PuregoSafeRegister(&xTlsConnectionGetNegotiatedProtocol, lib, "g_tls_connection_get_negotiated_protocol")
	core.PuregoSafeRegister(&xTlsConnectionGetPeerCertificate, lib, "g_tls_connection_get_peer_certificate")
	core.PuregoSafeRegister(&xTlsConnectionGetPeerCertificateErrors, lib, "g_tls_connection_get_peer_certificate_errors")
	core.PuregoSafeRegister(&xTlsConnectionGetProtocolVersion, lib, "g_tls_connection_get_protocol_version")
	core.PuregoSafeRegister(&xTlsConnectionGetRehandshakeMode, lib, "g_tls_connection_get_rehandshake_mode")
	core.PuregoSafeRegister(&xTlsConnectionGetRequireCloseNotify, lib, "g_tls_connection_get_require_close_notify")
	core.PuregoSafeRegister(&xTlsConnectionGetUseSystemCertdb, lib, "g_tls_connection_get_use_system_certdb")
	core.PuregoSafeRegister(&xTlsConnectionHandshake, lib, "g_tls_connection_handshake")
	core.PuregoSafeRegister(&xTlsConnectionHandshakeAsync, lib, "g_tls_connection_handshake_async")
	core.PuregoSafeRegister(&xTlsConnectionHandshakeFinish, lib, "g_tls_connection_handshake_finish")
	core.PuregoSafeRegister(&xTlsConnectionSetAdvertisedProtocols, lib, "g_tls_connection_set_advertised_protocols")
	core.PuregoSafeRegister(&xTlsConnectionSetCertificate, lib, "g_tls_connection_set_certificate")
	core.PuregoSafeRegister(&xTlsConnectionSetDatabase, lib, "g_tls_connection_set_database")
	core.PuregoSafeRegister(&xTlsConnectionSetInteraction, lib, "g_tls_connection_set_interaction")
	core.PuregoSafeRegister(&xTlsConnectionSetRehandshakeMode, lib, "g_tls_connection_set_rehandshake_mode")
	core.PuregoSafeRegister(&xTlsConnectionSetRequireCloseNotify, lib, "g_tls_connection_set_require_close_notify")
	core.PuregoSafeRegister(&xTlsConnectionSetUseSystemCertdb, lib, "g_tls_connection_set_use_system_certdb")

}
