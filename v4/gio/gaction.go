// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The virtual function table for #GAction.
type ActionInterface struct {
	GIface uintptr
}

func (x *ActionInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GAction represents a single named action.
//
// The main interface to an action is that it can be activated with
// g_action_activate().  This results in the 'activate' signal being
// emitted.  An activation has a #GVariant parameter (which may be
// %NULL).  The correct type for the parameter is determined by a static
// parameter type (which is given at construction time).
//
// An action may optionally have a state, in which case the state may be
// set with g_action_change_state().  This call takes a #GVariant.  The
// correct type for the state is determined by a static state type
// (which is given at construction time).
//
// The state may have a hint associated with it, specifying its valid
// range.
//
// #GAction is merely the interface to the concept of an action, as
// described above.  Various implementations of actions exist, including
// #GSimpleAction.
//
// In all cases, the implementing class is responsible for storing the
// name of the action, the parameter type, the enabled state, the
// optional state type and the state and emitting the appropriate
// signals when these change.  The implementor is responsible for filtering
// calls to g_action_activate() and g_action_change_state() for type
// safety and for the state being enabled.
//
// Probably the only useful thing to do with a #GAction is to put it
// inside of a #GSimpleActionGroup.
type Action interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	Activate(ParameterVar *glib.Variant)
	ChangeState(ValueVar *glib.Variant)
	GetEnabled() bool
	GetName() string
	GetParameterType() *glib.VariantType
	GetState() *glib.Variant
	GetStateHint() *glib.Variant
	GetStateType() *glib.VariantType
}

var xActionGLibType func() types.GType

func ActionGLibType() types.GType {
	return xActionGLibType()
}

type ActionBase struct {
	Ptr uintptr
}

func (x *ActionBase) GoPointer() uintptr {
	return x.Ptr
}

func (x *ActionBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Activates the action.
//
// @parameter must be the correct type of parameter for the action (ie:
// the parameter type given at construction time).  If the parameter
// type was %NULL then @parameter must also be %NULL.
//
// If the @parameter GVariant is floating, it is consumed.
func (x *ActionBase) Activate(ParameterVar *glib.Variant) {

	XGActionActivate(x.GoPointer(), ParameterVar)

}

// Request for the state of @action to be changed to @value.
//
// The action must be stateful and @value must be of the correct type.
// See g_action_get_state_type().
//
// This call merely requests a change.  The action may refuse to change
// its state or may change its state to something other than @value.
// See g_action_get_state_hint().
//
// If the @value GVariant is floating, it is consumed.
func (x *ActionBase) ChangeState(ValueVar *glib.Variant) {

	XGActionChangeState(x.GoPointer(), ValueVar)

}

// Checks if @action is currently enabled.
//
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
func (x *ActionBase) GetEnabled() bool {

	cret := XGActionGetEnabled(x.GoPointer())
	return cret
}

// Queries the name of @action.
func (x *ActionBase) GetName() string {

	cret := XGActionGetName(x.GoPointer())
	return cret
}

// Queries the type of the parameter that must be given when activating
// @action.
//
// When activating the action using g_action_activate(), the #GVariant
// given to that function must be of the type returned by this function.
//
// In the case that this function returns %NULL, you must not give any
// #GVariant, but %NULL instead.
func (x *ActionBase) GetParameterType() *glib.VariantType {

	cret := XGActionGetParameterType(x.GoPointer())
	return cret
}

// Queries the current state of @action.
//
// If the action is not stateful then %NULL will be returned.  If the
// action is stateful then the type of the return value is the type
// given by g_action_get_state_type().
//
// The return value (if non-%NULL) should be freed with
// g_variant_unref() when it is no longer required.
func (x *ActionBase) GetState() *glib.Variant {

	cret := XGActionGetState(x.GoPointer())
	return cret
}

// Requests a hint about the valid range of values for the state of
// @action.
//
// If %NULL is returned it either means that the action is not stateful
// or that there is no hint about the valid range of values for the
// state of the action.
//
// If a #GVariant array is returned then each item in the array is a
// possible value for the state.  If a #GVariant pair (ie: two-tuple) is
// returned then the tuple specifies the inclusive lower and upper bound
// of valid values for the state.
//
// In any case, the information is merely a hint.  It may be possible to
// have a state value outside of the hinted range and setting a value
// within the range may fail.
//
// The return value (if non-%NULL) should be freed with
// g_variant_unref() when it is no longer required.
func (x *ActionBase) GetStateHint() *glib.Variant {

	cret := XGActionGetStateHint(x.GoPointer())
	return cret
}

// Queries the type of the state of @action.
//
// If the action is stateful (e.g. created with
// g_simple_action_new_stateful()) then this function returns the
// #GVariantType of the state.  This is the type of the initial value
// given as the state. All calls to g_action_change_state() must give a
// #GVariant of this type and g_action_get_state() will return a
// #GVariant of the same type.
//
// If the action is not stateful (e.g. created with g_simple_action_new())
// then this function will return %NULL. In that case, g_action_get_state()
// will return %NULL and you must not call g_action_change_state().
func (x *ActionBase) GetStateType() *glib.VariantType {

	cret := XGActionGetStateType(x.GoPointer())
	return cret
}

var XGActionActivate func(uintptr, *glib.Variant)
var XGActionChangeState func(uintptr, *glib.Variant)
var XGActionGetEnabled func(uintptr) bool
var XGActionGetName func(uintptr) string
var XGActionGetParameterType func(uintptr) *glib.VariantType
var XGActionGetState func(uintptr) *glib.Variant
var XGActionGetStateHint func(uintptr) *glib.Variant
var XGActionGetStateType func(uintptr) *glib.VariantType

var xActionNameIsValid func(string) bool

// Checks if @action_name is valid.
//
// @action_name is valid if it consists only of alphanumeric characters,
// plus '-' and '.'.  The empty string is not a valid action name.
//
// It is an error to call this function with a non-utf8 @action_name.
// @action_name must not be %NULL.
func ActionNameIsValid(ActionNameVar string) bool {

	cret := xActionNameIsValid(ActionNameVar)
	return cret
}

var xActionParseDetailedName func(string, string, **glib.Variant, **glib.Error) bool

// Parses a detailed action name into its separate name and target
// components.
//
// Detailed action names can have three formats.
//
// The first format is used to represent an action name with no target
// value and consists of just an action name containing no whitespace
// nor the characters ':', '(' or ')'.  For example: "app.action".
//
// The second format is used to represent an action with a target value
// that is a non-empty string consisting only of alphanumerics, plus '-'
// and '.'.  In that case, the action name and target value are
// separated by a double colon ("::").  For example:
// "app.action::target".
//
// The third format is used to represent an action with any type of
// target value, including strings.  The target value follows the action
// name, surrounded in parens.  For example: "app.action(42)".  The
// target value is parsed using g_variant_parse().  If a tuple-typed
// value is desired, it must be specified in the same way, resulting in
// two sets of parens, for example: "app.action((1,2,3))".  A string
// target can be specified this way as well: "app.action('target')".
// For strings, this third format must be used if * target value is
// empty or contains characters other than alphanumerics, '-' and '.'.
func ActionParseDetailedName(DetailedNameVar string, ActionNameVar string, TargetValueVar **glib.Variant) (bool, error) {
	var cerr *glib.Error

	cret := xActionParseDetailedName(DetailedNameVar, ActionNameVar, TargetValueVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xActionPrintDetailedName func(string, *glib.Variant) string

// Formats a detailed action name from @action_name and @target_value.
//
// It is an error to call this function with an invalid action name.
//
// This function is the opposite of g_action_parse_detailed_name().
// It will produce a string that can be parsed back to the @action_name
// and @target_value by that function.
//
// See that function for the types of strings that will be printed by
// this function.
func ActionPrintDetailedName(ActionNameVar string, TargetValueVar *glib.Variant) string {

	cret := xActionPrintDetailedName(ActionNameVar, TargetValueVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xActionNameIsValid, lib, "g_action_name_is_valid")
	core.PuregoSafeRegister(&xActionParseDetailedName, lib, "g_action_parse_detailed_name")
	core.PuregoSafeRegister(&xActionPrintDetailedName, lib, "g_action_print_detailed_name")

	core.PuregoSafeRegister(&xActionGLibType, lib, "g_action_get_type")

	core.PuregoSafeRegister(&XGActionActivate, lib, "g_action_activate")
	core.PuregoSafeRegister(&XGActionChangeState, lib, "g_action_change_state")
	core.PuregoSafeRegister(&XGActionGetEnabled, lib, "g_action_get_enabled")
	core.PuregoSafeRegister(&XGActionGetName, lib, "g_action_get_name")
	core.PuregoSafeRegister(&XGActionGetParameterType, lib, "g_action_get_parameter_type")
	core.PuregoSafeRegister(&XGActionGetState, lib, "g_action_get_state")
	core.PuregoSafeRegister(&XGActionGetStateHint, lib, "g_action_get_state_hint")
	core.PuregoSafeRegister(&XGActionGetStateType, lib, "g_action_get_state_type")

}
