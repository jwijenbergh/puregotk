// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type InputStreamClass struct {
	ParentClass uintptr
}

func (x *InputStreamClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type InputStreamPrivate struct {
}

func (x *InputStreamPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GInputStream has functions to read from a stream (g_input_stream_read()),
// to close a stream (g_input_stream_close()) and to skip some content
// (g_input_stream_skip()).
//
// To copy the content of an input stream to an output stream without
// manually handling the reads and writes, use g_output_stream_splice().
//
// See the documentation for #GIOStream for details of thread safety of
// streaming APIs.
//
// All of these functions have async variants too.
type InputStream struct {
	gobject.Object
}

var xInputStreamGLibType func() types.GType

func InputStreamGLibType() types.GType {
	return xInputStreamGLibType()
}

func InputStreamNewFromInternalPtr(ptr uintptr) *InputStream {
	cls := &InputStream{}
	cls.Ptr = ptr
	return cls
}

var xInputStreamClearPending func(uintptr)

// Clears the pending flag on @stream.
func (x *InputStream) ClearPending() {

	xInputStreamClearPending(x.GoPointer())

}

var xInputStreamClose func(uintptr, uintptr, **glib.Error) bool

// Closes the stream, releasing resources related to it.
//
// Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
// Closing a stream multiple times will not return an error.
//
// Streams will be automatically closed when the last reference
// is dropped, but you might want to call this function to make sure
// resources are released as early as possible.
//
// Some streams might keep the backing store of the stream (e.g. a file descriptor)
// open after the stream is closed. See the documentation for the individual
// stream for details.
//
// On failure the first error that happened will be reported, but the close
// operation will finish as much as possible. A stream that failed to
// close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
// is important to check and report the error to the user.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// Cancelling a close will still leave the stream closed, but some streams
// can use a faster close that doesn't block to e.g. check errors.
func (x *InputStream) Close(CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xInputStreamClose(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xInputStreamCloseAsync func(uintptr, int, uintptr, uintptr, uintptr)

// Requests an asynchronous closes of the stream, releasing resources related to it.
// When the operation is finished @callback will be called.
// You can then call g_input_stream_close_finish() to get the result of the
// operation.
//
// For behaviour details see g_input_stream_close().
//
// The asynchronous methods have a default fallback that uses threads to implement
// asynchronicity, so they are optional for inheriting classes. However, if you
// override one you must override all.
func (x *InputStream) CloseAsync(IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xInputStreamCloseAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xInputStreamCloseFinish func(uintptr, uintptr, **glib.Error) bool

// Finishes closing a stream asynchronously, started from g_input_stream_close_async().
func (x *InputStream) CloseFinish(ResultVar AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xInputStreamCloseFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xInputStreamHasPending func(uintptr) bool

// Checks if an input stream has pending actions.
func (x *InputStream) HasPending() bool {

	cret := xInputStreamHasPending(x.GoPointer())
	return cret
}

var xInputStreamIsClosed func(uintptr) bool

// Checks if an input stream is closed.
func (x *InputStream) IsClosed() bool {

	cret := xInputStreamIsClosed(x.GoPointer())
	return cret
}

var xInputStreamRead func(uintptr, []byte, uint, uintptr, **glib.Error) int

// Tries to read @count bytes from the stream into the buffer starting at
// @buffer. Will block during this read.
//
// If count is zero returns zero and does nothing. A value of @count
// larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes read into the buffer is returned.
// It is not an error if this is not the same as the requested size, as it
// can happen e.g. near the end of a file. Zero is returned on end of file
// (or if @count is zero),  but never otherwise.
//
// The returned @buffer is not a nul-terminated string, it can contain nul bytes
// at any position, and this function doesn't nul-terminate the @buffer.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
//
// On error -1 is returned and @error is set accordingly.
func (x *InputStream) Read(BufferVar []byte, CountVar uint, CancellableVar *Cancellable) (int, error) {
	var cerr *glib.Error

	cret := xInputStreamRead(x.GoPointer(), BufferVar, CountVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xInputStreamReadAll func(uintptr, []byte, uint, uint, uintptr, **glib.Error) bool

// Tries to read @count bytes from the stream into the buffer starting at
// @buffer. Will block during this read.
//
// This function is similar to g_input_stream_read(), except it tries to
// read as many bytes as requested, only stopping on an error or end of stream.
//
// On a successful read of @count bytes, or if we reached the end of the
// stream,  %TRUE is returned, and @bytes_read is set to the number of bytes
// read into @buffer.
//
// If there is an error during the operation %FALSE is returned and @error
// is set to indicate the error status.
//
// As a special exception to the normal conventions for functions that
// use #GError, if this function returns %FALSE (and sets @error) then
// @bytes_read will be set to the number of bytes that were successfully
// read before the error was encountered.  This functionality is only
// available from C.  If you need it from another language then you must
// write your own loop around g_input_stream_read().
func (x *InputStream) ReadAll(BufferVar []byte, CountVar uint, BytesReadVar uint, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xInputStreamReadAll(x.GoPointer(), BufferVar, CountVar, BytesReadVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xInputStreamReadAllAsync func(uintptr, []byte, uint, int, uintptr, uintptr, uintptr)

// Request an asynchronous read of @count bytes from the stream into the
// buffer starting at @buffer.
//
// This is the asynchronous equivalent of g_input_stream_read_all().
//
// Call g_input_stream_read_all_finish() to collect the result.
//
// Any outstanding I/O request with higher priority (lower numerical
// value) will be executed before an outstanding request with lower
// priority. Default priority is %G_PRIORITY_DEFAULT.
func (x *InputStream) ReadAllAsync(BufferVar []byte, CountVar uint, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xInputStreamReadAllAsync(x.GoPointer(), BufferVar, CountVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xInputStreamReadAllFinish func(uintptr, uintptr, uint, **glib.Error) bool

// Finishes an asynchronous stream read operation started with
// g_input_stream_read_all_async().
//
// As a special exception to the normal conventions for functions that
// use #GError, if this function returns %FALSE (and sets @error) then
// @bytes_read will be set to the number of bytes that were successfully
// read before the error was encountered.  This functionality is only
// available from C.  If you need it from another language then you must
// write your own loop around g_input_stream_read_async().
func (x *InputStream) ReadAllFinish(ResultVar AsyncResult, BytesReadVar uint) (bool, error) {
	var cerr *glib.Error

	cret := xInputStreamReadAllFinish(x.GoPointer(), ResultVar.GoPointer(), BytesReadVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xInputStreamReadAsync func(uintptr, []byte, uint, int, uintptr, uintptr, uintptr)

// Request an asynchronous read of @count bytes from the stream into the buffer
// starting at @buffer. When the operation is finished @callback will be called.
// You can then call g_input_stream_read_finish() to get the result of the
// operation.
//
// During an async request no other sync and async calls are allowed on @stream, and will
// result in %G_IO_ERROR_PENDING errors.
//
// A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes read into the buffer will be passed to the
// callback. It is not an error if this is not the same as the requested size, as it
// can happen e.g. near the end of a file, but generally we try to read
// as many bytes as requested. Zero is returned on end of file
// (or if @count is zero),  but never otherwise.
//
// Any outstanding i/o request with higher priority (lower numerical value) will
// be executed before an outstanding request with lower priority. Default
// priority is %G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to implement
// asynchronicity, so they are optional for inheriting classes. However, if you
// override one you must override all.
func (x *InputStream) ReadAsync(BufferVar []byte, CountVar uint, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xInputStreamReadAsync(x.GoPointer(), BufferVar, CountVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xInputStreamReadBytes func(uintptr, uint, uintptr, **glib.Error) *glib.Bytes

// Like g_input_stream_read(), this tries to read @count bytes from
// the stream in a blocking fashion. However, rather than reading into
// a user-supplied buffer, this will create a new #GBytes containing
// the data that was read. This may be easier to use from language
// bindings.
//
// If count is zero, returns a zero-length #GBytes and does nothing. A
// value of @count larger than %G_MAXSSIZE will cause a
// %G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, a new #GBytes is returned. It is not an error if the
// size of this object is not the same as the requested size, as it
// can happen e.g. near the end of a file. A zero-length #GBytes is
// returned on end of file (or if @count is zero), but never
// otherwise.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
//
// On error %NULL is returned and @error is set accordingly.
func (x *InputStream) ReadBytes(CountVar uint, CancellableVar *Cancellable) (*glib.Bytes, error) {
	var cerr *glib.Error

	cret := xInputStreamReadBytes(x.GoPointer(), CountVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xInputStreamReadBytesAsync func(uintptr, uint, int, uintptr, uintptr, uintptr)

// Request an asynchronous read of @count bytes from the stream into a
// new #GBytes. When the operation is finished @callback will be
// called. You can then call g_input_stream_read_bytes_finish() to get the
// result of the operation.
//
// During an async request no other sync and async calls are allowed
// on @stream, and will result in %G_IO_ERROR_PENDING errors.
//
// A value of @count larger than %G_MAXSSIZE will cause a
// %G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the new #GBytes will be passed to the callback. It is
// not an error if this is smaller than the requested size, as it can
// happen e.g. near the end of a file, but generally we try to read as
// many bytes as requested. Zero is returned on end of file (or if
// @count is zero), but never otherwise.
//
// Any outstanding I/O request with higher priority (lower numerical
// value) will be executed before an outstanding request with lower
// priority. Default priority is %G_PRIORITY_DEFAULT.
func (x *InputStream) ReadBytesAsync(CountVar uint, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xInputStreamReadBytesAsync(x.GoPointer(), CountVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xInputStreamReadBytesFinish func(uintptr, uintptr, **glib.Error) *glib.Bytes

// Finishes an asynchronous stream read-into-#GBytes operation.
func (x *InputStream) ReadBytesFinish(ResultVar AsyncResult) (*glib.Bytes, error) {
	var cerr *glib.Error

	cret := xInputStreamReadBytesFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xInputStreamReadFinish func(uintptr, uintptr, **glib.Error) int

// Finishes an asynchronous stream read operation.
func (x *InputStream) ReadFinish(ResultVar AsyncResult) (int, error) {
	var cerr *glib.Error

	cret := xInputStreamReadFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xInputStreamSetPending func(uintptr) bool

// Sets @stream to have actions pending. If the pending flag is
// already set or @stream is closed, it will return %FALSE and set
// @error.
func (x *InputStream) SetPending() (bool, error) {
	var cerr *glib.Error

	cret := xInputStreamSetPending(x.GoPointer())
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xInputStreamSkip func(uintptr, uint, uintptr, **glib.Error) int

// Tries to skip @count bytes from the stream. Will block during the operation.
//
// This is identical to g_input_stream_read(), from a behaviour standpoint,
// but the bytes that are skipped are not returned to the user. Some
// streams have an implementation that is more efficient than reading the data.
//
// This function is optional for inherited classes, as the default implementation
// emulates it using read.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
func (x *InputStream) Skip(CountVar uint, CancellableVar *Cancellable) (int, error) {
	var cerr *glib.Error

	cret := xInputStreamSkip(x.GoPointer(), CountVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xInputStreamSkipAsync func(uintptr, uint, int, uintptr, uintptr, uintptr)

// Request an asynchronous skip of @count bytes from the stream.
// When the operation is finished @callback will be called.
// You can then call g_input_stream_skip_finish() to get the result
// of the operation.
//
// During an async request no other sync and async calls are allowed,
// and will result in %G_IO_ERROR_PENDING errors.
//
// A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes skipped will be passed to the callback.
// It is not an error if this is not the same as the requested size, as it
// can happen e.g. near the end of a file, but generally we try to skip
// as many bytes as requested. Zero is returned on end of file
// (or if @count is zero), but never otherwise.
//
// Any outstanding i/o request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority.
// Default priority is %G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one, you must override all.
func (x *InputStream) SkipAsync(CountVar uint, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xInputStreamSkipAsync(x.GoPointer(), CountVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xInputStreamSkipFinish func(uintptr, uintptr, **glib.Error) int

// Finishes a stream skip operation.
func (x *InputStream) SkipFinish(ResultVar AsyncResult) (int, error) {
	var cerr *glib.Error

	cret := xInputStreamSkipFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *InputStream) GoPointer() uintptr {
	return c.Ptr
}

func (c *InputStream) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xInputStreamGLibType, lib, "g_input_stream_get_type")

	core.PuregoSafeRegister(&xInputStreamClearPending, lib, "g_input_stream_clear_pending")
	core.PuregoSafeRegister(&xInputStreamClose, lib, "g_input_stream_close")
	core.PuregoSafeRegister(&xInputStreamCloseAsync, lib, "g_input_stream_close_async")
	core.PuregoSafeRegister(&xInputStreamCloseFinish, lib, "g_input_stream_close_finish")
	core.PuregoSafeRegister(&xInputStreamHasPending, lib, "g_input_stream_has_pending")
	core.PuregoSafeRegister(&xInputStreamIsClosed, lib, "g_input_stream_is_closed")
	core.PuregoSafeRegister(&xInputStreamRead, lib, "g_input_stream_read")
	core.PuregoSafeRegister(&xInputStreamReadAll, lib, "g_input_stream_read_all")
	core.PuregoSafeRegister(&xInputStreamReadAllAsync, lib, "g_input_stream_read_all_async")
	core.PuregoSafeRegister(&xInputStreamReadAllFinish, lib, "g_input_stream_read_all_finish")
	core.PuregoSafeRegister(&xInputStreamReadAsync, lib, "g_input_stream_read_async")
	core.PuregoSafeRegister(&xInputStreamReadBytes, lib, "g_input_stream_read_bytes")
	core.PuregoSafeRegister(&xInputStreamReadBytesAsync, lib, "g_input_stream_read_bytes_async")
	core.PuregoSafeRegister(&xInputStreamReadBytesFinish, lib, "g_input_stream_read_bytes_finish")
	core.PuregoSafeRegister(&xInputStreamReadFinish, lib, "g_input_stream_read_finish")
	core.PuregoSafeRegister(&xInputStreamSetPending, lib, "g_input_stream_set_pending")
	core.PuregoSafeRegister(&xInputStreamSkip, lib, "g_input_stream_skip")
	core.PuregoSafeRegister(&xInputStreamSkipAsync, lib, "g_input_stream_skip_async")
	core.PuregoSafeRegister(&xInputStreamSkipFinish, lib, "g_input_stream_skip_finish")

}
