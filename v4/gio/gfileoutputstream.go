// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
)

type FileOutputStreamClass struct {
	ParentClass uintptr
}

func (x *FileOutputStreamClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type FileOutputStreamPrivate struct {
}

func (x *FileOutputStreamPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// GFileOutputStream provides output streams that write their
// content to a file.
//
// GFileOutputStream implements #GSeekable, which allows the output
// stream to jump to arbitrary positions in the file and to truncate
// the file, provided the filesystem of the file supports these
// operations.
//
// To find the position of a file output stream, use g_seekable_tell().
// To find out if a file output stream supports seeking, use
// g_seekable_can_seek().To position a file output stream, use
// g_seekable_seek(). To find out if a file output stream supports
// truncating, use g_seekable_can_truncate(). To truncate a file output
// stream, use g_seekable_truncate().
type FileOutputStream struct {
	OutputStream
}

func FileOutputStreamNewFromInternalPtr(ptr uintptr) *FileOutputStream {
	cls := &FileOutputStream{}
	cls.Ptr = ptr
	return cls
}

var xFileOutputStreamGetEtag func(uintptr) string

// Gets the entity tag for the file when it has been written.
// This must be called after the stream has been written
// and closed, as the etag can change while writing.
func (x *FileOutputStream) GetEtag() string {

	cret := xFileOutputStreamGetEtag(x.GoPointer())
	return cret
}

var xFileOutputStreamQueryInfo func(uintptr, string, uintptr, **glib.Error) uintptr

// Queries a file output stream for the given @attributes.
// This function blocks while querying the stream. For the asynchronous
// version of this function, see g_file_output_stream_query_info_async().
// While the stream is blocked, the stream will set the pending flag
// internally, and any other operations on the stream will fail with
// %G_IO_ERROR_PENDING.
//
// Can fail if the stream was already closed (with @error being set to
// %G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
// set to %G_IO_ERROR_PENDING), or if querying info is not supported for
// the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). In
// all cases of failure, %NULL will be returned.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
// be returned.
func (x *FileOutputStream) QueryInfo(AttributesVar string, CancellableVar *Cancellable) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := xFileOutputStreamQueryInfo(x.GoPointer(), AttributesVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xFileOutputStreamQueryInfoAsync func(uintptr, string, int, uintptr, uintptr, uintptr)

// Asynchronously queries the @stream for a #GFileInfo. When completed,
// @callback will be called with a #GAsyncResult which can be used to
// finish the operation with g_file_output_stream_query_info_finish().
//
// For the synchronous version of this function, see
// g_file_output_stream_query_info().
func (x *FileOutputStream) QueryInfoAsync(AttributesVar string, IoPriorityVar int, CancellableVar *Cancellable, CallbackVar *AsyncReadyCallback, UserDataVar uintptr) {

	xFileOutputStreamQueryInfoAsync(x.GoPointer(), AttributesVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xFileOutputStreamQueryInfoFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finalizes the asynchronous query started
// by g_file_output_stream_query_info_async().
func (x *FileOutputStream) QueryInfoFinish(ResultVar AsyncResult) (*FileInfo, error) {
	var cls *FileInfo
	var cerr *glib.Error

	cret := xFileOutputStreamQueryInfoFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &FileInfo{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

func (c *FileOutputStream) GoPointer() uintptr {
	return c.Ptr
}

func (c *FileOutputStream) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Tests if the stream supports the #GSeekableIface.
func (x *FileOutputStream) CanSeek() bool {

	cret := XGSeekableCanSeek(x.GoPointer())
	return cret
}

// Tests if the length of the stream can be adjusted with
// g_seekable_truncate().
func (x *FileOutputStream) CanTruncate() bool {

	cret := XGSeekableCanTruncate(x.GoPointer())
	return cret
}

// Seeks in the stream by the given @offset, modified by @type.
//
// Attempting to seek past the end of the stream will have different
// results depending on if the stream is fixed-sized or resizable.  If
// the stream is resizable then seeking past the end and then writing
// will result in zeros filling the empty space.  Seeking past the end
// of a resizable stream and reading will result in EOF.  Seeking past
// the end of a fixed-sized stream will fail.
//
// Any operation that would result in a negative offset will fail.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (x *FileOutputStream) Seek(OffsetVar int64, TypeVar glib.SeekType, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGSeekableSeek(x.GoPointer(), OffsetVar, TypeVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Tells the current position within the stream.
func (x *FileOutputStream) Tell() int64 {

	cret := XGSeekableTell(x.GoPointer())
	return cret
}

// Sets the length of the stream to @offset. If the stream was previously
// larger than @offset, the extra data is discarded. If the stream was
// previously shorter than @offset, it is extended with NUL ('\0') bytes.
//
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
func (x *FileOutputStream) Truncate(OffsetVar int64, CancellableVar *Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := XGSeekableTruncate(x.GoPointer(), OffsetVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xFileOutputStreamGetEtag, lib, "g_file_output_stream_get_etag")
	core.PuregoSafeRegister(&xFileOutputStreamQueryInfo, lib, "g_file_output_stream_query_info")
	core.PuregoSafeRegister(&xFileOutputStreamQueryInfoAsync, lib, "g_file_output_stream_query_info_async")
	core.PuregoSafeRegister(&xFileOutputStreamQueryInfoFinish, lib, "g_file_output_stream_query_info_finish")

}
