// Package pango was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package pango

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The `PangoAnalysis` structure stores information about
// the properties of a segment of text.
type Analysis struct {
	_ structs.HostLayout

	ShapeEngine uintptr

	LangEngine uintptr

	Font *Font

	Level byte

	Gravity byte

	Flags byte

	Script byte

	Language *Language

	ExtraAttrs *glib.SList
}

func (x *Analysis) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// The `PangoItem` structure stores information about a segment of text.
//
// You typically obtain `PangoItems` by itemizing a piece of text
// with [func@itemize].
type Item struct {
	_ structs.HostLayout

	Offset int

	Length int

	NumChars int

	Analysis uintptr
}

var xItemGLibType func() types.GType

func ItemGLibType() types.GType {
	return xItemGLibType()
}

func (x *Item) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewItem func() *Item

// Creates a new `PangoItem` structure initialized to default values.
func NewItem() *Item {

	cret := xNewItem()
	return cret
}

var xItemApplyAttrs func(uintptr, *AttrIterator)

// Add attributes to a `PangoItem`.
//
// The idea is that you have attributes that don't affect itemization,
// such as font features, so you filter them out using
// [method@Pango.AttrList.filter], itemize your text, then reapply the
// attributes to the resulting items using this function.
//
// The @iter should be positioned before the range of the item,
// and will be advanced past it. This function is meant to be called
// in a loop over the items resulting from itemization, while passing
// the iter to each call.
func (x *Item) ApplyAttrs(IterVar *AttrIterator) {

	xItemApplyAttrs(x.GoPointer(), IterVar)

}

var xItemCopy func(uintptr) *Item

// Copy an existing `PangoItem` structure.
func (x *Item) Copy() *Item {

	cret := xItemCopy(x.GoPointer())
	return cret
}

var xItemFree func(uintptr)

// Free a `PangoItem` and all associated memory.
func (x *Item) Free() {

	xItemFree(x.GoPointer())

}

var xItemSplit func(uintptr, int, int) *Item

// Modifies @orig to cover only the text after @split_index, and
// returns a new item that covers the text before @split_index that
// used to be in @orig.
//
// You can think of @split_index as the length of the returned item.
// @split_index may not be 0, and it may not be greater than or equal
// to the length of @orig (that is, there must be at least one byte
// assigned to each item, you can't create a zero-length item).
// @split_offset is the length of the first item in chars, and must be
// provided because the text used to generate the item isn't available,
// so `pango_item_split()` can't count the char length of the split items
// itself.
func (x *Item) Split(SplitIndexVar int, SplitOffsetVar int) *Item {

	cret := xItemSplit(x.GoPointer(), SplitIndexVar, SplitOffsetVar)
	return cret
}

const (
	// Whether the segment should be shifted to center around the baseline.
	//
	// This is mainly used in vertical writing directions.
	ANALYSIS_FLAG_CENTERED_BASELINE int = 1
	// Whether this run holds ellipsized text.
	ANALYSIS_FLAG_IS_ELLIPSIS int = 2
	// Whether to add a hyphen at the end of the run during shaping.
	ANALYSIS_FLAG_NEED_HYPHEN int = 4
)

var xItemize func(uintptr, string, int, int, *AttrList, *AttrIterator) *glib.List

// Breaks a piece of text into segments with consistent directional
// level and font.
//
// Each byte of @text will be contained in exactly one of the items in the
// returned list; the generated list of items will be in logical order (the
// start offsets of the items are ascending).
//
// @cached_iter should be an iterator over @attrs currently positioned
// at a range before or containing @start_index; @cached_iter will be
// advanced to the range covering the position just after
// @start_index + @length. (i.e. if itemizing in a loop, just keep passing
// in the same @cached_iter).
func Itemize(ContextVar *Context, TextVar string, StartIndexVar int, LengthVar int, AttrsVar *AttrList, CachedIterVar *AttrIterator) *glib.List {

	cret := xItemize(ContextVar.GoPointer(), TextVar, StartIndexVar, LengthVar, AttrsVar, CachedIterVar)
	return cret
}

var xItemizeWithBaseDir func(uintptr, Direction, string, int, int, *AttrList, *AttrIterator) *glib.List

// Like `pango_itemize()`, but with an explicitly specified base direction.
//
// The base direction is used when computing bidirectional levels.
// [func@itemize] gets the base direction from the `PangoContext`
// (see [method@Pango.Context.set_base_dir]).
func ItemizeWithBaseDir(ContextVar *Context, BaseDirVar Direction, TextVar string, StartIndexVar int, LengthVar int, AttrsVar *AttrList, CachedIterVar *AttrIterator) *glib.List {

	cret := xItemizeWithBaseDir(ContextVar.GoPointer(), BaseDirVar, TextVar, StartIndexVar, LengthVar, AttrsVar, CachedIterVar)
	return cret
}

var xReorderItems func(*glib.List) *glib.List

// Reorder items from logical order to visual order.
//
// The visual order is determined from the associated directional
// levels of the items. The original list is unmodified.
//
// (Please open a bug if you use this function.
//
//	It is not a particularly convenient interface, and the code
//	is duplicated elsewhere in Pango for that reason.)
func ReorderItems(ItemsVar *glib.List) *glib.List {

	cret := xReorderItems(ItemsVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("PANGO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xItemize, lib, "pango_itemize")
	core.PuregoSafeRegister(&xItemizeWithBaseDir, lib, "pango_itemize_with_base_dir")
	core.PuregoSafeRegister(&xReorderItems, lib, "pango_reorder_items")

	core.PuregoSafeRegister(&xItemGLibType, lib, "pango_item_get_type")

	core.PuregoSafeRegister(&xNewItem, lib, "pango_item_new")

	core.PuregoSafeRegister(&xItemApplyAttrs, lib, "pango_item_apply_attrs")
	core.PuregoSafeRegister(&xItemCopy, lib, "pango_item_copy")
	core.PuregoSafeRegister(&xItemFree, lib, "pango_item_free")
	core.PuregoSafeRegister(&xItemSplit, lib, "pango_item_split")

}
