// Package pango was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package pango

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// A `PangoGlyphItem` is a pair of a `PangoItem` and the glyphs
// resulting from shaping the items text.
//
// As an example of the usage of `PangoGlyphItem`, the results
// of shaping text with `PangoLayout` is a list of `PangoLayoutLine`,
// each of which contains a list of `PangoGlyphItem`.
type GlyphItem struct {
	_ structs.HostLayout

	Item *Item

	Glyphs *GlyphString

	YOffset int

	StartXOffset int

	EndXOffset int
}

var xGlyphItemGLibType func() types.GType

func GlyphItemGLibType() types.GType {
	return xGlyphItemGLibType()
}

func (x *GlyphItem) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xGlyphItemApplyAttrs func(uintptr, string, *AttrList) *glib.SList

// Splits a shaped item (`PangoGlyphItem`) into multiple items based
// on an attribute list.
//
// The idea is that if you have attributes that don't affect shaping,
// such as color or underline, to avoid affecting shaping, you filter
// them out ([method@Pango.AttrList.filter]), apply the shaping process
// and then reapply them to the result using this function.
//
// All attributes that start or end inside a cluster are applied
// to that cluster; for instance, if half of a cluster is underlined
// and the other-half strikethrough, then the cluster will end
// up with both underline and strikethrough attributes. In these
// cases, it may happen that @item-&gt;extra_attrs for some of the
// result items can have multiple attributes of the same type.
//
// This function takes ownership of @glyph_item; it will be reused
// as one of the elements in the list.
func (x *GlyphItem) ApplyAttrs(TextVar string, ListVar *AttrList) *glib.SList {

	cret := xGlyphItemApplyAttrs(x.GoPointer(), TextVar, ListVar)
	return cret
}

var xGlyphItemCopy func(uintptr) *GlyphItem

// Make a deep copy of an existing `PangoGlyphItem` structure.
func (x *GlyphItem) Copy() *GlyphItem {

	cret := xGlyphItemCopy(x.GoPointer())
	return cret
}

var xGlyphItemFree func(uintptr)

// Frees a `PangoGlyphItem` and resources to which it points.
func (x *GlyphItem) Free() {

	xGlyphItemFree(x.GoPointer())

}

var xGlyphItemGetLogicalWidths func(uintptr, string, []int)

// Given a `PangoGlyphItem` and the corresponding text, determine the
// width corresponding to each character.
//
// When multiple characters compose a single cluster, the width of the
// entire cluster is divided equally among the characters.
//
// See also [method@Pango.GlyphString.get_logical_widths].
func (x *GlyphItem) GetLogicalWidths(TextVar string, LogicalWidthsVar []int) {

	xGlyphItemGetLogicalWidths(x.GoPointer(), TextVar, LogicalWidthsVar)

}

var xGlyphItemLetterSpace func(uintptr, string, []LogAttr, int)

// Adds spacing between the graphemes of @glyph_item to
// give the effect of typographic letter spacing.
func (x *GlyphItem) LetterSpace(TextVar string, LogAttrsVar []LogAttr, LetterSpacingVar int) {

	xGlyphItemLetterSpace(x.GoPointer(), TextVar, LogAttrsVar, LetterSpacingVar)

}

var xGlyphItemSplit func(uintptr, string, int) *GlyphItem

// Modifies @orig to cover only the text after @split_index, and
// returns a new item that covers the text before @split_index that
// used to be in @orig.
//
// You can think of @split_index as the length of the returned item.
// @split_index may not be 0, and it may not be greater than or equal
// to the length of @orig (that is, there must be at least one byte
// assigned to each item, you can't create a zero-length item).
//
// This function is similar in function to pango_item_split() (and uses
// it internally.)
func (x *GlyphItem) Split(TextVar string, SplitIndexVar int) *GlyphItem {

	cret := xGlyphItemSplit(x.GoPointer(), TextVar, SplitIndexVar)
	return cret
}

// A `PangoGlyphItemIter` is an iterator over the clusters in a
// `PangoGlyphItem`.
//
// The *forward direction* of the iterator is the logical direction of text.
// That is, with increasing @start_index and @start_char values. If @glyph_item
// is right-to-left (that is, if `glyph_item-&gt;item-&gt;analysis.level` is odd),
// then @start_glyph decreases as the iterator moves forward.  Moreover,
// in right-to-left cases, @start_glyph is greater than @end_glyph.
//
// An iterator should be initialized using either
// pango_glyph_item_iter_init_start() or
// pango_glyph_item_iter_init_end(), for forward and backward iteration
// respectively, and walked over using any desired mixture of
// pango_glyph_item_iter_next_cluster() and
// pango_glyph_item_iter_prev_cluster().
//
// A common idiom for doing a forward iteration over the clusters is:
//
// ```
// PangoGlyphItemIter cluster_iter;
// gboolean have_cluster;
//
// for (have_cluster = pango_glyph_item_iter_init_start (&amp;cluster_iter,
//
//	                                                 glyph_item, text);
//	have_cluster;
//	have_cluster = pango_glyph_item_iter_next_cluster (&amp;cluster_iter))
//
//	{
//	  ...
//	}
//
// ```
//
// Note that @text is the start of the text for layout, which is then
// indexed by `glyph_item-&gt;item-&gt;offset` to get to the text of @glyph_item.
// The @start_index and @end_index values can directly index into @text. The
// @start_glyph, @end_glyph, @start_char, and @end_char values however are
// zero-based for the @glyph_item.  For each cluster, the item pointed at by
// the start variables is included in the cluster while the one pointed at by
// end variables is not.
//
// None of the members of a `PangoGlyphItemIter` should be modified manually.
type GlyphItemIter struct {
	_ structs.HostLayout

	GlyphItem *GlyphItem

	Text uintptr

	StartGlyph int

	StartIndex int

	StartChar int

	EndGlyph int

	EndIndex int

	EndChar int
}

var xGlyphItemIterGLibType func() types.GType

func GlyphItemIterGLibType() types.GType {
	return xGlyphItemIterGLibType()
}

func (x *GlyphItemIter) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xGlyphItemIterCopy func(uintptr) *GlyphItemIter

// Make a shallow copy of an existing `PangoGlyphItemIter` structure.
func (x *GlyphItemIter) Copy() *GlyphItemIter {

	cret := xGlyphItemIterCopy(x.GoPointer())
	return cret
}

var xGlyphItemIterFree func(uintptr)

// Frees a `PangoGlyphItem`Iter.
func (x *GlyphItemIter) Free() {

	xGlyphItemIterFree(x.GoPointer())

}

var xGlyphItemIterInitEnd func(uintptr, *GlyphItem, string) bool

// Initializes a `PangoGlyphItemIter` structure to point to the
// last cluster in a glyph item.
//
// See `PangoGlyphItemIter` for details of cluster orders.
func (x *GlyphItemIter) InitEnd(GlyphItemVar *GlyphItem, TextVar string) bool {

	cret := xGlyphItemIterInitEnd(x.GoPointer(), GlyphItemVar, TextVar)
	return cret
}

var xGlyphItemIterInitStart func(uintptr, *GlyphItem, string) bool

// Initializes a `PangoGlyphItemIter` structure to point to the
// first cluster in a glyph item.
//
// See `PangoGlyphItemIter` for details of cluster orders.
func (x *GlyphItemIter) InitStart(GlyphItemVar *GlyphItem, TextVar string) bool {

	cret := xGlyphItemIterInitStart(x.GoPointer(), GlyphItemVar, TextVar)
	return cret
}

var xGlyphItemIterNextCluster func(uintptr) bool

// Advances the iterator to the next cluster in the glyph item.
//
// See `PangoGlyphItemIter` for details of cluster orders.
func (x *GlyphItemIter) NextCluster() bool {

	cret := xGlyphItemIterNextCluster(x.GoPointer())
	return cret
}

var xGlyphItemIterPrevCluster func(uintptr) bool

// Moves the iterator to the preceding cluster in the glyph item.
// See `PangoGlyphItemIter` for details of cluster orders.
func (x *GlyphItemIter) PrevCluster() bool {

	cret := xGlyphItemIterPrevCluster(x.GoPointer())
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("PANGO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xGlyphItemGLibType, lib, "pango_glyph_item_get_type")

	core.PuregoSafeRegister(&xGlyphItemApplyAttrs, lib, "pango_glyph_item_apply_attrs")
	core.PuregoSafeRegister(&xGlyphItemCopy, lib, "pango_glyph_item_copy")
	core.PuregoSafeRegister(&xGlyphItemFree, lib, "pango_glyph_item_free")
	core.PuregoSafeRegister(&xGlyphItemGetLogicalWidths, lib, "pango_glyph_item_get_logical_widths")
	core.PuregoSafeRegister(&xGlyphItemLetterSpace, lib, "pango_glyph_item_letter_space")
	core.PuregoSafeRegister(&xGlyphItemSplit, lib, "pango_glyph_item_split")

	core.PuregoSafeRegister(&xGlyphItemIterGLibType, lib, "pango_glyph_item_iter_get_type")

	core.PuregoSafeRegister(&xGlyphItemIterCopy, lib, "pango_glyph_item_iter_copy")
	core.PuregoSafeRegister(&xGlyphItemIterFree, lib, "pango_glyph_item_iter_free")
	core.PuregoSafeRegister(&xGlyphItemIterInitEnd, lib, "pango_glyph_item_iter_init_end")
	core.PuregoSafeRegister(&xGlyphItemIterInitStart, lib, "pango_glyph_item_iter_init_start")
	core.PuregoSafeRegister(&xGlyphItemIterNextCluster, lib, "pango_glyph_item_iter_next_cluster")
	core.PuregoSafeRegister(&xGlyphItemIterPrevCluster, lib, "pango_glyph_item_iter_prev_cluster")

}
