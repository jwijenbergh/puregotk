// Package pango was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package pango

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// A `PangoMatrix` specifies a transformation between user-space
// and device coordinates.
//
// # The transformation is given by
//
// ```
// x_device = x_user * matrix-&gt;xx + y_user * matrix-&gt;xy + matrix-&gt;x0;
// y_device = x_user * matrix-&gt;yx + y_user * matrix-&gt;yy + matrix-&gt;y0;
// ```
type Matrix struct {
	_ structs.HostLayout

	Xx float64

	Xy float64

	Yx float64

	Yy float64

	X0 float64

	Y0 float64
}

var xMatrixGLibType func() types.GType

func MatrixGLibType() types.GType {
	return xMatrixGLibType()
}

func (x *Matrix) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xMatrixConcat func(uintptr, *Matrix)

// Changes the transformation represented by @matrix to be the
// transformation given by first applying transformation
// given by @new_matrix then applying the original transformation.
func (x *Matrix) Concat(NewMatrixVar *Matrix) {

	xMatrixConcat(x.GoPointer(), NewMatrixVar)

}

var xMatrixCopy func(uintptr) *Matrix

// Copies a `PangoMatrix`.
func (x *Matrix) Copy() *Matrix {

	cret := xMatrixCopy(x.GoPointer())
	return cret
}

var xMatrixFree func(uintptr)

// Free a `PangoMatrix`.
func (x *Matrix) Free() {

	xMatrixFree(x.GoPointer())

}

var xMatrixGetFontScaleFactor func(uintptr) float64

// Returns the scale factor of a matrix on the height of the font.
//
// That is, the scale factor in the direction perpendicular to the
// vector that the X coordinate is mapped to.  If the scale in the X
// coordinate is needed as well, use [method@Pango.Matrix.get_font_scale_factors].
func (x *Matrix) GetFontScaleFactor() float64 {

	cret := xMatrixGetFontScaleFactor(x.GoPointer())
	return cret
}

var xMatrixGetFontScaleFactors func(uintptr, float64, float64)

// Calculates the scale factor of a matrix on the width and height of the font.
//
// That is, @xscale is the scale factor in the direction of the X coordinate,
// and @yscale is the scale factor in the direction perpendicular to the
// vector that the X coordinate is mapped to.
//
// Note that output numbers will always be non-negative.
func (x *Matrix) GetFontScaleFactors(XscaleVar float64, YscaleVar float64) {

	xMatrixGetFontScaleFactors(x.GoPointer(), XscaleVar, YscaleVar)

}

var xMatrixRotate func(uintptr, float64)

// Changes the transformation represented by @matrix to be the
// transformation given by first rotating by @degrees degrees
// counter-clockwise then applying the original transformation.
func (x *Matrix) Rotate(DegreesVar float64) {

	xMatrixRotate(x.GoPointer(), DegreesVar)

}

var xMatrixScale func(uintptr, float64, float64)

// Changes the transformation represented by @matrix to be the
// transformation given by first scaling by @sx in the X direction
// and @sy in the Y direction then applying the original
// transformation.
func (x *Matrix) Scale(ScaleXVar float64, ScaleYVar float64) {

	xMatrixScale(x.GoPointer(), ScaleXVar, ScaleYVar)

}

var xMatrixTransformDistance func(uintptr, float64, float64)

// Transforms the distance vector (@dx,@dy) by @matrix.
//
// This is similar to [method@Pango.Matrix.transform_point],
// except that the translation components of the transformation
// are ignored. The calculation of the returned vector is as follows:
//
// ```
// dx2 = dx1 * xx + dy1 * xy;
// dy2 = dx1 * yx + dy1 * yy;
// ```
//
// Affine transformations are position invariant, so the same vector
// always transforms to the same vector. If (@x1,@y1) transforms
// to (@x2,@y2) then (@x1+@dx1,@y1+@dy1) will transform to
// (@x1+@dx2,@y1+@dy2) for all values of @x1 and @x2.
func (x *Matrix) TransformDistance(DxVar float64, DyVar float64) {

	xMatrixTransformDistance(x.GoPointer(), DxVar, DyVar)

}

var xMatrixTransformPixelRectangle func(uintptr, *Rectangle)

// First transforms the @rect using @matrix, then calculates the bounding box
// of the transformed rectangle.
//
// This function is useful for example when you want to draw a rotated
// @PangoLayout to an image buffer, and want to know how large the image
// should be and how much you should shift the layout when rendering.
//
// For better accuracy, you should use [method@Pango.Matrix.transform_rectangle]
// on original rectangle in Pango units and convert to pixels afterward
// using [func@extents_to_pixels]'s first argument.
func (x *Matrix) TransformPixelRectangle(RectVar *Rectangle) {

	xMatrixTransformPixelRectangle(x.GoPointer(), RectVar)

}

var xMatrixTransformPoint func(uintptr, float64, float64)

// Transforms the point (@x, @y) by @matrix.
func (x *Matrix) TransformPoint(XVar float64, YVar float64) {

	xMatrixTransformPoint(x.GoPointer(), XVar, YVar)

}

var xMatrixTransformRectangle func(uintptr, *Rectangle)

// First transforms @rect using @matrix, then calculates the bounding box
// of the transformed rectangle.
//
// This function is useful for example when you want to draw a rotated
// @PangoLayout to an image buffer, and want to know how large the image
// should be and how much you should shift the layout when rendering.
//
// If you have a rectangle in device units (pixels), use
// [method@Pango.Matrix.transform_pixel_rectangle].
//
// If you have the rectangle in Pango units and want to convert to
// transformed pixel bounding box, it is more accurate to transform it first
// (using this function) and pass the result to pango_extents_to_pixels(),
// first argument, for an inclusive rounded rectangle.
// However, there are valid reasons that you may want to convert
// to pixels first and then transform, for example when the transformed
// coordinates may overflow in Pango units (large matrix translation for
// example).
func (x *Matrix) TransformRectangle(RectVar *Rectangle) {

	xMatrixTransformRectangle(x.GoPointer(), RectVar)

}

var xMatrixTranslate func(uintptr, float64, float64)

// Changes the transformation represented by @matrix to be the
// transformation given by first translating by (@tx, @ty)
// then applying the original transformation.
func (x *Matrix) Translate(TxVar float64, TyVar float64) {

	xMatrixTranslate(x.GoPointer(), TxVar, TyVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("PANGO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xMatrixGLibType, lib, "pango_matrix_get_type")

	core.PuregoSafeRegister(&xMatrixConcat, lib, "pango_matrix_concat")
	core.PuregoSafeRegister(&xMatrixCopy, lib, "pango_matrix_copy")
	core.PuregoSafeRegister(&xMatrixFree, lib, "pango_matrix_free")
	core.PuregoSafeRegister(&xMatrixGetFontScaleFactor, lib, "pango_matrix_get_font_scale_factor")
	core.PuregoSafeRegister(&xMatrixGetFontScaleFactors, lib, "pango_matrix_get_font_scale_factors")
	core.PuregoSafeRegister(&xMatrixRotate, lib, "pango_matrix_rotate")
	core.PuregoSafeRegister(&xMatrixScale, lib, "pango_matrix_scale")
	core.PuregoSafeRegister(&xMatrixTransformDistance, lib, "pango_matrix_transform_distance")
	core.PuregoSafeRegister(&xMatrixTransformPixelRectangle, lib, "pango_matrix_transform_pixel_rectangle")
	core.PuregoSafeRegister(&xMatrixTransformPoint, lib, "pango_matrix_transform_point")
	core.PuregoSafeRegister(&xMatrixTransformRectangle, lib, "pango_matrix_transform_rectangle")
	core.PuregoSafeRegister(&xMatrixTranslate, lib, "pango_matrix_translate")

}
