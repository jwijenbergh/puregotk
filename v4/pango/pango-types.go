// Package pango was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package pango

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The `PangoLanguage` structure is used to
// represent a language.
//
// `PangoLanguage` pointers can be efficiently
// copied and compared with each other.
type Language struct {
	_ structs.HostLayout
}

var xLanguageGLibType func() types.GType

func LanguageGLibType() types.GType {
	return xLanguageGLibType()
}

func (x *Language) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xLanguageGetSampleString func(uintptr) string

// Get a string that is representative of the characters needed to
// render a particular language.
//
// The sample text may be a pangram, but is not necessarily. It is chosen
// to be demonstrative of normal text in the language, as well as exposing
// font feature requirements unique to the language. It is suitable for use
// as sample text in a font selection dialog.
//
// If @language is %NULL, the default language as found by
// [func@Pango.Language.get_default] is used.
//
// If Pango does not have a sample string for @language, the classic
// "The quick brown fox..." is returned.  This can be detected by
// comparing the returned pointer value to that returned for (non-existent)
// language code "xx".  That is, compare to:
//
// ```
// pango_language_get_sample_string (pango_language_from_string ("xx"))
// ```
func (x *Language) GetSampleString() string {

	cret := xLanguageGetSampleString(x.GoPointer())
	return cret
}

var xLanguageGetScripts func(uintptr, int) []Script

// Determines the scripts used to to write @language.
//
// If nothing is known about the language tag @language,
// or if @language is %NULL, then %NULL is returned.
// The list of scripts returned starts with the script that the
// language uses most and continues to the one it uses least.
//
// The value @num_script points at will be set to the number
// of scripts in the returned array (or zero if %NULL is returned).
//
// Most languages use only one script for writing, but there are
// some that use two (Latin and Cyrillic for example), and a few
// use three (Japanese for example). Applications should not make
// any assumptions on the maximum number of scripts returned
// though, except that it is positive if the return value is not
// %NULL, and it is a small number.
//
// The [method@Pango.Language.includes_script] function uses this
// function internally.
//
// Note: while the return value is declared as `PangoScript`, the
// returned values are from the `GUnicodeScript` enumeration, which
// may have more values. Callers need to handle unknown values.
func (x *Language) GetScripts(NumScriptsVar int) []Script {

	cret := xLanguageGetScripts(x.GoPointer(), NumScriptsVar)
	return cret
}

var xLanguageIncludesScript func(uintptr, Script) bool

// Determines if @script is one of the scripts used to
// write @language.
//
// The returned value is conservative; if nothing is known about
// the language tag @language, %TRUE will be returned, since, as
// far as Pango knows, @script might be used to write @language.
//
// This routine is used in Pango's itemization process when
// determining if a supplied language tag is relevant to
// a particular section of text. It probably is not useful
// for applications in most circumstances.
//
// This function uses [method@Pango.Language.get_scripts] internally.
func (x *Language) IncludesScript(ScriptVar Script) bool {

	cret := xLanguageIncludesScript(x.GoPointer(), ScriptVar)
	return cret
}

var xLanguageMatches func(uintptr, string) bool

// Checks if a language tag matches one of the elements in a list of
// language ranges.
//
// A language tag is considered to match a range in the list if the
// range is '*', the range is exactly the tag, or the range is a prefix
// of the tag, and the character after it in the tag is '-'.
func (x *Language) Matches(RangeListVar string) bool {

	cret := xLanguageMatches(x.GoPointer(), RangeListVar)
	return cret
}

var xLanguageToString func(uintptr) string

// Gets the RFC-3066 format string representing the given language tag.
//
// Returns (transfer none): a string representing the language tag
func (x *Language) ToString() string {

	cret := xLanguageToString(x.GoPointer())
	return cret
}

// The `PangoRectangle` structure represents a rectangle.
//
// `PangoRectangle` is frequently used to represent the logical or ink
// extents of a single glyph or section of text. (See, for instance,
// [method@Pango.Font.get_glyph_extents].)
type Rectangle struct {
	_ structs.HostLayout

	X int

	Y int

	Width int

	Height int
}

func (x *Rectangle) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A `PangoGlyph` represents a single glyph in the output form of a string.
type Glyph = uint32

const (
	// The scale between dimensions used for Pango distances and device units.
	//
	// The definition of device units is dependent on the output device; it will
	// typically be pixels for a screen, and points for a printer. %PANGO_SCALE is
	// currently 1024, but this may be changed in the future.
	//
	// When setting font sizes, device units are always considered to be
	// points (as in "12 point font"), rather than pixels.
	SCALE int = 1024
)

var xExtentsToPixels func(*Rectangle, *Rectangle)

// Converts extents from Pango units to device units.
//
// The conversion is done by dividing by the %PANGO_SCALE factor and
// performing rounding.
//
// The @inclusive rectangle is converted by flooring the x/y coordinates
// and extending width/height, such that the final rectangle completely
// includes the original rectangle.
//
// The @nearest rectangle is converted by rounding the coordinates
// of the rectangle to the nearest device unit (pixel).
//
// The rule to which argument to use is: if you want the resulting device-space
// rectangle to completely contain the original rectangle, pass it in as
// @inclusive. If you want two touching-but-not-overlapping rectangles stay
// touching-but-not-overlapping after rounding to device units, pass them in
// as @nearest.
func ExtentsToPixels(InclusiveVar *Rectangle, NearestVar *Rectangle) {

	xExtentsToPixels(InclusiveVar, NearestVar)

}

var xUnitsFromDouble func(float64) int

// Converts a floating-point number to Pango units.
//
// The conversion is done by multiplying @d by %PANGO_SCALE and
// rounding the result to nearest integer.
func UnitsFromDouble(DVar float64) int {

	cret := xUnitsFromDouble(DVar)
	return cret
}

var xUnitsToDouble func(int) float64

// Converts a number in Pango units to floating-point.
//
// The conversion is done by dividing @i by %PANGO_SCALE.
func UnitsToDouble(IVar int) float64 {

	cret := xUnitsToDouble(IVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("PANGO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xExtentsToPixels, lib, "pango_extents_to_pixels")
	core.PuregoSafeRegister(&xUnitsFromDouble, lib, "pango_units_from_double")
	core.PuregoSafeRegister(&xUnitsToDouble, lib, "pango_units_to_double")

	core.PuregoSafeRegister(&xLanguageGLibType, lib, "pango_language_get_type")

	core.PuregoSafeRegister(&xLanguageGetSampleString, lib, "pango_language_get_sample_string")
	core.PuregoSafeRegister(&xLanguageGetScripts, lib, "pango_language_get_scripts")
	core.PuregoSafeRegister(&xLanguageIncludesScript, lib, "pango_language_includes_script")
	core.PuregoSafeRegister(&xLanguageMatches, lib, "pango_language_matches")
	core.PuregoSafeRegister(&xLanguageToString, lib, "pango_language_to_string")

}
