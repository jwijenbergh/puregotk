// Package pango was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package pango

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// `PangoCoverageLevel` is used to indicate how well a font can
// represent a particular Unicode character for a particular script.
//
// Since 1.44, only %PANGO_COVERAGE_NONE and %PANGO_COVERAGE_EXACT
// will be returned.
type CoverageLevel int

const (

	// The character is not representable with
	//   the font.
	CoverageNoneValue CoverageLevel = 0
	// The character is represented in a
	//   way that may be comprehensible but is not the correct
	//   graphical form. For instance, a Hangul character represented
	//   as a a sequence of Jamos, or a Latin transliteration of a
	//   Cyrillic word.
	CoverageFallbackValue CoverageLevel = 1
	// The character is represented as
	//   basically the correct graphical form, but with a stylistic
	//   variant inappropriate for the current script.
	CoverageApproximateValue CoverageLevel = 2
	// The character is represented as the
	//   correct graphical form.
	CoverageExactValue CoverageLevel = 3
)

// A `PangoCoverage` structure is a map from Unicode characters
// to [enum@Pango.CoverageLevel] values.
//
// It is often necessary in Pango to determine if a particular
// font can represent a particular character, and also how well
// it can represent that character. The `PangoCoverage` is a data
// structure that is used to represent that information. It is an
// opaque structure with no public fields.
type Coverage struct {
	gobject.Object
}

func CoverageNewFromInternalPtr(ptr uintptr) *Coverage {
	cls := &Coverage{}
	cls.Ptr = ptr
	return cls
}

var xNewCoverage func() uintptr

// Create a new `PangoCoverage`
func NewCoverage() *Coverage {
	var cls *Coverage

	cret := xNewCoverage()

	if cret == 0 {
		return nil
	}
	cls = &Coverage{}
	cls.Ptr = cret
	return cls
}

var xCoverageCopy func(uintptr) uintptr

// Copy an existing `PangoCoverage`.
func (x *Coverage) Copy() *Coverage {
	var cls *Coverage

	cret := xCoverageCopy(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Coverage{}
	cls.Ptr = cret
	return cls
}

var xCoverageGet func(uintptr, int) CoverageLevel

// Determine whether a particular index is covered by @coverage.
func (x *Coverage) Get(IndexVar int) CoverageLevel {

	cret := xCoverageGet(x.GoPointer(), IndexVar)
	return cret
}

var xCoverageMax func(uintptr, uintptr)

// Set the coverage for each index in @coverage to be the max (better)
// value of the current coverage for the index and the coverage for
// the corresponding index in @other.
func (x *Coverage) Max(OtherVar *Coverage) {

	xCoverageMax(x.GoPointer(), OtherVar.GoPointer())

}

var xCoverageRef func(uintptr) uintptr

// Increase the reference count on the `PangoCoverage` by one.
func (x *Coverage) Ref() *Coverage {
	var cls *Coverage

	cret := xCoverageRef(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Coverage{}
	cls.Ptr = cret
	return cls
}

var xCoverageSet func(uintptr, int, CoverageLevel)

// Modify a particular index within @coverage
func (x *Coverage) Set(IndexVar int, LevelVar CoverageLevel) {

	xCoverageSet(x.GoPointer(), IndexVar, LevelVar)

}

var xCoverageToBytes func(uintptr, []byte, int)

// Convert a `PangoCoverage` structure into a flat binary format.
func (x *Coverage) ToBytes(BytesVar []byte, NBytesVar int) {

	xCoverageToBytes(x.GoPointer(), BytesVar, NBytesVar)

}

var xCoverageUnref func(uintptr)

// Decrease the reference count on the `PangoCoverage` by one.
//
// If the result is zero, free the coverage and all associated memory.
func (x *Coverage) Unref() {

	xCoverageUnref(x.GoPointer())

}

func (c *Coverage) GoPointer() uintptr {
	return c.Ptr
}

func (c *Coverage) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

var xCoverageFromBytes func([]byte, int) uintptr

// Convert data generated from [method@Pango.Coverage.to_bytes]
// back to a `PangoCoverage`.
func CoverageFromBytes(BytesVar []byte, NBytesVar int) *Coverage {
	var cls *Coverage

	cret := xCoverageFromBytes(BytesVar, NBytesVar)

	if cret == 0 {
		return nil
	}
	cls = &Coverage{}
	cls.Ptr = cret
	return cls
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("PANGO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewCoverage, lib, "pango_coverage_new")

	core.PuregoSafeRegister(&xCoverageCopy, lib, "pango_coverage_copy")
	core.PuregoSafeRegister(&xCoverageGet, lib, "pango_coverage_get")
	core.PuregoSafeRegister(&xCoverageMax, lib, "pango_coverage_max")
	core.PuregoSafeRegister(&xCoverageRef, lib, "pango_coverage_ref")
	core.PuregoSafeRegister(&xCoverageSet, lib, "pango_coverage_set")
	core.PuregoSafeRegister(&xCoverageToBytes, lib, "pango_coverage_to_bytes")
	core.PuregoSafeRegister(&xCoverageUnref, lib, "pango_coverage_unref")

	core.PuregoSafeRegister(&xCoverageFromBytes, lib, "pango_coverage_from_bytes")

}
