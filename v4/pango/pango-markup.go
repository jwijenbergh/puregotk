// Package pango was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package pango

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
)

var xMarkupParserFinish func(*glib.MarkupParseContext, **AttrList, string, uint32, **glib.Error) bool

// Finishes parsing markup.
//
// After feeding a Pango markup parser some data with [method@GLib.MarkupParseContext.parse],
// use this function to get the list of attributes and text out of the
// markup. This function will not free @context, use [method@GLib.MarkupParseContext.free]
// to do so.
func MarkupParserFinish(ContextVar *glib.MarkupParseContext, AttrListVar **AttrList, TextVar string, AccelCharVar uint32) (bool, error) {
	var cerr *glib.Error

	cret := xMarkupParserFinish(ContextVar, AttrListVar, TextVar, AccelCharVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xMarkupParserNew func(uint32) *glib.MarkupParseContext

// Incrementally parses marked-up text to create a plain-text string
// and an attribute list.
//
// See the [Pango Markup](pango_markup.html) docs for details about the
// supported markup.
//
// If @accel_marker is nonzero, the given character will mark the
// character following it as an accelerator. For example, @accel_marker
// might be an ampersand or underscore. All characters marked
// as an accelerator will receive a %PANGO_UNDERLINE_LOW attribute,
// and the first character so marked will be returned in @accel_char,
// when calling [func@markup_parser_finish]. Two @accel_marker characters
// following each other produce a single literal @accel_marker character.
//
// To feed markup to the parser, use [method@GLib.MarkupParseContext.parse]
// on the returned [struct@GLib.MarkupParseContext]. When done with feeding markup
// to the parser, use [func@markup_parser_finish] to get the data out
// of it, and then use [method@GLib.MarkupParseContext.free] to free it.
//
// This function is designed for applications that read Pango markup
// from streams. To simply parse a string containing Pango markup,
// the [func@Pango.parse_markup] API is recommended instead.
func MarkupParserNew(AccelMarkerVar uint32) *glib.MarkupParseContext {

	cret := xMarkupParserNew(AccelMarkerVar)
	return cret
}

var xParseMarkup func(string, int, uint32, **AttrList, string, uint32, **glib.Error) bool

// Parses marked-up text to create a plain-text string and an attribute list.
//
// See the [Pango Markup](pango_markup.html) docs for details about the
// supported markup.
//
// If @accel_marker is nonzero, the given character will mark the
// character following it as an accelerator. For example, @accel_marker
// might be an ampersand or underscore. All characters marked
// as an accelerator will receive a %PANGO_UNDERLINE_LOW attribute,
// and the first character so marked will be returned in @accel_char.
// Two @accel_marker characters following each other produce a single
// literal @accel_marker character.
//
// To parse a stream of pango markup incrementally, use [func@markup_parser_new].
//
// If any error happens, none of the output arguments are touched except
// for @error.
func ParseMarkup(MarkupTextVar string, LengthVar int, AccelMarkerVar uint32, AttrListVar **AttrList, TextVar string, AccelCharVar uint32) (bool, error) {
	var cerr *glib.Error

	cret := xParseMarkup(MarkupTextVar, LengthVar, AccelMarkerVar, AttrListVar, TextVar, AccelCharVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("PANGO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xMarkupParserFinish, lib, "pango_markup_parser_finish")
	core.PuregoSafeRegister(&xMarkupParserNew, lib, "pango_markup_parser_new")
	core.PuregoSafeRegister(&xParseMarkup, lib, "pango_parse_markup")

}
