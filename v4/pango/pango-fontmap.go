// Package pango was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package pango

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The `PangoFontMapClass` structure holds the virtual functions for
// a particular `PangoFontMap` implementation.
type FontMapClass struct {
	_ structs.HostLayout

	ParentClass uintptr

	ShapeEngineType uintptr
}

func (x *FontMapClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A `PangoFontMap` represents the set of fonts available for a
// particular rendering system.
//
// This is a virtual object with implementations being specific to
// particular rendering systems.
type FontMap struct {
	gobject.Object
}

var xFontMapGLibType func() types.GType

func FontMapGLibType() types.GType {
	return xFontMapGLibType()
}

func FontMapNewFromInternalPtr(ptr uintptr) *FontMap {
	cls := &FontMap{}
	cls.Ptr = ptr
	return cls
}

var xFontMapChanged func(uintptr)

// Forces a change in the context, which will cause any `PangoContext`
// using this fontmap to change.
//
// This function is only useful when implementing a new backend
// for Pango, something applications won't do. Backends should
// call this function if they have attached extra data to the
// context and such data is changed.
func (x *FontMap) Changed() {

	xFontMapChanged(x.GoPointer())

}

var xFontMapCreateContext func(uintptr) uintptr

// Creates a `PangoContext` connected to @fontmap.
//
// This is equivalent to [ctor@Pango.Context.new] followed by
// [method@Pango.Context.set_font_map].
//
// If you are using Pango as part of a higher-level system,
// that system may have it's own way of create a `PangoContext`.
// For instance, the GTK toolkit has, among others,
// gtk_widget_get_pango_context(). Use those instead.
func (x *FontMap) CreateContext() *Context {
	var cls *Context

	cret := xFontMapCreateContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Context{}
	cls.Ptr = cret
	return cls
}

var xFontMapGetFamily func(uintptr, string) uintptr

// Gets a font family by name.
func (x *FontMap) GetFamily(NameVar string) *FontFamily {
	var cls *FontFamily

	cret := xFontMapGetFamily(x.GoPointer(), NameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FontFamily{}
	cls.Ptr = cret
	return cls
}

var xFontMapGetSerial func(uintptr) uint

// Returns the current serial number of @fontmap.
//
// The serial number is initialized to an small number larger than zero
// when a new fontmap is created and is increased whenever the fontmap
// is changed. It may wrap, but will never have the value 0. Since it can
// wrap, never compare it with "less than", always use "not equals".
//
// The fontmap can only be changed using backend-specific API, like changing
// fontmap resolution.
//
// This can be used to automatically detect changes to a `PangoFontMap`,
// like in `PangoContext`.
func (x *FontMap) GetSerial() uint {

	cret := xFontMapGetSerial(x.GoPointer())
	return cret
}

var xFontMapListFamilies func(uintptr, uintptr, int)

// List all families for a fontmap.
func (x *FontMap) ListFamilies(FamiliesVar uintptr, NFamiliesVar int) {

	xFontMapListFamilies(x.GoPointer(), FamiliesVar, NFamiliesVar)

}

var xFontMapLoadFont func(uintptr, uintptr, *FontDescription) uintptr

// Load the font in the fontmap that is the closest match for @desc.
func (x *FontMap) LoadFont(ContextVar *Context, DescVar *FontDescription) *Font {
	var cls *Font

	cret := xFontMapLoadFont(x.GoPointer(), ContextVar.GoPointer(), DescVar)

	if cret == 0 {
		return nil
	}
	cls = &Font{}
	cls.Ptr = cret
	return cls
}

var xFontMapLoadFontset func(uintptr, uintptr, *FontDescription, *Language) uintptr

// Load a set of fonts in the fontmap that can be used to render
// a font matching @desc.
func (x *FontMap) LoadFontset(ContextVar *Context, DescVar *FontDescription, LanguageVar *Language) *Fontset {
	var cls *Fontset

	cret := xFontMapLoadFontset(x.GoPointer(), ContextVar.GoPointer(), DescVar, LanguageVar)

	if cret == 0 {
		return nil
	}
	cls = &Fontset{}
	cls.Ptr = cret
	return cls
}

func (c *FontMap) GoPointer() uintptr {
	return c.Ptr
}

func (c *FontMap) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("PANGO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xFontMapGLibType, lib, "pango_font_map_get_type")

	core.PuregoSafeRegister(&xFontMapChanged, lib, "pango_font_map_changed")
	core.PuregoSafeRegister(&xFontMapCreateContext, lib, "pango_font_map_create_context")
	core.PuregoSafeRegister(&xFontMapGetFamily, lib, "pango_font_map_get_family")
	core.PuregoSafeRegister(&xFontMapGetSerial, lib, "pango_font_map_get_serial")
	core.PuregoSafeRegister(&xFontMapListFamilies, lib, "pango_font_map_list_families")
	core.PuregoSafeRegister(&xFontMapLoadFont, lib, "pango_font_map_load_font")
	core.PuregoSafeRegister(&xFontMapLoadFontset, lib, "pango_font_map_load_fontset")

}
