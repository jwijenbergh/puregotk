// Package gobject was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gobject

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The type of the @finalize function of #GObjectClass.
type ObjectFinalizeFunc func(uintptr)

// The type of the @get_property function of #GObjectClass.
type ObjectGetPropertyFunc func(uintptr, uint, *Value, uintptr)

// The type of the @set_property function of #GObjectClass.
type ObjectSetPropertyFunc func(uintptr, uint, *Value, uintptr)

// A callback function used for notification when the state
// of a toggle reference changes.
//
// See also: g_object_add_toggle_ref()
type ToggleNotify func(uintptr, uintptr, bool)

// A #GWeakNotify function can be added to an object as a callback that gets
// triggered when the object is finalized.
//
// Since the object is already being disposed when the #GWeakNotify is called,
// there's not much you could do with the object, apart from e.g. using its
// address as hash-index or the like.
//
// In particular, this means it’s invalid to call g_object_ref(),
// g_weak_ref_init(), g_weak_ref_set(), g_object_add_toggle_ref(),
// g_object_weak_ref(), g_object_add_weak_pointer() or any function which calls
// them on the object from this callback.
type WeakNotify func(uintptr, uintptr)

// The class structure for the GInitiallyUnowned type.
type InitiallyUnownedClass struct {
	_ structs.HostLayout

	GTypeClass uintptr

	ConstructProperties *glib.SList

	Flags uint

	Pdummy [6]uintptr
}

func (x *InitiallyUnownedClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// The class structure for the GObject type.
//
// |[&lt;!-- language="C" --&gt;
// // Example of implementing a singleton using a constructor.
// static MySingleton *the_singleton = NULL;
//
// static GObject*
// my_singleton_constructor (GType                  type,
//
//	guint                  n_construct_params,
//	GObjectConstructParam *construct_params)
//
//	{
//	  GObject *object;
//
//	  if (!the_singleton)
//	    {
//	      object = G_OBJECT_CLASS (parent_class)-&gt;constructor (type,
//	                                                           n_construct_params,
//	                                                           construct_params);
//	      the_singleton = MY_SINGLETON (object);
//	    }
//	  else
//	    object = g_object_ref (G_OBJECT (the_singleton));
//
//	  return object;
//	}
//
// ]|
type ObjectClass struct {
	_ structs.HostLayout

	GTypeClass uintptr

	ConstructProperties *glib.SList

	Flags uint

	Pdummy [6]uintptr
}

func (x *ObjectClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xObjectClassFindProperty func(uintptr, string) uintptr

// Looks up the #GParamSpec for a property of a class.
func (x *ObjectClass) FindProperty(PropertyNameVar string) *ParamSpec {
	var cls *ParamSpec

	cret := xObjectClassFindProperty(x.GoPointer(), PropertyNameVar)

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &ParamSpec{}
	cls.Ptr = cret
	return cls
}

var xObjectClassInstallProperties func(uintptr, uint, uintptr)

// Installs new properties from an array of #GParamSpecs.
//
// All properties should be installed during the class initializer.  It
// is possible to install properties after that, but doing so is not
// recommend, and specifically, is not guaranteed to be thread-safe vs.
// use of properties on the same type on other threads.
//
// The property id of each property is the index of each #GParamSpec in
// the @pspecs array.
//
// The property id of 0 is treated specially by #GObject and it should not
// be used to store a #GParamSpec.
//
// This function should be used if you plan to use a static array of
// #GParamSpecs and g_object_notify_by_pspec(). For instance, this
// class initialization:
//
// |[&lt;!-- language="C" --&gt;
//
//	enum {
//	  PROP_0, PROP_FOO, PROP_BAR, N_PROPERTIES
//	};
//
// static GParamSpec *obj_properties[N_PROPERTIES] = { NULL, };
//
// static void
// my_object_class_init (MyObjectClass *klass)
//
//	{
//	  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
//
//	  obj_properties[PROP_FOO] =
//	    g_param_spec_int ("foo", "Foo", "Foo",
//	                      -1, G_MAXINT,
//	                      0,
//	                      G_PARAM_READWRITE);
//
//	  obj_properties[PROP_BAR] =
//	    g_param_spec_string ("bar", "Bar", "Bar",
//	                         NULL,
//	                         G_PARAM_READWRITE);
//
//	  gobject_class-&gt;set_property = my_object_set_property;
//	  gobject_class-&gt;get_property = my_object_get_property;
//	  g_object_class_install_properties (gobject_class,
//	                                     N_PROPERTIES,
//	                                     obj_properties);
//	}
//
// ]|
//
// allows calling g_object_notify_by_pspec() to notify of property changes:
//
// |[&lt;!-- language="C" --&gt;
// void
// my_object_set_foo (MyObject *self, gint foo)
//
//	{
//	  if (self-&gt;foo != foo)
//	    {
//	      self-&gt;foo = foo;
//	      g_object_notify_by_pspec (G_OBJECT (self), obj_properties[PROP_FOO]);
//	    }
//	 }
//
// ]|
func (x *ObjectClass) InstallProperties(NPspecsVar uint, PspecsVar uintptr) {

	xObjectClassInstallProperties(x.GoPointer(), NPspecsVar, PspecsVar)

}

var xObjectClassInstallProperty func(uintptr, uint, uintptr)

// Installs a new property.
//
// All properties should be installed during the class initializer.  It
// is possible to install properties after that, but doing so is not
// recommend, and specifically, is not guaranteed to be thread-safe vs.
// use of properties on the same type on other threads.
//
// Note that it is possible to redefine a property in a derived class,
// by installing a property with the same name. This can be useful at times,
// e.g. to change the range of allowed values or the default value.
func (x *ObjectClass) InstallProperty(PropertyIdVar uint, PspecVar *ParamSpec) {

	xObjectClassInstallProperty(x.GoPointer(), PropertyIdVar, PspecVar.GoPointer())

}

var xObjectClassListProperties func(uintptr, uint) uintptr

// Get an array of #GParamSpec* for all properties of a class.
func (x *ObjectClass) ListProperties(NPropertiesVar uint) uintptr {

	cret := xObjectClassListProperties(x.GoPointer(), NPropertiesVar)
	return cret
}

var xObjectClassOverrideProperty func(uintptr, uint, string)

// Registers @property_id as referring to a property with the name
// @name in a parent class or in an interface implemented by @oclass.
// This allows this class to "override" a property implementation in
// a parent class or to provide the implementation of a property from
// an interface.
//
// Internally, overriding is implemented by creating a property of type
// #GParamSpecOverride; generally operations that query the properties of
// the object class, such as g_object_class_find_property() or
// g_object_class_list_properties() will return the overridden
// property. However, in one case, the @construct_properties argument of
// the @constructor virtual function, the #GParamSpecOverride is passed
// instead, so that the @param_id field of the #GParamSpec will be
// correct.  For virtually all uses, this makes no difference. If you
// need to get the overridden property, you can call
// g_param_spec_get_redirect_target().
func (x *ObjectClass) OverrideProperty(PropertyIdVar uint, NameVar string) {

	xObjectClassOverrideProperty(x.GoPointer(), PropertyIdVar, NameVar)

}

// The GObjectConstructParam struct is an auxiliary structure used to hand
// #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass.
type ObjectConstructParam struct {
	_ structs.HostLayout

	Pspec *ParamSpec

	Value *Value
}

func (x *ObjectConstructParam) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A structure containing a weak reference to a #GObject.
//
// A `GWeakRef` can either be empty (i.e. point to %NULL), or point to an
// object for as long as at least one "strong" reference to that object
// exists. Before the object's #GObjectClass.dispose method is called,
// every #GWeakRef associated with becomes empty (i.e. points to %NULL).
//
// Like #GValue, #GWeakRef can be statically allocated, stack- or
// heap-allocated, or embedded in larger structures.
//
// Unlike g_object_weak_ref() and g_object_add_weak_pointer(), this weak
// reference is thread-safe: converting a weak pointer to a reference is
// atomic with respect to invalidation of weak pointers to destroyed
// objects.
//
// If the object's #GObjectClass.dispose method results in additional
// references to the object being held (‘re-referencing’), any #GWeakRefs taken
// before it was disposed will continue to point to %NULL.  Any #GWeakRefs taken
// during disposal and after re-referencing, or after disposal has returned due
// to the re-referencing, will continue to point to the object until its refcount
// goes back to zero, at which point they too will be invalidated.
//
// It is invalid to take a #GWeakRef on an object during #GObjectClass.dispose
// without first having or creating a strong reference to the object.
type WeakRef struct {
	_ structs.HostLayout
}

func (x *WeakRef) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xWeakRefClear func(uintptr)

// Frees resources associated with a non-statically-allocated #GWeakRef.
// After this call, the #GWeakRef is left in an undefined state.
//
// You should only call this on a #GWeakRef that previously had
// g_weak_ref_init() called on it.
func (x *WeakRef) Clear() {

	xWeakRefClear(x.GoPointer())

}

var xWeakRefGet func(uintptr) uintptr

// If @weak_ref is not empty, atomically acquire a strong
// reference to the object it points to, and return that reference.
//
// This function is needed because of the potential race between taking
// the pointer value and g_object_ref() on it, if the object was losing
// its last reference at the same time in a different thread.
//
// The caller should release the resulting reference in the usual way,
// by using g_object_unref().
func (x *WeakRef) Get() *Object {
	var cls *Object

	cret := xWeakRefGet(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xWeakRefInit func(uintptr, uintptr)

// Initialise a non-statically-allocated #GWeakRef.
//
// This function also calls g_weak_ref_set() with @object on the
// freshly-initialised weak reference.
//
// This function should always be matched with a call to
// g_weak_ref_clear().  It is not necessary to use this function for a
// #GWeakRef in static storage because it will already be
// properly initialised.  Just use g_weak_ref_set() directly.
func (x *WeakRef) Init(ObjectVar *Object) {

	xWeakRefInit(x.GoPointer(), ObjectVar.GoPointer())

}

var xWeakRefSet func(uintptr, uintptr)

// Change the object to which @weak_ref points, or set it to
// %NULL.
//
// You must own a strong reference on @object while calling this
// function.
func (x *WeakRef) Set(ObjectVar *Object) {

	xWeakRefSet(x.GoPointer(), ObjectVar.GoPointer())

}

var xCclosureNewObject func(uintptr, uintptr) *Closure

// A variant of g_cclosure_new() which uses @object as @user_data and
// calls g_object_watch_closure() on @object and the created
// closure. This function is useful when you have a callback closely
// associated with a #GObject, and want the callback to no longer run
// after the object is is freed.
func CclosureNewObject(CallbackFuncVar *Callback, ObjectVar *Object) *Closure {

	cret := xCclosureNewObject(glib.NewCallback(CallbackFuncVar), ObjectVar.GoPointer())
	return cret
}

var xCclosureNewObjectSwap func(uintptr, uintptr) *Closure

// A variant of g_cclosure_new_swap() which uses @object as @user_data
// and calls g_object_watch_closure() on @object and the created
// closure. This function is useful when you have a callback closely
// associated with a #GObject, and want the callback to no longer run
// after the object is is freed.
func CclosureNewObjectSwap(CallbackFuncVar *Callback, ObjectVar *Object) *Closure {

	cret := xCclosureNewObjectSwap(glib.NewCallback(CallbackFuncVar), ObjectVar.GoPointer())
	return cret
}

var xClearObject func(*uintptr)

// Clears a reference to a #GObject.
//
// @object_ptr must not be %NULL.
//
// If the reference is %NULL then this function does nothing.
// Otherwise, the reference count of the object is decreased and the
// pointer is set to %NULL.
//
// A macro is also included that allows this function to be used without
// pointer casts.
func ClearObject(ObjectPtrVar **Object) {

	xClearObject(ConvertPtr(ObjectPtrVar))

}

var xSignalConnectObject func(*TypeInstance, string, uintptr, uintptr, ConnectFlags) uint32

// This is similar to g_signal_connect_data(), but uses a closure which
// ensures that the @gobject stays alive during the call to @c_handler
// by temporarily adding a reference count to @gobject.
//
// When the @gobject is destroyed the signal handler will be automatically
// disconnected.  Note that this is not currently threadsafe (ie:
// emitting a signal while @gobject is being destroyed in another thread
// is not safe).
func SignalConnectObject(InstanceVar *TypeInstance, DetailedSignalVar string, CHandlerVar *Callback, GobjectVar *Object, ConnectFlagsVar ConnectFlags) uint32 {

	cret := xSignalConnectObject(InstanceVar, DetailedSignalVar, glib.NewCallback(CHandlerVar), GobjectVar.GoPointer(), ConnectFlagsVar)
	return cret
}

// A type for objects that have an initially floating reference.
//
// All the fields in the `GInitiallyUnowned` structure are private to the
// implementation and should never be accessed directly.
type InitiallyUnowned struct {
	Object
}

var xInitiallyUnownedGLibType func() types.GType

func InitiallyUnownedGLibType() types.GType {
	return xInitiallyUnownedGLibType()
}

func InitiallyUnownedNewFromInternalPtr(ptr uintptr) *InitiallyUnowned {
	cls := &InitiallyUnowned{}
	cls.Ptr = ptr
	return cls
}

func (c *InitiallyUnowned) GoPointer() uintptr {
	return c.Ptr
}

func (c *InitiallyUnowned) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// The base object type.
//
// All the fields in the `GObject` structure are private to the implementation
// and should never be accessed directly.
//
// Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the
// alignment of the largest basic GLib type (typically this is #guint64 or
// #gdouble). If you need larger alignment for an element in a #GObject, you
// should allocate it on the heap (aligned), or arrange for your #GObject to be
// appropriately padded. This guarantee applies to the #GObject (or derived)
// struct, the #GObjectClass (or derived) struct, and any private data allocated
// by G_ADD_PRIVATE().
type Object struct {
	Ptr uintptr
}

var xObjectGLibType func() types.GType

func ObjectGLibType() types.GType {
	return xObjectGLibType()
}

func ObjectNewFromInternalPtr(ptr uintptr) *Object {
	cls := &Object{}
	cls.Ptr = ptr
	return cls
}

var xNewObject func(types.GType, string, ...interface{}) uintptr

// Creates a new instance of a #GObject subtype and sets its properties.
//
// Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
// which are not explicitly specified are set to their default values. Any
// private data for the object is guaranteed to be initialized with zeros, as
// per g_type_create_instance().
//
// Note that in C, small integer types in variable argument lists are promoted
// up to #gint or #guint as appropriate, and read back accordingly. #gint is 32
// bits on every platform on which GLib is currently supported. This means that
// you can use C expressions of type #gint with g_object_new() and properties of
// type #gint or #guint or smaller. Specifically, you can use integer literals
// with these property types.
//
// When using property types of #gint64 or #guint64, you must ensure that the
// value that you provide is 64 bit. This means that you should use a cast or
// make use of the %G_GINT64_CONSTANT or %G_GUINT64_CONSTANT macros.
//
// Similarly, #gfloat is promoted to #gdouble, so you must ensure that the value
// you provide is a #gdouble, even for a property of type #gfloat.
//
// Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the
// alignment of the largest basic GLib type (typically this is #guint64 or
// #gdouble). If you need larger alignment for an element in a #GObject, you
// should allocate it on the heap (aligned), or arrange for your #GObject to be
// appropriately padded.
func NewObject(ObjectTypeVar types.GType, FirstPropertyNameVar string, varArgs ...interface{}) *Object {
	var cls *Object

	cret := xNewObject(ObjectTypeVar, FirstPropertyNameVar, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xNewObjectValist func(types.GType, string, []interface{}) uintptr

// Creates a new instance of a #GObject subtype and sets its properties.
//
// Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
// which are not explicitly specified are set to their default values.
func NewObjectValist(ObjectTypeVar types.GType, FirstPropertyNameVar string, VarArgsVar []interface{}) *Object {
	var cls *Object

	cret := xNewObjectValist(ObjectTypeVar, FirstPropertyNameVar, VarArgsVar)

	if cret == 0 {
		return nil
	}
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xNewObjectWithProperties func(types.GType, uint, []string, []Value) uintptr

// Creates a new instance of a #GObject subtype and sets its properties using
// the provided arrays. Both arrays must have exactly @n_properties elements,
// and the names and values correspond by index.
//
// Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
// which are not explicitly specified are set to their default values.
func NewObjectWithProperties(ObjectTypeVar types.GType, NPropertiesVar uint, NamesVar []string, ValuesVar []Value) *Object {
	var cls *Object

	cret := xNewObjectWithProperties(ObjectTypeVar, NPropertiesVar, NamesVar, ValuesVar)

	if cret == 0 {
		return nil
	}
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xNewObjectv func(types.GType, uint, []Parameter) uintptr

// Creates a new instance of a #GObject subtype and sets its properties.
//
// Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
// which are not explicitly specified are set to their default values.
func NewObjectv(ObjectTypeVar types.GType, NParametersVar uint, ParametersVar []Parameter) *Object {
	var cls *Object

	cret := xNewObjectv(ObjectTypeVar, NParametersVar, ParametersVar)

	if cret == 0 {
		return nil
	}
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xObjectAddToggleRef func(uintptr, uintptr, uintptr)

// Increases the reference count of the object by one and sets a
// callback to be called when all other references to the object are
// dropped, or when this is already the last reference to the object
// and another reference is established.
//
// This functionality is intended for binding @object to a proxy
// object managed by another memory manager. This is done with two
// paired references: the strong reference added by
// g_object_add_toggle_ref() and a reverse reference to the proxy
// object which is either a strong reference or weak reference.
//
// The setup is that when there are no other references to @object,
// only a weak reference is held in the reverse direction from @object
// to the proxy object, but when there are other references held to
// @object, a strong reference is held. The @notify callback is called
// when the reference from @object to the proxy object should be
// "toggled" from strong to weak (@is_last_ref true) or weak to strong
// (@is_last_ref false).
//
// Since a (normal) reference must be held to the object before
// calling g_object_add_toggle_ref(), the initial state of the reverse
// link is always strong.
//
// Multiple toggle references may be added to the same gobject,
// however if there are multiple toggle references to an object, none
// of them will ever be notified until all but one are removed.  For
// this reason, you should only ever use a toggle reference if there
// is important state in the proxy object.
func (x *Object) AddToggleRef(NotifyVar *ToggleNotify, DataVar uintptr) {

	xObjectAddToggleRef(x.GoPointer(), glib.NewCallback(NotifyVar), DataVar)

}

var xObjectAddWeakPointer func(uintptr, uintptr)

// Adds a weak reference from weak_pointer to @object to indicate that
// the pointer located at @weak_pointer_location is only valid during
// the lifetime of @object. When the @object is finalized,
// @weak_pointer will be set to %NULL.
//
// Note that as with g_object_weak_ref(), the weak references created by
// this method are not thread-safe: they cannot safely be used in one
// thread if the object's last g_object_unref() might happen in another
// thread. Use #GWeakRef if thread-safety is required.
func (x *Object) AddWeakPointer(WeakPointerLocationVar uintptr) {

	xObjectAddWeakPointer(x.GoPointer(), WeakPointerLocationVar)

}

var xObjectBindProperty func(uintptr, string, uintptr, string, BindingFlags) uintptr

// Creates a binding between @source_property on @source and @target_property
// on @target.
//
// Whenever the @source_property is changed the @target_property is
// updated using the same value. For instance:
//
// |[&lt;!-- language="C" --&gt;
//
//	g_object_bind_property (action, "active", widget, "sensitive", 0);
//
// ]|
//
// Will result in the "sensitive" property of the widget #GObject instance to be
// updated with the same value of the "active" property of the action #GObject
// instance.
//
// If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
// if @target_property on @target changes then the @source_property on @source
// will be updated as well.
//
// The binding will automatically be removed when either the @source or the
// @target instances are finalized. To remove the binding without affecting the
// @source and the @target you can just call g_object_unref() on the returned
// #GBinding instance.
//
// Removing the binding by calling g_object_unref() on it must only be done if
// the binding, @source and @target are only used from a single thread and it
// is clear that both @source and @target outlive the binding. Especially it
// is not safe to rely on this if the binding, @source or @target can be
// finalized from different threads. Keep another reference to the binding and
// use g_binding_unbind() instead to be on the safe side.
//
// A #GObject can have multiple bindings.
func (x *Object) BindProperty(SourcePropertyVar string, TargetVar *Object, TargetPropertyVar string, FlagsVar BindingFlags) *Binding {
	var cls *Binding

	cret := xObjectBindProperty(x.GoPointer(), SourcePropertyVar, TargetVar.GoPointer(), TargetPropertyVar, FlagsVar)

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &Binding{}
	cls.Ptr = cret
	return cls
}

var xObjectBindPropertyFull func(uintptr, string, uintptr, string, BindingFlags, uintptr, uintptr, uintptr, uintptr) uintptr

// Complete version of g_object_bind_property().
//
// Creates a binding between @source_property on @source and @target_property
// on @target, allowing you to set the transformation functions to be used by
// the binding.
//
// If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
// if @target_property on @target changes then the @source_property on @source
// will be updated as well. The @transform_from function is only used in case
// of bidirectional bindings, otherwise it will be ignored
//
// The binding will automatically be removed when either the @source or the
// @target instances are finalized. This will release the reference that is
// being held on the #GBinding instance; if you want to hold on to the
// #GBinding instance, you will need to hold a reference to it.
//
// To remove the binding, call g_binding_unbind().
//
// A #GObject can have multiple bindings.
//
// The same @user_data parameter will be used for both @transform_to
// and @transform_from transformation functions; the @notify function will
// be called once, when the binding is removed. If you need different data
// for each transformation function, please use
// g_object_bind_property_with_closures() instead.
func (x *Object) BindPropertyFull(SourcePropertyVar string, TargetVar *Object, TargetPropertyVar string, FlagsVar BindingFlags, TransformToVar *BindingTransformFunc, TransformFromVar *BindingTransformFunc, UserDataVar uintptr, NotifyVar *glib.DestroyNotify) *Binding {
	var cls *Binding

	cret := xObjectBindPropertyFull(x.GoPointer(), SourcePropertyVar, TargetVar.GoPointer(), TargetPropertyVar, FlagsVar, glib.NewCallback(TransformToVar), glib.NewCallback(TransformFromVar), UserDataVar, glib.NewCallback(NotifyVar))

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &Binding{}
	cls.Ptr = cret
	return cls
}

var xObjectBindPropertyWithClosures func(uintptr, string, uintptr, string, BindingFlags, *Closure, *Closure) uintptr

// Creates a binding between @source_property on @source and @target_property
// on @target, allowing you to set the transformation functions to be used by
// the binding.
//
// This function is the language bindings friendly version of
// g_object_bind_property_full(), using #GClosures instead of
// function pointers.
func (x *Object) BindPropertyWithClosures(SourcePropertyVar string, TargetVar *Object, TargetPropertyVar string, FlagsVar BindingFlags, TransformToVar *Closure, TransformFromVar *Closure) *Binding {
	var cls *Binding

	cret := xObjectBindPropertyWithClosures(x.GoPointer(), SourcePropertyVar, TargetVar.GoPointer(), TargetPropertyVar, FlagsVar, TransformToVar, TransformFromVar)

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &Binding{}
	cls.Ptr = cret
	return cls
}

var xObjectConnect func(uintptr, string, ...interface{}) uintptr

// A convenience function to connect multiple signals at once.
//
// The signal specs expected by this function have the form
// "modifier::signal_name", where modifier can be one of the following:
// - signal: equivalent to g_signal_connect_data (..., NULL, 0)
// - object-signal, object_signal: equivalent to g_signal_connect_object (..., 0)
// - swapped-signal, swapped_signal: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED)
// - swapped_object_signal, swapped-object-signal: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED)
// - signal_after, signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_AFTER)
// - object_signal_after, object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_AFTER)
// - swapped_signal_after, swapped-signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED | G_CONNECT_AFTER)
// - swapped_object_signal_after, swapped-object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED | G_CONNECT_AFTER)
//
// |[&lt;!-- language="C" --&gt;
//
//	  menu-&gt;toplevel = g_object_connect (g_object_new (GTK_TYPE_WINDOW,
//							   "type", GTK_WINDOW_POPUP,
//							   "child", menu,
//							   NULL),
//					     "signal::event", gtk_menu_window_event, menu,
//					     "signal::size_request", gtk_menu_window_size_request, menu,
//					     "signal::destroy", gtk_widget_destroyed, &amp;menu-&gt;toplevel,
//					     NULL);
//
// ]|
func (x *Object) Connect(SignalSpecVar string, varArgs ...interface{}) *Object {
	var cls *Object

	cret := xObjectConnect(x.GoPointer(), SignalSpecVar, varArgs...)

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xObjectDisconnect func(uintptr, string, ...interface{})

// A convenience function to disconnect multiple signals at once.
//
// The signal specs expected by this function have the form
// "any_signal", which means to disconnect any signal with matching
// callback and data, or "any_signal::signal_name", which only
// disconnects the signal named "signal_name".
func (x *Object) Disconnect(SignalSpecVar string, varArgs ...interface{}) {

	xObjectDisconnect(x.GoPointer(), SignalSpecVar, varArgs...)

}

var xObjectDupData func(uintptr, string, uintptr, uintptr) uintptr

// This is a variant of g_object_get_data() which returns
// a 'duplicate' of the value. @dup_func defines the
// meaning of 'duplicate' in this context, it could e.g.
// take a reference on a ref-counted object.
//
// If the @key is not set on the object then @dup_func
// will be called with a %NULL argument.
//
// Note that @dup_func is called while user data of @object
// is locked.
//
// This function can be useful to avoid races when multiple
// threads are using object data on the same key on the same
// object.
func (x *Object) DupData(KeyVar string, DupFuncVar *glib.DuplicateFunc, UserDataVar uintptr) uintptr {

	cret := xObjectDupData(x.GoPointer(), KeyVar, glib.NewCallback(DupFuncVar), UserDataVar)
	return cret
}

var xObjectDupQdata func(uintptr, glib.Quark, uintptr, uintptr) uintptr

// This is a variant of g_object_get_qdata() which returns
// a 'duplicate' of the value. @dup_func defines the
// meaning of 'duplicate' in this context, it could e.g.
// take a reference on a ref-counted object.
//
// If the @quark is not set on the object then @dup_func
// will be called with a %NULL argument.
//
// Note that @dup_func is called while user data of @object
// is locked.
//
// This function can be useful to avoid races when multiple
// threads are using object data on the same key on the same
// object.
func (x *Object) DupQdata(QuarkVar glib.Quark, DupFuncVar *glib.DuplicateFunc, UserDataVar uintptr) uintptr {

	cret := xObjectDupQdata(x.GoPointer(), QuarkVar, glib.NewCallback(DupFuncVar), UserDataVar)
	return cret
}

var xObjectForceFloating func(uintptr)

// This function is intended for #GObject implementations to re-enforce
// a [floating][floating-ref] object reference. Doing this is seldom
// required: all #GInitiallyUnowneds are created with a floating reference
// which usually just needs to be sunken by calling g_object_ref_sink().
func (x *Object) ForceFloating() {

	xObjectForceFloating(x.GoPointer())

}

var xObjectFreezeNotify func(uintptr)

// Increases the freeze count on @object. If the freeze count is
// non-zero, the emission of "notify" signals on @object is
// stopped. The signals are queued until the freeze count is decreased
// to zero. Duplicate notifications are squashed so that at most one
// #GObject::notify signal is emitted for each property modified while the
// object is frozen.
//
// This is necessary for accessors that modify multiple properties to prevent
// premature notification while the object is still being modified.
func (x *Object) FreezeNotify() {

	xObjectFreezeNotify(x.GoPointer())

}

var xObjectGet func(uintptr, string, ...interface{})

// Gets properties of an object.
//
// In general, a copy is made of the property contents and the caller
// is responsible for freeing the memory in the appropriate manner for
// the type, for instance by calling g_free() or g_object_unref().
//
// Here is an example of using g_object_get() to get the contents
// of three properties: an integer, a string and an object:
// |[&lt;!-- language="C" --&gt;
//
//	gint intval;
//	guint64 uint64val;
//	gchar *strval;
//	GObject *objval;
//
//	g_object_get (my_object,
//	              "int-property", &amp;intval,
//	              "uint64-property", &amp;uint64val,
//	              "str-property", &amp;strval,
//	              "obj-property", &amp;objval,
//	              NULL);
//
//	// Do something with intval, uint64val, strval, objval
//
//	g_free (strval);
//	g_object_unref (objval);
//
// ]|
func (x *Object) Get(FirstPropertyNameVar string, varArgs ...interface{}) {

	xObjectGet(x.GoPointer(), FirstPropertyNameVar, varArgs...)

}

var xObjectGetData func(uintptr, string) uintptr

// Gets a named field from the objects table of associations (see g_object_set_data()).
func (x *Object) GetData(KeyVar string) uintptr {

	cret := xObjectGetData(x.GoPointer(), KeyVar)
	return cret
}

var xObjectGetProperty func(uintptr, string, *Value)

// Gets a property of an object.
//
// The @value can be:
//
//   - an empty #GValue initialized by %G_VALUE_INIT, which will be
//     automatically initialized with the expected type of the property
//     (since GLib 2.60)
//   - a #GValue initialized with the expected type of the property
//   - a #GValue initialized with a type to which the expected type
//     of the property can be transformed
//
// In general, a copy is made of the property contents and the caller is
// responsible for freeing the memory by calling g_value_unset().
//
// Note that g_object_get_property() is really intended for language
// bindings, g_object_get() is much more convenient for C programming.
func (x *Object) GetProperty(PropertyNameVar string, ValueVar *Value) {

	xObjectGetProperty(x.GoPointer(), PropertyNameVar, ValueVar)

}

var xObjectGetQdata func(uintptr, glib.Quark) uintptr

// This function gets back user data pointers stored via
// g_object_set_qdata().
func (x *Object) GetQdata(QuarkVar glib.Quark) uintptr {

	cret := xObjectGetQdata(x.GoPointer(), QuarkVar)
	return cret
}

var xObjectGetValist func(uintptr, string, []interface{})

// Gets properties of an object.
//
// In general, a copy is made of the property contents and the caller
// is responsible for freeing the memory in the appropriate manner for
// the type, for instance by calling g_free() or g_object_unref().
//
// See g_object_get().
func (x *Object) GetValist(FirstPropertyNameVar string, VarArgsVar []interface{}) {

	xObjectGetValist(x.GoPointer(), FirstPropertyNameVar, VarArgsVar)

}

var xObjectGetv func(uintptr, uint, []string, []Value)

// Gets @n_properties properties for an @object.
// Obtained properties will be set to @values. All properties must be valid.
// Warnings will be emitted and undefined behaviour may result if invalid
// properties are passed in.
func (x *Object) Getv(NPropertiesVar uint, NamesVar []string, ValuesVar []Value) {

	xObjectGetv(x.GoPointer(), NPropertiesVar, NamesVar, ValuesVar)

}

var xObjectIsFloating func(uintptr) bool

// Checks whether @object has a [floating][floating-ref] reference.
func (x *Object) IsFloating() bool {

	cret := xObjectIsFloating(x.GoPointer())
	return cret
}

var xObjectNotify func(uintptr, string)

// Emits a "notify" signal for the property @property_name on @object.
//
// When possible, eg. when signaling a property change from within the class
// that registered the property, you should use g_object_notify_by_pspec()
// instead.
//
// Note that emission of the notify signal may be blocked with
// g_object_freeze_notify(). In this case, the signal emissions are queued
// and will be emitted (in reverse order) when g_object_thaw_notify() is
// called.
func (x *Object) Notify(PropertyNameVar string) {

	xObjectNotify(x.GoPointer(), PropertyNameVar)

}

var xObjectNotifyByPspec func(uintptr, uintptr)

// Emits a "notify" signal for the property specified by @pspec on @object.
//
// This function omits the property name lookup, hence it is faster than
// g_object_notify().
//
// One way to avoid using g_object_notify() from within the
// class that registered the properties, and using g_object_notify_by_pspec()
// instead, is to store the GParamSpec used with
// g_object_class_install_property() inside a static array, e.g.:
//
// |[&lt;!-- language="C" --&gt;
//
//	enum
//	{
//	  PROP_0,
//	  PROP_FOO,
//	  PROP_LAST
//	};
//
//	static GParamSpec *properties[PROP_LAST];
//
//	static void
//	my_object_class_init (MyObjectClass *klass)
//	{
//	  properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
//	                                           0, 100,
//	                                           50,
//	                                           G_PARAM_READWRITE);
//	  g_object_class_install_property (gobject_class,
//	                                   PROP_FOO,
//	                                   properties[PROP_FOO]);
//	}
//
// ]|
//
// and then notify a change on the "foo" property with:
//
// |[&lt;!-- language="C" --&gt;
//
//	g_object_notify_by_pspec (self, properties[PROP_FOO]);
//
// ]|
func (x *Object) NotifyByPspec(PspecVar *ParamSpec) {

	xObjectNotifyByPspec(x.GoPointer(), PspecVar.GoPointer())

}

var xObjectRef func(uintptr) uintptr

// Increases the reference count of @object.
//
// Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
// of @object will be propagated to the return type (using the GCC typeof()
// extension), so any casting the caller needs to do on the return type must be
// explicit.
func (x *Object) Ref() *Object {
	var cls *Object

	cret := xObjectRef(x.GoPointer())

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xObjectRefSink func(uintptr) uintptr

// Increase the reference count of @object, and possibly remove the
// [floating][floating-ref] reference, if @object has a floating reference.
//
// In other words, if the object is floating, then this call "assumes
// ownership" of the floating reference, converting it to a normal
// reference by clearing the floating flag while leaving the reference
// count unchanged.  If the object is not floating, then this call
// adds a new normal reference increasing the reference count by one.
//
// Since GLib 2.56, the type of @object will be propagated to the return type
// under the same conditions as for g_object_ref().
func (x *Object) RefSink() *Object {
	var cls *Object

	cret := xObjectRefSink(x.GoPointer())

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xObjectRemoveToggleRef func(uintptr, uintptr, uintptr)

// Removes a reference added with g_object_add_toggle_ref(). The
// reference count of the object is decreased by one.
func (x *Object) RemoveToggleRef(NotifyVar *ToggleNotify, DataVar uintptr) {

	xObjectRemoveToggleRef(x.GoPointer(), glib.NewCallback(NotifyVar), DataVar)

}

var xObjectRemoveWeakPointer func(uintptr, uintptr)

// Removes a weak reference from @object that was previously added
// using g_object_add_weak_pointer(). The @weak_pointer_location has
// to match the one used with g_object_add_weak_pointer().
func (x *Object) RemoveWeakPointer(WeakPointerLocationVar uintptr) {

	xObjectRemoveWeakPointer(x.GoPointer(), WeakPointerLocationVar)

}

var xObjectReplaceData func(uintptr, string, uintptr, uintptr, uintptr, uintptr) bool

// Compares the user data for the key @key on @object with
// @oldval, and if they are the same, replaces @oldval with
// @newval.
//
// This is like a typical atomic compare-and-exchange
// operation, for user data on an object.
//
// If the previous value was replaced then ownership of the
// old value (@oldval) is passed to the caller, including
// the registered destroy notify for it (passed out in @old_destroy).
// It’s up to the caller to free this as needed, which may
// or may not include using @old_destroy as sometimes replacement
// should not destroy the object in the normal way.
//
// See g_object_set_data() for guidance on using a small, bounded set of values
// for @key.
func (x *Object) ReplaceData(KeyVar string, OldvalVar uintptr, NewvalVar uintptr, DestroyVar *glib.DestroyNotify, OldDestroyVar *glib.DestroyNotify) bool {

	cret := xObjectReplaceData(x.GoPointer(), KeyVar, OldvalVar, NewvalVar, glib.NewCallback(DestroyVar), glib.NewCallback(OldDestroyVar))
	return cret
}

var xObjectReplaceQdata func(uintptr, glib.Quark, uintptr, uintptr, uintptr, uintptr) bool

// Compares the user data for the key @quark on @object with
// @oldval, and if they are the same, replaces @oldval with
// @newval.
//
// This is like a typical atomic compare-and-exchange
// operation, for user data on an object.
//
// If the previous value was replaced then ownership of the
// old value (@oldval) is passed to the caller, including
// the registered destroy notify for it (passed out in @old_destroy).
// It’s up to the caller to free this as needed, which may
// or may not include using @old_destroy as sometimes replacement
// should not destroy the object in the normal way.
func (x *Object) ReplaceQdata(QuarkVar glib.Quark, OldvalVar uintptr, NewvalVar uintptr, DestroyVar *glib.DestroyNotify, OldDestroyVar *glib.DestroyNotify) bool {

	cret := xObjectReplaceQdata(x.GoPointer(), QuarkVar, OldvalVar, NewvalVar, glib.NewCallback(DestroyVar), glib.NewCallback(OldDestroyVar))
	return cret
}

var xObjectRunDispose func(uintptr)

// Releases all references to other objects. This can be used to break
// reference cycles.
//
// This function should only be called from object system implementations.
func (x *Object) RunDispose() {

	xObjectRunDispose(x.GoPointer())

}

var xObjectSet func(uintptr, string, ...interface{})

// Sets properties on an object.
//
// The same caveats about passing integer literals as varargs apply as with
// g_object_new(). In particular, any integer literals set as the values for
// properties of type #gint64 or #guint64 must be 64 bits wide, using the
// %G_GINT64_CONSTANT or %G_GUINT64_CONSTANT macros.
//
// Note that the "notify" signals are queued and only emitted (in
// reverse order) after all properties have been set. See
// g_object_freeze_notify().
func (x *Object) Set(FirstPropertyNameVar string, varArgs ...interface{}) {

	xObjectSet(x.GoPointer(), FirstPropertyNameVar, varArgs...)

}

var xObjectSetData func(uintptr, string, uintptr)

// Each object carries around a table of associations from
// strings to pointers.  This function lets you set an association.
//
// If the object already had an association with that name,
// the old association will be destroyed.
//
// Internally, the @key is converted to a #GQuark using g_quark_from_string().
// This means a copy of @key is kept permanently (even after @object has been
// finalized) — so it is recommended to only use a small, bounded set of values
// for @key in your program, to avoid the #GQuark storage growing unbounded.
func (x *Object) SetData(KeyVar string, DataVar uintptr) {

	xObjectSetData(x.GoPointer(), KeyVar, DataVar)

}

var xObjectSetDataFull func(uintptr, string, uintptr, uintptr)

// Like g_object_set_data() except it adds notification
// for when the association is destroyed, either by setting it
// to a different value or when the object is destroyed.
//
// Note that the @destroy callback is not called if @data is %NULL.
func (x *Object) SetDataFull(KeyVar string, DataVar uintptr, DestroyVar *glib.DestroyNotify) {

	xObjectSetDataFull(x.GoPointer(), KeyVar, DataVar, glib.NewCallback(DestroyVar))

}

var xObjectSetProperty func(uintptr, string, *Value)

// Sets a property on an object.
func (x *Object) SetProperty(PropertyNameVar string, ValueVar *Value) {

	xObjectSetProperty(x.GoPointer(), PropertyNameVar, ValueVar)

}

var xObjectSetQdata func(uintptr, glib.Quark, uintptr)

// This sets an opaque, named pointer on an object.
// The name is specified through a #GQuark (retrieved e.g. via
// g_quark_from_static_string()), and the pointer
// can be gotten back from the @object with g_object_get_qdata()
// until the @object is finalized.
// Setting a previously set user data pointer, overrides (frees)
// the old pointer set, using #NULL as pointer essentially
// removes the data stored.
func (x *Object) SetQdata(QuarkVar glib.Quark, DataVar uintptr) {

	xObjectSetQdata(x.GoPointer(), QuarkVar, DataVar)

}

var xObjectSetQdataFull func(uintptr, glib.Quark, uintptr, uintptr)

// This function works like g_object_set_qdata(), but in addition,
// a void (*destroy) (gpointer) function may be specified which is
// called with @data as argument when the @object is finalized, or
// the data is being overwritten by a call to g_object_set_qdata()
// with the same @quark.
func (x *Object) SetQdataFull(QuarkVar glib.Quark, DataVar uintptr, DestroyVar *glib.DestroyNotify) {

	xObjectSetQdataFull(x.GoPointer(), QuarkVar, DataVar, glib.NewCallback(DestroyVar))

}

var xObjectSetValist func(uintptr, string, []interface{})

// Sets properties on an object.
func (x *Object) SetValist(FirstPropertyNameVar string, VarArgsVar []interface{}) {

	xObjectSetValist(x.GoPointer(), FirstPropertyNameVar, VarArgsVar)

}

var xObjectSetv func(uintptr, uint, []string, []Value)

// Sets @n_properties properties for an @object.
// Properties to be set will be taken from @values. All properties must be
// valid. Warnings will be emitted and undefined behaviour may result if invalid
// properties are passed in.
func (x *Object) Setv(NPropertiesVar uint, NamesVar []string, ValuesVar []Value) {

	xObjectSetv(x.GoPointer(), NPropertiesVar, NamesVar, ValuesVar)

}

var xObjectStealData func(uintptr, string) uintptr

// Remove a specified datum from the object's data associations,
// without invoking the association's destroy handler.
func (x *Object) StealData(KeyVar string) uintptr {

	cret := xObjectStealData(x.GoPointer(), KeyVar)
	return cret
}

var xObjectStealQdata func(uintptr, glib.Quark) uintptr

// This function gets back user data pointers stored via
// g_object_set_qdata() and removes the @data from object
// without invoking its destroy() function (if any was
// set).
// Usually, calling this function is only required to update
// user data pointers with a destroy notifier, for example:
// |[&lt;!-- language="C" --&gt;
// void
// object_add_to_user_list (GObject     *object,
//
//	const gchar *new_string)
//
//	{
//	  // the quark, naming the object data
//	  GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
//	  // retrieve the old string list
//	  GList *list = g_object_steal_qdata (object, quark_string_list);
//
//	  // prepend new string
//	  list = g_list_prepend (list, g_strdup (new_string));
//	  // this changed 'list', so we need to set it again
//	  g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
//	}
//
// static void
// free_string_list (gpointer data)
//
//	{
//	  GList *node, *list = data;
//
//	  for (node = list; node; node = node-&gt;next)
//	    g_free (node-&gt;data);
//	  g_list_free (list);
//	}
//
// ]|
// Using g_object_get_qdata() in the above example, instead of
// g_object_steal_qdata() would have left the destroy function set,
// and thus the partial string list would have been freed upon
// g_object_set_qdata_full().
func (x *Object) StealQdata(QuarkVar glib.Quark) uintptr {

	cret := xObjectStealQdata(x.GoPointer(), QuarkVar)
	return cret
}

var xObjectTakeRef func(uintptr) uintptr

// If @object is floating, sink it.  Otherwise, do nothing.
//
// In other words, this function will convert a floating reference (if
// present) into a full reference.
//
// Typically you want to use g_object_ref_sink() in order to
// automatically do the correct thing with respect to floating or
// non-floating references, but there is one specific scenario where
// this function is helpful.
//
// The situation where this function is helpful is when creating an API
// that allows the user to provide a callback function that returns a
// GObject. We certainly want to allow the user the flexibility to
// return a non-floating reference from this callback (for the case
// where the object that is being returned already exists).
//
// At the same time, the API style of some popular GObject-based
// libraries (such as Gtk) make it likely that for newly-created GObject
// instances, the user can be saved some typing if they are allowed to
// return a floating reference.
//
// Using this function on the return value of the user's callback allows
// the user to do whichever is more convenient for them. The caller will
// alway receives exactly one full reference to the value: either the
// one that was returned in the first place, or a floating reference
// that has been converted to a full reference.
//
// This function has an odd interaction when combined with
// g_object_ref_sink() running at the same time in another thread on
// the same #GObject instance. If g_object_ref_sink() runs first then
// the result will be that the floating reference is converted to a hard
// reference. If g_object_take_ref() runs first then the result will be
// that the floating reference is converted to a hard reference and an
// additional reference on top of that one is added. It is best to avoid
// this situation.
func (x *Object) TakeRef() *Object {
	var cls *Object

	cret := xObjectTakeRef(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xObjectThawNotify func(uintptr)

// Reverts the effect of a previous call to
// g_object_freeze_notify(). The freeze count is decreased on @object
// and when it reaches zero, queued "notify" signals are emitted.
//
// Duplicate notifications for each property are squashed so that at most one
// #GObject::notify signal is emitted for each property, in the reverse order
// in which they have been queued.
//
// It is an error to call this function when the freeze count is zero.
func (x *Object) ThawNotify() {

	xObjectThawNotify(x.GoPointer())

}

var xObjectUnref func(uintptr)

// Decreases the reference count of @object. When its reference count
// drops to 0, the object is finalized (i.e. its memory is freed).
//
// If the pointer to the #GObject may be reused in future (for example, if it is
// an instance variable of another object), it is recommended to clear the
// pointer to %NULL rather than retain a dangling pointer to a potentially
// invalid #GObject instance. Use g_clear_object() for this.
func (x *Object) Unref() {

	xObjectUnref(x.GoPointer())

}

var xObjectWatchClosure func(uintptr, *Closure)

// This function essentially limits the life time of the @closure to
// the life time of the object. That is, when the object is finalized,
// the @closure is invalidated by calling g_closure_invalidate() on
// it, in order to prevent invocations of the closure with a finalized
// (nonexisting) object. Also, g_object_ref() and g_object_unref() are
// added as marshal guards to the @closure, to ensure that an extra
// reference count is held on @object during invocation of the
// @closure.  Usually, this function will be called on closures that
// use this @object as closure data.
func (x *Object) WatchClosure(ClosureVar *Closure) {

	xObjectWatchClosure(x.GoPointer(), ClosureVar)

}

var xObjectWeakRef func(uintptr, uintptr, uintptr)

// Adds a weak reference callback to an object. Weak references are
// used for notification when an object is disposed. They are called
// "weak references" because they allow you to safely hold a pointer
// to an object without calling g_object_ref() (g_object_ref() adds a
// strong reference, that is, forces the object to stay alive).
//
// Note that the weak references created by this method are not
// thread-safe: they cannot safely be used in one thread if the
// object's last g_object_unref() might happen in another thread.
// Use #GWeakRef if thread-safety is required.
func (x *Object) WeakRef(NotifyVar *WeakNotify, DataVar uintptr) {

	xObjectWeakRef(x.GoPointer(), glib.NewCallback(NotifyVar), DataVar)

}

var xObjectWeakUnref func(uintptr, uintptr, uintptr)

// Removes a weak reference callback to an object.
func (x *Object) WeakUnref(NotifyVar *WeakNotify, DataVar uintptr) {

	xObjectWeakUnref(x.GoPointer(), glib.NewCallback(NotifyVar), DataVar)

}

func (c *Object) GoPointer() uintptr {
	return c.Ptr
}

func (c *Object) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// The notify signal is emitted on an object when one of its properties has
// its value set through g_object_set_property(), g_object_set(), et al.
//
// Note that getting this signal doesn’t itself guarantee that the value of
// the property has actually changed. When it is emitted is determined by the
// derived GObject class. If the implementor did not create the property with
// %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
// in ::notify being emitted, even if the new value is the same as the old.
// If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
// when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
// and common practice is to do that only when the value has actually changed.
//
// This signal is typically used to obtain change notification for a
// single property, by specifying the property name as a detail in the
// g_signal_connect() call, like this:
//
// |[&lt;!-- language="C" --&gt;
// g_signal_connect (text_view-&gt;buffer, "notify::paste-target-list",
//
//	G_CALLBACK (gtk_text_view_target_list_notify),
//	text_view)
//
// ]|
//
// It is important to note that you must use
// [canonical parameter names][canonical-parameter-names] as
// detail strings for the notify signal.
func (x *Object) ConnectNotify(cb *func(Object, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return SignalConnect(x.GoPointer(), "notify", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PspecVarp uintptr) {
		fa := Object{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PspecVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return SignalConnect(x.GoPointer(), "notify", cbRefPtr)
}

var xObjectCompatControl func(uint, uintptr) uint

func ObjectCompatControl(WhatVar uint, DataVar uintptr) uint {

	cret := xObjectCompatControl(WhatVar, DataVar)
	return cret
}

var xObjectInterfaceFindProperty func(*TypeInterface, string) uintptr

// Find the #GParamSpec with the given name for an
// interface. Generally, the interface vtable passed in as @g_iface
// will be the default vtable from g_type_default_interface_ref(), or,
// if you know the interface has already been loaded,
// g_type_default_interface_peek().
func ObjectInterfaceFindProperty(GIfaceVar *TypeInterface, PropertyNameVar string) *ParamSpec {
	var cls *ParamSpec

	cret := xObjectInterfaceFindProperty(GIfaceVar, PropertyNameVar)

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &ParamSpec{}
	cls.Ptr = cret
	return cls
}

var xObjectInterfaceInstallProperty func(*TypeInterface, uintptr)

// Add a property to an interface; this is only useful for interfaces
// that are added to GObject-derived types. Adding a property to an
// interface forces all objects classes with that interface to have a
// compatible property. The compatible property could be a newly
// created #GParamSpec, but normally
// g_object_class_override_property() will be used so that the object
// class only needs to provide an implementation and inherits the
// property description, default value, bounds, and so forth from the
// interface property.
//
// This function is meant to be called from the interface's default
// vtable initialization function (the @class_init member of
// #GTypeInfo.) It must not be called after after @class_init has
// been called for any object types implementing this interface.
//
// If @pspec is a floating reference, it will be consumed.
func ObjectInterfaceInstallProperty(GIfaceVar *TypeInterface, PspecVar *ParamSpec) {

	xObjectInterfaceInstallProperty(GIfaceVar, PspecVar.GoPointer())

}

var xObjectInterfaceListProperties func(*TypeInterface, uint) uintptr

// Lists the properties of an interface.Generally, the interface
// vtable passed in as @g_iface will be the default vtable from
// g_type_default_interface_ref(), or, if you know the interface has
// already been loaded, g_type_default_interface_peek().
func ObjectInterfaceListProperties(GIfaceVar *TypeInterface, NPropertiesPVar uint) uintptr {

	cret := xObjectInterfaceListProperties(GIfaceVar, NPropertiesPVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GOBJECT"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xCclosureNewObject, lib, "g_cclosure_new_object")
	core.PuregoSafeRegister(&xCclosureNewObjectSwap, lib, "g_cclosure_new_object_swap")
	core.PuregoSafeRegister(&xClearObject, lib, "g_clear_object")
	core.PuregoSafeRegister(&xSignalConnectObject, lib, "g_signal_connect_object")

	core.PuregoSafeRegister(&xObjectClassFindProperty, lib, "g_object_class_find_property")
	core.PuregoSafeRegister(&xObjectClassInstallProperties, lib, "g_object_class_install_properties")
	core.PuregoSafeRegister(&xObjectClassInstallProperty, lib, "g_object_class_install_property")
	core.PuregoSafeRegister(&xObjectClassListProperties, lib, "g_object_class_list_properties")
	core.PuregoSafeRegister(&xObjectClassOverrideProperty, lib, "g_object_class_override_property")

	core.PuregoSafeRegister(&xWeakRefClear, lib, "g_weak_ref_clear")
	core.PuregoSafeRegister(&xWeakRefGet, lib, "g_weak_ref_get")
	core.PuregoSafeRegister(&xWeakRefInit, lib, "g_weak_ref_init")
	core.PuregoSafeRegister(&xWeakRefSet, lib, "g_weak_ref_set")

	core.PuregoSafeRegister(&xInitiallyUnownedGLibType, lib, "g_initially_unowned_get_type")

	core.PuregoSafeRegister(&xObjectGLibType, lib, "g_object_get_type")

	core.PuregoSafeRegister(&xNewObject, lib, "g_object_new")
	core.PuregoSafeRegister(&xNewObjectValist, lib, "g_object_new_valist")
	core.PuregoSafeRegister(&xNewObjectWithProperties, lib, "g_object_new_with_properties")
	core.PuregoSafeRegister(&xNewObjectv, lib, "g_object_newv")

	core.PuregoSafeRegister(&xObjectAddToggleRef, lib, "g_object_add_toggle_ref")
	core.PuregoSafeRegister(&xObjectAddWeakPointer, lib, "g_object_add_weak_pointer")
	core.PuregoSafeRegister(&xObjectBindProperty, lib, "g_object_bind_property")
	core.PuregoSafeRegister(&xObjectBindPropertyFull, lib, "g_object_bind_property_full")
	core.PuregoSafeRegister(&xObjectBindPropertyWithClosures, lib, "g_object_bind_property_with_closures")
	core.PuregoSafeRegister(&xObjectConnect, lib, "g_object_connect")
	core.PuregoSafeRegister(&xObjectDisconnect, lib, "g_object_disconnect")
	core.PuregoSafeRegister(&xObjectDupData, lib, "g_object_dup_data")
	core.PuregoSafeRegister(&xObjectDupQdata, lib, "g_object_dup_qdata")
	core.PuregoSafeRegister(&xObjectForceFloating, lib, "g_object_force_floating")
	core.PuregoSafeRegister(&xObjectFreezeNotify, lib, "g_object_freeze_notify")
	core.PuregoSafeRegister(&xObjectGet, lib, "g_object_get")
	core.PuregoSafeRegister(&xObjectGetData, lib, "g_object_get_data")
	core.PuregoSafeRegister(&xObjectGetProperty, lib, "g_object_get_property")
	core.PuregoSafeRegister(&xObjectGetQdata, lib, "g_object_get_qdata")
	core.PuregoSafeRegister(&xObjectGetValist, lib, "g_object_get_valist")
	core.PuregoSafeRegister(&xObjectGetv, lib, "g_object_getv")
	core.PuregoSafeRegister(&xObjectIsFloating, lib, "g_object_is_floating")
	core.PuregoSafeRegister(&xObjectNotify, lib, "g_object_notify")
	core.PuregoSafeRegister(&xObjectNotifyByPspec, lib, "g_object_notify_by_pspec")
	core.PuregoSafeRegister(&xObjectRef, lib, "g_object_ref")
	core.PuregoSafeRegister(&xObjectRefSink, lib, "g_object_ref_sink")
	core.PuregoSafeRegister(&xObjectRemoveToggleRef, lib, "g_object_remove_toggle_ref")
	core.PuregoSafeRegister(&xObjectRemoveWeakPointer, lib, "g_object_remove_weak_pointer")
	core.PuregoSafeRegister(&xObjectReplaceData, lib, "g_object_replace_data")
	core.PuregoSafeRegister(&xObjectReplaceQdata, lib, "g_object_replace_qdata")
	core.PuregoSafeRegister(&xObjectRunDispose, lib, "g_object_run_dispose")
	core.PuregoSafeRegister(&xObjectSet, lib, "g_object_set")
	core.PuregoSafeRegister(&xObjectSetData, lib, "g_object_set_data")
	core.PuregoSafeRegister(&xObjectSetDataFull, lib, "g_object_set_data_full")
	core.PuregoSafeRegister(&xObjectSetProperty, lib, "g_object_set_property")
	core.PuregoSafeRegister(&xObjectSetQdata, lib, "g_object_set_qdata")
	core.PuregoSafeRegister(&xObjectSetQdataFull, lib, "g_object_set_qdata_full")
	core.PuregoSafeRegister(&xObjectSetValist, lib, "g_object_set_valist")
	core.PuregoSafeRegister(&xObjectSetv, lib, "g_object_setv")
	core.PuregoSafeRegister(&xObjectStealData, lib, "g_object_steal_data")
	core.PuregoSafeRegister(&xObjectStealQdata, lib, "g_object_steal_qdata")
	core.PuregoSafeRegister(&xObjectTakeRef, lib, "g_object_take_ref")
	core.PuregoSafeRegister(&xObjectThawNotify, lib, "g_object_thaw_notify")
	core.PuregoSafeRegister(&xObjectUnref, lib, "g_object_unref")
	core.PuregoSafeRegister(&xObjectWatchClosure, lib, "g_object_watch_closure")
	core.PuregoSafeRegister(&xObjectWeakRef, lib, "g_object_weak_ref")
	core.PuregoSafeRegister(&xObjectWeakUnref, lib, "g_object_weak_unref")

	core.PuregoSafeRegister(&xObjectCompatControl, lib, "g_object_compat_control")
	core.PuregoSafeRegister(&xObjectInterfaceFindProperty, lib, "g_object_interface_find_property")
	core.PuregoSafeRegister(&xObjectInterfaceInstallProperty, lib, "g_object_interface_install_property")
	core.PuregoSafeRegister(&xObjectInterfaceListProperties, lib, "g_object_interface_list_properties")

}
