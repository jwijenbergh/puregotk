// Package gobject was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gobject

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// A callback function used by the type system to finalize those portions
// of a derived types class structure that were setup from the corresponding
// GBaseInitFunc() function.
//
// Class finalization basically works the inverse way in which class
// initialization is performed.
//
// See GClassInitFunc() for a discussion of the class initialization process.
type BaseFinalizeFunc func(*TypeClass)

// A callback function used by the type system to do base initialization
// of the class structures of derived types.
//
// This function is called as part of the initialization process of all derived
// classes and should reallocate or reset all dynamic class members copied over
// from the parent class.
//
// For example, class members (such as strings) that are not sufficiently
// handled by a plain memory copy of the parent class into the derived class
// have to be altered. See GClassInitFunc() for a discussion of the class
// initialization process.
type BaseInitFunc func(*TypeClass)

// A callback function used by the type system to finalize a class.
//
// This function is rarely needed, as dynamically allocated class resources
// should be handled by GBaseInitFunc() and GBaseFinalizeFunc().
//
// Also, specification of a GClassFinalizeFunc() in the #GTypeInfo
// structure of a static type is invalid, because classes of static types
// will never be finalized (they are artificially kept alive when their
// reference count drops to zero).
type ClassFinalizeFunc func(*TypeClass, uintptr)

// A callback function used by the type system to initialize the class
// of a specific type.
//
// This function should initialize all static class members.
//
// The initialization process of a class involves:
//
//   - Copying common members from the parent class over to the
//     derived class structure.
//   - Zero initialization of the remaining members not copied
//     over from the parent class.
//   - Invocation of the GBaseInitFunc() initializers of all parent
//     types and the class' type.
//   - Invocation of the class' GClassInitFunc() initializer.
//
// Since derived classes are partially initialized through a memory copy
// of the parent class, the general rule is that GBaseInitFunc() and
// GBaseFinalizeFunc() should take care of necessary reinitialization
// and release of those class members that were introduced by the type
// that specified these GBaseInitFunc()/GBaseFinalizeFunc().
// GClassInitFunc() should only care about initializing static
// class members, while dynamic class members (such as allocated strings
// or reference counted resources) are better handled by a GBaseInitFunc()
// for this type, so proper initialization of the dynamic class members
// is performed for class initialization of derived types as well.
//
// An example may help to correspond the intend of the different class
// initializers:
//
// |[&lt;!-- language="C" --&gt;
//
//	typedef struct {
//	  GObjectClass parent_class;
//	  gint         static_integer;
//	  gchar       *dynamic_string;
//	} TypeAClass;
//
// static void
// type_a_base_class_init (TypeAClass *class)
//
//	{
//	  class-&gt;dynamic_string = g_strdup ("some string");
//	}
//
// static void
// type_a_base_class_finalize (TypeAClass *class)
//
//	{
//	  g_free (class-&gt;dynamic_string);
//	}
//
// static void
// type_a_class_init (TypeAClass *class)
//
//	{
//	  class-&gt;static_integer = 42;
//	}
//
//	typedef struct {
//	  TypeAClass   parent_class;
//	  gfloat       static_float;
//	  GString     *dynamic_gstring;
//	} TypeBClass;
//
// static void
// type_b_base_class_init (TypeBClass *class)
//
//	{
//	  class-&gt;dynamic_gstring = g_string_new ("some other string");
//	}
//
// static void
// type_b_base_class_finalize (TypeBClass *class)
//
//	{
//	  g_string_free (class-&gt;dynamic_gstring);
//	}
//
// static void
// type_b_class_init (TypeBClass *class)
//
//	{
//	  class-&gt;static_float = 3.14159265358979323846;
//	}
//
// ]|
//
// Initialization of TypeBClass will first cause initialization of
// TypeAClass (derived classes reference their parent classes, see
// g_type_class_ref() on this).
//
// Initialization of TypeAClass roughly involves zero-initializing its fields,
// then calling its GBaseInitFunc() type_a_base_class_init() to allocate
// its dynamic members (dynamic_string), and finally calling its GClassInitFunc()
// type_a_class_init() to initialize its static members (static_integer).
// The first step in the initialization process of TypeBClass is then
// a plain memory copy of the contents of TypeAClass into TypeBClass and
// zero-initialization of the remaining fields in TypeBClass.
// The dynamic members of TypeAClass within TypeBClass now need
// reinitialization which is performed by calling type_a_base_class_init()
// with an argument of TypeBClass.
//
// After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()
// is called to allocate the dynamic members of TypeBClass (dynamic_gstring),
// and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),
// is called to complete the initialization process with the static members
// (static_float).
//
// Corresponding finalization counter parts to the GBaseInitFunc() functions
// have to be provided to release allocated resources at class finalization
// time.
type ClassInitFunc func(*TypeClass, uintptr)

// A callback function used by the type system to initialize a new
// instance of a type.
//
// This function initializes all instance members and allocates any resources
// required by it.
//
// Initialization of a derived instance involves calling all its parent
// types instance initializers, so the class member of the instance
// is altered during its initialization to always point to the class that
// belongs to the type the current initializer was introduced for.
//
// The extended members of @instance are guaranteed to have been filled with
// zeros before this function is called.
type InstanceInitFunc func(*TypeInstance, *TypeClass)

// A callback function used by the type system to finalize an interface.
//
// This function should destroy any internal data and release any resources
// allocated by the corresponding GInterfaceInitFunc() function.
type InterfaceFinalizeFunc func(*TypeInterface, uintptr)

// A callback function used by the type system to initialize a new
// interface.
//
// This function should initialize all internal data and* allocate any
// resources required by the interface.
//
// The members of @iface_data are guaranteed to have been filled with
// zeros before this function is called.
type InterfaceInitFunc func(*TypeInterface, uintptr)

// A callback function which is called when the reference count of a class
// drops to zero.
//
// It may use g_type_class_ref() to prevent the class from being freed. You
// should not call g_type_class_unref() from a #GTypeClassCacheFunc function
// to prevent infinite recursion, use g_type_class_unref_uncached() instead.
//
// The functions have to check the class id passed in to figure
// whether they actually want to cache the class of this type, since all
// classes are routed through the same #GTypeClassCacheFunc chain.
type TypeClassCacheFunc func(uintptr, *TypeClass) bool

// A callback called after an interface vtable is initialized.
//
// See g_type_add_interface_check().
type TypeInterfaceCheckFunc func(uintptr, *TypeInterface)

// A structure that provides information to the type system which is
// used specifically for managing interface types.
type InterfaceInfo struct {
	InterfaceInit InterfaceInitFunc

	InterfaceFinalize InterfaceFinalizeFunc

	InterfaceData uintptr
}

func (x *InterfaceInfo) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// An opaque structure used as the base of all classes.
type TypeClass struct {
	GType types.GType
}

func (x *TypeClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTypeClassAddPrivate func(uintptr, uint)

// Registers a private structure for an instantiatable type.
//
// When an object is allocated, the private structures for
// the type and all of its parent types are allocated
// sequentially in the same memory block as the public
// structures, and are zero-filled.
//
// Note that the accumulated size of the private structures of
// a type and all its parent types cannot exceed 64 KiB.
//
// This function should be called in the type's class_init() function.
// The private structure can be retrieved using the
// G_TYPE_INSTANCE_GET_PRIVATE() macro.
//
// The following example shows attaching a private structure
// MyObjectPrivate to an object MyObject defined in the standard
// GObject fashion in the type's class_init() function.
//
// Note the use of a structure member "priv" to avoid the overhead
// of repeatedly calling MY_OBJECT_GET_PRIVATE().
//
// |[&lt;!-- language="C" --&gt;
// typedef struct _MyObject        MyObject;
// typedef struct _MyObjectPrivate MyObjectPrivate;
//
//	struct _MyObject {
//	 GObject parent;
//
//	 MyObjectPrivate *priv;
//	};
//
//	struct _MyObjectPrivate {
//	  int some_field;
//	};
//
// static void
// my_object_class_init (MyObjectClass *klass)
//
//	{
//	  g_type_class_add_private (klass, sizeof (MyObjectPrivate));
//	}
//
// static void
// my_object_init (MyObject *my_object)
//
//	{
//	  my_object-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (my_object,
//	                                                 MY_TYPE_OBJECT,
//	                                                 MyObjectPrivate);
//	  // my_object-&gt;priv-&gt;some_field will be automatically initialised to 0
//	}
//
// static int
// my_object_get_some_field (MyObject *my_object)
//
//	{
//	  MyObjectPrivate *priv;
//
//	  g_return_val_if_fail (MY_IS_OBJECT (my_object), 0);
//
//	  priv = my_object-&gt;priv;
//
//	  return priv-&gt;some_field;
//	}
//
// ]|
func (x *TypeClass) AddPrivate(PrivateSizeVar uint) {

	xTypeClassAddPrivate(x.GoPointer(), PrivateSizeVar)

}

var xTypeClassGetInstancePrivateOffset func(uintptr) int

// Gets the offset of the private data for instances of @g_class.
//
// This is how many bytes you should add to the instance pointer of a
// class in order to get the private data for the type represented by
// @g_class.
//
// You can only call this function after you have registered a private
// data area for @g_class using g_type_class_add_private().
func (x *TypeClass) GetInstancePrivateOffset() int {

	cret := xTypeClassGetInstancePrivateOffset(x.GoPointer())
	return cret
}

var xTypeClassGetPrivate func(uintptr, types.GType) uintptr

func (x *TypeClass) GetPrivate(PrivateTypeVar types.GType) uintptr {

	cret := xTypeClassGetPrivate(x.GoPointer(), PrivateTypeVar)
	return cret
}

var xTypeClassPeekParent func(uintptr) *TypeClass

// This is a convenience function often needed in class initializers.
// It returns the class structure of the immediate parent type of the
// class passed in.  Since derived classes hold a reference count on
// their parent classes as long as they are instantiated, the returned
// class will always exist.
//
// This function is essentially equivalent to:
// g_type_class_peek (g_type_parent (G_TYPE_FROM_CLASS (g_class)))
func (x *TypeClass) PeekParent() *TypeClass {

	cret := xTypeClassPeekParent(x.GoPointer())
	return cret
}

var xTypeClassUnref func(uintptr)

// Decrements the reference count of the class structure being passed in.
// Once the last reference count of a class has been released, classes
// may be finalized by the type system, so further dereferencing of a
// class pointer after g_type_class_unref() are invalid.
func (x *TypeClass) Unref() {

	xTypeClassUnref(x.GoPointer())

}

var xTypeClassUnrefUncached func(uintptr)

// A variant of g_type_class_unref() for use in #GTypeClassCacheFunc
// implementations. It unreferences a class without consulting the chain
// of #GTypeClassCacheFuncs, avoiding the recursion which would occur
// otherwise.
func (x *TypeClass) UnrefUncached() {

	xTypeClassUnrefUncached(x.GoPointer())

}

// A structure that provides information to the type system which is
// used specifically for managing fundamental types.
type TypeFundamentalInfo struct {
	TypeFlags TypeFundamentalFlags
}

func (x *TypeFundamentalInfo) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// This structure is used to provide the type system with the information
// required to initialize and destruct (finalize) a type's class and
// its instances.
//
// The initialized structure is passed to the g_type_register_static() function
// (or is copied into the provided #GTypeInfo structure in the
// g_type_plugin_complete_type_info()). The type system will perform a deep
// copy of this structure, so its memory does not need to be persistent
// across invocation of g_type_register_static().
type TypeInfo struct {
	ClassSize uint16

	BaseInit BaseInitFunc

	BaseFinalize BaseFinalizeFunc

	ClassInit ClassInitFunc

	ClassFinalize ClassFinalizeFunc

	ClassData uintptr

	InstanceSize uint16

	NPreallocs uint16

	InstanceInit InstanceInitFunc

	ValueTable *TypeValueTable
}

func (x *TypeInfo) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// An opaque structure used as the base of all type instances.
type TypeInstance struct {
	GClass *TypeClass
}

func (x *TypeInstance) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTypeInstanceGetPrivate func(uintptr, types.GType) uintptr

func (x *TypeInstance) GetPrivate(PrivateTypeVar types.GType) uintptr {

	cret := xTypeInstanceGetPrivate(x.GoPointer(), PrivateTypeVar)
	return cret
}

// An opaque structure used as the base of all interface types.
type TypeInterface struct {
	GType types.GType

	GInstanceType types.GType
}

func (x *TypeInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTypeInterfacePeekParent func(uintptr) *TypeInterface

// Returns the corresponding #GTypeInterface structure of the parent type
// of the instance type to which @g_iface belongs. This is useful when
// deriving the implementation of an interface from the parent type and
// then possibly overriding some methods.
func (x *TypeInterface) PeekParent() *TypeInterface {

	cret := xTypeInterfacePeekParent(x.GoPointer())
	return cret
}

// A structure holding information for a specific type.
//
// See also: g_type_query()
type TypeQuery struct {
	Type types.GType

	TypeName uintptr

	ClassSize uint

	InstanceSize uint
}

func (x *TypeQuery) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// The #GTypeValueTable provides the functions required by the #GValue
// implementation, to serve as a container for values of a type.
type TypeValueTable struct {
	CollectFormat uintptr

	LcopyFormat uintptr
}

func (x *TypeValueTable) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type TypeCValue = uintptr

// A numerical value which represents the unique identifier of a registered
// type.
type Type = uint

const (
	// A bit in the type number that's supposed to be left untouched.
	TYPE_FLAG_RESERVED_ID_BIT glib.Type = 1
	// An integer constant that represents the number of identifiers reserved
	// for types that are assigned at compile-time.
	TYPE_FUNDAMENTAL_MAX int = 255
	// Shift value used in converting numbers to type IDs.
	TYPE_FUNDAMENTAL_SHIFT int = 2
	// First fundamental type number to create a new fundamental type id with
	// G_TYPE_MAKE_FUNDAMENTAL() reserved for BSE.
	TYPE_RESERVED_BSE_FIRST int = 32
	// Last fundamental type number reserved for BSE.
	TYPE_RESERVED_BSE_LAST int = 48
	// First fundamental type number to create a new fundamental type id with
	// G_TYPE_MAKE_FUNDAMENTAL() reserved for GLib.
	TYPE_RESERVED_GLIB_FIRST int = 22
	// Last fundamental type number reserved for GLib.
	TYPE_RESERVED_GLIB_LAST int = 31
	// First available fundamental type number to create new fundamental
	// type id with G_TYPE_MAKE_FUNDAMENTAL().
	TYPE_RESERVED_USER_FIRST int = 49
)

// These flags used to be passed to g_type_init_with_debug_flags() which
// is now deprecated.
//
// If you need to enable debugging features, use the GOBJECT_DEBUG
// environment variable.
type TypeDebugFlags int

const (

	// Print no messages
	GTypeDebugNoneValue TypeDebugFlags = 0
	// Print messages about object bookkeeping
	GTypeDebugObjectsValue TypeDebugFlags = 1
	// Print messages about signal emissions
	GTypeDebugSignalsValue TypeDebugFlags = 2
	// Keep a count of instances of each type
	GTypeDebugInstanceCountValue TypeDebugFlags = 4
	// Mask covering all debug flags
	GTypeDebugMaskValue TypeDebugFlags = 7
)

// Bit masks used to check or determine characteristics of a type.
type TypeFlags int

const (

	// Indicates an abstract type. No instances can be
	//  created for an abstract type
	GTypeFlagAbstractValue TypeFlags = 16
	// Indicates an abstract value type, i.e. a type
	//  that introduces a value table, but can't be used for
	//  g_value_init()
	GTypeFlagValueAbstractValue TypeFlags = 32
	// Indicates a final type. A final type is a non-derivable
	//  leaf node in a deep derivable type hierarchy tree. Since: 2.70
	GTypeFlagFinalValue TypeFlags = 64
)

// Bit masks used to check or determine specific characteristics of a
// fundamental type.
type TypeFundamentalFlags int

const (

	// Indicates a classed type
	GTypeFlagClassedValue TypeFundamentalFlags = 1
	// Indicates an instantiatable type (implies classed)
	GTypeFlagInstantiatableValue TypeFundamentalFlags = 2
	// Indicates a flat derivable type
	GTypeFlagDerivableValue TypeFundamentalFlags = 4
	// Indicates a deep derivable type (implies derivable)
	GTypeFlagDeepDerivableValue TypeFundamentalFlags = 8
)

var xTypeAddClassCacheFunc func(uintptr, uintptr)

// Adds a #GTypeClassCacheFunc to be called before the reference count of a
// class goes from one to zero. This can be used to prevent premature class
// destruction. All installed #GTypeClassCacheFunc functions will be chained
// until one of them returns %TRUE. The functions have to check the class id
// passed in to figure whether they actually want to cache the class of this
// type, since all classes are routed through the same #GTypeClassCacheFunc
// chain.
func TypeAddClassCacheFunc(CacheDataVar uintptr, CacheFuncVar *TypeClassCacheFunc) {

	xTypeAddClassCacheFunc(CacheDataVar, glib.NewCallback(CacheFuncVar))

}

var xTypeAddClassPrivate func(types.GType, uint)

// Registers a private class structure for a classed type;
// when the class is allocated, the private structures for
// the class and all of its parent types are allocated
// sequentially in the same memory block as the public
// structures, and are zero-filled.
//
// This function should be called in the
// type's get_type() function after the type is registered.
// The private structure can be retrieved using the
// G_TYPE_CLASS_GET_PRIVATE() macro.
func TypeAddClassPrivate(ClassTypeVar types.GType, PrivateSizeVar uint) {

	xTypeAddClassPrivate(ClassTypeVar, PrivateSizeVar)

}

var xTypeAddInstancePrivate func(types.GType, uint) int

func TypeAddInstancePrivate(ClassTypeVar types.GType, PrivateSizeVar uint) int {

	cret := xTypeAddInstancePrivate(ClassTypeVar, PrivateSizeVar)
	return cret
}

var xTypeAddInterfaceCheck func(uintptr, uintptr)

// Adds a function to be called after an interface vtable is
// initialized for any class (i.e. after the @interface_init
// member of #GInterfaceInfo has been called).
//
// This function is useful when you want to check an invariant
// that depends on the interfaces of a class. For instance, the
// implementation of #GObject uses this facility to check that an
// object implements all of the properties that are defined on its
// interfaces.
func TypeAddInterfaceCheck(CheckDataVar uintptr, CheckFuncVar *TypeInterfaceCheckFunc) {

	xTypeAddInterfaceCheck(CheckDataVar, glib.NewCallback(CheckFuncVar))

}

var xTypeAddInterfaceDynamic func(types.GType, types.GType, uintptr)

// Adds @interface_type to the dynamic @instance_type. The information
// contained in the #GTypePlugin structure pointed to by @plugin
// is used to manage the relationship.
func TypeAddInterfaceDynamic(InstanceTypeVar types.GType, InterfaceTypeVar types.GType, PluginVar TypePlugin) {

	xTypeAddInterfaceDynamic(InstanceTypeVar, InterfaceTypeVar, PluginVar.GoPointer())

}

var xTypeAddInterfaceStatic func(types.GType, types.GType, *InterfaceInfo)

// Adds @interface_type to the static @instance_type.
// The information contained in the #GInterfaceInfo structure
// pointed to by @info is used to manage the relationship.
func TypeAddInterfaceStatic(InstanceTypeVar types.GType, InterfaceTypeVar types.GType, InfoVar *InterfaceInfo) {

	xTypeAddInterfaceStatic(InstanceTypeVar, InterfaceTypeVar, InfoVar)

}

var xTypeCheckClassCast func(*TypeClass, types.GType) *TypeClass

func TypeCheckClassCast(GClassVar *TypeClass, IsATypeVar types.GType) *TypeClass {

	cret := xTypeCheckClassCast(GClassVar, IsATypeVar)
	return cret
}

var xTypeCheckClassIsA func(*TypeClass, types.GType) bool

func TypeCheckClassIsA(GClassVar *TypeClass, IsATypeVar types.GType) bool {

	cret := xTypeCheckClassIsA(GClassVar, IsATypeVar)
	return cret
}

var xTypeCheckInstance func(*TypeInstance) bool

// Private helper function to aid implementation of the
// G_TYPE_CHECK_INSTANCE() macro.
func TypeCheckInstance(InstanceVar *TypeInstance) bool {

	cret := xTypeCheckInstance(InstanceVar)
	return cret
}

var xTypeCheckInstanceCast func(*TypeInstance, types.GType) *TypeInstance

func TypeCheckInstanceCast(InstanceVar *TypeInstance, IfaceTypeVar types.GType) *TypeInstance {

	cret := xTypeCheckInstanceCast(InstanceVar, IfaceTypeVar)
	return cret
}

var xTypeCheckInstanceIsA func(*TypeInstance, types.GType) bool

func TypeCheckInstanceIsA(InstanceVar *TypeInstance, IfaceTypeVar types.GType) bool {

	cret := xTypeCheckInstanceIsA(InstanceVar, IfaceTypeVar)
	return cret
}

var xTypeCheckInstanceIsFundamentallyA func(*TypeInstance, types.GType) bool

func TypeCheckInstanceIsFundamentallyA(InstanceVar *TypeInstance, FundamentalTypeVar types.GType) bool {

	cret := xTypeCheckInstanceIsFundamentallyA(InstanceVar, FundamentalTypeVar)
	return cret
}

var xTypeCheckIsValueType func(types.GType) bool

func TypeCheckIsValueType(TypeVar types.GType) bool {

	cret := xTypeCheckIsValueType(TypeVar)
	return cret
}

var xTypeCheckValue func(*Value) bool

func TypeCheckValue(ValueVar *Value) bool {

	cret := xTypeCheckValue(ValueVar)
	return cret
}

var xTypeCheckValueHolds func(*Value, types.GType) bool

func TypeCheckValueHolds(ValueVar *Value, TypeVar types.GType) bool {

	cret := xTypeCheckValueHolds(ValueVar, TypeVar)
	return cret
}

var xTypeChildren func(types.GType, uint) []types.GType

// Return a newly allocated and 0-terminated array of type IDs, listing
// the child types of @type.
func TypeChildren(TypeVar types.GType, NChildrenVar uint) []types.GType {

	cret := xTypeChildren(TypeVar, NChildrenVar)
	return cret
}

var xTypeClassAdjustPrivateOffset func(uintptr, int)

func TypeClassAdjustPrivateOffset(GClassVar uintptr, PrivateSizeOrOffsetVar int) {

	xTypeClassAdjustPrivateOffset(GClassVar, PrivateSizeOrOffsetVar)

}

var xTypeClassPeek func(types.GType) *TypeClass

// This function is essentially the same as g_type_class_ref(),
// except that the classes reference count isn't incremented.
// As a consequence, this function may return %NULL if the class
// of the type passed in does not currently exist (hasn't been
// referenced before).
func TypeClassPeek(TypeVar types.GType) *TypeClass {

	cret := xTypeClassPeek(TypeVar)
	return cret
}

var xTypeClassPeekStatic func(types.GType) *TypeClass

// A more efficient version of g_type_class_peek() which works only for
// static types.
func TypeClassPeekStatic(TypeVar types.GType) *TypeClass {

	cret := xTypeClassPeekStatic(TypeVar)
	return cret
}

var xTypeClassRef func(types.GType) *TypeClass

// Increments the reference count of the class structure belonging to
// @type. This function will demand-create the class if it doesn't
// exist already.
func TypeClassRef(TypeVar types.GType) *TypeClass {

	cret := xTypeClassRef(TypeVar)
	return cret
}

var xTypeCreateInstance func(types.GType) *TypeInstance

// Creates and initializes an instance of @type if @type is valid and
// can be instantiated. The type system only performs basic allocation
// and structure setups for instances: actual instance creation should
// happen through functions supplied by the type's fundamental type
// implementation.  So use of g_type_create_instance() is reserved for
// implementers of fundamental types only. E.g. instances of the
// #GObject hierarchy should be created via g_object_new() and never
// directly through g_type_create_instance() which doesn't handle things
// like singleton objects or object construction.
//
// The extended members of the returned instance are guaranteed to be filled
// with zeros.
//
// Note: Do not use this function, unless you're implementing a
// fundamental type. Also language bindings should not use this
// function, but g_object_new() instead.
func TypeCreateInstance(TypeVar types.GType) *TypeInstance {

	cret := xTypeCreateInstance(TypeVar)
	return cret
}

var xTypeDefaultInterfacePeek func(types.GType) *TypeInterface

// If the interface type @g_type is currently in use, returns its
// default interface vtable.
func TypeDefaultInterfacePeek(GTypeVar types.GType) *TypeInterface {

	cret := xTypeDefaultInterfacePeek(GTypeVar)
	return cret
}

var xTypeDefaultInterfaceRef func(types.GType) *TypeInterface

// Increments the reference count for the interface type @g_type,
// and returns the default interface vtable for the type.
//
// If the type is not currently in use, then the default vtable
// for the type will be created and initialized by calling
// the base interface init and default vtable init functions for
// the type (the @base_init and @class_init members of #GTypeInfo).
// Calling g_type_default_interface_ref() is useful when you
// want to make sure that signals and properties for an interface
// have been installed.
func TypeDefaultInterfaceRef(GTypeVar types.GType) *TypeInterface {

	cret := xTypeDefaultInterfaceRef(GTypeVar)
	return cret
}

var xTypeDefaultInterfaceUnref func(*TypeInterface)

// Decrements the reference count for the type corresponding to the
// interface default vtable @g_iface. If the type is dynamic, then
// when no one is using the interface and all references have
// been released, the finalize function for the interface's default
// vtable (the @class_finalize member of #GTypeInfo) will be called.
func TypeDefaultInterfaceUnref(GIfaceVar *TypeInterface) {

	xTypeDefaultInterfaceUnref(GIfaceVar)

}

var xTypeDepth func(types.GType) uint

// Returns the length of the ancestry of the passed in type. This
// includes the type itself, so that e.g. a fundamental type has depth 1.
func TypeDepth(TypeVar types.GType) uint {

	cret := xTypeDepth(TypeVar)
	return cret
}

var xTypeEnsure func(types.GType)

// Ensures that the indicated @type has been registered with the
// type system, and its _class_init() method has been run.
//
// In theory, simply calling the type's _get_type() method (or using
// the corresponding macro) is supposed take care of this. However,
// _get_type() methods are often marked %G_GNUC_CONST for performance
// reasons, even though this is technically incorrect (since
// %G_GNUC_CONST requires that the function not have side effects,
// which _get_type() methods do on the first call). As a result, if
// you write a bare call to a _get_type() macro, it may get optimized
// out by the compiler. Using g_type_ensure() guarantees that the
// type's _get_type() method is called.
func TypeEnsure(TypeVar types.GType) {

	xTypeEnsure(TypeVar)

}

var xTypeFreeInstance func(*TypeInstance)

// Frees an instance of a type, returning it to the instance pool for
// the type, if there is one.
//
// Like g_type_create_instance(), this function is reserved for
// implementors of fundamental types.
func TypeFreeInstance(InstanceVar *TypeInstance) {

	xTypeFreeInstance(InstanceVar)

}

var xTypeFromName func(string) types.GType

// Look up the type ID from a given type name, returning 0 if no type
// has been registered under this name (this is the preferred method
// to find out by name whether a specific type has been registered
// yet).
func TypeFromName(NameVar string) types.GType {

	cret := xTypeFromName(NameVar)
	return cret
}

var xTypeFundamental func(types.GType) types.GType

// Internal function, used to extract the fundamental type ID portion.
// Use G_TYPE_FUNDAMENTAL() instead.
func TypeFundamental(TypeIdVar types.GType) types.GType {

	cret := xTypeFundamental(TypeIdVar)
	return cret
}

var xTypeFundamentalNext func() types.GType

// Returns the next free fundamental type id which can be used to
// register a new fundamental type with g_type_register_fundamental().
// The returned type ID represents the highest currently registered
// fundamental type identifier.
func TypeFundamentalNext() types.GType {

	cret := xTypeFundamentalNext()
	return cret
}

var xTypeGetInstanceCount func(types.GType) int

// Returns the number of instances allocated of the particular type;
// this is only available if GLib is built with debugging support and
// the instance_count debug flag is set (by setting the GOBJECT_DEBUG
// variable to include instance-count).
func TypeGetInstanceCount(TypeVar types.GType) int {

	cret := xTypeGetInstanceCount(TypeVar)
	return cret
}

var xTypeGetPlugin func(types.GType) uintptr

// Returns the #GTypePlugin structure for @type.
func TypeGetPlugin(TypeVar types.GType) *TypePluginBase {
	var cls *TypePluginBase

	cret := xTypeGetPlugin(TypeVar)

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &TypePluginBase{}
	cls.Ptr = cret
	return cls
}

var xTypeGetQdata func(types.GType, glib.Quark) uintptr

// Obtains data which has previously been attached to @type
// with g_type_set_qdata().
//
// Note that this does not take subtyping into account; data
// attached to one type with g_type_set_qdata() cannot
// be retrieved from a subtype using g_type_get_qdata().
func TypeGetQdata(TypeVar types.GType, QuarkVar glib.Quark) uintptr {

	cret := xTypeGetQdata(TypeVar, QuarkVar)
	return cret
}

var xTypeGetTypeRegistrationSerial func() uint

// Returns an opaque serial number that represents the state of the set
// of registered types. Any time a type is registered this serial changes,
// which means you can cache information based on type lookups (such as
// g_type_from_name()) and know if the cache is still valid at a later
// time by comparing the current serial with the one at the type lookup.
func TypeGetTypeRegistrationSerial() uint {

	cret := xTypeGetTypeRegistrationSerial()
	return cret
}

var xTypeInit func()

// This function used to initialise the type system.  Since GLib 2.36,
// the type system is initialised automatically and this function does
// nothing.
func TypeInit() {

	xTypeInit()

}

var xTypeInitWithDebugFlags func(TypeDebugFlags)

// This function used to initialise the type system with debugging
// flags.  Since GLib 2.36, the type system is initialised automatically
// and this function does nothing.
//
// If you need to enable debugging features, use the GOBJECT_DEBUG
// environment variable.
func TypeInitWithDebugFlags(DebugFlagsVar TypeDebugFlags) {

	xTypeInitWithDebugFlags(DebugFlagsVar)

}

var xTypeInterfaceAddPrerequisite func(types.GType, types.GType)

// Adds @prerequisite_type to the list of prerequisites of @interface_type.
// This means that any type implementing @interface_type must also implement
// @prerequisite_type. Prerequisites can be thought of as an alternative to
// interface derivation (which GType doesn't support). An interface can have
// at most one instantiatable prerequisite type.
func TypeInterfaceAddPrerequisite(InterfaceTypeVar types.GType, PrerequisiteTypeVar types.GType) {

	xTypeInterfaceAddPrerequisite(InterfaceTypeVar, PrerequisiteTypeVar)

}

var xTypeInterfaceGetPlugin func(types.GType, types.GType) uintptr

// Returns the #GTypePlugin structure for the dynamic interface
// @interface_type which has been added to @instance_type, or %NULL
// if @interface_type has not been added to @instance_type or does
// not have a #GTypePlugin structure. See g_type_add_interface_dynamic().
func TypeInterfaceGetPlugin(InstanceTypeVar types.GType, InterfaceTypeVar types.GType) *TypePluginBase {
	var cls *TypePluginBase

	cret := xTypeInterfaceGetPlugin(InstanceTypeVar, InterfaceTypeVar)

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &TypePluginBase{}
	cls.Ptr = cret
	return cls
}

var xTypeInterfaceInstantiatablePrerequisite func(types.GType) types.GType

// Returns the most specific instantiatable prerequisite of an
// interface type. If the interface type has no instantiatable
// prerequisite, %G_TYPE_INVALID is returned.
//
// See g_type_interface_add_prerequisite() for more information
// about prerequisites.
func TypeInterfaceInstantiatablePrerequisite(InterfaceTypeVar types.GType) types.GType {

	cret := xTypeInterfaceInstantiatablePrerequisite(InterfaceTypeVar)
	return cret
}

var xTypeInterfacePeek func(*TypeClass, types.GType) *TypeInterface

// Returns the #GTypeInterface structure of an interface to which the
// passed in class conforms.
func TypeInterfacePeek(InstanceClassVar *TypeClass, IfaceTypeVar types.GType) *TypeInterface {

	cret := xTypeInterfacePeek(InstanceClassVar, IfaceTypeVar)
	return cret
}

var xTypeInterfacePrerequisites func(types.GType, uint) []types.GType

// Returns the prerequisites of an interfaces type.
func TypeInterfacePrerequisites(InterfaceTypeVar types.GType, NPrerequisitesVar uint) []types.GType {

	cret := xTypeInterfacePrerequisites(InterfaceTypeVar, NPrerequisitesVar)
	return cret
}

var xTypeInterfaces func(types.GType, uint) []types.GType

// Return a newly allocated and 0-terminated array of type IDs, listing
// the interface types that @type conforms to.
func TypeInterfaces(TypeVar types.GType, NInterfacesVar uint) []types.GType {

	cret := xTypeInterfaces(TypeVar, NInterfacesVar)
	return cret
}

var xTypeIsA func(types.GType, types.GType) bool

// If @is_a_type is a derivable type, check whether @type is a
// descendant of @is_a_type. If @is_a_type is an interface, check
// whether @type conforms to it.
func TypeIsA(TypeVar types.GType, IsATypeVar types.GType) bool {

	cret := xTypeIsA(TypeVar, IsATypeVar)
	return cret
}

var xTypeName func(types.GType) string

// Get the unique name that is assigned to a type ID.  Note that this
// function (like all other GType API) cannot cope with invalid type
// IDs. %G_TYPE_INVALID may be passed to this function, as may be any
// other validly registered type ID, but randomized type IDs should
// not be passed in and will most likely lead to a crash.
func TypeName(TypeVar types.GType) string {

	cret := xTypeName(TypeVar)
	return cret
}

var xTypeNameFromClass func(*TypeClass) string

func TypeNameFromClass(GClassVar *TypeClass) string {

	cret := xTypeNameFromClass(GClassVar)
	return cret
}

var xTypeNameFromInstance func(*TypeInstance) string

func TypeNameFromInstance(InstanceVar *TypeInstance) string {

	cret := xTypeNameFromInstance(InstanceVar)
	return cret
}

var xTypeNextBase func(types.GType, types.GType) types.GType

// Given a @leaf_type and a @root_type which is contained in its
// ancestry, return the type that @root_type is the immediate parent
// of. In other words, this function determines the type that is
// derived directly from @root_type which is also a base class of
// @leaf_type.  Given a root type and a leaf type, this function can
// be used to determine the types and order in which the leaf type is
// descended from the root type.
func TypeNextBase(LeafTypeVar types.GType, RootTypeVar types.GType) types.GType {

	cret := xTypeNextBase(LeafTypeVar, RootTypeVar)
	return cret
}

var xTypeParent func(types.GType) types.GType

// Return the direct parent type of the passed in type. If the passed
// in type has no parent, i.e. is a fundamental type, 0 is returned.
func TypeParent(TypeVar types.GType) types.GType {

	cret := xTypeParent(TypeVar)
	return cret
}

var xTypeQname func(types.GType) glib.Quark

// Get the corresponding quark of the type IDs name.
func TypeQname(TypeVar types.GType) glib.Quark {

	cret := xTypeQname(TypeVar)
	return cret
}

var xNewTypeQuery func(types.GType, *TypeQuery)

// Queries the type system for information about a specific type.
// This function will fill in a user-provided structure to hold
// type-specific information. If an invalid #GType is passed in, the
// @type member of the #GTypeQuery is 0. All members filled into the
// #GTypeQuery structure should be considered constant and have to be
// left untouched.
func NewTypeQuery(TypeVar types.GType, QueryVar *TypeQuery) {

	xNewTypeQuery(TypeVar, QueryVar)

}

var xTypeRegisterDynamic func(types.GType, string, uintptr, TypeFlags) types.GType

// Registers @type_name as the name of a new dynamic type derived from
// @parent_type.  The type system uses the information contained in the
// #GTypePlugin structure pointed to by @plugin to manage the type and its
// instances (if not abstract).  The value of @flags determines the nature
// (e.g. abstract or not) of the type.
func TypeRegisterDynamic(ParentTypeVar types.GType, TypeNameVar string, PluginVar TypePlugin, FlagsVar TypeFlags) types.GType {

	cret := xTypeRegisterDynamic(ParentTypeVar, TypeNameVar, PluginVar.GoPointer(), FlagsVar)
	return cret
}

var xTypeRegisterFundamental func(types.GType, string, *TypeInfo, *TypeFundamentalInfo, TypeFlags) types.GType

// Registers @type_id as the predefined identifier and @type_name as the
// name of a fundamental type. If @type_id is already registered, or a
// type named @type_name is already registered, the behaviour is undefined.
// The type system uses the information contained in the #GTypeInfo structure
// pointed to by @info and the #GTypeFundamentalInfo structure pointed to by
// @finfo to manage the type and its instances. The value of @flags determines
// additional characteristics of the fundamental type.
func TypeRegisterFundamental(TypeIdVar types.GType, TypeNameVar string, InfoVar *TypeInfo, FinfoVar *TypeFundamentalInfo, FlagsVar TypeFlags) types.GType {

	cret := xTypeRegisterFundamental(TypeIdVar, TypeNameVar, InfoVar, FinfoVar, FlagsVar)
	return cret
}

var xTypeRegisterStatic func(types.GType, string, *TypeInfo, TypeFlags) types.GType

// Registers @type_name as the name of a new static type derived from
// @parent_type. The type system uses the information contained in the
// #GTypeInfo structure pointed to by @info to manage the type and its
// instances (if not abstract). The value of @flags determines the nature
// (e.g. abstract or not) of the type.
func TypeRegisterStatic(ParentTypeVar types.GType, TypeNameVar string, InfoVar *TypeInfo, FlagsVar TypeFlags) types.GType {

	cret := xTypeRegisterStatic(ParentTypeVar, TypeNameVar, InfoVar, FlagsVar)
	return cret
}

var xTypeRegisterStaticSimple func(types.GType, string, uint, uintptr, uint, uintptr, TypeFlags) types.GType

// Registers @type_name as the name of a new static type derived from
// @parent_type.  The value of @flags determines the nature (e.g.
// abstract or not) of the type. It works by filling a #GTypeInfo
// struct and calling g_type_register_static().
func TypeRegisterStaticSimple(ParentTypeVar types.GType, TypeNameVar string, ClassSizeVar uint, ClassInitVar *ClassInitFunc, InstanceSizeVar uint, InstanceInitVar *InstanceInitFunc, FlagsVar TypeFlags) types.GType {

	cret := xTypeRegisterStaticSimple(ParentTypeVar, TypeNameVar, ClassSizeVar, glib.NewCallback(ClassInitVar), InstanceSizeVar, glib.NewCallback(InstanceInitVar), FlagsVar)
	return cret
}

var xTypeRemoveClassCacheFunc func(uintptr, uintptr)

// Removes a previously installed #GTypeClassCacheFunc. The cache
// maintained by @cache_func has to be empty when calling
// g_type_remove_class_cache_func() to avoid leaks.
func TypeRemoveClassCacheFunc(CacheDataVar uintptr, CacheFuncVar *TypeClassCacheFunc) {

	xTypeRemoveClassCacheFunc(CacheDataVar, glib.NewCallback(CacheFuncVar))

}

var xTypeRemoveInterfaceCheck func(uintptr, uintptr)

// Removes an interface check function added with
// g_type_add_interface_check().
func TypeRemoveInterfaceCheck(CheckDataVar uintptr, CheckFuncVar *TypeInterfaceCheckFunc) {

	xTypeRemoveInterfaceCheck(CheckDataVar, glib.NewCallback(CheckFuncVar))

}

var xTypeSetQdata func(types.GType, glib.Quark, uintptr)

// Attaches arbitrary data to a type.
func TypeSetQdata(TypeVar types.GType, QuarkVar glib.Quark, DataVar uintptr) {

	xTypeSetQdata(TypeVar, QuarkVar, DataVar)

}

var xTypeTestFlags func(types.GType, uint) bool

func TypeTestFlags(TypeVar types.GType, FlagsVar uint) bool {

	cret := xTypeTestFlags(TypeVar, FlagsVar)
	return cret
}

var xTypeValueTablePeek func(types.GType) *TypeValueTable

// Returns the location of the #GTypeValueTable associated with @type.
//
// Note that this function should only be used from source code
// that implements or has internal knowledge of the implementation of
// @type.
func TypeValueTablePeek(TypeVar types.GType) *TypeValueTable {

	cret := xTypeValueTablePeek(TypeVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GOBJECT"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xTypeAddClassCacheFunc, lib, "g_type_add_class_cache_func")
	core.PuregoSafeRegister(&xTypeAddClassPrivate, lib, "g_type_add_class_private")
	core.PuregoSafeRegister(&xTypeAddInstancePrivate, lib, "g_type_add_instance_private")
	core.PuregoSafeRegister(&xTypeAddInterfaceCheck, lib, "g_type_add_interface_check")
	core.PuregoSafeRegister(&xTypeAddInterfaceDynamic, lib, "g_type_add_interface_dynamic")
	core.PuregoSafeRegister(&xTypeAddInterfaceStatic, lib, "g_type_add_interface_static")
	core.PuregoSafeRegister(&xTypeCheckClassCast, lib, "g_type_check_class_cast")
	core.PuregoSafeRegister(&xTypeCheckClassIsA, lib, "g_type_check_class_is_a")
	core.PuregoSafeRegister(&xTypeCheckInstance, lib, "g_type_check_instance")
	core.PuregoSafeRegister(&xTypeCheckInstanceCast, lib, "g_type_check_instance_cast")
	core.PuregoSafeRegister(&xTypeCheckInstanceIsA, lib, "g_type_check_instance_is_a")
	core.PuregoSafeRegister(&xTypeCheckInstanceIsFundamentallyA, lib, "g_type_check_instance_is_fundamentally_a")
	core.PuregoSafeRegister(&xTypeCheckIsValueType, lib, "g_type_check_is_value_type")
	core.PuregoSafeRegister(&xTypeCheckValue, lib, "g_type_check_value")
	core.PuregoSafeRegister(&xTypeCheckValueHolds, lib, "g_type_check_value_holds")
	core.PuregoSafeRegister(&xTypeChildren, lib, "g_type_children")
	core.PuregoSafeRegister(&xTypeClassAdjustPrivateOffset, lib, "g_type_class_adjust_private_offset")
	core.PuregoSafeRegister(&xTypeClassPeek, lib, "g_type_class_peek")
	core.PuregoSafeRegister(&xTypeClassPeekStatic, lib, "g_type_class_peek_static")
	core.PuregoSafeRegister(&xTypeClassRef, lib, "g_type_class_ref")
	core.PuregoSafeRegister(&xTypeCreateInstance, lib, "g_type_create_instance")
	core.PuregoSafeRegister(&xTypeDefaultInterfacePeek, lib, "g_type_default_interface_peek")
	core.PuregoSafeRegister(&xTypeDefaultInterfaceRef, lib, "g_type_default_interface_ref")
	core.PuregoSafeRegister(&xTypeDefaultInterfaceUnref, lib, "g_type_default_interface_unref")
	core.PuregoSafeRegister(&xTypeDepth, lib, "g_type_depth")
	core.PuregoSafeRegister(&xTypeEnsure, lib, "g_type_ensure")
	core.PuregoSafeRegister(&xTypeFreeInstance, lib, "g_type_free_instance")
	core.PuregoSafeRegister(&xTypeFromName, lib, "g_type_from_name")
	core.PuregoSafeRegister(&xTypeFundamental, lib, "g_type_fundamental")
	core.PuregoSafeRegister(&xTypeFundamentalNext, lib, "g_type_fundamental_next")
	core.PuregoSafeRegister(&xTypeGetInstanceCount, lib, "g_type_get_instance_count")
	core.PuregoSafeRegister(&xTypeGetPlugin, lib, "g_type_get_plugin")
	core.PuregoSafeRegister(&xTypeGetQdata, lib, "g_type_get_qdata")
	core.PuregoSafeRegister(&xTypeGetTypeRegistrationSerial, lib, "g_type_get_type_registration_serial")
	core.PuregoSafeRegister(&xTypeInit, lib, "g_type_init")
	core.PuregoSafeRegister(&xTypeInitWithDebugFlags, lib, "g_type_init_with_debug_flags")
	core.PuregoSafeRegister(&xTypeInterfaceAddPrerequisite, lib, "g_type_interface_add_prerequisite")
	core.PuregoSafeRegister(&xTypeInterfaceGetPlugin, lib, "g_type_interface_get_plugin")
	core.PuregoSafeRegister(&xTypeInterfaceInstantiatablePrerequisite, lib, "g_type_interface_instantiatable_prerequisite")
	core.PuregoSafeRegister(&xTypeInterfacePeek, lib, "g_type_interface_peek")
	core.PuregoSafeRegister(&xTypeInterfacePrerequisites, lib, "g_type_interface_prerequisites")
	core.PuregoSafeRegister(&xTypeInterfaces, lib, "g_type_interfaces")
	core.PuregoSafeRegister(&xTypeIsA, lib, "g_type_is_a")
	core.PuregoSafeRegister(&xTypeName, lib, "g_type_name")
	core.PuregoSafeRegister(&xTypeNameFromClass, lib, "g_type_name_from_class")
	core.PuregoSafeRegister(&xTypeNameFromInstance, lib, "g_type_name_from_instance")
	core.PuregoSafeRegister(&xTypeNextBase, lib, "g_type_next_base")
	core.PuregoSafeRegister(&xTypeParent, lib, "g_type_parent")
	core.PuregoSafeRegister(&xTypeQname, lib, "g_type_qname")
	core.PuregoSafeRegister(&xNewTypeQuery, lib, "g_type_query")
	core.PuregoSafeRegister(&xTypeRegisterDynamic, lib, "g_type_register_dynamic")
	core.PuregoSafeRegister(&xTypeRegisterFundamental, lib, "g_type_register_fundamental")
	core.PuregoSafeRegister(&xTypeRegisterStatic, lib, "g_type_register_static")
	core.PuregoSafeRegister(&xTypeRegisterStaticSimple, lib, "g_type_register_static_simple")
	core.PuregoSafeRegister(&xTypeRemoveClassCacheFunc, lib, "g_type_remove_class_cache_func")
	core.PuregoSafeRegister(&xTypeRemoveInterfaceCheck, lib, "g_type_remove_interface_check")
	core.PuregoSafeRegister(&xTypeSetQdata, lib, "g_type_set_qdata")
	core.PuregoSafeRegister(&xTypeTestFlags, lib, "g_type_test_flags")
	core.PuregoSafeRegister(&xTypeValueTablePeek, lib, "g_type_value_table_peek")

	core.PuregoSafeRegister(&xTypeClassAddPrivate, lib, "g_type_class_add_private")
	core.PuregoSafeRegister(&xTypeClassGetInstancePrivateOffset, lib, "g_type_class_get_instance_private_offset")
	core.PuregoSafeRegister(&xTypeClassGetPrivate, lib, "g_type_class_get_private")
	core.PuregoSafeRegister(&xTypeClassPeekParent, lib, "g_type_class_peek_parent")
	core.PuregoSafeRegister(&xTypeClassUnref, lib, "g_type_class_unref")
	core.PuregoSafeRegister(&xTypeClassUnrefUncached, lib, "g_type_class_unref_uncached")

	core.PuregoSafeRegister(&xTypeInstanceGetPrivate, lib, "g_type_instance_get_private")

	core.PuregoSafeRegister(&xTypeInterfacePeekParent, lib, "g_type_interface_peek_parent")

}
