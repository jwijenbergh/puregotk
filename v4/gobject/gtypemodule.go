// Package gobject was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gobject

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// In order to implement dynamic loading of types based on #GTypeModule,
// the @load and @unload functions in #GTypeModuleClass must be implemented.
type TypeModuleClass struct {
	ParentClass uintptr
}

func (x *TypeModuleClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// #GTypeModule provides a simple implementation of the #GTypePlugin
// interface.
//
// The model of #GTypeModule is a dynamically loaded module which
// implements some number of types and interface implementations.
//
// When the module is loaded, it registers its types and interfaces
// using g_type_module_register_type() and g_type_module_add_interface().
// As long as any instances of these types and interface implementations
// are in use, the module is kept loaded. When the types and interfaces
// are gone, the module may be unloaded. If the types and interfaces
// become used again, the module will be reloaded. Note that the last
// reference cannot be released from within the module code, since that
// would lead to the caller's code being unloaded before g_object_unref()
// returns to it.
//
// Keeping track of whether the module should be loaded or not is done by
// using a use count - it starts at zero, and whenever it is greater than
// zero, the module is loaded. The use count is maintained internally by
// the type system, but also can be explicitly controlled by
// g_type_module_use() and g_type_module_unuse(). Typically, when loading
// a module for the first type, g_type_module_use() will be used to load
// it so that it can initialize its types. At some later point, when the
// module no longer needs to be loaded except for the type
// implementations it contains, g_type_module_unuse() is called.
//
// #GTypeModule does not actually provide any implementation of module
// loading and unloading. To create a particular module type you must
// derive from #GTypeModule and implement the load and unload functions
// in #GTypeModuleClass.
type TypeModule struct {
	Object
}

func TypeModuleNewFromInternalPtr(ptr uintptr) *TypeModule {
	cls := &TypeModule{}
	cls.Ptr = ptr
	return cls
}

var xTypeModuleAddInterface func(uintptr, types.GType, types.GType, *InterfaceInfo)

// Registers an additional interface for a type, whose interface lives
// in the given type plugin. If the interface was already registered
// for the type in this plugin, nothing will be done.
//
// As long as any instances of the type exist, the type plugin will
// not be unloaded.
//
// Since 2.56 if @module is %NULL this will call g_type_add_interface_static()
// instead. This can be used when making a static build of the module.
func (x *TypeModule) AddInterface(InstanceTypeVar types.GType, InterfaceTypeVar types.GType, InterfaceInfoVar *InterfaceInfo) {

	xTypeModuleAddInterface(x.GoPointer(), InstanceTypeVar, InterfaceTypeVar, InterfaceInfoVar)

}

var xTypeModuleRegisterEnum func(uintptr, string, *EnumValue) types.GType

// Looks up or registers an enumeration that is implemented with a particular
// type plugin. If a type with name @type_name was previously registered,
// the #GType identifier for the type is returned, otherwise the type
// is newly registered, and the resulting #GType identifier returned.
//
// As long as any instances of the type exist, the type plugin will
// not be unloaded.
//
// Since 2.56 if @module is %NULL this will call g_type_register_static()
// instead. This can be used when making a static build of the module.
func (x *TypeModule) RegisterEnum(NameVar string, ConstStaticValuesVar *EnumValue) types.GType {

	cret := xTypeModuleRegisterEnum(x.GoPointer(), NameVar, ConstStaticValuesVar)
	return cret
}

var xTypeModuleRegisterFlags func(uintptr, string, *FlagsValue) types.GType

// Looks up or registers a flags type that is implemented with a particular
// type plugin. If a type with name @type_name was previously registered,
// the #GType identifier for the type is returned, otherwise the type
// is newly registered, and the resulting #GType identifier returned.
//
// As long as any instances of the type exist, the type plugin will
// not be unloaded.
//
// Since 2.56 if @module is %NULL this will call g_type_register_static()
// instead. This can be used when making a static build of the module.
func (x *TypeModule) RegisterFlags(NameVar string, ConstStaticValuesVar *FlagsValue) types.GType {

	cret := xTypeModuleRegisterFlags(x.GoPointer(), NameVar, ConstStaticValuesVar)
	return cret
}

var xTypeModuleRegisterType func(uintptr, types.GType, string, *TypeInfo, TypeFlags) types.GType

// Looks up or registers a type that is implemented with a particular
// type plugin. If a type with name @type_name was previously registered,
// the #GType identifier for the type is returned, otherwise the type
// is newly registered, and the resulting #GType identifier returned.
//
// When reregistering a type (typically because a module is unloaded
// then reloaded, and reinitialized), @module and @parent_type must
// be the same as they were previously.
//
// As long as any instances of the type exist, the type plugin will
// not be unloaded.
//
// Since 2.56 if @module is %NULL this will call g_type_register_static()
// instead. This can be used when making a static build of the module.
func (x *TypeModule) RegisterType(ParentTypeVar types.GType, TypeNameVar string, TypeInfoVar *TypeInfo, FlagsVar TypeFlags) types.GType {

	cret := xTypeModuleRegisterType(x.GoPointer(), ParentTypeVar, TypeNameVar, TypeInfoVar, FlagsVar)
	return cret
}

var xTypeModuleSetName func(uintptr, string)

// Sets the name for a #GTypeModule
func (x *TypeModule) SetName(NameVar string) {

	xTypeModuleSetName(x.GoPointer(), NameVar)

}

var xTypeModuleUnuse func(uintptr)

// Decreases the use count of a #GTypeModule by one. If the
// result is zero, the module will be unloaded. (However, the
// #GTypeModule will not be freed, and types associated with the
// #GTypeModule are not unregistered. Once a #GTypeModule is
// initialized, it must exist forever.)
func (x *TypeModule) Unuse() {

	xTypeModuleUnuse(x.GoPointer())

}

var xTypeModuleUse func(uintptr) bool

// Increases the use count of a #GTypeModule by one. If the
// use count was zero before, the plugin will be loaded.
// If loading the plugin fails, the use count is reset to
// its prior value.
func (x *TypeModule) Use() bool {

	cret := xTypeModuleUse(x.GoPointer())
	return cret
}

func (c *TypeModule) GoPointer() uintptr {
	return c.Ptr
}

func (c *TypeModule) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Calls the @complete_interface_info function from the
// #GTypePluginClass of @plugin. There should be no need to use this
// function outside of the GObject type system itself.
func (x *TypeModule) CompleteInterfaceInfo(InstanceTypeVar types.GType, InterfaceTypeVar types.GType, InfoVar *InterfaceInfo) {

	XGTypePluginCompleteInterfaceInfo(x.GoPointer(), InstanceTypeVar, InterfaceTypeVar, InfoVar)

}

// Calls the @complete_type_info function from the #GTypePluginClass of @plugin.
// There should be no need to use this function outside of the GObject
// type system itself.
func (x *TypeModule) CompleteTypeInfo(GTypeVar types.GType, InfoVar *TypeInfo, ValueTableVar *TypeValueTable) {

	XGTypePluginCompleteTypeInfo(x.GoPointer(), GTypeVar, InfoVar, ValueTableVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GOBJECT"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xTypeModuleAddInterface, lib, "g_type_module_add_interface")
	core.PuregoSafeRegister(&xTypeModuleRegisterEnum, lib, "g_type_module_register_enum")
	core.PuregoSafeRegister(&xTypeModuleRegisterFlags, lib, "g_type_module_register_flags")
	core.PuregoSafeRegister(&xTypeModuleRegisterType, lib, "g_type_module_register_type")
	core.PuregoSafeRegister(&xTypeModuleSetName, lib, "g_type_module_set_name")
	core.PuregoSafeRegister(&xTypeModuleUnuse, lib, "g_type_module_unuse")
	core.PuregoSafeRegister(&xTypeModuleUse, lib, "g_type_module_use")

}
