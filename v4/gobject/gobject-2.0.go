// Package gobject was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gobject

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
)

// An interface that handles the lifecycle of dynamically loaded types.
//
// The GObject type system supports dynamic loading of types.
// It goes as follows:
//
//  1. The type is initially introduced (usually upon loading the module
//     the first time, or by your main application that knows what modules
//     introduces what types), like this:
//     |[&lt;!-- language="C" --&gt;
//     new_type_id = g_type_register_dynamic (parent_type_id,
//     "TypeName",
//     new_type_plugin,
//     type_flags);
//     ]|
//     where @new_type_plugin is an implementation of the
//     #GTypePlugin interface.
//
//  2. The type's implementation is referenced, e.g. through
//     g_type_class_ref() or through g_type_create_instance() (this is
//     being called by g_object_new()) or through one of the above done on
//     a type derived from @new_type_id.
//
//  3. This causes the type system to load the type's implementation by
//     calling g_type_plugin_use() and g_type_plugin_complete_type_info()
//     on @new_type_plugin.
//
//  4. At some point the type's implementation isn't required anymore,
//     e.g. after g_type_class_unref() or g_type_free_instance() (called
//     when the reference count of an instance drops to zero).
//
//  5. This causes the type system to throw away the information retrieved
//     from g_type_plugin_complete_type_info() and then it calls
//     g_type_plugin_unuse() on @new_type_plugin.
//
// 6. Things may repeat from the second step.
//
// So basically, you need to implement a #GTypePlugin type that
// carries a use_count, once use_count goes from zero to one, you need
// to load the implementation to successfully handle the upcoming
// g_type_plugin_complete_type_info() call. Later, maybe after
// succeeding use/unuse calls, once use_count drops to zero, you can
// unload the implementation again. The type system makes sure to call
// g_type_plugin_use() and g_type_plugin_complete_type_info() again
// when the type is needed again.
//
// #GTypeModule is an implementation of #GTypePlugin that already
// implements most of this except for the actual module loading and
// unloading. It even handles multiple registered types per module.
type TypePlugin interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	CompleteInterfaceInfo(InstanceTypeVar []interface{}, InterfaceTypeVar []interface{}, InfoVar *InterfaceInfo)
	CompleteTypeInfo(GTypeVar []interface{}, InfoVar *TypeInfo, ValueTableVar *TypeValueTable)
	Unuse()
	Use()
}
type TypePluginBase struct {
	Ptr uintptr
}

func (x *TypePluginBase) GoPointer() uintptr {
	return x.Ptr
}

func (x *TypePluginBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Calls the @complete_interface_info function from the
// #GTypePluginClass of @plugin. There should be no need to use this
// function outside of the GObject type system itself.
func (x *TypePluginBase) CompleteInterfaceInfo(InstanceTypeVar []interface{}, InterfaceTypeVar []interface{}, InfoVar *InterfaceInfo) {

	XGTypePluginCompleteInterfaceInfo(x.GoPointer(), InstanceTypeVar, InterfaceTypeVar, InfoVar)

}

// Calls the @complete_type_info function from the #GTypePluginClass of @plugin.
// There should be no need to use this function outside of the GObject
// type system itself.
func (x *TypePluginBase) CompleteTypeInfo(GTypeVar []interface{}, InfoVar *TypeInfo, ValueTableVar *TypeValueTable) {

	XGTypePluginCompleteTypeInfo(x.GoPointer(), GTypeVar, InfoVar, ValueTableVar)

}

// Calls the @unuse_plugin function from the #GTypePluginClass of
// @plugin.  There should be no need to use this function outside of
// the GObject type system itself.
func (x *TypePluginBase) Unuse() {

	XGTypePluginUnuse(x.GoPointer())

}

// Calls the @use_plugin function from the #GTypePluginClass of
// @plugin.  There should be no need to use this function outside of
// the GObject type system itself.
func (x *TypePluginBase) Use() {

	XGTypePluginUse(x.GoPointer())

}

var XGTypePluginCompleteInterfaceInfo func(uintptr, []interface{}, []interface{}, *InterfaceInfo)
var XGTypePluginCompleteTypeInfo func(uintptr, []interface{}, *TypeInfo, *TypeValueTable)
var XGTypePluginUnuse func(uintptr)
var XGTypePluginUse func(uintptr)

// #GBinding is the representation of a binding between a property on a
// #GObject instance (or source) and another property on another #GObject
// instance (or target).
//
// Whenever the source property changes, the same value is applied to the
// target property; for instance, the following binding:
//
// |[&lt;!-- language="C" --&gt;
//
//	g_object_bind_property (object1, "property-a",
//	                        object2, "property-b",
//	                        G_BINDING_DEFAULT);
//
// ]|
//
// will cause the property named "property-b" of @object2 to be updated
// every time g_object_set() or the specific accessor changes the value of
// the property "property-a" of @object1.
//
// It is possible to create a bidirectional binding between two properties
// of two #GObject instances, so that if either property changes, the
// other is updated as well, for instance:
//
// |[&lt;!-- language="C" --&gt;
//
//	g_object_bind_property (object1, "property-a",
//	                        object2, "property-b",
//	                        G_BINDING_BIDIRECTIONAL);
//
// ]|
//
// will keep the two properties in sync.
//
// It is also possible to set a custom transformation function (in both
// directions, in case of a bidirectional binding) to apply a custom
// transformation from the source value to the target value before
// applying it; for instance, the following binding:
//
// |[&lt;!-- language="C" --&gt;
//
//	g_object_bind_property_full (adjustment1, "value",
//	                             adjustment2, "value",
//	                             G_BINDING_BIDIRECTIONAL,
//	                             celsius_to_fahrenheit,
//	                             fahrenheit_to_celsius,
//	                             NULL, NULL);
//
// ]|
//
// will keep the "value" property of the two adjustments in sync; the
// @celsius_to_fahrenheit function will be called whenever the "value"
// property of @adjustment1 changes and will transform the current value
// of the property before applying it to the "value" property of @adjustment2.
//
// Vice versa, the @fahrenheit_to_celsius function will be called whenever
// the "value" property of @adjustment2 changes, and will transform the
// current value of the property before applying it to the "value" property
// of @adjustment1.
//
// Note that #GBinding does not resolve cycles by itself; a cycle like
//
// |[
//
//	object1:propertyA -&gt; object2:propertyB
//	object2:propertyB -&gt; object3:propertyC
//	object3:propertyC -&gt; object1:propertyA
//
// ]|
//
// might lead to an infinite loop. The loop, in this particular case,
// can be avoided if the objects emit the #GObject::notify signal only
// if the value has effectively been changed. A binding is implemented
// using the #GObject::notify signal, so it is susceptible to all the
// various ways of blocking a signal emission, like g_signal_stop_emission()
// or g_signal_handler_block().
//
// A binding will be severed, and the resources it allocates freed, whenever
// either one of the #GObject instances it refers to are finalized, or when
// the #GBinding instance loses its last reference.
//
// Bindings for languages with garbage collection can use
// g_binding_unbind() to explicitly release a binding between the source
// and target properties, instead of relying on the last reference on the
// binding, source, and target instances to drop.
//
// #GBinding is available since GObject 2.26
type Binding struct {
	Object
}

func BindingNewFromInternalPtr(ptr uintptr) *Binding {
	cls := &Binding{}
	cls.Ptr = ptr
	return cls
}

var xBindingDupSource func(uintptr) uintptr

// Retrieves the #GObject instance used as the source of the binding.
//
// A #GBinding can outlive the source #GObject as the binding does not hold a
// strong reference to the source. If the source is destroyed before the
// binding then this function will return %NULL.
func (x *Binding) DupSource() *Object {
	var cls *Object

	cret := xBindingDupSource(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xBindingDupTarget func(uintptr) uintptr

// Retrieves the #GObject instance used as the target of the binding.
//
// A #GBinding can outlive the target #GObject as the binding does not hold a
// strong reference to the target. If the target is destroyed before the
// binding then this function will return %NULL.
func (x *Binding) DupTarget() *Object {
	var cls *Object

	cret := xBindingDupTarget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xBindingGetFlags func(uintptr) BindingFlags

// Retrieves the flags passed when constructing the #GBinding.
func (x *Binding) GetFlags() BindingFlags {

	cret := xBindingGetFlags(x.GoPointer())
	return cret
}

var xBindingGetSource func(uintptr) uintptr

// Retrieves the #GObject instance used as the source of the binding.
//
// A #GBinding can outlive the source #GObject as the binding does not hold a
// strong reference to the source. If the source is destroyed before the
// binding then this function will return %NULL.
//
// Use g_binding_dup_source() if the source or binding are used from different
// threads as otherwise the pointer returned from this function might become
// invalid if the source is finalized from another thread in the meantime.
func (x *Binding) GetSource() *Object {
	var cls *Object

	cret := xBindingGetSource(x.GoPointer())

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xBindingGetSourceProperty func(uintptr) string

// Retrieves the name of the property of #GBinding:source used as the source
// of the binding.
func (x *Binding) GetSourceProperty() string {

	cret := xBindingGetSourceProperty(x.GoPointer())
	return cret
}

var xBindingGetTarget func(uintptr) uintptr

// Retrieves the #GObject instance used as the target of the binding.
//
// A #GBinding can outlive the target #GObject as the binding does not hold a
// strong reference to the target. If the target is destroyed before the
// binding then this function will return %NULL.
//
// Use g_binding_dup_target() if the target or binding are used from different
// threads as otherwise the pointer returned from this function might become
// invalid if the target is finalized from another thread in the meantime.
func (x *Binding) GetTarget() *Object {
	var cls *Object

	cret := xBindingGetTarget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xBindingGetTargetProperty func(uintptr) string

// Retrieves the name of the property of #GBinding:target used as the target
// of the binding.
func (x *Binding) GetTargetProperty() string {

	cret := xBindingGetTargetProperty(x.GoPointer())
	return cret
}

var xBindingUnbind func(uintptr)

// Explicitly releases the binding between the source and the target
// property expressed by @binding.
//
// This function will release the reference that is being held on
// the @binding instance if the binding is still bound; if you want to hold on
// to the #GBinding instance after calling g_binding_unbind(), you will need
// to hold a reference to it.
//
// Note however that this function does not take ownership of @binding, it
// only unrefs the reference that was initially created by
// g_object_bind_property() and is owned by the binding.
func (x *Binding) Unbind() {

	xBindingUnbind(x.GoPointer())

}

func (c *Binding) GoPointer() uintptr {
	return c.Ptr
}

func (c *Binding) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// The #GBindingGroup can be used to bind multiple properties
// from an object collectively.
//
// Use the various methods to bind properties from a single source
// object to multiple destination objects. Properties can be bound
// bidirectionally and are connected when the source object is set
// with g_binding_group_set_source().
type BindingGroup struct {
	Object
}

func BindingGroupNewFromInternalPtr(ptr uintptr) *BindingGroup {
	cls := &BindingGroup{}
	cls.Ptr = ptr
	return cls
}

var xNewBindingGroup func() uintptr

// Creates a new #GBindingGroup.
func NewBindingGroup() *BindingGroup {
	var cls *BindingGroup

	cret := xNewBindingGroup()

	if cret == 0 {
		return nil
	}
	cls = &BindingGroup{}
	cls.Ptr = cret
	return cls
}

var xBindingGroupBind func(uintptr, string, uintptr, string, BindingFlags)

// Creates a binding between @source_property on the source object
// and @target_property on @target. Whenever the @source_property
// is changed the @target_property is updated using the same value.
// The binding flag %G_BINDING_SYNC_CREATE is automatically specified.
//
// See g_object_bind_property() for more information.
func (x *BindingGroup) Bind(SourcePropertyVar string, TargetVar *Object, TargetPropertyVar string, FlagsVar BindingFlags) {

	xBindingGroupBind(x.GoPointer(), SourcePropertyVar, TargetVar.GoPointer(), TargetPropertyVar, FlagsVar)

}

var xBindingGroupBindFull func(uintptr, string, uintptr, string, BindingFlags, uintptr, uintptr, uintptr, uintptr)

// Creates a binding between @source_property on the source object and
// @target_property on @target, allowing you to set the transformation
// functions to be used by the binding. The binding flag
// %G_BINDING_SYNC_CREATE is automatically specified.
//
// See g_object_bind_property_full() for more information.
func (x *BindingGroup) BindFull(SourcePropertyVar string, TargetVar *Object, TargetPropertyVar string, FlagsVar BindingFlags, TransformToVar *BindingTransformFunc, TransformFromVar *BindingTransformFunc, UserDataVar uintptr, UserDataDestroyVar *glib.DestroyNotify) {

	xBindingGroupBindFull(x.GoPointer(), SourcePropertyVar, TargetVar.GoPointer(), TargetPropertyVar, FlagsVar, glib.NewCallback(TransformToVar), glib.NewCallback(TransformFromVar), UserDataVar, glib.NewCallback(UserDataDestroyVar))

}

var xBindingGroupBindWithClosures func(uintptr, string, uintptr, string, BindingFlags, *Closure, *Closure)

// Creates a binding between @source_property on the source object and
// @target_property on @target, allowing you to set the transformation
// functions to be used by the binding. The binding flag
// %G_BINDING_SYNC_CREATE is automatically specified.
//
// This function is the language bindings friendly version of
// g_binding_group_bind_property_full(), using #GClosures
// instead of function pointers.
//
// See g_object_bind_property_with_closures() for more information.
func (x *BindingGroup) BindWithClosures(SourcePropertyVar string, TargetVar *Object, TargetPropertyVar string, FlagsVar BindingFlags, TransformToVar *Closure, TransformFromVar *Closure) {

	xBindingGroupBindWithClosures(x.GoPointer(), SourcePropertyVar, TargetVar.GoPointer(), TargetPropertyVar, FlagsVar, TransformToVar, TransformFromVar)

}

var xBindingGroupDupSource func(uintptr) uintptr

// Gets the source object used for binding properties.
func (x *BindingGroup) DupSource() *Object {
	var cls *Object

	cret := xBindingGroupDupSource(x.GoPointer())

	if cret == 0 {
		return nil
	}
	IncreaseRef(cret)
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xBindingGroupSetSource func(uintptr, uintptr)

// Sets @source as the source object used for creating property
// bindings. If there is already a source object all bindings from it
// will be removed.
//
// Note that all properties that have been bound must exist on @source.
func (x *BindingGroup) SetSource(SourceVar *Object) {

	xBindingGroupSetSource(x.GoPointer(), SourceVar.GoPointer())

}

func (c *BindingGroup) GoPointer() uintptr {
	return c.Ptr
}

func (c *BindingGroup) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// #GSignalGroup manages to simplify the process of connecting
// many signals to a #GObject as a group. As such there is no API
// to disconnect a signal from the group.
//
// In particular, this allows you to:
//
//   - Change the target instance, which automatically causes disconnection
//     of the signals from the old instance and connecting to the new instance.
//   - Block and unblock signals as a group
//   - Ensuring that blocked state transfers across target instances.
//
// One place you might want to use such a structure is with #GtkTextView and
// #GtkTextBuffer. Often times, you'll need to connect to many signals on
// #GtkTextBuffer from a #GtkTextView subclass. This allows you to create a
// signal group during instance construction, simply bind the
// #GtkTextView:buffer property to #GSignalGroup:target and connect
// all the signals you need. When the #GtkTextView:buffer property changes
// all of the signals will be transitioned correctly.
type SignalGroup struct {
	Object
}

func SignalGroupNewFromInternalPtr(ptr uintptr) *SignalGroup {
	cls := &SignalGroup{}
	cls.Ptr = ptr
	return cls
}

var xNewSignalGroup func([]interface{}) uintptr

// Creates a new #GSignalGroup for target instances of @target_type.
func NewSignalGroup(TargetTypeVar []interface{}) *SignalGroup {
	var cls *SignalGroup

	cret := xNewSignalGroup(TargetTypeVar)

	if cret == 0 {
		return nil
	}
	cls = &SignalGroup{}
	cls.Ptr = cret
	return cls
}

var xSignalGroupBlock func(uintptr)

// Blocks all signal handlers managed by @self so they will not
// be called during any signal emissions. Must be unblocked exactly
// the same number of times it has been blocked to become active again.
//
// This blocked state will be kept across changes of the target instance.
func (x *SignalGroup) Block() {

	xSignalGroupBlock(x.GoPointer())

}

var xSignalGroupConnect func(uintptr, string, uintptr, uintptr)

// Connects @c_handler to the signal @detailed_signal
// on the target instance of @self.
//
// You cannot connect a signal handler after #GSignalGroup:target has been set.
func (x *SignalGroup) Connect(DetailedSignalVar string, CHandlerVar *Callback, DataVar uintptr) {

	xSignalGroupConnect(x.GoPointer(), DetailedSignalVar, glib.NewCallback(CHandlerVar), DataVar)

}

var xSignalGroupConnectAfter func(uintptr, string, uintptr, uintptr)

// Connects @c_handler to the signal @detailed_signal
// on the target instance of @self.
//
// The @c_handler will be called after the default handler of the signal.
//
// You cannot connect a signal handler after #GSignalGroup:target has been set.
func (x *SignalGroup) ConnectAfter(DetailedSignalVar string, CHandlerVar *Callback, DataVar uintptr) {

	xSignalGroupConnectAfter(x.GoPointer(), DetailedSignalVar, glib.NewCallback(CHandlerVar), DataVar)

}

var xSignalGroupConnectData func(uintptr, string, uintptr, uintptr, uintptr, ConnectFlags)

// Connects @c_handler to the signal @detailed_signal
// on the target instance of @self.
//
// You cannot connect a signal handler after #GSignalGroup:target has been set.
func (x *SignalGroup) ConnectData(DetailedSignalVar string, CHandlerVar *Callback, DataVar uintptr, NotifyVar *ClosureNotify, FlagsVar ConnectFlags) {

	xSignalGroupConnectData(x.GoPointer(), DetailedSignalVar, glib.NewCallback(CHandlerVar), DataVar, glib.NewCallback(NotifyVar), FlagsVar)

}

var xSignalGroupConnectObject func(uintptr, string, uintptr, uintptr, ConnectFlags)

// Connects @c_handler to the signal @detailed_signal on #GSignalGroup:target.
//
// Ensures that the @object stays alive during the call to @c_handler
// by temporarily adding a reference count. When the @object is destroyed
// the signal handler will automatically be removed.
//
// You cannot connect a signal handler after #GSignalGroup:target has been set.
func (x *SignalGroup) ConnectObject(DetailedSignalVar string, CHandlerVar *Callback, ObjectVar uintptr, FlagsVar ConnectFlags) {

	xSignalGroupConnectObject(x.GoPointer(), DetailedSignalVar, glib.NewCallback(CHandlerVar), ObjectVar, FlagsVar)

}

var xSignalGroupConnectSwapped func(uintptr, string, uintptr, uintptr)

// Connects @c_handler to the signal @detailed_signal
// on the target instance of @self.
//
// The instance on which the signal is emitted and @data
// will be swapped when calling @c_handler.
//
// You cannot connect a signal handler after #GSignalGroup:target has been set.
func (x *SignalGroup) ConnectSwapped(DetailedSignalVar string, CHandlerVar *Callback, DataVar uintptr) {

	xSignalGroupConnectSwapped(x.GoPointer(), DetailedSignalVar, glib.NewCallback(CHandlerVar), DataVar)

}

var xSignalGroupDupTarget func(uintptr) uintptr

// Gets the target instance used when connecting signals.
func (x *SignalGroup) DupTarget() *Object {
	var cls *Object

	cret := xSignalGroupDupTarget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Object{}
	cls.Ptr = cret
	return cls
}

var xSignalGroupSetTarget func(uintptr, uintptr)

// Sets the target instance used when connecting signals. Any signal
// that has been registered with g_signal_group_connect_object() or
// similar functions will be connected to this object.
//
// If the target instance was previously set, signals will be
// disconnected from that object prior to connecting to @target.
func (x *SignalGroup) SetTarget(TargetVar *Object) {

	xSignalGroupSetTarget(x.GoPointer(), TargetVar.GoPointer())

}

var xSignalGroupUnblock func(uintptr)

// Unblocks all signal handlers managed by @self so they will be
// called again during any signal emissions unless it is blocked
// again. Must be unblocked exactly the same number of times it
// has been blocked to become active again.
func (x *SignalGroup) Unblock() {

	xSignalGroupUnblock(x.GoPointer())

}

func (c *SignalGroup) GoPointer() uintptr {
	return c.Ptr
}

func (c *SignalGroup) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// This signal is emitted when #GSignalGroup:target is set to a new value
// other than %NULL. It is similar to #GObject::notify on `target` except it
// will not emit when #GSignalGroup:target is %NULL and also allows for
// receiving the #GObject without a data-race.
func (x *SignalGroup) ConnectBind(cb *func(SignalGroup, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return SignalConnect(x.GoPointer(), "bind", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, InstanceVarp uintptr) {
		fa := SignalGroup{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, InstanceVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return SignalConnect(x.GoPointer(), "bind", cbRefPtr)
}

// This signal is emitted when the target instance of @self is set to a
// new #GObject.
//
// This signal will only be emitted if the previous target of @self is
// non-%NULL.
func (x *SignalGroup) ConnectUnbind(cb *func(SignalGroup)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return SignalConnect(x.GoPointer(), "unbind", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := SignalGroup{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return SignalConnect(x.GoPointer(), "unbind", cbRefPtr)
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GOBJECT"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xBindingDupSource, lib, "g_binding_dup_source")
	core.PuregoSafeRegister(&xBindingDupTarget, lib, "g_binding_dup_target")
	core.PuregoSafeRegister(&xBindingGetFlags, lib, "g_binding_get_flags")
	core.PuregoSafeRegister(&xBindingGetSource, lib, "g_binding_get_source")
	core.PuregoSafeRegister(&xBindingGetSourceProperty, lib, "g_binding_get_source_property")
	core.PuregoSafeRegister(&xBindingGetTarget, lib, "g_binding_get_target")
	core.PuregoSafeRegister(&xBindingGetTargetProperty, lib, "g_binding_get_target_property")
	core.PuregoSafeRegister(&xBindingUnbind, lib, "g_binding_unbind")

	core.PuregoSafeRegister(&xNewBindingGroup, lib, "g_binding_group_new")

	core.PuregoSafeRegister(&xBindingGroupBind, lib, "g_binding_group_bind")
	core.PuregoSafeRegister(&xBindingGroupBindFull, lib, "g_binding_group_bind_full")
	core.PuregoSafeRegister(&xBindingGroupBindWithClosures, lib, "g_binding_group_bind_with_closures")
	core.PuregoSafeRegister(&xBindingGroupDupSource, lib, "g_binding_group_dup_source")
	core.PuregoSafeRegister(&xBindingGroupSetSource, lib, "g_binding_group_set_source")

	core.PuregoSafeRegister(&xNewSignalGroup, lib, "g_signal_group_new")

	core.PuregoSafeRegister(&xSignalGroupBlock, lib, "g_signal_group_block")
	core.PuregoSafeRegister(&xSignalGroupConnect, lib, "g_signal_group_connect")
	core.PuregoSafeRegister(&xSignalGroupConnectAfter, lib, "g_signal_group_connect_after")
	core.PuregoSafeRegister(&xSignalGroupConnectData, lib, "g_signal_group_connect_data")
	core.PuregoSafeRegister(&xSignalGroupConnectObject, lib, "g_signal_group_connect_object")
	core.PuregoSafeRegister(&xSignalGroupConnectSwapped, lib, "g_signal_group_connect_swapped")
	core.PuregoSafeRegister(&xSignalGroupDupTarget, lib, "g_signal_group_dup_target")
	core.PuregoSafeRegister(&xSignalGroupSetTarget, lib, "g_signal_group_set_target")
	core.PuregoSafeRegister(&xSignalGroupUnblock, lib, "g_signal_group_unblock")

	core.PuregoSafeRegister(&XGTypePluginCompleteInterfaceInfo, lib, "g_type_plugin_complete_interface_info")
	core.PuregoSafeRegister(&XGTypePluginCompleteTypeInfo, lib, "g_type_plugin_complete_type_info")
	core.PuregoSafeRegister(&XGTypePluginUnuse, lib, "g_type_plugin_unuse")
	core.PuregoSafeRegister(&XGTypePluginUse, lib, "g_type_plugin_use")

}
