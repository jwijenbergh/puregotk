// Package gobject was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gobject

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The signal accumulator is a special callback function that can be used
// to collect return values of the various callbacks that are called
// during a signal emission.
//
// The signal accumulator is specified at signal creation time, if it is
// left %NULL, no accumulation of callback return values is performed.
// The return value of signal emissions is then the value returned by the
// last callback.
type SignalAccumulator func(*SignalInvocationHint, *Value, *Value, uintptr) bool

// A simple function pointer to get invoked when the signal is emitted.
//
// Emission hooks allow you to tie a hook to the signal type, so that it will
// trap all emissions of that signal, from any object.
//
// You may not attach these to signals created with the %G_SIGNAL_NO_HOOKS flag.
type SignalEmissionHook func(*SignalInvocationHint, uint, []Value, uintptr) bool

// The #GSignalInvocationHint structure is used to pass on additional information
// to callbacks during a signal emission.
type SignalInvocationHint struct {
	SignalId uint

	Detail glib.Quark

	RunType SignalFlags
}

func (x *SignalInvocationHint) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A structure holding in-depth information for a specific signal.
//
// See also: g_signal_query()
type SignalQuery struct {
	SignalId uint

	SignalName uintptr

	Itype types.GType

	SignalFlags SignalFlags

	ReturnType types.GType

	NParams uint

	ParamTypes []types.GType
}

func (x *SignalQuery) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// This is the signature of marshaller functions, required to marshall
// arrays of parameter values to signal emissions into C language callback
// invocations.
//
// It is merely an alias to #GClosureMarshal since the #GClosure mechanism
// takes over responsibility of actual function invocation for the signal
// system.
type SignalCMarshaller = ClosureMarshal

// This is the signature of va_list marshaller functions, an optional
// marshaller that can be used in some situations to avoid
// marshalling the signal argument into GValues.
type SignalCVaMarshaller = VaClosureMarshal

const (
	// A mask for all #GSignalFlags bits.
	SIGNAL_FLAGS_MASK int = 511
	// A mask for all #GSignalMatchType bits.
	SIGNAL_MATCH_MASK int = 63
)

// The connection flags are used to specify the behaviour of a signal's
// connection.
type ConnectFlags int

const (

	// whether the handler should be called before or after the
	//  default handler of the signal.
	GConnectAfterValue ConnectFlags = 1
	// whether the instance and data should be swapped when
	//  calling the handler; see g_signal_connect_swapped() for an example.
	GConnectSwappedValue ConnectFlags = 2
)

// The signal flags are used to specify a signal's behaviour.
type SignalFlags int

const (

	// Invoke the object method handler in the first emission stage.
	GSignalRunFirstValue SignalFlags = 1
	// Invoke the object method handler in the third emission stage.
	GSignalRunLastValue SignalFlags = 2
	// Invoke the object method handler in the last emission stage.
	GSignalRunCleanupValue SignalFlags = 4
	// Signals being emitted for an object while currently being in
	//  emission for this very object will not be emitted recursively,
	//  but instead cause the first emission to be restarted.
	GSignalNoRecurseValue SignalFlags = 8
	// This signal supports "::detail" appendices to the signal name
	//  upon handler connections and emissions.
	GSignalDetailedValue SignalFlags = 16
	// Action signals are signals that may freely be emitted on alive
	//  objects from user code via g_signal_emit() and friends, without
	//  the need of being embedded into extra code that performs pre or
	//  post emission adjustments on the object. They can also be thought
	//  of as object methods which can be called generically by
	//  third-party code.
	GSignalActionValue SignalFlags = 32
	// No emissions hooks are supported for this signal.
	GSignalNoHooksValue SignalFlags = 64
	// Varargs signal emission will always collect the
	//   arguments, even if there are no signal handlers connected.  Since 2.30.
	GSignalMustCollectValue SignalFlags = 128
	// The signal is deprecated and will be removed
	//   in a future version. A warning will be generated if it is connected while
	//   running with G_ENABLE_DIAGNOSTIC=1.  Since 2.32.
	GSignalDeprecatedValue SignalFlags = 256
	// Only used in #GSignalAccumulator accumulator
	//   functions for the #GSignalInvocationHint::run_type field to mark the first
	//   call to the accumulator function for a signal emission.  Since 2.68.
	GSignalAccumulatorFirstRunValue SignalFlags = 131072
)

// The match types specify what g_signal_handlers_block_matched(),
// g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()
// match signals by.
type SignalMatchType int

const (

	// The signal id must be equal.
	GSignalMatchIdValue SignalMatchType = 1
	// The signal detail must be equal.
	GSignalMatchDetailValue SignalMatchType = 2
	// The closure must be the same.
	GSignalMatchClosureValue SignalMatchType = 4
	// The C closure callback must be the same.
	GSignalMatchFuncValue SignalMatchType = 8
	// The closure data must be the same.
	GSignalMatchDataValue SignalMatchType = 16
	// Only unblocked signals may be matched.
	GSignalMatchUnblockedValue SignalMatchType = 32
)

var xClearSignalHandler func(uint32, uintptr)

// Disconnects a handler from @instance so it will not be called during
// any future or currently ongoing emissions of the signal it has been
// connected to. The @handler_id_ptr is then set to zero, which is never a valid handler ID value (see g_signal_connect()).
//
// If the handler ID is 0 then this function does nothing.
//
// There is also a macro version of this function so that the code
// will be inlined.
func ClearSignalHandler(HandlerIdPtrVar uint32, InstanceVar *Object) {

	xClearSignalHandler(HandlerIdPtrVar, InstanceVar.GoPointer())

}

var xSignalAccumulatorFirstWins func(*SignalInvocationHint, *Value, *Value, uintptr) bool

// A predefined #GSignalAccumulator for signals intended to be used as a
// hook for application code to provide a particular value.  Usually
// only one such value is desired and multiple handlers for the same
// signal don't make much sense (except for the case of the default
// handler defined in the class structure, in which case you will
// usually want the signal connection to override the class handler).
//
// This accumulator will use the return value from the first signal
// handler that is run as the return value for the signal and not run
// any further handlers (ie: the first handler "wins").
func SignalAccumulatorFirstWins(IhintVar *SignalInvocationHint, ReturnAccuVar *Value, HandlerReturnVar *Value, DummyVar uintptr) bool {

	cret := xSignalAccumulatorFirstWins(IhintVar, ReturnAccuVar, HandlerReturnVar, DummyVar)
	return cret
}

var xSignalAccumulatorTrueHandled func(*SignalInvocationHint, *Value, *Value, uintptr) bool

// A predefined #GSignalAccumulator for signals that return a
// boolean values. The behavior that this accumulator gives is
// that a return of %TRUE stops the signal emission: no further
// callbacks will be invoked, while a return of %FALSE allows
// the emission to continue. The idea here is that a %TRUE return
// indicates that the callback handled the signal, and no further
// handling is needed.
func SignalAccumulatorTrueHandled(IhintVar *SignalInvocationHint, ReturnAccuVar *Value, HandlerReturnVar *Value, DummyVar uintptr) bool {

	cret := xSignalAccumulatorTrueHandled(IhintVar, ReturnAccuVar, HandlerReturnVar, DummyVar)
	return cret
}

var xSignalAddEmissionHook func(uint, glib.Quark, uintptr, uintptr, uintptr) uint32

// Adds an emission hook for a signal, which will get called for any emission
// of that signal, independent of the instance. This is possible only
// for signals which don't have %G_SIGNAL_NO_HOOKS flag set.
func SignalAddEmissionHook(SignalIdVar uint, DetailVar glib.Quark, HookFuncVar *SignalEmissionHook, HookDataVar uintptr, DataDestroyVar *glib.DestroyNotify) uint32 {

	cret := xSignalAddEmissionHook(SignalIdVar, DetailVar, glib.NewCallback(HookFuncVar), HookDataVar, glib.NewCallback(DataDestroyVar))
	return cret
}

var xSignalChainFromOverridden func([]Value, *Value)

// Calls the original class closure of a signal. This function should only
// be called from an overridden class closure; see
// g_signal_override_class_closure() and
// g_signal_override_class_handler().
func SignalChainFromOverridden(InstanceAndParamsVar []Value, ReturnValueVar *Value) {

	xSignalChainFromOverridden(InstanceAndParamsVar, ReturnValueVar)

}

var xSignalChainFromOverriddenHandler func(*TypeInstance, ...interface{})

// Calls the original class closure of a signal. This function should
// only be called from an overridden class closure; see
// g_signal_override_class_closure() and
// g_signal_override_class_handler().
func SignalChainFromOverriddenHandler(InstanceVar *TypeInstance, varArgs ...interface{}) {

	xSignalChainFromOverriddenHandler(InstanceVar, varArgs...)

}

var xSignalConnectClosure func(uintptr, string, *Closure, bool) uint32

// Connects a closure to a signal for a particular object.
func SignalConnectClosure(InstanceVar *Object, DetailedSignalVar string, ClosureVar *Closure, AfterVar bool) uint32 {

	cret := xSignalConnectClosure(InstanceVar.GoPointer(), DetailedSignalVar, ClosureVar, AfterVar)
	return cret
}

var xSignalConnectClosureById func(uintptr, uint, glib.Quark, *Closure, bool) uint32

// Connects a closure to a signal for a particular object.
func SignalConnectClosureById(InstanceVar *Object, SignalIdVar uint, DetailVar glib.Quark, ClosureVar *Closure, AfterVar bool) uint32 {

	cret := xSignalConnectClosureById(InstanceVar.GoPointer(), SignalIdVar, DetailVar, ClosureVar, AfterVar)
	return cret
}

var xSignalConnectData func(uintptr, string, uintptr, uintptr, uintptr, ConnectFlags) uint32

// Connects a #GCallback function to a signal for a particular object. Similar
// to g_signal_connect(), but allows to provide a #GClosureNotify for the data
// which will be called when the signal handler is disconnected and no longer
// used. Specify @connect_flags if you need `..._after()` or
// `..._swapped()` variants of this function.
func SignalConnectData(InstanceVar *Object, DetailedSignalVar string, CHandlerVar *Callback, DataVar uintptr, DestroyDataVar *ClosureNotify, ConnectFlagsVar ConnectFlags) uint32 {

	cret := xSignalConnectData(InstanceVar.GoPointer(), DetailedSignalVar, glib.NewCallback(CHandlerVar), DataVar, glib.NewCallback(DestroyDataVar), ConnectFlagsVar)
	return cret
}

var xSignalEmit func(uintptr, uint, glib.Quark, ...interface{})

// Emits a signal. Signal emission is done synchronously.
// The method will only return control after all handlers are called or signal emission was stopped.
//
// Note that g_signal_emit() resets the return value to the default
// if no handlers are connected, in contrast to g_signal_emitv().
func SignalEmit(InstanceVar *Object, SignalIdVar uint, DetailVar glib.Quark, varArgs ...interface{}) {

	xSignalEmit(InstanceVar.GoPointer(), SignalIdVar, DetailVar, varArgs...)

}

var xSignalEmitByName func(uintptr, string, ...interface{})

// Emits a signal. Signal emission is done synchronously.
// The method will only return control after all handlers are called or signal emission was stopped.
//
// Note that g_signal_emit_by_name() resets the return value to the default
// if no handlers are connected, in contrast to g_signal_emitv().
func SignalEmitByName(InstanceVar *Object, DetailedSignalVar string, varArgs ...interface{}) {

	xSignalEmitByName(InstanceVar.GoPointer(), DetailedSignalVar, varArgs...)

}

var xSignalEmitValist func(*TypeInstance, uint, glib.Quark, []interface{})

// Emits a signal. Signal emission is done synchronously.
// The method will only return control after all handlers are called or signal emission was stopped.
//
// Note that g_signal_emit_valist() resets the return value to the default
// if no handlers are connected, in contrast to g_signal_emitv().
func SignalEmitValist(InstanceVar *TypeInstance, SignalIdVar uint, DetailVar glib.Quark, VarArgsVar []interface{}) {

	xSignalEmitValist(InstanceVar, SignalIdVar, DetailVar, VarArgsVar)

}

var xSignalEmitv func([]Value, uint, glib.Quark, *Value)

// Emits a signal. Signal emission is done synchronously.
// The method will only return control after all handlers are called or signal emission was stopped.
//
// Note that g_signal_emitv() doesn't change @return_value if no handlers are
// connected, in contrast to g_signal_emit() and g_signal_emit_valist().
func SignalEmitv(InstanceAndParamsVar []Value, SignalIdVar uint, DetailVar glib.Quark, ReturnValueVar *Value) {

	xSignalEmitv(InstanceAndParamsVar, SignalIdVar, DetailVar, ReturnValueVar)

}

var xSignalGetInvocationHint func(uintptr) *SignalInvocationHint

// Returns the invocation hint of the innermost signal emission of instance.
func SignalGetInvocationHint(InstanceVar *Object) *SignalInvocationHint {

	cret := xSignalGetInvocationHint(InstanceVar.GoPointer())
	return cret
}

var xSignalHandlerBlock func(uintptr, uint32)

// Blocks a handler of an instance so it will not be called during any
// signal emissions unless it is unblocked again. Thus "blocking" a
// signal handler means to temporarily deactivate it, a signal handler
// has to be unblocked exactly the same amount of times it has been
// blocked before to become active again.
//
// The @handler_id has to be a valid signal handler id, connected to a
// signal of @instance.
func SignalHandlerBlock(InstanceVar *Object, HandlerIdVar uint32) {

	xSignalHandlerBlock(InstanceVar.GoPointer(), HandlerIdVar)

}

var xSignalHandlerDisconnect func(uintptr, uint32)

// Disconnects a handler from an instance so it will not be called during
// any future or currently ongoing emissions of the signal it has been
// connected to. The @handler_id becomes invalid and may be reused.
//
// The @handler_id has to be a valid signal handler id, connected to a
// signal of @instance.
func SignalHandlerDisconnect(InstanceVar *Object, HandlerIdVar uint32) {

	xSignalHandlerDisconnect(InstanceVar.GoPointer(), HandlerIdVar)

}

var xSignalHandlerFind func(uintptr, SignalMatchType, uint, glib.Quark, *Closure, uintptr, uintptr) uint32

// Finds the first signal handler that matches certain selection criteria.
// The criteria mask is passed as an OR-ed combination of #GSignalMatchType
// flags, and the criteria values are passed as arguments.
// The match @mask has to be non-0 for successful matches.
// If no handler was found, 0 is returned.
func SignalHandlerFind(InstanceVar *Object, MaskVar SignalMatchType, SignalIdVar uint, DetailVar glib.Quark, ClosureVar *Closure, FuncVar uintptr, DataVar uintptr) uint32 {

	cret := xSignalHandlerFind(InstanceVar.GoPointer(), MaskVar, SignalIdVar, DetailVar, ClosureVar, FuncVar, DataVar)
	return cret
}

var xSignalHandlerIsConnected func(uintptr, uint32) bool

// Returns whether @handler_id is the ID of a handler connected to @instance.
func SignalHandlerIsConnected(InstanceVar *Object, HandlerIdVar uint32) bool {

	cret := xSignalHandlerIsConnected(InstanceVar.GoPointer(), HandlerIdVar)
	return cret
}

var xSignalHandlerUnblock func(uintptr, uint32)

// Undoes the effect of a previous g_signal_handler_block() call.  A
// blocked handler is skipped during signal emissions and will not be
// invoked, unblocking it (for exactly the amount of times it has been
// blocked before) reverts its "blocked" state, so the handler will be
// recognized by the signal system and is called upon future or
// currently ongoing signal emissions (since the order in which
// handlers are called during signal emissions is deterministic,
// whether the unblocked handler in question is called as part of a
// currently ongoing emission depends on how far that emission has
// proceeded yet).
//
// The @handler_id has to be a valid id of a signal handler that is
// connected to a signal of @instance and is currently blocked.
func SignalHandlerUnblock(InstanceVar *Object, HandlerIdVar uint32) {

	xSignalHandlerUnblock(InstanceVar.GoPointer(), HandlerIdVar)

}

var xSignalHandlersBlockMatched func(uintptr, SignalMatchType, uint, glib.Quark, *Closure, uintptr, uintptr) uint

// Blocks all handlers on an instance that match a certain selection criteria.
// The criteria mask is passed as an OR-ed combination of #GSignalMatchType
// flags, and the criteria values are passed as arguments.
// Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
// or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
// If no handlers were found, 0 is returned, the number of blocked handlers
// otherwise.
func SignalHandlersBlockMatched(InstanceVar *Object, MaskVar SignalMatchType, SignalIdVar uint, DetailVar glib.Quark, ClosureVar *Closure, FuncVar uintptr, DataVar uintptr) uint {

	cret := xSignalHandlersBlockMatched(InstanceVar.GoPointer(), MaskVar, SignalIdVar, DetailVar, ClosureVar, FuncVar, DataVar)
	return cret
}

var xSignalHandlersDestroy func(uintptr)

// Destroy all signal handlers of a type instance. This function is
// an implementation detail of the #GObject dispose implementation,
// and should not be used outside of the type system.
func SignalHandlersDestroy(InstanceVar *Object) {

	xSignalHandlersDestroy(InstanceVar.GoPointer())

}

var xSignalHandlersDisconnectMatched func(uintptr, SignalMatchType, uint, glib.Quark, *Closure, uintptr, uintptr) uint

// Disconnects all handlers on an instance that match a certain
// selection criteria. The criteria mask is passed as an OR-ed
// combination of #GSignalMatchType flags, and the criteria values are
// passed as arguments.  Passing at least one of the
// %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC or
// %G_SIGNAL_MATCH_DATA match flags is required for successful
// matches.  If no handlers were found, 0 is returned, the number of
// disconnected handlers otherwise.
func SignalHandlersDisconnectMatched(InstanceVar *Object, MaskVar SignalMatchType, SignalIdVar uint, DetailVar glib.Quark, ClosureVar *Closure, FuncVar uintptr, DataVar uintptr) uint {

	cret := xSignalHandlersDisconnectMatched(InstanceVar.GoPointer(), MaskVar, SignalIdVar, DetailVar, ClosureVar, FuncVar, DataVar)
	return cret
}

var xSignalHandlersUnblockMatched func(uintptr, SignalMatchType, uint, glib.Quark, *Closure, uintptr, uintptr) uint

// Unblocks all handlers on an instance that match a certain selection
// criteria. The criteria mask is passed as an OR-ed combination of
// #GSignalMatchType flags, and the criteria values are passed as arguments.
// Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
// or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
// If no handlers were found, 0 is returned, the number of unblocked handlers
// otherwise. The match criteria should not apply to any handlers that are
// not currently blocked.
func SignalHandlersUnblockMatched(InstanceVar *Object, MaskVar SignalMatchType, SignalIdVar uint, DetailVar glib.Quark, ClosureVar *Closure, FuncVar uintptr, DataVar uintptr) uint {

	cret := xSignalHandlersUnblockMatched(InstanceVar.GoPointer(), MaskVar, SignalIdVar, DetailVar, ClosureVar, FuncVar, DataVar)
	return cret
}

var xSignalHasHandlerPending func(uintptr, uint, glib.Quark, bool) bool

// Returns whether there are any handlers connected to @instance for the
// given signal id and detail.
//
// If @detail is 0 then it will only match handlers that were connected
// without detail.  If @detail is non-zero then it will match handlers
// connected both without detail and with the given detail.  This is
// consistent with how a signal emitted with @detail would be delivered
// to those handlers.
//
// Since 2.46 this also checks for a non-default class closure being
// installed, as this is basically always what you want.
//
// One example of when you might use this is when the arguments to the
// signal are difficult to compute. A class implementor may opt to not
// emit the signal if no one is attached anyway, thus saving the cost
// of building the arguments.
func SignalHasHandlerPending(InstanceVar *Object, SignalIdVar uint, DetailVar glib.Quark, MayBeBlockedVar bool) bool {

	cret := xSignalHasHandlerPending(InstanceVar.GoPointer(), SignalIdVar, DetailVar, MayBeBlockedVar)
	return cret
}

var xSignalIsValidName func(string) bool

// Validate a signal name. This can be useful for dynamically-generated signals
// which need to be validated at run-time before actually trying to create them.
//
// See [canonical parameter names][canonical-parameter-names] for details of
// the rules for valid names. The rules for signal names are the same as those
// for property names.
func SignalIsValidName(NameVar string) bool {

	cret := xSignalIsValidName(NameVar)
	return cret
}

var xSignalListIds func(types.GType, uint) []uint

// Lists the signals by id that a certain instance or interface type
// created. Further information about the signals can be acquired through
// g_signal_query().
func SignalListIds(ItypeVar types.GType, NIdsVar uint) []uint {

	cret := xSignalListIds(ItypeVar, NIdsVar)
	return cret
}

var xSignalLookup func(string, types.GType) uint

// Given the name of the signal and the type of object it connects to, gets
// the signal's identifying integer. Emitting the signal by number is
// somewhat faster than using the name each time.
//
// Also tries the ancestors of the given type.
//
// The type class passed as @itype must already have been instantiated (for
// example, using g_type_class_ref()) for this function to work, as signals are
// always installed during class initialization.
//
// See g_signal_new() for details on allowed signal names.
func SignalLookup(NameVar string, ItypeVar types.GType) uint {

	cret := xSignalLookup(NameVar, ItypeVar)
	return cret
}

var xSignalName func(uint) string

// Given the signal's identifier, finds its name.
//
// Two different signals may have the same name, if they have differing types.
func SignalName(SignalIdVar uint) string {

	cret := xSignalName(SignalIdVar)
	return cret
}

var xSignalNew func(string, types.GType, SignalFlags, uint, uintptr, uintptr, SignalCMarshaller, types.GType, uint, ...interface{}) uint

// Creates a new signal. (This is usually done in the class initializer.)
//
// A signal name consists of segments consisting of ASCII letters and
// digits, separated by either the `-` or `_` character. The first
// character of a signal name must be a letter. Names which violate these
// rules lead to undefined behaviour. These are the same rules as for property
// naming (see g_param_spec_internal()).
//
// When registering a signal and looking up a signal, either separator can
// be used, but they cannot be mixed. Using `-` is considerably more efficient.
// Using `_` is discouraged.
//
// If 0 is used for @class_offset subclasses cannot override the class handler
// in their class_init method by doing super_class-&gt;signal_handler = my_signal_handler.
// Instead they will have to use g_signal_override_class_handler().
//
// If @c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
// the marshaller for this signal. In some simple cases, g_signal_new()
// will use a more optimized c_marshaller and va_marshaller for the signal
// instead of g_cclosure_marshal_generic().
//
// If @c_marshaller is non-%NULL, you need to also specify a va_marshaller
// using g_signal_set_va_marshaller() or the generic va_marshaller will
// be used.
func SignalNew(SignalNameVar string, ItypeVar types.GType, SignalFlagsVar SignalFlags, ClassOffsetVar uint, AccumulatorVar *SignalAccumulator, AccuDataVar uintptr, CMarshallerVar SignalCMarshaller, ReturnTypeVar types.GType, NParamsVar uint, varArgs ...interface{}) uint {

	cret := xSignalNew(SignalNameVar, ItypeVar, SignalFlagsVar, ClassOffsetVar, glib.NewCallback(AccumulatorVar), AccuDataVar, CMarshallerVar, ReturnTypeVar, NParamsVar, varArgs...)
	return cret
}

var xSignalNewClassHandler func(string, types.GType, SignalFlags, uintptr, uintptr, uintptr, SignalCMarshaller, types.GType, uint, ...interface{}) uint

// Creates a new signal. (This is usually done in the class initializer.)
//
// This is a variant of g_signal_new() that takes a C callback instead
// of a class offset for the signal's class handler. This function
// doesn't need a function pointer exposed in the class structure of
// an object definition, instead the function pointer is passed
// directly and can be overridden by derived classes with
// g_signal_override_class_closure() or
// g_signal_override_class_handler()and chained to with
// g_signal_chain_from_overridden() or
// g_signal_chain_from_overridden_handler().
//
// See g_signal_new() for information about signal names.
//
// If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
// the marshaller for this signal.
func SignalNewClassHandler(SignalNameVar string, ItypeVar types.GType, SignalFlagsVar SignalFlags, ClassHandlerVar *Callback, AccumulatorVar *SignalAccumulator, AccuDataVar uintptr, CMarshallerVar SignalCMarshaller, ReturnTypeVar types.GType, NParamsVar uint, varArgs ...interface{}) uint {

	cret := xSignalNewClassHandler(SignalNameVar, ItypeVar, SignalFlagsVar, glib.NewCallback(ClassHandlerVar), glib.NewCallback(AccumulatorVar), AccuDataVar, CMarshallerVar, ReturnTypeVar, NParamsVar, varArgs...)
	return cret
}

var xSignalNewValist func(string, types.GType, SignalFlags, *Closure, uintptr, uintptr, SignalCMarshaller, types.GType, uint, []interface{}) uint

// Creates a new signal. (This is usually done in the class initializer.)
//
// See g_signal_new() for details on allowed signal names.
//
// If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
// the marshaller for this signal.
func SignalNewValist(SignalNameVar string, ItypeVar types.GType, SignalFlagsVar SignalFlags, ClassClosureVar *Closure, AccumulatorVar *SignalAccumulator, AccuDataVar uintptr, CMarshallerVar SignalCMarshaller, ReturnTypeVar types.GType, NParamsVar uint, ArgsVar []interface{}) uint {

	cret := xSignalNewValist(SignalNameVar, ItypeVar, SignalFlagsVar, ClassClosureVar, glib.NewCallback(AccumulatorVar), AccuDataVar, CMarshallerVar, ReturnTypeVar, NParamsVar, ArgsVar)
	return cret
}

var xSignalNewv func(string, types.GType, SignalFlags, *Closure, uintptr, uintptr, SignalCMarshaller, types.GType, uint, []types.GType) uint

// Creates a new signal. (This is usually done in the class initializer.)
//
// See g_signal_new() for details on allowed signal names.
//
// If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
// the marshaller for this signal.
func SignalNewv(SignalNameVar string, ItypeVar types.GType, SignalFlagsVar SignalFlags, ClassClosureVar *Closure, AccumulatorVar *SignalAccumulator, AccuDataVar uintptr, CMarshallerVar SignalCMarshaller, ReturnTypeVar types.GType, NParamsVar uint, ParamTypesVar []types.GType) uint {

	cret := xSignalNewv(SignalNameVar, ItypeVar, SignalFlagsVar, ClassClosureVar, glib.NewCallback(AccumulatorVar), AccuDataVar, CMarshallerVar, ReturnTypeVar, NParamsVar, ParamTypesVar)
	return cret
}

var xSignalOverrideClassClosure func(uint, types.GType, *Closure)

// Overrides the class closure (i.e. the default handler) for the given signal
// for emissions on instances of @instance_type. @instance_type must be derived
// from the type to which the signal belongs.
//
// See g_signal_chain_from_overridden() and
// g_signal_chain_from_overridden_handler() for how to chain up to the
// parent class closure from inside the overridden one.
func SignalOverrideClassClosure(SignalIdVar uint, InstanceTypeVar types.GType, ClassClosureVar *Closure) {

	xSignalOverrideClassClosure(SignalIdVar, InstanceTypeVar, ClassClosureVar)

}

var xSignalOverrideClassHandler func(string, types.GType, uintptr)

// Overrides the class closure (i.e. the default handler) for the
// given signal for emissions on instances of @instance_type with
// callback @class_handler. @instance_type must be derived from the
// type to which the signal belongs.
//
// See g_signal_chain_from_overridden() and
// g_signal_chain_from_overridden_handler() for how to chain up to the
// parent class closure from inside the overridden one.
func SignalOverrideClassHandler(SignalNameVar string, InstanceTypeVar types.GType, ClassHandlerVar *Callback) {

	xSignalOverrideClassHandler(SignalNameVar, InstanceTypeVar, glib.NewCallback(ClassHandlerVar))

}

var xSignalParseName func(string, types.GType, uint, *glib.Quark, bool) bool

// Internal function to parse a signal name into its @signal_id
// and @detail quark.
func SignalParseName(DetailedSignalVar string, ItypeVar types.GType, SignalIdPVar uint, DetailPVar *glib.Quark, ForceDetailQuarkVar bool) bool {

	cret := xSignalParseName(DetailedSignalVar, ItypeVar, SignalIdPVar, DetailPVar, ForceDetailQuarkVar)
	return cret
}

var xNewSignalQuery func(uint, *SignalQuery)

// Queries the signal system for in-depth information about a
// specific signal. This function will fill in a user-provided
// structure to hold signal-specific information. If an invalid
// signal id is passed in, the @signal_id member of the #GSignalQuery
// is 0. All members filled into the #GSignalQuery structure should
// be considered constant and have to be left untouched.
func NewSignalQuery(SignalIdVar uint, QueryVar *SignalQuery) {

	xNewSignalQuery(SignalIdVar, QueryVar)

}

var xSignalRemoveEmissionHook func(uint, uint32)

// Deletes an emission hook.
func SignalRemoveEmissionHook(SignalIdVar uint, HookIdVar uint32) {

	xSignalRemoveEmissionHook(SignalIdVar, HookIdVar)

}

var xSignalSetVaMarshaller func(uint, types.GType, SignalCVaMarshaller)

// Change the #GSignalCVaMarshaller used for a given signal.  This is a
// specialised form of the marshaller that can often be used for the
// common case of a single connected signal handler and avoids the
// overhead of #GValue.  Its use is optional.
func SignalSetVaMarshaller(SignalIdVar uint, InstanceTypeVar types.GType, VaMarshallerVar SignalCVaMarshaller) {

	xSignalSetVaMarshaller(SignalIdVar, InstanceTypeVar, VaMarshallerVar)

}

var xSignalStopEmission func(uintptr, uint, glib.Quark)

// Stops a signal's current emission.
//
// This will prevent the default method from running, if the signal was
// %G_SIGNAL_RUN_LAST and you connected normally (i.e. without the "after"
// flag).
//
// Prints a warning if used on a signal which isn't being emitted.
func SignalStopEmission(InstanceVar *Object, SignalIdVar uint, DetailVar glib.Quark) {

	xSignalStopEmission(InstanceVar.GoPointer(), SignalIdVar, DetailVar)

}

var xSignalStopEmissionByName func(uintptr, string)

// Stops a signal's current emission.
//
// This is just like g_signal_stop_emission() except it will look up the
// signal id for you.
func SignalStopEmissionByName(InstanceVar *Object, DetailedSignalVar string) {

	xSignalStopEmissionByName(InstanceVar.GoPointer(), DetailedSignalVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GOBJECT"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xClearSignalHandler, lib, "g_clear_signal_handler")
	core.PuregoSafeRegister(&xSignalAccumulatorFirstWins, lib, "g_signal_accumulator_first_wins")
	core.PuregoSafeRegister(&xSignalAccumulatorTrueHandled, lib, "g_signal_accumulator_true_handled")
	core.PuregoSafeRegister(&xSignalAddEmissionHook, lib, "g_signal_add_emission_hook")
	core.PuregoSafeRegister(&xSignalChainFromOverridden, lib, "g_signal_chain_from_overridden")
	core.PuregoSafeRegister(&xSignalChainFromOverriddenHandler, lib, "g_signal_chain_from_overridden_handler")
	core.PuregoSafeRegister(&xSignalConnectClosure, lib, "g_signal_connect_closure")
	core.PuregoSafeRegister(&xSignalConnectClosureById, lib, "g_signal_connect_closure_by_id")
	core.PuregoSafeRegister(&xSignalConnectData, lib, "g_signal_connect_data")
	core.PuregoSafeRegister(&xSignalEmit, lib, "g_signal_emit")
	core.PuregoSafeRegister(&xSignalEmitByName, lib, "g_signal_emit_by_name")
	core.PuregoSafeRegister(&xSignalEmitValist, lib, "g_signal_emit_valist")
	core.PuregoSafeRegister(&xSignalEmitv, lib, "g_signal_emitv")
	core.PuregoSafeRegister(&xSignalGetInvocationHint, lib, "g_signal_get_invocation_hint")
	core.PuregoSafeRegister(&xSignalHandlerBlock, lib, "g_signal_handler_block")
	core.PuregoSafeRegister(&xSignalHandlerDisconnect, lib, "g_signal_handler_disconnect")
	core.PuregoSafeRegister(&xSignalHandlerFind, lib, "g_signal_handler_find")
	core.PuregoSafeRegister(&xSignalHandlerIsConnected, lib, "g_signal_handler_is_connected")
	core.PuregoSafeRegister(&xSignalHandlerUnblock, lib, "g_signal_handler_unblock")
	core.PuregoSafeRegister(&xSignalHandlersBlockMatched, lib, "g_signal_handlers_block_matched")
	core.PuregoSafeRegister(&xSignalHandlersDestroy, lib, "g_signal_handlers_destroy")
	core.PuregoSafeRegister(&xSignalHandlersDisconnectMatched, lib, "g_signal_handlers_disconnect_matched")
	core.PuregoSafeRegister(&xSignalHandlersUnblockMatched, lib, "g_signal_handlers_unblock_matched")
	core.PuregoSafeRegister(&xSignalHasHandlerPending, lib, "g_signal_has_handler_pending")
	core.PuregoSafeRegister(&xSignalIsValidName, lib, "g_signal_is_valid_name")
	core.PuregoSafeRegister(&xSignalListIds, lib, "g_signal_list_ids")
	core.PuregoSafeRegister(&xSignalLookup, lib, "g_signal_lookup")
	core.PuregoSafeRegister(&xSignalName, lib, "g_signal_name")
	core.PuregoSafeRegister(&xSignalNew, lib, "g_signal_new")
	core.PuregoSafeRegister(&xSignalNewClassHandler, lib, "g_signal_new_class_handler")
	core.PuregoSafeRegister(&xSignalNewValist, lib, "g_signal_new_valist")
	core.PuregoSafeRegister(&xSignalNewv, lib, "g_signal_newv")
	core.PuregoSafeRegister(&xSignalOverrideClassClosure, lib, "g_signal_override_class_closure")
	core.PuregoSafeRegister(&xSignalOverrideClassHandler, lib, "g_signal_override_class_handler")
	core.PuregoSafeRegister(&xSignalParseName, lib, "g_signal_parse_name")
	core.PuregoSafeRegister(&xNewSignalQuery, lib, "g_signal_query")
	core.PuregoSafeRegister(&xSignalRemoveEmissionHook, lib, "g_signal_remove_emission_hook")
	core.PuregoSafeRegister(&xSignalSetVaMarshaller, lib, "g_signal_set_va_marshaller")
	core.PuregoSafeRegister(&xSignalStopEmission, lib, "g_signal_stop_emission")
	core.PuregoSafeRegister(&xSignalStopEmissionByName, lib, "g_signal_stop_emission_by_name")

}
