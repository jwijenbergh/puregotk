// Package gdk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gdk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// Class structure for `GdkContentProvider`.
type ContentProviderClass struct {
	ParentClass uintptr

	Padding uintptr
}

func (x *ContentProviderClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A `GdkContentProvider` is used to provide content for the clipboard or
// for drag-and-drop operations in a number of formats.
//
// To create a `GdkContentProvider`, use [ctor@Gdk.ContentProvider.new_for_value]
// or [ctor@Gdk.ContentProvider.new_for_bytes].
//
// GDK knows how to handle common text and image formats out-of-the-box. See
// [class@Gdk.ContentSerializer] and [class@Gdk.ContentDeserializer] if you want
// to add support for application-specific data formats.
type ContentProvider struct {
	gobject.Object
}

func ContentProviderNewFromInternalPtr(ptr uintptr) *ContentProvider {
	cls := &ContentProvider{}
	cls.Ptr = ptr
	return cls
}

var xNewContentProviderForBytes func(string, *glib.Bytes) uintptr

// Create a content provider that provides the given @bytes as data for
// the given @mime_type.
func NewContentProviderForBytes(MimeTypeVar string, BytesVar *glib.Bytes) *ContentProvider {
	var cls *ContentProvider

	cret := xNewContentProviderForBytes(MimeTypeVar, BytesVar)

	if cret == 0 {
		return nil
	}
	cls = &ContentProvider{}
	cls.Ptr = cret
	return cls
}

var xNewContentProviderForValue func(*gobject.Value) uintptr

// Create a content provider that provides the given @value.
func NewContentProviderForValue(ValueVar *gobject.Value) *ContentProvider {
	var cls *ContentProvider

	cret := xNewContentProviderForValue(ValueVar)

	if cret == 0 {
		return nil
	}
	cls = &ContentProvider{}
	cls.Ptr = cret
	return cls
}

var xNewContentProviderTyped func([]interface{}, ...interface{}) uintptr

// Create a content provider that provides the value of the given
// @type.
//
// The value is provided using G_VALUE_COLLECT(), so the same rules
// apply as when calling g_object_new() or g_object_set().
func NewContentProviderTyped(TypeVar []interface{}, varArgs ...interface{}) *ContentProvider {
	var cls *ContentProvider

	cret := xNewContentProviderTyped(TypeVar, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &ContentProvider{}
	cls.Ptr = cret
	return cls
}

var xNewContentProviderUnion func(uintptr, uint) uintptr

// Creates a content provider that represents all the given @providers.
//
// Whenever data needs to be written, the union provider will try the given
// @providers in the given order and the first one supporting a format will
// be chosen to provide it.
//
// This allows an easy way to support providing data in different formats.
// For example, an image may be provided by its file and by the image
// contents with a call such as
// ```c
//
//	gdk_content_provider_new_union ((GdkContentProvider *[2]) {
//	                                  gdk_content_provider_new_typed (G_TYPE_FILE, file),
//	                                  gdk_content_provider_new_typed (G_TYPE_TEXTURE, texture)
//	                                }, 2);
//
// ```
func NewContentProviderUnion(ProvidersVar uintptr, NProvidersVar uint) *ContentProvider {
	var cls *ContentProvider

	cret := xNewContentProviderUnion(ProvidersVar, NProvidersVar)

	if cret == 0 {
		return nil
	}
	cls = &ContentProvider{}
	cls.Ptr = cret
	return cls
}

var xContentProviderContentChanged func(uintptr)

// Emits the ::content-changed signal.
func (x *ContentProvider) ContentChanged() {

	xContentProviderContentChanged(x.GoPointer())

}

var xContentProviderGetValue func(uintptr, *gobject.Value, **glib.Error) bool

// Gets the contents of @provider stored in @value.
//
// The @value will have been initialized to the `GType` the value should be
// provided in. This given `GType` does not need to be listed in the formats
// returned by [method@Gdk.ContentProvider.ref_formats]. However, if the
// given `GType` is not supported, this operation can fail and
// `G_IO_ERROR_NOT_SUPPORTED` will be reported.
func (x *ContentProvider) GetValue(ValueVar *gobject.Value) (bool, error) {
	var cerr *glib.Error

	cret := xContentProviderGetValue(x.GoPointer(), ValueVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xContentProviderRefFormats func(uintptr) *ContentFormats

// Gets the formats that the provider can provide its current contents in.
func (x *ContentProvider) RefFormats() *ContentFormats {

	cret := xContentProviderRefFormats(x.GoPointer())
	return cret
}

var xContentProviderRefStorableFormats func(uintptr) *ContentFormats

// Gets the formats that the provider suggests other applications to store
// the data in.
//
// An example of such an application would be a clipboard manager.
//
// This can be assumed to be a subset of [method@Gdk.ContentProvider.ref_formats].
func (x *ContentProvider) RefStorableFormats() *ContentFormats {

	cret := xContentProviderRefStorableFormats(x.GoPointer())
	return cret
}

var xContentProviderWriteMimeTypeAsync func(uintptr, string, uintptr, int, uintptr, uintptr, uintptr)

// Asynchronously writes the contents of @provider to @stream in the given
// @mime_type.
//
// When the operation is finished @callback will be called. You must then call
// [method@Gdk.ContentProvider.write_mime_type_finish] to get the result
// of the operation.
//
// The given mime type does not need to be listed in the formats returned by
// [method@Gdk.ContentProvider.ref_formats]. However, if the given `GType` is
// not supported, `G_IO_ERROR_NOT_SUPPORTED` will be reported.
//
// The given @stream will not be closed.
func (x *ContentProvider) WriteMimeTypeAsync(MimeTypeVar string, StreamVar *gio.OutputStream, IoPriorityVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xContentProviderWriteMimeTypeAsync(x.GoPointer(), MimeTypeVar, StreamVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xContentProviderWriteMimeTypeFinish func(uintptr, uintptr, **glib.Error) bool

// Finishes an asynchronous write operation.
//
// See [method@Gdk.ContentProvider.write_mime_type_async].
func (x *ContentProvider) WriteMimeTypeFinish(ResultVar gio.AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xContentProviderWriteMimeTypeFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *ContentProvider) GoPointer() uintptr {
	return c.Ptr
}

func (c *ContentProvider) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted whenever the content provided by this provider has changed.
func (x *ContentProvider) ConnectContentChanged(cb *func(ContentProvider)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "content-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := ContentProvider{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "content-changed", cbRefPtr)
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GDK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewContentProviderForBytes, lib, "gdk_content_provider_new_for_bytes")
	core.PuregoSafeRegister(&xNewContentProviderForValue, lib, "gdk_content_provider_new_for_value")
	core.PuregoSafeRegister(&xNewContentProviderTyped, lib, "gdk_content_provider_new_typed")
	core.PuregoSafeRegister(&xNewContentProviderUnion, lib, "gdk_content_provider_new_union")

	core.PuregoSafeRegister(&xContentProviderContentChanged, lib, "gdk_content_provider_content_changed")
	core.PuregoSafeRegister(&xContentProviderGetValue, lib, "gdk_content_provider_get_value")
	core.PuregoSafeRegister(&xContentProviderRefFormats, lib, "gdk_content_provider_ref_formats")
	core.PuregoSafeRegister(&xContentProviderRefStorableFormats, lib, "gdk_content_provider_ref_storable_formats")
	core.PuregoSafeRegister(&xContentProviderWriteMimeTypeAsync, lib, "gdk_content_provider_write_mime_type_async")
	core.PuregoSafeRegister(&xContentProviderWriteMimeTypeFinish, lib, "gdk_content_provider_write_mime_type_finish")

}
