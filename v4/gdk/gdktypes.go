// Package gdk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gdk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The `GdkContentFormats` structure is used to advertise and negotiate the
// format of content.
//
// You will encounter `GdkContentFormats` when interacting with objects
// controlling operations that pass data between different widgets, window
// or application, like [class@Gdk.Drag], [class@Gdk.Drop],
// [class@Gdk.Clipboard] or [class@Gdk.ContentProvider].
//
// GDK supports content in 2 forms: `GType` and mime type.
// Using `GTypes` is meant only for in-process content transfers. Mime types
// are meant to be used for data passing both in-process and out-of-process.
// The details of how data is passed is described in the documentation of
// the actual implementations. To transform between the two forms,
// [class@Gdk.ContentSerializer] and [class@Gdk.ContentDeserializer] are used.
//
// A `GdkContentFormats` describes a set of possible formats content can be
// exchanged in. It is assumed that this set is ordered. `GTypes` are more
// important than mime types. Order between different `GTypes` or mime types
// is the order they were added in, most important first. Functions that
// care about order, such as [method@Gdk.ContentFormats.union], will describe
// in their documentation how they interpret that order, though in general the
// order of the first argument is considered the primary order of the result,
// followed by the order of further arguments.
//
// For debugging purposes, the function [method@Gdk.ContentFormats.to_string]
// exists. It will print a comma-separated list of formats from most important
// to least important.
//
// `GdkContentFormats` is an immutable struct. After creation, you cannot change
// the types it represents. Instead, new `GdkContentFormats` have to be created.
// The [struct@Gdk.ContentFormatsBuilder] structure is meant to help in this
// endeavor.
type ContentFormats struct {
}

func (x *ContentFormats) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewContentFormats func([]string, uint) *ContentFormats

// Creates a new `GdkContentFormats` from an array of mime types.
//
// The mime types must be valid and different from each other or the
// behavior of the return value is undefined. If you cannot guarantee
// this, use [struct@Gdk.ContentFormatsBuilder] instead.
func NewContentFormats(MimeTypesVar []string, NMimeTypesVar uint) *ContentFormats {

	cret := xNewContentFormats(MimeTypesVar, NMimeTypesVar)
	return cret
}

var xNewContentFormatsForGtype func(types.GType) *ContentFormats

// Creates a new `GdkContentFormats` for a given `GType`.
func NewContentFormatsForGtype(TypeVar types.GType) *ContentFormats {

	cret := xNewContentFormatsForGtype(TypeVar)
	return cret
}

var xContentFormatsContainGtype func(uintptr, types.GType) bool

// Checks if a given `GType` is part of the given @formats.
func (x *ContentFormats) ContainGtype(TypeVar types.GType) bool {

	cret := xContentFormatsContainGtype(x.GoPointer(), TypeVar)
	return cret
}

var xContentFormatsContainMimeType func(uintptr, string) bool

// Checks if a given mime type is part of the given @formats.
func (x *ContentFormats) ContainMimeType(MimeTypeVar string) bool {

	cret := xContentFormatsContainMimeType(x.GoPointer(), MimeTypeVar)
	return cret
}

var xContentFormatsGetGtypes func(uintptr, uint) []types.GType

// Gets the `GType`s included in @formats.
//
// Note that @formats may not contain any `GType`s, in particular when
// they are empty. In that case %NULL will be returned.
func (x *ContentFormats) GetGtypes(NGtypesVar uint) []types.GType {

	cret := xContentFormatsGetGtypes(x.GoPointer(), NGtypesVar)
	return cret
}

var xContentFormatsGetMimeTypes func(uintptr, uint) []string

// Gets the mime types included in @formats.
//
// Note that @formats may not contain any mime types, in particular
// when they are empty. In that case %NULL will be returned.
func (x *ContentFormats) GetMimeTypes(NMimeTypesVar uint) []string {

	cret := xContentFormatsGetMimeTypes(x.GoPointer(), NMimeTypesVar)
	return cret
}

var xContentFormatsMatch func(uintptr, *ContentFormats) bool

// Checks if @first and @second have any matching formats.
func (x *ContentFormats) Match(SecondVar *ContentFormats) bool {

	cret := xContentFormatsMatch(x.GoPointer(), SecondVar)
	return cret
}

var xContentFormatsMatchGtype func(uintptr, *ContentFormats) types.GType

// Finds the first `GType` from @first that is also contained
// in @second.
//
// If no matching `GType` is found, %G_TYPE_INVALID is returned.
func (x *ContentFormats) MatchGtype(SecondVar *ContentFormats) types.GType {

	cret := xContentFormatsMatchGtype(x.GoPointer(), SecondVar)
	return cret
}

var xContentFormatsMatchMimeType func(uintptr, *ContentFormats) string

// Finds the first mime type from @first that is also contained
// in @second.
//
// If no matching mime type is found, %NULL is returned.
func (x *ContentFormats) MatchMimeType(SecondVar *ContentFormats) string {

	cret := xContentFormatsMatchMimeType(x.GoPointer(), SecondVar)
	return cret
}

var xContentFormatsPrint func(uintptr, *glib.String)

// Prints the given @formats into a string for human consumption.
//
// The result of this function can later be parsed with
// [func@Gdk.ContentFormats.parse].
func (x *ContentFormats) Print(StringVar *glib.String) {

	xContentFormatsPrint(x.GoPointer(), StringVar)

}

var xContentFormatsRef func(uintptr) *ContentFormats

// Increases the reference count of a `GdkContentFormats` by one.
func (x *ContentFormats) Ref() *ContentFormats {

	cret := xContentFormatsRef(x.GoPointer())
	return cret
}

var xContentFormatsToString func(uintptr) string

// Prints the given @formats into a human-readable string.
//
// The resulting string can be parsed with [func@Gdk.ContentFormats.parse].
//
// This is a small wrapper around [method@Gdk.ContentFormats.print]
// to help when debugging.
func (x *ContentFormats) ToString() string {

	cret := xContentFormatsToString(x.GoPointer())
	return cret
}

var xContentFormatsUnion func(uintptr, *ContentFormats) *ContentFormats

// Append all missing types from @second to @first, in the order
// they had in @second.
func (x *ContentFormats) Union(SecondVar *ContentFormats) *ContentFormats {

	cret := xContentFormatsUnion(x.GoPointer(), SecondVar)
	return cret
}

var xContentFormatsUnionDeserializeGtypes func(uintptr) *ContentFormats

// Add GTypes for mime types in @formats for which deserializers are
// registered.
func (x *ContentFormats) UnionDeserializeGtypes() *ContentFormats {

	cret := xContentFormatsUnionDeserializeGtypes(x.GoPointer())
	return cret
}

var xContentFormatsUnionDeserializeMimeTypes func(uintptr) *ContentFormats

// Add mime types for GTypes in @formats for which deserializers are
// registered.
func (x *ContentFormats) UnionDeserializeMimeTypes() *ContentFormats {

	cret := xContentFormatsUnionDeserializeMimeTypes(x.GoPointer())
	return cret
}

var xContentFormatsUnionSerializeGtypes func(uintptr) *ContentFormats

// Add GTypes for the mime types in @formats for which serializers are
// registered.
func (x *ContentFormats) UnionSerializeGtypes() *ContentFormats {

	cret := xContentFormatsUnionSerializeGtypes(x.GoPointer())
	return cret
}

var xContentFormatsUnionSerializeMimeTypes func(uintptr) *ContentFormats

// Add mime types for GTypes in @formats for which serializers are
// registered.
func (x *ContentFormats) UnionSerializeMimeTypes() *ContentFormats {

	cret := xContentFormatsUnionSerializeMimeTypes(x.GoPointer())
	return cret
}

var xContentFormatsUnref func(uintptr)

// Decreases the reference count of a `GdkContentFormats` by one.
//
// If the resulting reference count is zero, frees the formats.
func (x *ContentFormats) Unref() {

	xContentFormatsUnref(x.GoPointer())

}

// A `GdkKeymapKey` is a hardware key that can be mapped to a keyval.
type KeymapKey struct {
	Keycode uint

	Group int

	Level int
}

func (x *KeymapKey) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A `GdkRectangle` data type for representing rectangles.
//
// `GdkRectangle` is identical to `cairo_rectangle_t`. Together with Cairo’s
// `cairo_region_t` data type, these are the central types for representing
// sets of pixels.
//
// The intersection of two rectangles can be computed with
// [method@Gdk.Rectangle.intersect]; to find the union of two rectangles use
// [method@Gdk.Rectangle.union].
//
// The `cairo_region_t` type provided by Cairo is usually used for managing
// non-rectangular clipping of graphical operations.
//
// The Graphene library has a number of other data types for regions and
// volumes in 2D and 3D.
type Rectangle struct {
	X int

	Y int

	Width int

	Height int
}

func (x *Rectangle) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xRectangleContainsPoint func(uintptr, int, int) bool

// Returns %TRUE if @rect contains the point described by @x and @y.
func (x *Rectangle) ContainsPoint(XVar int, YVar int) bool {

	cret := xRectangleContainsPoint(x.GoPointer(), XVar, YVar)
	return cret
}

var xRectangleEqual func(uintptr, *Rectangle) bool

// Checks if the two given rectangles are equal.
func (x *Rectangle) Equal(Rect2Var *Rectangle) bool {

	cret := xRectangleEqual(x.GoPointer(), Rect2Var)
	return cret
}

var xRectangleIntersect func(uintptr, *Rectangle, *Rectangle) bool

// Calculates the intersection of two rectangles.
//
// It is allowed for @dest to be the same as either @src1 or @src2.
// If the rectangles do not intersect, @dest’s width and height is set
// to 0 and its x and y values are undefined. If you are only interested
// in whether the rectangles intersect, but not in the intersecting area
// itself, pass %NULL for @dest.
func (x *Rectangle) Intersect(Src2Var *Rectangle, DestVar *Rectangle) bool {

	cret := xRectangleIntersect(x.GoPointer(), Src2Var, DestVar)
	return cret
}

var xRectangleUnion func(uintptr, *Rectangle, *Rectangle)

// Calculates the union of two rectangles.
//
// The union of rectangles @src1 and @src2 is the smallest rectangle which
// includes both @src1 and @src2 within it. It is allowed for @dest to be
// the same as either @src1 or @src2.
//
// Note that this function does not ignore 'empty' rectangles (ie. with
// zero width or height).
func (x *Rectangle) Union(Src2Var *Rectangle, DestVar *Rectangle) {

	xRectangleUnion(x.GoPointer(), Src2Var, DestVar)

}

const (
	// Represents the current time, and can be used anywhere a time is expected.
	CURRENT_TIME int = 0
)

func init() {
	lib, err := purego.Dlopen(core.GetPath("GDK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewContentFormats, lib, "gdk_content_formats_new")
	core.PuregoSafeRegister(&xNewContentFormatsForGtype, lib, "gdk_content_formats_new_for_gtype")

	core.PuregoSafeRegister(&xContentFormatsContainGtype, lib, "gdk_content_formats_contain_gtype")
	core.PuregoSafeRegister(&xContentFormatsContainMimeType, lib, "gdk_content_formats_contain_mime_type")
	core.PuregoSafeRegister(&xContentFormatsGetGtypes, lib, "gdk_content_formats_get_gtypes")
	core.PuregoSafeRegister(&xContentFormatsGetMimeTypes, lib, "gdk_content_formats_get_mime_types")
	core.PuregoSafeRegister(&xContentFormatsMatch, lib, "gdk_content_formats_match")
	core.PuregoSafeRegister(&xContentFormatsMatchGtype, lib, "gdk_content_formats_match_gtype")
	core.PuregoSafeRegister(&xContentFormatsMatchMimeType, lib, "gdk_content_formats_match_mime_type")
	core.PuregoSafeRegister(&xContentFormatsPrint, lib, "gdk_content_formats_print")
	core.PuregoSafeRegister(&xContentFormatsRef, lib, "gdk_content_formats_ref")
	core.PuregoSafeRegister(&xContentFormatsToString, lib, "gdk_content_formats_to_string")
	core.PuregoSafeRegister(&xContentFormatsUnion, lib, "gdk_content_formats_union")
	core.PuregoSafeRegister(&xContentFormatsUnionDeserializeGtypes, lib, "gdk_content_formats_union_deserialize_gtypes")
	core.PuregoSafeRegister(&xContentFormatsUnionDeserializeMimeTypes, lib, "gdk_content_formats_union_deserialize_mime_types")
	core.PuregoSafeRegister(&xContentFormatsUnionSerializeGtypes, lib, "gdk_content_formats_union_serialize_gtypes")
	core.PuregoSafeRegister(&xContentFormatsUnionSerializeMimeTypes, lib, "gdk_content_formats_union_serialize_mime_types")
	core.PuregoSafeRegister(&xContentFormatsUnref, lib, "gdk_content_formats_unref")

	core.PuregoSafeRegister(&xRectangleContainsPoint, lib, "gdk_rectangle_contains_point")
	core.PuregoSafeRegister(&xRectangleEqual, lib, "gdk_rectangle_equal")
	core.PuregoSafeRegister(&xRectangleIntersect, lib, "gdk_rectangle_intersect")
	core.PuregoSafeRegister(&xRectangleUnion, lib, "gdk_rectangle_union")

}
