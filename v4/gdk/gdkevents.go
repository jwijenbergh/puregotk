// Package gdk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gdk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// `GdkEventSequence` is an opaque type representing a sequence
// of related touch events.
type EventSequence struct {
}

func (x *EventSequence) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

const (
	// The middle button.
	BUTTON_MIDDLE int = 2
	// The primary button. This is typically the left mouse button, or the
	// right button in a left-handed setup.
	BUTTON_PRIMARY int = 1
	// The secondary button. This is typically the right mouse button, or the
	// left button in a left-handed setup.
	BUTTON_SECONDARY int = 3
	// Use this macro as the return value for continuing the propagation of
	// an event handler.
	EVENT_PROPAGATE bool = false
	// Use this macro as the return value for stopping the propagation of
	// an event handler.
	EVENT_STOP bool = true
	// This is the priority that the idle handler processing surface updates
	// is given in the main loop.
	PRIORITY_REDRAW int = 120
)

// Specifies the crossing mode for enter and leave events.
type CrossingMode int

const (

	// crossing because of pointer motion.
	CrossingNormalValue CrossingMode = 0
	// crossing because a grab is activated.
	CrossingGrabValue CrossingMode = 1
	// crossing because a grab is deactivated.
	CrossingUngrabValue CrossingMode = 2
	// crossing because a GTK grab is activated.
	CrossingGtkGrabValue CrossingMode = 3
	// crossing because a GTK grab is deactivated.
	CrossingGtkUngrabValue CrossingMode = 4
	// crossing because a GTK widget changed
	//   state (e.g. sensitivity).
	CrossingStateChangedValue CrossingMode = 5
	// crossing because a touch sequence has begun,
	//   this event is synthetic as the pointer might have not left the surface.
	CrossingTouchBeginValue CrossingMode = 6
	// crossing because a touch sequence has ended,
	//   this event is synthetic as the pointer might have not left the surface.
	CrossingTouchEndValue CrossingMode = 7
	// crossing because of a device switch (i.e.
	//   a mouse taking control of the pointer after a touch device), this event
	//   is synthetic as the pointer didnâ€™t leave the surface.
	CrossingDeviceSwitchValue CrossingMode = 8
)

// Specifies the type of the event.
type EventType int

const (

	// the window manager has requested that the toplevel surface be
	//   hidden or destroyed, usually when the user clicks on a special icon in the
	//   title bar.
	DeleteValue EventType = 0
	// the pointer (usually a mouse) has moved.
	MotionNotifyValue EventType = 1
	// a mouse button has been pressed.
	ButtonPressValue EventType = 2
	// a mouse button has been released.
	ButtonReleaseValue EventType = 3
	// a key has been pressed.
	KeyPressValue EventType = 4
	// a key has been released.
	KeyReleaseValue EventType = 5
	// the pointer has entered the surface.
	EnterNotifyValue EventType = 6
	// the pointer has left the surface.
	LeaveNotifyValue EventType = 7
	// the keyboard focus has entered or left the surface.
	FocusChangeValue EventType = 8
	// an input device has moved into contact with a sensing
	//   surface (e.g. a touchscreen or graphics tablet).
	ProximityInValue EventType = 9
	// an input device has moved out of contact with a sensing
	//   surface.
	ProximityOutValue EventType = 10
	// the mouse has entered the surface while a drag is in progress.
	DragEnterValue EventType = 11
	// the mouse has left the surface while a drag is in progress.
	DragLeaveValue EventType = 12
	// the mouse has moved in the surface while a drag is in
	//   progress.
	DragMotionValue EventType = 13
	// a drop operation onto the surface has started.
	DropStartValue EventType = 14
	// the scroll wheel was turned
	ScrollValue EventType = 15
	// a pointer or keyboard grab was broken.
	GrabBrokenValue EventType = 16
	// A new touch event sequence has just started.
	TouchBeginValue EventType = 17
	// A touch event sequence has been updated.
	TouchUpdateValue EventType = 18
	// A touch event sequence has finished.
	TouchEndValue EventType = 19
	// A touch event sequence has been canceled.
	TouchCancelValue EventType = 20
	// A touchpad swipe gesture event, the current state
	//   is determined by its phase field.
	TouchpadSwipeValue EventType = 21
	// A touchpad pinch gesture event, the current state
	//   is determined by its phase field.
	TouchpadPinchValue EventType = 22
	// A tablet pad button press event.
	PadButtonPressValue EventType = 23
	// A tablet pad button release event.
	PadButtonReleaseValue EventType = 24
	// A tablet pad axis event from a "ring".
	PadRingValue EventType = 25
	// A tablet pad axis event from a "strip".
	PadStripValue EventType = 26
	// A tablet pad group mode change.
	PadGroupModeValue EventType = 27
	// A touchpad hold gesture event, the current state
	//   is determined by its phase field. Since: 4.6
	TouchpadHoldValue EventType = 28
	// marks the end of the GdkEventType enumeration.
	EventLastValue EventType = 29
)

// Describes how well an event matches a given keyval and modifiers.
//
// `GdkKeyMatch` values are returned by [method@Gdk.KeyEvent.matches].
type KeyMatch int

const (

	// The key event does not match
	KeyMatchNoneValue KeyMatch = 0
	// The key event matches if keyboard state
	//   (specifically, the currently active group) is ignored
	KeyMatchPartialValue KeyMatch = 1
	// The key event matches
	KeyMatchExactValue KeyMatch = 2
)

// Specifies the kind of crossing for enter and leave events.
//
// See the X11 protocol specification of LeaveNotify for
// full details of crossing event generation.
type NotifyType int

const (

	// the surface is entered from an ancestor or
	//   left towards an ancestor.
	NotifyAncestorValue NotifyType = 0
	// the pointer moves between an ancestor and an
	//   inferior of the surface.
	NotifyVirtualValue NotifyType = 1
	// the surface is entered from an inferior or
	//   left towards an inferior.
	NotifyInferiorValue NotifyType = 2
	// the surface is entered from or left towards
	//   a surface which is neither an ancestor nor an inferior.
	NotifyNonlinearValue NotifyType = 3
	// the pointer moves between two surfaces
	//   which are not ancestors of each other and the surface is part of
	//   the ancestor chain between one of these surfaces and their least
	//   common ancestor.
	NotifyNonlinearVirtualValue NotifyType = 4
	// an unknown type of enter/leave event occurred.
	NotifyUnknownValue NotifyType = 5
)

// Specifies the direction for scroll events.
type ScrollDirection int

const (

	// the surface is scrolled up.
	ScrollUpValue ScrollDirection = 0
	// the surface is scrolled down.
	ScrollDownValue ScrollDirection = 1
	// the surface is scrolled to the left.
	ScrollLeftValue ScrollDirection = 2
	// the surface is scrolled to the right.
	ScrollRightValue ScrollDirection = 3
	// the scrolling is determined by the delta values
	//   in scroll events. See gdk_scroll_event_get_deltas()
	ScrollSmoothValue ScrollDirection = 4
)

// Specifies the unit of scroll deltas.
//
// When you get %GDK_SCROLL_UNIT_WHEEL, a delta of 1.0 means 1 wheel detent
// click in the south direction, 2.0 means 2 wheel detent clicks in the south
// direction... This is the same logic for negative values but in the north
// direction.
//
// If you get %GDK_SCROLL_UNIT_SURFACE, are managing a scrollable view and get a
// value of 123, you have to scroll 123 surface logical pixels right if it's
// @delta_x or down if it's @delta_y. This is the same logic for negative values
// but you have to scroll left instead of right if it's @delta_x and up instead
// of down if it's @delta_y.
//
// 1 surface logical pixel is equal to 1 real screen pixel multiplied by the
// final scale factor of your graphical interface (the product of the desktop
// scale factor and eventually a custom scale factor in your app).
type ScrollUnit int

const (

	// The delta is in number of wheel clicks.
	ScrollUnitWheelValue ScrollUnit = 0
	// The delta is in surface pixels to scroll directly
	//   on screen.
	ScrollUnitSurfaceValue ScrollUnit = 1
)

// Specifies the current state of a touchpad gesture.
//
// All gestures are guaranteed to begin with an event with phase
// %GDK_TOUCHPAD_GESTURE_PHASE_BEGIN, followed by 0 or several events
// with phase %GDK_TOUCHPAD_GESTURE_PHASE_UPDATE.
//
// A finished gesture may have 2 possible outcomes, an event with phase
// %GDK_TOUCHPAD_GESTURE_PHASE_END will be emitted when the gesture is
// considered successful, this should be used as the hint to perform any
// permanent changes.
//
// Cancelled gestures may be so for a variety of reasons, due to hardware
// or the compositor, or due to the gesture recognition layers hinting the
// gesture did not finish resolutely (eg. a 3rd finger being added during
// a pinch gesture). In these cases, the last event will report the phase
// %GDK_TOUCHPAD_GESTURE_PHASE_CANCEL, this should be used as a hint
// to undo any visible/permanent changes that were done throughout the
// progress of the gesture.
type TouchpadGesturePhase int

const (

	// The gesture has begun.
	TouchpadGesturePhaseBeginValue TouchpadGesturePhase = 0
	// The gesture has been updated.
	TouchpadGesturePhaseUpdateValue TouchpadGesturePhase = 1
	// The gesture was finished, changes
	//   should be permanently applied.
	TouchpadGesturePhaseEndValue TouchpadGesturePhase = 2
	// The gesture was cancelled, all
	//   changes should be undone.
	TouchpadGesturePhaseCancelValue TouchpadGesturePhase = 3
)

var xEventsGetAngle func(uintptr, uintptr, float64) bool

// Returns the relative angle from @event1 to @event2.
//
// The relative angle is the angle between the X axis and the line
// through both events' positions. The rotation direction for positive
// angles is from the positive X axis towards the positive Y axis.
//
// This assumes that both events have X/Y information.
// If not, this function returns %FALSE.
func EventsGetAngle(Event1Var *Event, Event2Var *Event, AngleVar float64) bool {

	cret := xEventsGetAngle(Event1Var.GoPointer(), Event2Var.GoPointer(), AngleVar)
	return cret
}

var xEventsGetCenter func(uintptr, uintptr, float64, float64) bool

// Returns the point halfway between the events' positions.
//
// This assumes that both events have X/Y information.
// If not, this function returns %FALSE.
func EventsGetCenter(Event1Var *Event, Event2Var *Event, XVar float64, YVar float64) bool {

	cret := xEventsGetCenter(Event1Var.GoPointer(), Event2Var.GoPointer(), XVar, YVar)
	return cret
}

var xEventsGetDistance func(uintptr, uintptr, float64) bool

// Returns the distance between the event locations.
//
// This assumes that both events have X/Y information.
// If not, this function returns %FALSE.
func EventsGetDistance(Event1Var *Event, Event2Var *Event, DistanceVar float64) bool {

	cret := xEventsGetDistance(Event1Var.GoPointer(), Event2Var.GoPointer(), DistanceVar)
	return cret
}

// An event related to a button on a pointer device.
type ButtonEvent struct {
	Event
}

func ButtonEventNewFromInternalPtr(ptr uintptr) *ButtonEvent {
	cls := &ButtonEvent{}
	cls.Ptr = ptr
	return cls
}

var xButtonEventGetButton func(uintptr) uint

// Extract the button number from a button event.
func (x *ButtonEvent) GetButton() uint {

	cret := xButtonEventGetButton(x.GoPointer())
	return cret
}

func (c *ButtonEvent) GoPointer() uintptr {
	return c.Ptr
}

func (c *ButtonEvent) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// An event caused by a pointing device moving between surfaces.
type CrossingEvent struct {
	Event
}

func CrossingEventNewFromInternalPtr(ptr uintptr) *CrossingEvent {
	cls := &CrossingEvent{}
	cls.Ptr = ptr
	return cls
}

var xCrossingEventGetDetail func(uintptr) NotifyType

// Extracts the notify detail from a crossing event.
func (x *CrossingEvent) GetDetail() NotifyType {

	cret := xCrossingEventGetDetail(x.GoPointer())
	return cret
}

var xCrossingEventGetFocus func(uintptr) bool

// Checks if the @event surface is the focus surface.
func (x *CrossingEvent) GetFocus() bool {

	cret := xCrossingEventGetFocus(x.GoPointer())
	return cret
}

var xCrossingEventGetMode func(uintptr) CrossingMode

// Extracts the crossing mode from a crossing event.
func (x *CrossingEvent) GetMode() CrossingMode {

	cret := xCrossingEventGetMode(x.GoPointer())
	return cret
}

func (c *CrossingEvent) GoPointer() uintptr {
	return c.Ptr
}

func (c *CrossingEvent) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// An event related to drag and drop operations.
type DNDEvent struct {
	Event
}

func DNDEventNewFromInternalPtr(ptr uintptr) *DNDEvent {
	cls := &DNDEvent{}
	cls.Ptr = ptr
	return cls
}

var xDNDEventGetDrop func(uintptr) uintptr

// Gets the `GdkDrop` object from a DND event.
func (x *DNDEvent) GetDrop() *Drop {
	var cls *Drop

	cret := xDNDEventGetDrop(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Drop{}
	cls.Ptr = cret
	return cls
}

func (c *DNDEvent) GoPointer() uintptr {
	return c.Ptr
}

func (c *DNDEvent) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// An event related to closing a top-level surface.
type DeleteEvent struct {
	Event
}

func DeleteEventNewFromInternalPtr(ptr uintptr) *DeleteEvent {
	cls := &DeleteEvent{}
	cls.Ptr = ptr
	return cls
}

func (c *DeleteEvent) GoPointer() uintptr {
	return c.Ptr
}

func (c *DeleteEvent) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// `GdkEvent`s are immutable data structures, created by GDK to
// represent windowing system events.
//
// In GTK applications the events are handled automatically by toplevel
// widgets and passed on to the event controllers of appropriate widgets,
// so using `GdkEvent` and its related API is rarely needed.
type Event struct {
	Ptr uintptr
}

func EventNewFromInternalPtr(ptr uintptr) *Event {
	cls := &Event{}
	cls.Ptr = ptr
	return cls
}

var xEventGetAngle func(uintptr, uintptr, float64) bool

// Returns the relative angle from @event1 to @event2.
//
// The relative angle is the angle between the X axis and the line
// through both events' positions. The rotation direction for positive
// angles is from the positive X axis towards the positive Y axis.
//
// This assumes that both events have X/Y information.
// If not, this function returns %FALSE.
func (x *Event) GetAngle(Event2Var *Event, AngleVar float64) bool {

	cret := xEventGetAngle(x.GoPointer(), Event2Var.GoPointer(), AngleVar)
	return cret
}

var xEventGetCenter func(uintptr, uintptr, float64, float64) bool

// Returns the point halfway between the events' positions.
//
// This assumes that both events have X/Y information.
// If not, this function returns %FALSE.
func (x *Event) GetCenter(Event2Var *Event, XVar float64, YVar float64) bool {

	cret := xEventGetCenter(x.GoPointer(), Event2Var.GoPointer(), XVar, YVar)
	return cret
}

var xEventGetDistance func(uintptr, uintptr, float64) bool

// Returns the distance between the event locations.
//
// This assumes that both events have X/Y information.
// If not, this function returns %FALSE.
func (x *Event) GetDistance(Event2Var *Event, DistanceVar float64) bool {

	cret := xEventGetDistance(x.GoPointer(), Event2Var.GoPointer(), DistanceVar)
	return cret
}

var xEventGetAxes func(uintptr, []float64, uint) bool

// Extracts all axis values from an event.
//
// To find out which axes are used, use [method@Gdk.DeviceTool.get_axes]
// on the device tool returned by [method@Gdk.Event.get_device_tool].
func (x *Event) GetAxes(AxesVar []float64, NAxesVar uint) bool {

	cret := xEventGetAxes(x.GoPointer(), AxesVar, NAxesVar)
	return cret
}

var xEventGetAxis func(uintptr, AxisUse, float64) bool

// Extract the axis value for a particular axis use from
// an event structure.
//
// To find out which axes are used, use [method@Gdk.DeviceTool.get_axes]
// on the device tool returned by [method@Gdk.Event.get_device_tool].
func (x *Event) GetAxis(AxisUseVar AxisUse, ValueVar float64) bool {

	cret := xEventGetAxis(x.GoPointer(), AxisUseVar, ValueVar)
	return cret
}

var xEventGetDevice func(uintptr) uintptr

// Returns the device of an event.
func (x *Event) GetDevice() *Device {
	var cls *Device

	cret := xEventGetDevice(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Device{}
	cls.Ptr = cret
	return cls
}

var xEventGetDeviceTool func(uintptr) uintptr

// Returns a `GdkDeviceTool` representing the tool that
// caused the event.
//
// If the was not generated by a device that supports
// different tools (such as a tablet), this function will
// return %NULL.
//
// Note: the `GdkDeviceTool` will be constant during
// the application lifetime, if settings must be stored
// persistently across runs, see [method@Gdk.DeviceTool.get_serial].
func (x *Event) GetDeviceTool() *DeviceTool {
	var cls *DeviceTool

	cret := xEventGetDeviceTool(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &DeviceTool{}
	cls.Ptr = cret
	return cls
}

var xEventGetDisplay func(uintptr) uintptr

// Retrieves the display associated to the @event.
func (x *Event) GetDisplay() *Display {
	var cls *Display

	cret := xEventGetDisplay(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Display{}
	cls.Ptr = cret
	return cls
}

var xEventGetEventSequence func(uintptr) *EventSequence

// Retuns the event sequence to which the event belongs.
//
// Related touch events are connected in a sequence. Other
// events typically don't have event sequence information.
func (x *Event) GetEventSequence() *EventSequence {

	cret := xEventGetEventSequence(x.GoPointer())
	return cret
}

var xEventGetEventType func(uintptr) EventType

// Retrieves the type of the event.
func (x *Event) GetEventType() EventType {

	cret := xEventGetEventType(x.GoPointer())
	return cret
}

var xEventGetHistory func(uintptr, uint) []TimeCoord

// Retrieves the history of the device that @event is for, as a list of
// time and coordinates.
//
// The history includes positions that are not delivered as separate events
// to the application because they occurred in the same frame as @event.
//
// Note that only motion and scroll events record history, and motion
// events do it only if one of the mouse buttons is down, or the device
// has a tool.
func (x *Event) GetHistory(OutNCoordsVar uint) []TimeCoord {

	cret := xEventGetHistory(x.GoPointer(), OutNCoordsVar)
	return cret
}

var xEventGetModifierState func(uintptr) ModifierType

// Returns the modifier state field of an event.
func (x *Event) GetModifierState() ModifierType {

	cret := xEventGetModifierState(x.GoPointer())
	return cret
}

var xEventGetPointerEmulated func(uintptr) bool

// Returns whether this event is an 'emulated' pointer event.
//
// Emulated pointer events typically originate from a touch events.
func (x *Event) GetPointerEmulated() bool {

	cret := xEventGetPointerEmulated(x.GoPointer())
	return cret
}

var xEventGetPosition func(uintptr, float64, float64) bool

// Extract the event surface relative x/y coordinates from an event.
func (x *Event) GetPosition(XVar float64, YVar float64) bool {

	cret := xEventGetPosition(x.GoPointer(), XVar, YVar)
	return cret
}

var xEventGetSeat func(uintptr) uintptr

// Returns the seat that originated the event.
func (x *Event) GetSeat() *Seat {
	var cls *Seat

	cret := xEventGetSeat(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Seat{}
	cls.Ptr = cret
	return cls
}

var xEventGetSurface func(uintptr) uintptr

// Extracts the surface associated with an event.
func (x *Event) GetSurface() *Surface {
	var cls *Surface

	cret := xEventGetSurface(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Surface{}
	cls.Ptr = cret
	return cls
}

var xEventGetTime func(uintptr) uint32

// Returns the timestamp of @event.
//
// Not all events have timestamps. In that case, this function
// returns %GDK_CURRENT_TIME.
func (x *Event) GetTime() uint32 {

	cret := xEventGetTime(x.GoPointer())
	return cret
}

var xEventRef func(uintptr) uintptr

// Increase the ref count of @event.
func (x *Event) Ref() *Event {
	var cls *Event

	cret := xEventRef(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Event{}
	cls.Ptr = cret
	return cls
}

var xEventTriggersContextMenu func(uintptr) bool

// Returns whether a `GdkEvent` should trigger a context menu,
// according to platform conventions.
//
// The right mouse button typically triggers context menus.
//
// This function should always be used instead of simply checking for
// event-&gt;button == %GDK_BUTTON_SECONDARY.
func (x *Event) TriggersContextMenu() bool {

	cret := xEventTriggersContextMenu(x.GoPointer())
	return cret
}

var xEventUnref func(uintptr)

// Decrease the ref count of @event.
//
// If the last reference is dropped, the structure is freed.
func (x *Event) Unref() {

	xEventUnref(x.GoPointer())

}

func (c *Event) GoPointer() uintptr {
	return c.Ptr
}

func (c *Event) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// An event related to a keyboard focus change.
type FocusEvent struct {
	Event
}

func FocusEventNewFromInternalPtr(ptr uintptr) *FocusEvent {
	cls := &FocusEvent{}
	cls.Ptr = ptr
	return cls
}

var xFocusEventGetIn func(uintptr) bool

// Extracts whether this event is about focus entering or
// leaving the surface.
func (x *FocusEvent) GetIn() bool {

	cret := xFocusEventGetIn(x.GoPointer())
	return cret
}

func (c *FocusEvent) GoPointer() uintptr {
	return c.Ptr
}

func (c *FocusEvent) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// An event related to a broken windowing system grab.
type GrabBrokenEvent struct {
	Event
}

func GrabBrokenEventNewFromInternalPtr(ptr uintptr) *GrabBrokenEvent {
	cls := &GrabBrokenEvent{}
	cls.Ptr = ptr
	return cls
}

var xGrabBrokenEventGetGrabSurface func(uintptr) uintptr

// Extracts the grab surface from a grab broken event.
func (x *GrabBrokenEvent) GetGrabSurface() *Surface {
	var cls *Surface

	cret := xGrabBrokenEventGetGrabSurface(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Surface{}
	cls.Ptr = cret
	return cls
}

var xGrabBrokenEventGetImplicit func(uintptr) bool

// Checks whether the grab broken event is for an implicit grab.
func (x *GrabBrokenEvent) GetImplicit() bool {

	cret := xGrabBrokenEventGetImplicit(x.GoPointer())
	return cret
}

func (c *GrabBrokenEvent) GoPointer() uintptr {
	return c.Ptr
}

func (c *GrabBrokenEvent) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// An event related to a key-based device.
type KeyEvent struct {
	Event
}

func KeyEventNewFromInternalPtr(ptr uintptr) *KeyEvent {
	cls := &KeyEvent{}
	cls.Ptr = ptr
	return cls
}

var xKeyEventGetConsumedModifiers func(uintptr) ModifierType

// Extracts the consumed modifiers from a key event.
func (x *KeyEvent) GetConsumedModifiers() ModifierType {

	cret := xKeyEventGetConsumedModifiers(x.GoPointer())
	return cret
}

var xKeyEventGetKeycode func(uintptr) uint

// Extracts the keycode from a key event.
func (x *KeyEvent) GetKeycode() uint {

	cret := xKeyEventGetKeycode(x.GoPointer())
	return cret
}

var xKeyEventGetKeyval func(uintptr) uint

// Extracts the keyval from a key event.
func (x *KeyEvent) GetKeyval() uint {

	cret := xKeyEventGetKeyval(x.GoPointer())
	return cret
}

var xKeyEventGetLayout func(uintptr) uint

// Extracts the layout from a key event.
func (x *KeyEvent) GetLayout() uint {

	cret := xKeyEventGetLayout(x.GoPointer())
	return cret
}

var xKeyEventGetLevel func(uintptr) uint

// Extracts the shift level from a key event.
func (x *KeyEvent) GetLevel() uint {

	cret := xKeyEventGetLevel(x.GoPointer())
	return cret
}

var xKeyEventGetMatch func(uintptr, uint, *ModifierType) bool

// Gets a keyval and modifier combination that will match
// the event.
//
// See [method@Gdk.KeyEvent.matches].
func (x *KeyEvent) GetMatch(KeyvalVar uint, ModifiersVar *ModifierType) bool {

	cret := xKeyEventGetMatch(x.GoPointer(), KeyvalVar, ModifiersVar)
	return cret
}

var xKeyEventIsModifier func(uintptr) bool

// Extracts whether the key event is for a modifier key.
func (x *KeyEvent) IsModifier() bool {

	cret := xKeyEventIsModifier(x.GoPointer())
	return cret
}

var xKeyEventMatches func(uintptr, uint, ModifierType) KeyMatch

// Matches a key event against a keyval and modifiers.
//
// This is typically used to trigger keyboard shortcuts such as Ctrl-C.
//
// Partial matches are possible where the combination matches
// if the currently active group is ignored.
//
// Note that we ignore Caps Lock for matching.
func (x *KeyEvent) Matches(KeyvalVar uint, ModifiersVar ModifierType) KeyMatch {

	cret := xKeyEventMatches(x.GoPointer(), KeyvalVar, ModifiersVar)
	return cret
}

func (c *KeyEvent) GoPointer() uintptr {
	return c.Ptr
}

func (c *KeyEvent) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// An event related to a pointer or touch device motion.
type MotionEvent struct {
	Event
}

func MotionEventNewFromInternalPtr(ptr uintptr) *MotionEvent {
	cls := &MotionEvent{}
	cls.Ptr = ptr
	return cls
}

func (c *MotionEvent) GoPointer() uintptr {
	return c.Ptr
}

func (c *MotionEvent) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// An event related to a pad-based device.
type PadEvent struct {
	Event
}

func PadEventNewFromInternalPtr(ptr uintptr) *PadEvent {
	cls := &PadEvent{}
	cls.Ptr = ptr
	return cls
}

var xPadEventGetAxisValue func(uintptr, uint, float64)

// Extracts the information from a pad strip or ring event.
func (x *PadEvent) GetAxisValue(IndexVar uint, ValueVar float64) {

	xPadEventGetAxisValue(x.GoPointer(), IndexVar, ValueVar)

}

var xPadEventGetButton func(uintptr) uint

// Extracts information about the pressed button from
// a pad event.
func (x *PadEvent) GetButton() uint {

	cret := xPadEventGetButton(x.GoPointer())
	return cret
}

var xPadEventGetGroupMode func(uintptr, uint, uint)

// Extracts group and mode information from a pad event.
func (x *PadEvent) GetGroupMode(GroupVar uint, ModeVar uint) {

	xPadEventGetGroupMode(x.GoPointer(), GroupVar, ModeVar)

}

func (c *PadEvent) GoPointer() uintptr {
	return c.Ptr
}

func (c *PadEvent) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// An event related to the proximity of a tool to a device.
type ProximityEvent struct {
	Event
}

func ProximityEventNewFromInternalPtr(ptr uintptr) *ProximityEvent {
	cls := &ProximityEvent{}
	cls.Ptr = ptr
	return cls
}

func (c *ProximityEvent) GoPointer() uintptr {
	return c.Ptr
}

func (c *ProximityEvent) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// An event related to a scrolling motion.
type ScrollEvent struct {
	Event
}

func ScrollEventNewFromInternalPtr(ptr uintptr) *ScrollEvent {
	cls := &ScrollEvent{}
	cls.Ptr = ptr
	return cls
}

var xScrollEventGetDeltas func(uintptr, float64, float64)

// Extracts the scroll deltas of a scroll event.
//
// The deltas will be zero unless the scroll direction
// is %GDK_SCROLL_SMOOTH.
//
// For the representation unit of these deltas, see
// [method@Gdk.ScrollEvent.get_unit].
func (x *ScrollEvent) GetDeltas(DeltaXVar float64, DeltaYVar float64) {

	xScrollEventGetDeltas(x.GoPointer(), DeltaXVar, DeltaYVar)

}

var xScrollEventGetDirection func(uintptr) ScrollDirection

// Extracts the direction of a scroll event.
func (x *ScrollEvent) GetDirection() ScrollDirection {

	cret := xScrollEventGetDirection(x.GoPointer())
	return cret
}

var xScrollEventGetUnit func(uintptr) ScrollUnit

// Extracts the scroll delta unit of a scroll event.
//
// The unit will always be %GDK_SCROLL_UNIT_WHEEL if the scroll direction is not
// %GDK_SCROLL_SMOOTH.
func (x *ScrollEvent) GetUnit() ScrollUnit {

	cret := xScrollEventGetUnit(x.GoPointer())
	return cret
}

var xScrollEventIsStop func(uintptr) bool

// Check whether a scroll event is a stop scroll event.
//
// Scroll sequences with smooth scroll information may provide
// a stop scroll event once the interaction with the device finishes,
// e.g. by lifting a finger. This stop scroll event is the signal
// that a widget may trigger kinetic scrolling based on the current
// velocity.
//
// Stop scroll events always have a delta of 0/0.
func (x *ScrollEvent) IsStop() bool {

	cret := xScrollEventIsStop(x.GoPointer())
	return cret
}

func (c *ScrollEvent) GoPointer() uintptr {
	return c.Ptr
}

func (c *ScrollEvent) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// An event related to a touch-based device.
type TouchEvent struct {
	Event
}

func TouchEventNewFromInternalPtr(ptr uintptr) *TouchEvent {
	cls := &TouchEvent{}
	cls.Ptr = ptr
	return cls
}

var xTouchEventGetEmulatingPointer func(uintptr) bool

// Extracts whether a touch event is emulating a pointer event.
func (x *TouchEvent) GetEmulatingPointer() bool {

	cret := xTouchEventGetEmulatingPointer(x.GoPointer())
	return cret
}

func (c *TouchEvent) GoPointer() uintptr {
	return c.Ptr
}

func (c *TouchEvent) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// An event related to a gesture on a touchpad device.
//
// Unlike touchscreens, where the windowing system sends basic
// sequences of begin, update, end events, and leaves gesture
// recognition to the clients, touchpad gestures are typically
// processed by the system, resulting in these events.
type TouchpadEvent struct {
	Event
}

func TouchpadEventNewFromInternalPtr(ptr uintptr) *TouchpadEvent {
	cls := &TouchpadEvent{}
	cls.Ptr = ptr
	return cls
}

var xTouchpadEventGetDeltas func(uintptr, float64, float64)

// Extracts delta information from a touchpad event.
func (x *TouchpadEvent) GetDeltas(DxVar float64, DyVar float64) {

	xTouchpadEventGetDeltas(x.GoPointer(), DxVar, DyVar)

}

var xTouchpadEventGetGesturePhase func(uintptr) TouchpadGesturePhase

// Extracts the touchpad gesture phase from a touchpad event.
func (x *TouchpadEvent) GetGesturePhase() TouchpadGesturePhase {

	cret := xTouchpadEventGetGesturePhase(x.GoPointer())
	return cret
}

var xTouchpadEventGetNFingers func(uintptr) uint

// Extracts the number of fingers from a touchpad event.
func (x *TouchpadEvent) GetNFingers() uint {

	cret := xTouchpadEventGetNFingers(x.GoPointer())
	return cret
}

var xTouchpadEventGetPinchAngleDelta func(uintptr) float64

// Extracts the angle delta from a touchpad pinch event.
func (x *TouchpadEvent) GetPinchAngleDelta() float64 {

	cret := xTouchpadEventGetPinchAngleDelta(x.GoPointer())
	return cret
}

var xTouchpadEventGetPinchScale func(uintptr) float64

// Extracts the scale from a touchpad pinch event.
func (x *TouchpadEvent) GetPinchScale() float64 {

	cret := xTouchpadEventGetPinchScale(x.GoPointer())
	return cret
}

func (c *TouchpadEvent) GoPointer() uintptr {
	return c.Ptr
}

func (c *TouchpadEvent) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GDK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xEventsGetAngle, lib, "gdk_events_get_angle")
	core.PuregoSafeRegister(&xEventsGetCenter, lib, "gdk_events_get_center")
	core.PuregoSafeRegister(&xEventsGetDistance, lib, "gdk_events_get_distance")

	core.PuregoSafeRegister(&xButtonEventGetButton, lib, "gdk_button_event_get_button")

	core.PuregoSafeRegister(&xCrossingEventGetDetail, lib, "gdk_crossing_event_get_detail")
	core.PuregoSafeRegister(&xCrossingEventGetFocus, lib, "gdk_crossing_event_get_focus")
	core.PuregoSafeRegister(&xCrossingEventGetMode, lib, "gdk_crossing_event_get_mode")

	core.PuregoSafeRegister(&xDNDEventGetDrop, lib, "gdk_dnd_event_get_drop")

	core.PuregoSafeRegister(&xEventGetAngle, lib, "gdk_events_get_angle")
	core.PuregoSafeRegister(&xEventGetCenter, lib, "gdk_events_get_center")
	core.PuregoSafeRegister(&xEventGetDistance, lib, "gdk_events_get_distance")
	core.PuregoSafeRegister(&xEventGetAxes, lib, "gdk_event_get_axes")
	core.PuregoSafeRegister(&xEventGetAxis, lib, "gdk_event_get_axis")
	core.PuregoSafeRegister(&xEventGetDevice, lib, "gdk_event_get_device")
	core.PuregoSafeRegister(&xEventGetDeviceTool, lib, "gdk_event_get_device_tool")
	core.PuregoSafeRegister(&xEventGetDisplay, lib, "gdk_event_get_display")
	core.PuregoSafeRegister(&xEventGetEventSequence, lib, "gdk_event_get_event_sequence")
	core.PuregoSafeRegister(&xEventGetEventType, lib, "gdk_event_get_event_type")
	core.PuregoSafeRegister(&xEventGetHistory, lib, "gdk_event_get_history")
	core.PuregoSafeRegister(&xEventGetModifierState, lib, "gdk_event_get_modifier_state")
	core.PuregoSafeRegister(&xEventGetPointerEmulated, lib, "gdk_event_get_pointer_emulated")
	core.PuregoSafeRegister(&xEventGetPosition, lib, "gdk_event_get_position")
	core.PuregoSafeRegister(&xEventGetSeat, lib, "gdk_event_get_seat")
	core.PuregoSafeRegister(&xEventGetSurface, lib, "gdk_event_get_surface")
	core.PuregoSafeRegister(&xEventGetTime, lib, "gdk_event_get_time")
	core.PuregoSafeRegister(&xEventRef, lib, "gdk_event_ref")
	core.PuregoSafeRegister(&xEventTriggersContextMenu, lib, "gdk_event_triggers_context_menu")
	core.PuregoSafeRegister(&xEventUnref, lib, "gdk_event_unref")

	core.PuregoSafeRegister(&xFocusEventGetIn, lib, "gdk_focus_event_get_in")

	core.PuregoSafeRegister(&xGrabBrokenEventGetGrabSurface, lib, "gdk_grab_broken_event_get_grab_surface")
	core.PuregoSafeRegister(&xGrabBrokenEventGetImplicit, lib, "gdk_grab_broken_event_get_implicit")

	core.PuregoSafeRegister(&xKeyEventGetConsumedModifiers, lib, "gdk_key_event_get_consumed_modifiers")
	core.PuregoSafeRegister(&xKeyEventGetKeycode, lib, "gdk_key_event_get_keycode")
	core.PuregoSafeRegister(&xKeyEventGetKeyval, lib, "gdk_key_event_get_keyval")
	core.PuregoSafeRegister(&xKeyEventGetLayout, lib, "gdk_key_event_get_layout")
	core.PuregoSafeRegister(&xKeyEventGetLevel, lib, "gdk_key_event_get_level")
	core.PuregoSafeRegister(&xKeyEventGetMatch, lib, "gdk_key_event_get_match")
	core.PuregoSafeRegister(&xKeyEventIsModifier, lib, "gdk_key_event_is_modifier")
	core.PuregoSafeRegister(&xKeyEventMatches, lib, "gdk_key_event_matches")

	core.PuregoSafeRegister(&xPadEventGetAxisValue, lib, "gdk_pad_event_get_axis_value")
	core.PuregoSafeRegister(&xPadEventGetButton, lib, "gdk_pad_event_get_button")
	core.PuregoSafeRegister(&xPadEventGetGroupMode, lib, "gdk_pad_event_get_group_mode")

	core.PuregoSafeRegister(&xScrollEventGetDeltas, lib, "gdk_scroll_event_get_deltas")
	core.PuregoSafeRegister(&xScrollEventGetDirection, lib, "gdk_scroll_event_get_direction")
	core.PuregoSafeRegister(&xScrollEventGetUnit, lib, "gdk_scroll_event_get_unit")
	core.PuregoSafeRegister(&xScrollEventIsStop, lib, "gdk_scroll_event_is_stop")

	core.PuregoSafeRegister(&xTouchEventGetEmulatingPointer, lib, "gdk_touch_event_get_emulating_pointer")

	core.PuregoSafeRegister(&xTouchpadEventGetDeltas, lib, "gdk_touchpad_event_get_deltas")
	core.PuregoSafeRegister(&xTouchpadEventGetGesturePhase, lib, "gdk_touchpad_event_get_gesture_phase")
	core.PuregoSafeRegister(&xTouchpadEventGetNFingers, lib, "gdk_touchpad_event_get_n_fingers")
	core.PuregoSafeRegister(&xTouchpadEventGetPinchAngleDelta, lib, "gdk_touchpad_event_get_pinch_angle_delta")
	core.PuregoSafeRegister(&xTouchpadEventGetPinchScale, lib, "gdk_touchpad_event_get_pinch_scale")

}
