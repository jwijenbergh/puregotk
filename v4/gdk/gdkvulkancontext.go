// Package gdk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gdk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// `GdkVulkanContext` is an object representing the platform-specific
// Vulkan draw context.
//
// `GdkVulkanContext`s are created for a surface using
// [method@Gdk.Surface.create_vulkan_context], and the context will match
// the characteristics of the surface.
//
// Support for `GdkVulkanContext` is platform-specific and context creation
// can fail, returning %NULL context.
type VulkanContext struct {
	DrawContext
}

func VulkanContextNewFromInternalPtr(ptr uintptr) *VulkanContext {
	cls := &VulkanContext{}
	cls.Ptr = ptr
	return cls
}

func (c *VulkanContext) GoPointer() uintptr {
	return c.Ptr
}

func (c *VulkanContext) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the images managed by this context have changed.
//
// Usually this means that the swapchain had to be recreated,
// for example in response to a change of the surface size.
func (x *VulkanContext) ConnectImagesUpdated(cb *func(VulkanContext)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "images-updated", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := VulkanContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "images-updated", cbRefPtr)
}

// Initializes the object implementing the interface.
//
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
//
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
//
// Implementations may also support cancellation. If @cancellable is not %NULL,
// then initialization can be cancelled by triggering the cancellable object
// from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
// the object doesn't support cancellable initialization the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
//
// If the object is not initialized, or initialization returns with an
// error, then all operations on the object except g_object_ref() and
// g_object_unref() are considered to be invalid, and have undefined
// behaviour. See the [introduction][ginitable] for more details.
//
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a classâ€™ implementation of init() can assume
// (and assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
//
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes
// the object; further calls return the result of the first call.
//
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a
// #GObjectClass.constructor that sometimes returns an existing instance.
// In this pattern, a caller would expect to be able to call g_initable_init()
// on the result of g_object_new(), regardless of whether it is in fact a new
// instance.
func (x *VulkanContext) Init(CancellableVar *gio.Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := gio.XGInitableInit(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}
