// Package gdk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gdk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The `GdkPopupLayout` struct contains information that is
// necessary position a [iface@Gdk.Popup] relative to its parent.
//
// The positioning requires a negotiation with the windowing system,
// since it depends on external constraints, such as the position of
// the parent surface, and the screen dimensions.
//
// The basic ingredients are a rectangle on the parent surface,
// and the anchor on both that rectangle and the popup. The anchors
// specify a side or corner to place next to each other.
//
// ![Popup anchors](popup-anchors.png)
//
// For cases where placing the anchors next to each other would make
// the popup extend offscreen, the layout includes some hints for how
// to resolve this problem. The hints may suggest to flip the anchor
// position to the other side, or to 'slide' the popup along a side,
// or to resize it.
//
// ![Flipping popups](popup-flip.png)
//
// ![Sliding popups](popup-slide.png)
//
// These hints may be combined.
//
// Ultimatively, it is up to the windowing system to determine the position
// and size of the popup. You can learn about the result by calling
// [method@Gdk.Popup.get_position_x], [method@Gdk.Popup.get_position_y],
// [method@Gdk.Popup.get_rect_anchor] and [method@Gdk.Popup.get_surface_anchor]
// after the popup has been presented. This can be used to adjust the rendering.
// For example, [class@Gtk.Popover] changes its arrow position accordingly.
// But you have to be careful avoid changing the size of the popover, or it
// has to be presented again.
type PopupLayout struct {
	_ structs.HostLayout
}

var xPopupLayoutGLibType func() types.GType

func PopupLayoutGLibType() types.GType {
	return xPopupLayoutGLibType()
}

func (x *PopupLayout) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewPopupLayout func(*Rectangle, Gravity, Gravity) *PopupLayout

// Create a popup layout description.
//
// Used together with [method@Gdk.Popup.present] to describe how a popup
// surface should be placed and behave on-screen.
//
// @anchor_rect is relative to the top-left corner of the surface's parent.
// @rect_anchor and @surface_anchor determine anchor points on @anchor_rect
// and surface to pin together.
//
// The position of @anchor_rect's anchor point can optionally be offset using
// [method@Gdk.PopupLayout.set_offset], which is equivalent to offsetting the
// position of surface.
func NewPopupLayout(AnchorRectVar *Rectangle, RectAnchorVar Gravity, SurfaceAnchorVar Gravity) *PopupLayout {

	cret := xNewPopupLayout(AnchorRectVar, RectAnchorVar, SurfaceAnchorVar)
	return cret
}

var xPopupLayoutCopy func(uintptr) *PopupLayout

// Makes a copy of @layout.
func (x *PopupLayout) Copy() *PopupLayout {

	cret := xPopupLayoutCopy(x.GoPointer())
	return cret
}

var xPopupLayoutEqual func(uintptr, *PopupLayout) bool

// Check whether @layout and @other has identical layout properties.
func (x *PopupLayout) Equal(OtherVar *PopupLayout) bool {

	cret := xPopupLayoutEqual(x.GoPointer(), OtherVar)
	return cret
}

var xPopupLayoutGetAnchorHints func(uintptr) AnchorHints

// Get the `GdkAnchorHints`.
func (x *PopupLayout) GetAnchorHints() AnchorHints {

	cret := xPopupLayoutGetAnchorHints(x.GoPointer())
	return cret
}

var xPopupLayoutGetAnchorRect func(uintptr) *Rectangle

// Get the anchor rectangle.
func (x *PopupLayout) GetAnchorRect() *Rectangle {

	cret := xPopupLayoutGetAnchorRect(x.GoPointer())
	return cret
}

var xPopupLayoutGetOffset func(uintptr, int, int)

// Retrieves the offset for the anchor rectangle.
func (x *PopupLayout) GetOffset(DxVar int, DyVar int) {

	xPopupLayoutGetOffset(x.GoPointer(), DxVar, DyVar)

}

var xPopupLayoutGetRectAnchor func(uintptr) Gravity

// Returns the anchor position on the anchor rectangle.
func (x *PopupLayout) GetRectAnchor() Gravity {

	cret := xPopupLayoutGetRectAnchor(x.GoPointer())
	return cret
}

var xPopupLayoutGetShadowWidth func(uintptr, int, int, int, int)

// Obtains the shadow widths of this layout.
func (x *PopupLayout) GetShadowWidth(LeftVar int, RightVar int, TopVar int, BottomVar int) {

	xPopupLayoutGetShadowWidth(x.GoPointer(), LeftVar, RightVar, TopVar, BottomVar)

}

var xPopupLayoutGetSurfaceAnchor func(uintptr) Gravity

// Returns the anchor position on the popup surface.
func (x *PopupLayout) GetSurfaceAnchor() Gravity {

	cret := xPopupLayoutGetSurfaceAnchor(x.GoPointer())
	return cret
}

var xPopupLayoutRef func(uintptr) *PopupLayout

// Increases the reference count of @value.
func (x *PopupLayout) Ref() *PopupLayout {

	cret := xPopupLayoutRef(x.GoPointer())
	return cret
}

var xPopupLayoutSetAnchorHints func(uintptr, AnchorHints)

// Set new anchor hints.
//
// The set @anchor_hints determines how @surface will be moved
// if the anchor points cause it to move off-screen. For example,
// %GDK_ANCHOR_FLIP_X will replace %GDK_GRAVITY_NORTH_WEST with
// %GDK_GRAVITY_NORTH_EAST and vice versa if @surface extends
// beyond the left or right edges of the monitor.
func (x *PopupLayout) SetAnchorHints(AnchorHintsVar AnchorHints) {

	xPopupLayoutSetAnchorHints(x.GoPointer(), AnchorHintsVar)

}

var xPopupLayoutSetAnchorRect func(uintptr, *Rectangle)

// Set the anchor rectangle.
func (x *PopupLayout) SetAnchorRect(AnchorRectVar *Rectangle) {

	xPopupLayoutSetAnchorRect(x.GoPointer(), AnchorRectVar)

}

var xPopupLayoutSetOffset func(uintptr, int, int)

// Offset the position of the anchor rectangle with the given delta.
func (x *PopupLayout) SetOffset(DxVar int, DyVar int) {

	xPopupLayoutSetOffset(x.GoPointer(), DxVar, DyVar)

}

var xPopupLayoutSetRectAnchor func(uintptr, Gravity)

// Set the anchor on the anchor rectangle.
func (x *PopupLayout) SetRectAnchor(AnchorVar Gravity) {

	xPopupLayoutSetRectAnchor(x.GoPointer(), AnchorVar)

}

var xPopupLayoutSetShadowWidth func(uintptr, int, int, int, int)

// Sets the shadow width of the popup.
//
// The shadow width corresponds to the part of the computed
// surface size that would consist of the shadow margin
// surrounding the window, would there be any.
func (x *PopupLayout) SetShadowWidth(LeftVar int, RightVar int, TopVar int, BottomVar int) {

	xPopupLayoutSetShadowWidth(x.GoPointer(), LeftVar, RightVar, TopVar, BottomVar)

}

var xPopupLayoutSetSurfaceAnchor func(uintptr, Gravity)

// Set the anchor on the popup surface.
func (x *PopupLayout) SetSurfaceAnchor(AnchorVar Gravity) {

	xPopupLayoutSetSurfaceAnchor(x.GoPointer(), AnchorVar)

}

var xPopupLayoutUnref func(uintptr)

// Decreases the reference count of @value.
func (x *PopupLayout) Unref() {

	xPopupLayoutUnref(x.GoPointer())

}

// Positioning hints for aligning a surface relative to a rectangle.
//
// These hints determine how the surface should be positioned in the case that
// the surface would fall off-screen if placed in its ideal position.
//
// For example, %GDK_ANCHOR_FLIP_X will replace %GDK_GRAVITY_NORTH_WEST with
// %GDK_GRAVITY_NORTH_EAST and vice versa if the surface extends beyond the left
// or right edges of the monitor.
//
// If %GDK_ANCHOR_SLIDE_X is set, the surface can be shifted horizontally to fit
// on-screen. If %GDK_ANCHOR_RESIZE_X is set, the surface can be shrunken
// horizontally to fit.
//
// In general, when multiple flags are set, flipping should take precedence over
// sliding, which should take precedence over resizing.
type AnchorHints int

var xAnchorHintsGLibType func() types.GType

func AnchorHintsGLibType() types.GType {
	return xAnchorHintsGLibType()
}

const (

	// allow flipping anchors horizontally
	AnchorFlipXValue AnchorHints = 1
	// allow flipping anchors vertically
	AnchorFlipYValue AnchorHints = 2
	// allow sliding surface horizontally
	AnchorSlideXValue AnchorHints = 4
	// allow sliding surface vertically
	AnchorSlideYValue AnchorHints = 8
	// allow resizing surface horizontally
	AnchorResizeXValue AnchorHints = 16
	// allow resizing surface vertically
	AnchorResizeYValue AnchorHints = 32
	// allow flipping anchors on both axes
	AnchorFlipValue AnchorHints = 3
	// allow sliding surface on both axes
	AnchorSlideValue AnchorHints = 12
	// allow resizing surface on both axes
	AnchorResizeValue AnchorHints = 48
)

func init() {
	lib, err := purego.Dlopen(core.GetPath("GDK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xAnchorHintsGLibType, lib, "gdk_anchor_hints_get_type")

	core.PuregoSafeRegister(&xPopupLayoutGLibType, lib, "gdk_popup_layout_get_type")

	core.PuregoSafeRegister(&xNewPopupLayout, lib, "gdk_popup_layout_new")

	core.PuregoSafeRegister(&xPopupLayoutCopy, lib, "gdk_popup_layout_copy")
	core.PuregoSafeRegister(&xPopupLayoutEqual, lib, "gdk_popup_layout_equal")
	core.PuregoSafeRegister(&xPopupLayoutGetAnchorHints, lib, "gdk_popup_layout_get_anchor_hints")
	core.PuregoSafeRegister(&xPopupLayoutGetAnchorRect, lib, "gdk_popup_layout_get_anchor_rect")
	core.PuregoSafeRegister(&xPopupLayoutGetOffset, lib, "gdk_popup_layout_get_offset")
	core.PuregoSafeRegister(&xPopupLayoutGetRectAnchor, lib, "gdk_popup_layout_get_rect_anchor")
	core.PuregoSafeRegister(&xPopupLayoutGetShadowWidth, lib, "gdk_popup_layout_get_shadow_width")
	core.PuregoSafeRegister(&xPopupLayoutGetSurfaceAnchor, lib, "gdk_popup_layout_get_surface_anchor")
	core.PuregoSafeRegister(&xPopupLayoutRef, lib, "gdk_popup_layout_ref")
	core.PuregoSafeRegister(&xPopupLayoutSetAnchorHints, lib, "gdk_popup_layout_set_anchor_hints")
	core.PuregoSafeRegister(&xPopupLayoutSetAnchorRect, lib, "gdk_popup_layout_set_anchor_rect")
	core.PuregoSafeRegister(&xPopupLayoutSetOffset, lib, "gdk_popup_layout_set_offset")
	core.PuregoSafeRegister(&xPopupLayoutSetRectAnchor, lib, "gdk_popup_layout_set_rect_anchor")
	core.PuregoSafeRegister(&xPopupLayoutSetShadowWidth, lib, "gdk_popup_layout_set_shadow_width")
	core.PuregoSafeRegister(&xPopupLayoutSetSurfaceAnchor, lib, "gdk_popup_layout_set_surface_anchor")
	core.PuregoSafeRegister(&xPopupLayoutUnref, lib, "gdk_popup_layout_unref")

}
