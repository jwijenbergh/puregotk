// Package gdk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gdk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type FrameClockClass struct {
}

func (x *FrameClockClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type FrameClockPrivate struct {
}

func (x *FrameClockPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Used to represent the different paint clock phases that can be requested.
//
// The elements of the enumeration correspond to the signals of `GdkFrameClock`.
type FrameClockPhase int

const (

	// no phase
	FrameClockPhaseNoneValue FrameClockPhase = 0
	// corresponds to GdkFrameClock::flush-events. Should not be handled by applications.
	FrameClockPhaseFlushEventsValue FrameClockPhase = 1
	// corresponds to GdkFrameClock::before-paint. Should not be handled by applications.
	FrameClockPhaseBeforePaintValue FrameClockPhase = 2
	// corresponds to GdkFrameClock::update.
	FrameClockPhaseUpdateValue FrameClockPhase = 4
	// corresponds to GdkFrameClock::layout. Should not be handled by applications.
	FrameClockPhaseLayoutValue FrameClockPhase = 8
	// corresponds to GdkFrameClock::paint.
	FrameClockPhasePaintValue FrameClockPhase = 16
	// corresponds to GdkFrameClock::resume-events. Should not be handled by applications.
	FrameClockPhaseResumeEventsValue FrameClockPhase = 32
	// corresponds to GdkFrameClock::after-paint. Should not be handled by applications.
	FrameClockPhaseAfterPaintValue FrameClockPhase = 64
)

// A `GdkFrameClock` tells the application when to update and repaint
// a surface.
//
// This may be synced to the vertical refresh rate of the monitor, for example.
// Even when the frame clock uses a simple timer rather than a hardware-based
// vertical sync, the frame clock helps because it ensures everything paints at
// the same time (reducing the total number of frames).
//
// The frame clock can also automatically stop painting when it knows the frames
// will not be visible, or scale back animation framerates.
//
// `GdkFrameClock` is designed to be compatible with an OpenGL-based implementation
// or with mozRequestAnimationFrame in Firefox, for example.
//
// A frame clock is idle until someone requests a frame with
// [method@Gdk.FrameClock.request_phase]. At some later point that makes sense
// for the synchronization being implemented, the clock will process a frame and
// emit signals for each phase that has been requested. (See the signals of the
// `GdkFrameClock` class for documentation of the phases.
// %GDK_FRAME_CLOCK_PHASE_UPDATE and the [signal@GdkFrameClock::update] signal
// are most interesting for application writers, and are used to update the
// animations, using the frame time given by [method@Gdk.FrameClock.get_frame_time].
//
// The frame time is reported in microseconds and generally in the same
// timescale as g_get_monotonic_time(), however, it is not the same
// as g_get_monotonic_time(). The frame time does not advance during
// the time a frame is being painted, and outside of a frame, an attempt
// is made so that all calls to [method@Gdk.FrameClock.get_frame_time] that
// are called at a “similar” time get the same value. This means that
// if different animations are timed by looking at the difference in
// time between an initial value from [method@Gdk.FrameClock.get_frame_time]
// and the value inside the [signal@GdkFrameClock::update] signal of the clock,
// they will stay exactly synchronized.
type FrameClock struct {
	gobject.Object
}

func FrameClockNewFromInternalPtr(ptr uintptr) *FrameClock {
	cls := &FrameClock{}
	cls.Ptr = ptr
	return cls
}

var xFrameClockBeginUpdating func(uintptr)

// Starts updates for an animation.
//
// Until a matching call to [method@Gdk.FrameClock.end_updating] is made,
// the frame clock will continually request a new frame with the
// %GDK_FRAME_CLOCK_PHASE_UPDATE phase. This function may be called multiple
// times and frames will be requested until gdk_frame_clock_end_updating()
// is called the same number of times.
func (x *FrameClock) BeginUpdating() {

	xFrameClockBeginUpdating(x.GoPointer())

}

var xFrameClockEndUpdating func(uintptr)

// Stops updates for an animation.
//
// See the documentation for [method@Gdk.FrameClock.begin_updating].
func (x *FrameClock) EndUpdating() {

	xFrameClockEndUpdating(x.GoPointer())

}

var xFrameClockGetCurrentTimings func(uintptr) *FrameTimings

// Gets the frame timings for the current frame.
func (x *FrameClock) GetCurrentTimings() *FrameTimings {

	cret := xFrameClockGetCurrentTimings(x.GoPointer())
	return cret
}

var xFrameClockGetFps func(uintptr) float64

// Calculates the current frames-per-second, based on the
// frame timings of @frame_clock.
func (x *FrameClock) GetFps() float64 {

	cret := xFrameClockGetFps(x.GoPointer())
	return cret
}

var xFrameClockGetFrameCounter func(uintptr) int64

// `GdkFrameClock` maintains a 64-bit counter that increments for
// each frame drawn.
func (x *FrameClock) GetFrameCounter() int64 {

	cret := xFrameClockGetFrameCounter(x.GoPointer())
	return cret
}

var xFrameClockGetFrameTime func(uintptr) int64

// Gets the time that should currently be used for animations.
//
// Inside the processing of a frame, it’s the time used to compute the
// animation position of everything in a frame. Outside of a frame, it's
// the time of the conceptual “previous frame,” which may be either
// the actual previous frame time, or if that’s too old, an updated
// time.
func (x *FrameClock) GetFrameTime() int64 {

	cret := xFrameClockGetFrameTime(x.GoPointer())
	return cret
}

var xFrameClockGetHistoryStart func(uintptr) int64

// Returns the frame counter for the oldest frame available in history.
//
// `GdkFrameClock` internally keeps a history of `GdkFrameTimings`
// objects for recent frames that can be retrieved with
// [method@Gdk.FrameClock.get_timings]. The set of stored frames
// is the set from the counter values given by
// [method@Gdk.FrameClock.get_history_start] and
// [method@Gdk.FrameClock.get_frame_counter], inclusive.
func (x *FrameClock) GetHistoryStart() int64 {

	cret := xFrameClockGetHistoryStart(x.GoPointer())
	return cret
}

var xFrameClockGetRefreshInfo func(uintptr, int64, int64, int64)

// Predicts a presentation time, based on history.
//
// Using the frame history stored in the frame clock, finds the last
// known presentation time and refresh interval, and assuming that
// presentation times are separated by the refresh interval,
// predicts a presentation time that is a multiple of the refresh
// interval after the last presentation time, and later than @base_time.
func (x *FrameClock) GetRefreshInfo(BaseTimeVar int64, RefreshIntervalReturnVar int64, PresentationTimeReturnVar int64) {

	xFrameClockGetRefreshInfo(x.GoPointer(), BaseTimeVar, RefreshIntervalReturnVar, PresentationTimeReturnVar)

}

var xFrameClockGetTimings func(uintptr, int64) *FrameTimings

// Retrieves a `GdkFrameTimings` object holding timing information
// for the current frame or a recent frame.
//
// The `GdkFrameTimings` object may not yet be complete: see
// [method@Gdk.FrameTimings.get_complete] and
// [method@Gdk.FrameClock.get_history_start].
func (x *FrameClock) GetTimings(FrameCounterVar int64) *FrameTimings {

	cret := xFrameClockGetTimings(x.GoPointer(), FrameCounterVar)
	return cret
}

var xFrameClockRequestPhase func(uintptr, FrameClockPhase)

// Asks the frame clock to run a particular phase.
//
// The signal corresponding the requested phase will be emitted the next
// time the frame clock processes. Multiple calls to
// gdk_frame_clock_request_phase() will be combined together
// and only one frame processed. If you are displaying animated
// content and want to continually request the
// %GDK_FRAME_CLOCK_PHASE_UPDATE phase for a period of time,
// you should use [method@Gdk.FrameClock.begin_updating] instead,
// since this allows GTK to adjust system parameters to get maximally
// smooth animations.
func (x *FrameClock) RequestPhase(PhaseVar FrameClockPhase) {

	xFrameClockRequestPhase(x.GoPointer(), PhaseVar)

}

func (c *FrameClock) GoPointer() uintptr {
	return c.Ptr
}

func (c *FrameClock) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// This signal ends processing of the frame.
//
// Applications should generally not handle this signal.
func (x *FrameClock) ConnectAfterPaint(cb *func(FrameClock)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "after-paint", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FrameClock{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "after-paint", cbRefPtr)
}

// Begins processing of the frame.
//
// Applications should generally not handle this signal.
func (x *FrameClock) ConnectBeforePaint(cb *func(FrameClock)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "before-paint", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FrameClock{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "before-paint", cbRefPtr)
}

// Used to flush pending motion events that are being batched up and
// compressed together.
//
// Applications should not handle this signal.
func (x *FrameClock) ConnectFlushEvents(cb *func(FrameClock)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "flush-events", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FrameClock{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "flush-events", cbRefPtr)
}

// Emitted as the second step of toolkit and application processing
// of the frame.
//
// Any work to update sizes and positions of application elements
// should be performed. GTK normally handles this internally.
func (x *FrameClock) ConnectLayout(cb *func(FrameClock)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "layout", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FrameClock{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "layout", cbRefPtr)
}

// Emitted as the third step of toolkit and application processing
// of the frame.
//
// The frame is repainted. GDK normally handles this internally and
// emits [signal@Gdk.Surface::render] signals which are turned into
// [signal@Gtk.Widget::snapshot] signals by GTK.
func (x *FrameClock) ConnectPaint(cb *func(FrameClock)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "paint", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FrameClock{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "paint", cbRefPtr)
}

// Emitted after processing of the frame is finished.
//
// This signal is handled internally by GTK to resume normal
// event processing. Applications should not handle this signal.
func (x *FrameClock) ConnectResumeEvents(cb *func(FrameClock)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "resume-events", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FrameClock{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "resume-events", cbRefPtr)
}

// Emitted as the first step of toolkit and application processing
// of the frame.
//
// Animations should be updated using [method@Gdk.FrameClock.get_frame_time].
// Applications can connect directly to this signal, or use
// [method@Gtk.Widget.add_tick_callback] as a more convenient interface.
func (x *FrameClock) ConnectUpdate(cb *func(FrameClock)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "update", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FrameClock{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "update", cbRefPtr)
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GDK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xFrameClockBeginUpdating, lib, "gdk_frame_clock_begin_updating")
	core.PuregoSafeRegister(&xFrameClockEndUpdating, lib, "gdk_frame_clock_end_updating")
	core.PuregoSafeRegister(&xFrameClockGetCurrentTimings, lib, "gdk_frame_clock_get_current_timings")
	core.PuregoSafeRegister(&xFrameClockGetFps, lib, "gdk_frame_clock_get_fps")
	core.PuregoSafeRegister(&xFrameClockGetFrameCounter, lib, "gdk_frame_clock_get_frame_counter")
	core.PuregoSafeRegister(&xFrameClockGetFrameTime, lib, "gdk_frame_clock_get_frame_time")
	core.PuregoSafeRegister(&xFrameClockGetHistoryStart, lib, "gdk_frame_clock_get_history_start")
	core.PuregoSafeRegister(&xFrameClockGetRefreshInfo, lib, "gdk_frame_clock_get_refresh_info")
	core.PuregoSafeRegister(&xFrameClockGetTimings, lib, "gdk_frame_clock_get_timings")
	core.PuregoSafeRegister(&xFrameClockRequestPhase, lib, "gdk_frame_clock_request_phase")

}
