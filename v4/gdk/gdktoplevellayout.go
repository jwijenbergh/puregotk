// Package gdk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gdk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The `GdkToplevelLayout` struct contains information that
// is necessary to present a sovereign window on screen.
//
// The `GdkToplevelLayout` struct is necessary for using
// [method@Gdk.Toplevel.present].
//
// Toplevel surfaces are sovereign windows that can be presented
// to the user in various states (maximized, on all workspaces,
// etc).
type ToplevelLayout struct {
	_ structs.HostLayout
}

var xToplevelLayoutGLibType func() types.GType

func ToplevelLayoutGLibType() types.GType {
	return xToplevelLayoutGLibType()
}

func (x *ToplevelLayout) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewToplevelLayout func() *ToplevelLayout

// Create a toplevel layout description.
//
// Used together with gdk_toplevel_present() to describe
// how a toplevel surface should be placed and behave on-screen.
//
// The size is in ”application pixels”, not
// ”device pixels” (see gdk_surface_get_scale_factor()).
func NewToplevelLayout() *ToplevelLayout {

	cret := xNewToplevelLayout()
	return cret
}

var xToplevelLayoutCopy func(uintptr) *ToplevelLayout

// Create a new `GdkToplevelLayout` and copy the contents of @layout into it.
func (x *ToplevelLayout) Copy() *ToplevelLayout {

	cret := xToplevelLayoutCopy(x.GoPointer())
	return cret
}

var xToplevelLayoutEqual func(uintptr, *ToplevelLayout) bool

// Check whether @layout and @other has identical layout properties.
func (x *ToplevelLayout) Equal(OtherVar *ToplevelLayout) bool {

	cret := xToplevelLayoutEqual(x.GoPointer(), OtherVar)
	return cret
}

var xToplevelLayoutGetFullscreen func(uintptr, bool) bool

// If the layout specifies whether to the toplevel should go fullscreen,
// the value pointed to by @fullscreen is set to %TRUE if it should go
// fullscreen, or %FALSE, if it should go unfullscreen.
func (x *ToplevelLayout) GetFullscreen(FullscreenVar bool) bool {

	cret := xToplevelLayoutGetFullscreen(x.GoPointer(), FullscreenVar)
	return cret
}

var xToplevelLayoutGetFullscreenMonitor func(uintptr) uintptr

// Returns the monitor that the layout is fullscreening
// the surface on.
func (x *ToplevelLayout) GetFullscreenMonitor() *Monitor {
	var cls *Monitor

	cret := xToplevelLayoutGetFullscreenMonitor(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Monitor{}
	cls.Ptr = cret
	return cls
}

var xToplevelLayoutGetMaximized func(uintptr, bool) bool

// If the layout specifies whether to the toplevel should go maximized,
// the value pointed to by @maximized is set to %TRUE if it should go
// fullscreen, or %FALSE, if it should go unmaximized.
func (x *ToplevelLayout) GetMaximized(MaximizedVar bool) bool {

	cret := xToplevelLayoutGetMaximized(x.GoPointer(), MaximizedVar)
	return cret
}

var xToplevelLayoutGetResizable func(uintptr) bool

// Returns whether the layout should allow the user
// to resize the surface.
func (x *ToplevelLayout) GetResizable() bool {

	cret := xToplevelLayoutGetResizable(x.GoPointer())
	return cret
}

var xToplevelLayoutRef func(uintptr) *ToplevelLayout

// Increases the reference count of @layout.
func (x *ToplevelLayout) Ref() *ToplevelLayout {

	cret := xToplevelLayoutRef(x.GoPointer())
	return cret
}

var xToplevelLayoutSetFullscreen func(uintptr, bool, uintptr)

// Sets whether the layout should cause the surface
// to be fullscreen when presented.
func (x *ToplevelLayout) SetFullscreen(FullscreenVar bool, MonitorVar *Monitor) {

	xToplevelLayoutSetFullscreen(x.GoPointer(), FullscreenVar, MonitorVar.GoPointer())

}

var xToplevelLayoutSetMaximized func(uintptr, bool)

// Sets whether the layout should cause the surface
// to be maximized when presented.
func (x *ToplevelLayout) SetMaximized(MaximizedVar bool) {

	xToplevelLayoutSetMaximized(x.GoPointer(), MaximizedVar)

}

var xToplevelLayoutSetResizable func(uintptr, bool)

// Sets whether the layout should allow the user
// to resize the surface after it has been presented.
func (x *ToplevelLayout) SetResizable(ResizableVar bool) {

	xToplevelLayoutSetResizable(x.GoPointer(), ResizableVar)

}

var xToplevelLayoutUnref func(uintptr)

// Decreases the reference count of @layout.
func (x *ToplevelLayout) Unref() {

	xToplevelLayoutUnref(x.GoPointer())

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GDK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xToplevelLayoutGLibType, lib, "gdk_toplevel_layout_get_type")

	core.PuregoSafeRegister(&xNewToplevelLayout, lib, "gdk_toplevel_layout_new")

	core.PuregoSafeRegister(&xToplevelLayoutCopy, lib, "gdk_toplevel_layout_copy")
	core.PuregoSafeRegister(&xToplevelLayoutEqual, lib, "gdk_toplevel_layout_equal")
	core.PuregoSafeRegister(&xToplevelLayoutGetFullscreen, lib, "gdk_toplevel_layout_get_fullscreen")
	core.PuregoSafeRegister(&xToplevelLayoutGetFullscreenMonitor, lib, "gdk_toplevel_layout_get_fullscreen_monitor")
	core.PuregoSafeRegister(&xToplevelLayoutGetMaximized, lib, "gdk_toplevel_layout_get_maximized")
	core.PuregoSafeRegister(&xToplevelLayoutGetResizable, lib, "gdk_toplevel_layout_get_resizable")
	core.PuregoSafeRegister(&xToplevelLayoutRef, lib, "gdk_toplevel_layout_ref")
	core.PuregoSafeRegister(&xToplevelLayoutSetFullscreen, lib, "gdk_toplevel_layout_set_fullscreen")
	core.PuregoSafeRegister(&xToplevelLayoutSetMaximized, lib, "gdk_toplevel_layout_set_maximized")
	core.PuregoSafeRegister(&xToplevelLayoutSetResizable, lib, "gdk_toplevel_layout_set_resizable")
	core.PuregoSafeRegister(&xToplevelLayoutUnref, lib, "gdk_toplevel_layout_unref")

}
