// Package gdk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gdk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// `GdkDisplay` objects are the GDK representation of a workstation.
//
// Their purpose are two-fold:
//
// - To manage and provide information about input devices (pointers, keyboards, etc)
// - To manage and provide information about output devices (monitors, projectors, etc)
//
// Most of the input device handling has been factored out into separate
// [class@Gdk.Seat] objects. Every display has a one or more seats, which
// can be accessed with [method@Gdk.Display.get_default_seat] and
// [method@Gdk.Display.list_seats].
//
// Output devices are represented by [class@Gdk.Monitor] objects, which can
// be accessed with [method@Gdk.Display.get_monitor_at_surface] and similar APIs.
type Display struct {
	gobject.Object
}

func DisplayNewFromInternalPtr(ptr uintptr) *Display {
	cls := &Display{}
	cls.Ptr = ptr
	return cls
}

var xDisplayBeep func(uintptr)

// Emits a short beep on @display
func (x *Display) Beep() {

	xDisplayBeep(x.GoPointer())

}

var xDisplayClose func(uintptr)

// Closes the connection to the windowing system for the given display.
//
// This cleans up associated resources.
func (x *Display) Close() {

	xDisplayClose(x.GoPointer())

}

var xDisplayCreateGlContext func(uintptr) uintptr

// Creates a new `GdkGLContext` for the `GdkDisplay`.
//
// The context is disconnected from any particular surface or surface
// and cannot be used to draw to any surface. It can only be used to
// draw to non-surface framebuffers like textures.
//
// If the creation of the `GdkGLContext` failed, @error will be set.
// Before using the returned `GdkGLContext`, you will need to
// call [method@Gdk.GLContext.make_current] or [method@Gdk.GLContext.realize].
func (x *Display) CreateGlContext() (*GLContext, error) {
	var cls *GLContext
	var cerr *glib.Error

	cret := xDisplayCreateGlContext(x.GoPointer())

	if cret == 0 {
		return nil, cerr
	}
	cls = &GLContext{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xDisplayDeviceIsGrabbed func(uintptr, uintptr) bool

// Returns %TRUE if there is an ongoing grab on @device for @display.
func (x *Display) DeviceIsGrabbed(DeviceVar *Device) bool {

	cret := xDisplayDeviceIsGrabbed(x.GoPointer(), DeviceVar.GoPointer())
	return cret
}

var xDisplayFlush func(uintptr)

// Flushes any requests queued for the windowing system.
//
// This happens automatically when the main loop blocks waiting for new events,
// but if your application is drawing without returning control to the main loop,
// you may need to call this function explicitly. A common case where this function
// needs to be called is when an application is executing drawing commands
// from a thread other than the thread where the main loop is running.
//
// This is most useful for X11. On windowing systems where requests are
// handled synchronously, this function will do nothing.
func (x *Display) Flush() {

	xDisplayFlush(x.GoPointer())

}

var xDisplayGetAppLaunchContext func(uintptr) uintptr

// Returns a `GdkAppLaunchContext` suitable for launching
// applications on the given display.
func (x *Display) GetAppLaunchContext() *AppLaunchContext {
	var cls *AppLaunchContext

	cret := xDisplayGetAppLaunchContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AppLaunchContext{}
	cls.Ptr = cret
	return cls
}

var xDisplayGetClipboard func(uintptr) uintptr

// Gets the clipboard used for copy/paste operations.
func (x *Display) GetClipboard() *Clipboard {
	var cls *Clipboard

	cret := xDisplayGetClipboard(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Clipboard{}
	cls.Ptr = cret
	return cls
}

var xDisplayGetDefaultSeat func(uintptr) uintptr

// Returns the default `GdkSeat` for this display.
//
// Note that a display may not have a seat. In this case,
// this function will return %NULL.
func (x *Display) GetDefaultSeat() *Seat {
	var cls *Seat

	cret := xDisplayGetDefaultSeat(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Seat{}
	cls.Ptr = cret
	return cls
}

var xDisplayGetMonitorAtSurface func(uintptr, uintptr) uintptr

// Gets the monitor in which the largest area of @surface
// resides.
//
// Returns a monitor close to @surface if it is outside
// of all monitors.
func (x *Display) GetMonitorAtSurface(SurfaceVar *Surface) *Monitor {
	var cls *Monitor

	cret := xDisplayGetMonitorAtSurface(x.GoPointer(), SurfaceVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Monitor{}
	cls.Ptr = cret
	return cls
}

var xDisplayGetMonitors func(uintptr) uintptr

// Gets the list of monitors associated with this display.
//
// Subsequent calls to this function will always return the
// same list for the same display.
//
// You can listen to the GListModel::items-changed signal on
// this list to monitor changes to the monitor of this display.
func (x *Display) GetMonitors() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xDisplayGetMonitors(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xDisplayGetName func(uintptr) string

// Gets the name of the display.
func (x *Display) GetName() string {

	cret := xDisplayGetName(x.GoPointer())
	return cret
}

var xDisplayGetPrimaryClipboard func(uintptr) uintptr

// Gets the clipboard used for the primary selection.
//
// On backends where the primary clipboard is not supported natively,
// GDK emulates this clipboard locally.
func (x *Display) GetPrimaryClipboard() *Clipboard {
	var cls *Clipboard

	cret := xDisplayGetPrimaryClipboard(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Clipboard{}
	cls.Ptr = cret
	return cls
}

var xDisplayGetSetting func(uintptr, string, *gobject.Value) bool

// Retrieves a desktop-wide setting such as double-click time
// for the @display.
func (x *Display) GetSetting(NameVar string, ValueVar *gobject.Value) bool {

	cret := xDisplayGetSetting(x.GoPointer(), NameVar, ValueVar)
	return cret
}

var xDisplayGetStartupNotificationId func(uintptr) string

// Gets the startup notification ID for a Wayland display, or %NULL
// if no ID has been defined.
func (x *Display) GetStartupNotificationId() string {

	cret := xDisplayGetStartupNotificationId(x.GoPointer())
	return cret
}

var xDisplayIsClosed func(uintptr) bool

// Finds out if the display has been closed.
func (x *Display) IsClosed() bool {

	cret := xDisplayIsClosed(x.GoPointer())
	return cret
}

var xDisplayIsComposited func(uintptr) bool

// Returns whether surfaces can reasonably be expected to have
// their alpha channel drawn correctly on the screen.
//
// Check [method@Gdk.Display.is_rgba] for whether the display
// supports an alpha channel.
//
// On X11 this function returns whether a compositing manager is
// compositing on @display.
//
// On modern displays, this value is always %TRUE.
func (x *Display) IsComposited() bool {

	cret := xDisplayIsComposited(x.GoPointer())
	return cret
}

var xDisplayIsRgba func(uintptr) bool

// Returns whether surfaces on this @display are created with an
// alpha channel.
//
// Even if a %TRUE is returned, it is possible that the
// surface’s alpha channel won’t be honored when displaying the
// surface on the screen: in particular, for X an appropriate
// windowing manager and compositing manager must be running to
// provide appropriate display. Use [method@Gdk.Display.is_composited]
// to check if that is the case.
//
// On modern displays, this value is always %TRUE.
func (x *Display) IsRgba() bool {

	cret := xDisplayIsRgba(x.GoPointer())
	return cret
}

var xDisplayListSeats func(uintptr) *glib.List

// Returns the list of seats known to @display.
func (x *Display) ListSeats() *glib.List {

	cret := xDisplayListSeats(x.GoPointer())
	return cret
}

var xDisplayMapKeycode func(uintptr, uint, uintptr, []uint, int) bool

// Returns the keyvals bound to @keycode.
//
// The Nth `GdkKeymapKey` in @keys is bound to the Nth keyval in @keyvals.
//
// When a keycode is pressed by the user, the keyval from
// this list of entries is selected by considering the effective
// keyboard group and level.
//
// Free the returned arrays with g_free().
func (x *Display) MapKeycode(KeycodeVar uint, KeysVar uintptr, KeyvalsVar []uint, NEntriesVar int) bool {

	cret := xDisplayMapKeycode(x.GoPointer(), KeycodeVar, KeysVar, KeyvalsVar, NEntriesVar)
	return cret
}

var xDisplayMapKeyval func(uintptr, uint, uintptr, int) bool

// Obtains a list of keycode/group/level combinations that will
// generate @keyval.
//
// Groups and levels are two kinds of keyboard mode; in general, the level
// determines whether the top or bottom symbol on a key is used, and the
// group determines whether the left or right symbol is used.
//
// On US keyboards, the shift key changes the keyboard level, and there
// are no groups. A group switch key might convert a keyboard between
// Hebrew to English modes, for example.
//
// `GdkEventKey` contains a %group field that indicates the active
// keyboard group. The level is computed from the modifier mask.
//
// The returned array should be freed with g_free().
func (x *Display) MapKeyval(KeyvalVar uint, KeysVar uintptr, NKeysVar int) bool {

	cret := xDisplayMapKeyval(x.GoPointer(), KeyvalVar, KeysVar, NKeysVar)
	return cret
}

var xDisplayNotifyStartupComplete func(uintptr, string)

// Indicates to the GUI environment that the application has
// finished loading, using a given identifier.
//
// GTK will call this function automatically for [class@Gtk.Window]
// with custom startup-notification identifier unless
// [method@Gtk.Window.set_auto_startup_notification]
// is called to disable that feature.
func (x *Display) NotifyStartupComplete(StartupIdVar string) {

	xDisplayNotifyStartupComplete(x.GoPointer(), StartupIdVar)

}

var xDisplayPrepareGl func(uintptr) bool

// Checks that OpenGL is available for @self and ensures that it is
// properly initialized.
// When this fails, an @error will be set describing the error and this
// function returns %FALSE.
//
// Note that even if this function succeeds, creating a `GdkGLContext`
// may still fail.
//
// This function is idempotent. Calling it multiple times will just
// return the same value or error.
//
// You never need to call this function, GDK will call it automatically
// as needed. But you can use it as a check when setting up code that
// might make use of OpenGL.
func (x *Display) PrepareGl() (bool, error) {
	var cerr *glib.Error

	cret := xDisplayPrepareGl(x.GoPointer())
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xDisplayPutEvent func(uintptr, uintptr)

// Appends the given event onto the front of the event
// queue for @display.
//
// This function is only useful in very special situations
// and should not be used by applications.
func (x *Display) PutEvent(EventVar *Event) {

	xDisplayPutEvent(x.GoPointer(), EventVar.GoPointer())

}

var xDisplaySupportsInputShapes func(uintptr) bool

// Returns %TRUE if the display supports input shapes.
//
// This means that [method@Gdk.Surface.set_input_region] can
// be used to modify the input shape of surfaces on @display.
//
// On modern displays, this value is always %TRUE.
func (x *Display) SupportsInputShapes() bool {

	cret := xDisplaySupportsInputShapes(x.GoPointer())
	return cret
}

var xDisplaySync func(uintptr)

// Flushes any requests queued for the windowing system and waits until all
// requests have been handled.
//
// This is often used for making sure that the display is synchronized
// with the current state of the program. Calling [method@Gdk.Display.sync]
// before [method@GdkX11.Display.error_trap_pop] makes sure that any errors
// generated from earlier requests are handled before the error trap is removed.
//
// This is most useful for X11. On windowing systems where requests are
// handled synchronously, this function will do nothing.
func (x *Display) Sync() {

	xDisplaySync(x.GoPointer())

}

var xDisplayTranslateKey func(uintptr, uint, ModifierType, int, uint, int, int, *ModifierType) bool

// Translates the contents of a `GdkEventKey` into a keyval, effective group,
// and level.
//
// Modifiers that affected the translation and are thus unavailable for
// application use are returned in @consumed_modifiers.
//
// The @effective_group is the group that was actually used for the
// translation; some keys such as Enter are not affected by the active
// keyboard group. The @level is derived from @state.
//
// @consumed_modifiers gives modifiers that should be masked out
// from @state when comparing this key press to a keyboard shortcut.
// For instance, on a US keyboard, the `plus` symbol is shifted, so
// when comparing a key press to a `&lt;Control&gt;plus` accelerator `&lt;Shift&gt;`
// should be masked out.
//
// This function should rarely be needed, since `GdkEventKey` already
// contains the translated keyval. It is exported for the benefit of
// virtualized test environments.
func (x *Display) TranslateKey(KeycodeVar uint, StateVar ModifierType, GroupVar int, KeyvalVar uint, EffectiveGroupVar int, LevelVar int, ConsumedVar *ModifierType) bool {

	cret := xDisplayTranslateKey(x.GoPointer(), KeycodeVar, StateVar, GroupVar, KeyvalVar, EffectiveGroupVar, LevelVar, ConsumedVar)
	return cret
}

func (c *Display) GoPointer() uintptr {
	return c.Ptr
}

func (c *Display) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the connection to the windowing system for @display is closed.
func (x *Display) ConnectClosed(cb *func(Display, bool)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, IsErrorVarp bool) {
		fa := Display{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, IsErrorVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
}

// Emitted when the connection to the windowing system for @display is opened.
func (x *Display) ConnectOpened(cb *func(Display)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "opened", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Display{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "opened", cbRefPtr)
}

// Emitted whenever a new seat is made known to the windowing system.
func (x *Display) ConnectSeatAdded(cb *func(Display, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "seat-added", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, SeatVarp uintptr) {
		fa := Display{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, SeatVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "seat-added", cbRefPtr)
}

// Emitted whenever a seat is removed by the windowing system.
func (x *Display) ConnectSeatRemoved(cb *func(Display, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "seat-removed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, SeatVarp uintptr) {
		fa := Display{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, SeatVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "seat-removed", cbRefPtr)
}

// Emitted whenever a setting changes its value.
func (x *Display) ConnectSettingChanged(cb *func(Display, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "setting-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, SettingVarp string) {
		fa := Display{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, SettingVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "setting-changed", cbRefPtr)
}

var xDisplayGetDefault func() uintptr

// Gets the default `GdkDisplay`.
//
// This is a convenience function for:
//
//	gdk_display_manager_get_default_display (gdk_display_manager_get ())
func DisplayGetDefault() *Display {
	var cls *Display

	cret := xDisplayGetDefault()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Display{}
	cls.Ptr = cret
	return cls
}

var xDisplayOpen func(string) uintptr

// Opens a display.
//
// If opening the display fails, `NULL` is returned.
func DisplayOpen(DisplayNameVar string) *Display {
	var cls *Display

	cret := xDisplayOpen(DisplayNameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Display{}
	cls.Ptr = cret
	return cls
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GDK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xDisplayBeep, lib, "gdk_display_beep")
	core.PuregoSafeRegister(&xDisplayClose, lib, "gdk_display_close")
	core.PuregoSafeRegister(&xDisplayCreateGlContext, lib, "gdk_display_create_gl_context")
	core.PuregoSafeRegister(&xDisplayDeviceIsGrabbed, lib, "gdk_display_device_is_grabbed")
	core.PuregoSafeRegister(&xDisplayFlush, lib, "gdk_display_flush")
	core.PuregoSafeRegister(&xDisplayGetAppLaunchContext, lib, "gdk_display_get_app_launch_context")
	core.PuregoSafeRegister(&xDisplayGetClipboard, lib, "gdk_display_get_clipboard")
	core.PuregoSafeRegister(&xDisplayGetDefaultSeat, lib, "gdk_display_get_default_seat")
	core.PuregoSafeRegister(&xDisplayGetMonitorAtSurface, lib, "gdk_display_get_monitor_at_surface")
	core.PuregoSafeRegister(&xDisplayGetMonitors, lib, "gdk_display_get_monitors")
	core.PuregoSafeRegister(&xDisplayGetName, lib, "gdk_display_get_name")
	core.PuregoSafeRegister(&xDisplayGetPrimaryClipboard, lib, "gdk_display_get_primary_clipboard")
	core.PuregoSafeRegister(&xDisplayGetSetting, lib, "gdk_display_get_setting")
	core.PuregoSafeRegister(&xDisplayGetStartupNotificationId, lib, "gdk_display_get_startup_notification_id")
	core.PuregoSafeRegister(&xDisplayIsClosed, lib, "gdk_display_is_closed")
	core.PuregoSafeRegister(&xDisplayIsComposited, lib, "gdk_display_is_composited")
	core.PuregoSafeRegister(&xDisplayIsRgba, lib, "gdk_display_is_rgba")
	core.PuregoSafeRegister(&xDisplayListSeats, lib, "gdk_display_list_seats")
	core.PuregoSafeRegister(&xDisplayMapKeycode, lib, "gdk_display_map_keycode")
	core.PuregoSafeRegister(&xDisplayMapKeyval, lib, "gdk_display_map_keyval")
	core.PuregoSafeRegister(&xDisplayNotifyStartupComplete, lib, "gdk_display_notify_startup_complete")
	core.PuregoSafeRegister(&xDisplayPrepareGl, lib, "gdk_display_prepare_gl")
	core.PuregoSafeRegister(&xDisplayPutEvent, lib, "gdk_display_put_event")
	core.PuregoSafeRegister(&xDisplaySupportsInputShapes, lib, "gdk_display_supports_input_shapes")
	core.PuregoSafeRegister(&xDisplaySync, lib, "gdk_display_sync")
	core.PuregoSafeRegister(&xDisplayTranslateKey, lib, "gdk_display_translate_key")

	core.PuregoSafeRegister(&xDisplayGetDefault, lib, "gdk_display_get_default")
	core.PuregoSafeRegister(&xDisplayOpen, lib, "gdk_display_open")

}
