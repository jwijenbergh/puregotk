// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type FilterClass struct {
	ParentClass uintptr
}

func (x *FilterClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Describes changes in a filter in more detail and allows objects
// using the filter to optimize refiltering items.
//
// If you are writing an implementation and are not sure which
// value to pass, %GTK_FILTER_CHANGE_DIFFERENT is always a correct
// choice.
type FilterChange int

const (

	// The filter change cannot be
	//   described with any of the other enumeration values.
	FilterChangeDifferentValue FilterChange = 0
	// The filter is less strict than
	//   it was before: All items that it used to return %TRUE for
	//   still return %TRUE, others now may, too.
	FilterChangeLessStrictValue FilterChange = 1
	// The filter is more strict than
	//   it was before: All items that it used to return %FALSE for
	//   still return %FALSE, others now may, too.
	FilterChangeMoreStrictValue FilterChange = 2
)

// Describes the known strictness of a filter.
//
// Note that for filters where the strictness is not known,
// %GTK_FILTER_MATCH_SOME is always an acceptable value,
// even if a filter does match all or no items.
type FilterMatch int

const (

	// The filter matches some items,
	//   gtk_filter_match() may return %TRUE or %FALSE
	FilterMatchSomeValue FilterMatch = 0
	// The filter does not match any item,
	//   gtk_filter_match() will always return %FALSE.
	FilterMatchNoneValue FilterMatch = 1
	// The filter matches all items,
	//   gtk_filter_match() will alays return %TRUE.
	FilterMatchAllValue FilterMatch = 2
)

// A `GtkFilter` object describes the filtering to be performed by a
// [class@Gtk.FilterListModel].
//
// The model will use the filter to determine if it should include items
// or not by calling [method@Gtk.Filter.match] for each item and only
// keeping the ones that the function returns %TRUE for.
//
// Filters may change what items they match through their lifetime. In that
// case, they will emit the [signal@Gtk.Filter::changed] signal to notify
// that previous filter results are no longer valid and that items should
// be checked again via [method@Gtk.Filter.match].
//
// GTK provides various pre-made filter implementations for common filtering
// operations. These filters often include properties that can be linked to
// various widgets to easily allow searches.
//
// However, in particular for large lists or complex search methods, it is
// also possible to subclass `GtkFilter` and provide one's own filter.
type Filter struct {
	gobject.Object
}

func FilterNewFromInternalPtr(ptr uintptr) *Filter {
	cls := &Filter{}
	cls.Ptr = ptr
	return cls
}

var xFilterChanged func(uintptr, FilterChange)

// Notifies all users of the filter that it has changed.
//
// This emits the [signal@Gtk.Filter::changed] signal. Users
// of the filter should then check items again via
// [method@Gtk.Filter.match].
//
// Depending on the @change parameter, not all items need to
// be changed, but only some. Refer to the [enum@Gtk.FilterChange]
// documentation for details.
//
// This function is intended for implementors of `GtkFilter`
// subclasses and should not be called from other functions.
func (x *Filter) Changed(ChangeVar FilterChange) {

	xFilterChanged(x.GoPointer(), ChangeVar)

}

var xFilterGetStrictness func(uintptr) FilterMatch

// Gets the known strictness of @filters.
//
// If the strictness is not known, %GTK_FILTER_MATCH_SOME is returned.
//
// This value may change after emission of the [signal@Gtk.Filter::changed]
// signal.
//
// This function is meant purely for optimization purposes, filters can
// choose to omit implementing it, but `GtkFilterListModel` uses it.
func (x *Filter) GetStrictness() FilterMatch {

	cret := xFilterGetStrictness(x.GoPointer())
	return cret
}

var xFilterMatch func(uintptr, uintptr) bool

// Checks if the given @item is matched by the filter or not.
func (x *Filter) Match(ItemVar *gobject.Object) bool {

	cret := xFilterMatch(x.GoPointer(), ItemVar.GoPointer())
	return cret
}

func (c *Filter) GoPointer() uintptr {
	return c.Ptr
}

func (c *Filter) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted whenever the filter changed.
//
// Users of the filter should then check items again via
// [method@Gtk.Filter.match].
//
// `GtkFilterListModel` handles this signal automatically.
//
// Depending on the @change parameter, not all items need
// to be checked, but only some. Refer to the [enum@Gtk.FilterChange]
// documentation for details.
func (x *Filter) ConnectChanged(cb *func(Filter, FilterChange)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ChangeVarp FilterChange) {
		fa := Filter{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ChangeVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xFilterChanged, lib, "gtk_filter_changed")
	core.PuregoSafeRegister(&xFilterGetStrictness, lib, "gtk_filter_get_strictness")
	core.PuregoSafeRegister(&xFilterMatch, lib, "gtk_filter_match")

}
