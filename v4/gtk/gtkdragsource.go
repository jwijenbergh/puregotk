// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type DragSourceClass struct {
}

func (x *DragSourceClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GtkDragSource` is an event controller to initiate Drag-And-Drop operations.
//
// `GtkDragSource` can be set up with the necessary
// ingredients for a DND operation ahead of time. This includes
// the source for the data that is being transferred, in the form
// of a [class@Gdk.ContentProvider], the desired action, and the icon to
// use during the drag operation. After setting it up, the drag
// source must be added to a widget as an event controller, using
// [method@Gtk.Widget.add_controller].
//
// ```c
// static void
// my_widget_init (MyWidget *self)
//
//	{
//	  GtkDragSource *drag_source = gtk_drag_source_new ();
//
//	  g_signal_connect (drag_source, "prepare", G_CALLBACK (on_drag_prepare), self);
//	  g_signal_connect (drag_source, "drag-begin", G_CALLBACK (on_drag_begin), self);
//
//	  gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (drag_source));
//	}
//
// ```
//
// Setting up the content provider and icon ahead of time only makes
// sense when the data does not change. More commonly, you will want
// to set them up just in time. To do so, `GtkDragSource` has
// [signal@Gtk.DragSource::prepare] and [signal@Gtk.DragSource::drag-begin]
// signals.
//
// The ::prepare signal is emitted before a drag is started, and
// can be used to set the content provider and actions that the
// drag should be started with.
//
// ```c
// static GdkContentProvider *
// on_drag_prepare (GtkDragSource *source,
//
//	double         x,
//	double         y,
//	MyWidget      *self)
//
//	{
//	  // This widget supports two types of content: GFile objects
//	  // and GdkPixbuf objects; GTK will handle the serialization
//	  // of these types automatically
//	  GFile *file = my_widget_get_file (self);
//	  GdkPixbuf *pixbuf = my_widget_get_pixbuf (self);
//
//	  return gdk_content_provider_new_union ((GdkContentProvider *[2]) {
//	      gdk_content_provider_new_typed (G_TYPE_FILE, file),
//	      gdk_content_provider_new_typed (GDK_TYPE_PIXBUF, pixbuf),
//	    }, 2);
//	}
//
// ```
//
// The ::drag-begin signal is emitted after the `GdkDrag` object has
// been created, and can be used to set up the drag icon.
//
// ```c
// static void
// on_drag_begin (GtkDragSource *source,
//
//	GdkDrag       *drag,
//	MyWidget      *self)
//
//	{
//	  // Set the widget as the drag icon
//	  GdkPaintable *paintable = gtk_widget_paintable_new (GTK_WIDGET (self));
//	  gtk_drag_source_set_icon (source, paintable, 0, 0);
//	  g_object_unref (paintable);
//	}
//
// ```
//
// During the DND operation, `GtkDragSource` emits signals that
// can be used to obtain updates about the status of the operation,
// but it is not normally necessary to connect to any signals,
// except for one case: when the supported actions include
// %GDK_ACTION_MOVE, you need to listen for the
// [signal@Gtk.DragSource::drag-end] signal and delete the
// data after it has been transferred.
type DragSource struct {
	GestureSingle
}

var xDragSourceGLibType func() types.GType

func DragSourceGLibType() types.GType {
	return xDragSourceGLibType()
}

func DragSourceNewFromInternalPtr(ptr uintptr) *DragSource {
	cls := &DragSource{}
	cls.Ptr = ptr
	return cls
}

var xNewDragSource func() uintptr

// Creates a new `GtkDragSource` object.
func NewDragSource() *DragSource {
	var cls *DragSource

	cret := xNewDragSource()

	if cret == 0 {
		return nil
	}
	cls = &DragSource{}
	cls.Ptr = cret
	return cls
}

var xDragSourceDragCancel func(uintptr)

// Cancels a currently ongoing drag operation.
func (x *DragSource) DragCancel() {

	xDragSourceDragCancel(x.GoPointer())

}

var xDragSourceGetActions func(uintptr) gdk.DragAction

// Gets the actions that are currently set on the `GtkDragSource`.
func (x *DragSource) GetActions() gdk.DragAction {

	cret := xDragSourceGetActions(x.GoPointer())
	return cret
}

var xDragSourceGetContent func(uintptr) uintptr

// Gets the current content provider of a `GtkDragSource`.
func (x *DragSource) GetContent() *gdk.ContentProvider {
	var cls *gdk.ContentProvider

	cret := xDragSourceGetContent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.ContentProvider{}
	cls.Ptr = cret
	return cls
}

var xDragSourceGetDrag func(uintptr) uintptr

// Returns the underlying `GdkDrag` object for an ongoing drag.
func (x *DragSource) GetDrag() *gdk.Drag {
	var cls *gdk.Drag

	cret := xDragSourceGetDrag(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Drag{}
	cls.Ptr = cret
	return cls
}

var xDragSourceSetActions func(uintptr, gdk.DragAction)

// Sets the actions on the `GtkDragSource`.
//
// During a DND operation, the actions are offered to potential
// drop targets. If @actions include %GDK_ACTION_MOVE, you need
// to listen to the [signal@Gtk.DragSource::drag-end] signal and
// handle @delete_data being %TRUE.
//
// This function can be called before a drag is started,
// or in a handler for the [signal@Gtk.DragSource::prepare] signal.
func (x *DragSource) SetActions(ActionsVar gdk.DragAction) {

	xDragSourceSetActions(x.GoPointer(), ActionsVar)

}

var xDragSourceSetContent func(uintptr, uintptr)

// Sets a content provider on a `GtkDragSource`.
//
// When the data is requested in the cause of a DND operation,
// it will be obtained from the content provider.
//
// This function can be called before a drag is started,
// or in a handler for the [signal@Gtk.DragSource::prepare] signal.
//
// You may consider setting the content provider back to
// %NULL in a [signal@Gtk.DragSource::drag-end] signal handler.
func (x *DragSource) SetContent(ContentVar *gdk.ContentProvider) {

	xDragSourceSetContent(x.GoPointer(), ContentVar.GoPointer())

}

var xDragSourceSetIcon func(uintptr, uintptr, int, int)

// Sets a paintable to use as icon during DND operations.
//
// The hotspot coordinates determine the point on the icon
// that gets aligned with the hotspot of the cursor.
//
// If @paintable is %NULL, a default icon is used.
//
// This function can be called before a drag is started, or in
// a [signal@Gtk.DragSource::prepare] or
// [signal@Gtk.DragSource::drag-begin] signal handler.
func (x *DragSource) SetIcon(PaintableVar gdk.Paintable, HotXVar int, HotYVar int) {

	xDragSourceSetIcon(x.GoPointer(), PaintableVar.GoPointer(), HotXVar, HotYVar)

}

func (c *DragSource) GoPointer() uintptr {
	return c.Ptr
}

func (c *DragSource) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted on the drag source when a drag is started.
//
// It can be used to e.g. set a custom drag icon with
// [method@Gtk.DragSource.set_icon].
func (x *DragSource) ConnectDragBegin(cb *func(DragSource, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "drag-begin", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, DragVarp uintptr) {
		fa := DragSource{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, DragVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "drag-begin", cbRefPtr)
}

// Emitted on the drag source when a drag has failed.
//
// The signal handler may handle a failed drag operation based on
// the type of error. It should return %TRUE if the failure has been handled
// and the default "drag operation failed" animation should not be shown.
func (x *DragSource) ConnectDragCancel(cb *func(DragSource, uintptr, gdk.DragCancelReason) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "drag-cancel", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, DragVarp uintptr, ReasonVarp gdk.DragCancelReason) bool {
		fa := DragSource{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, DragVarp, ReasonVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "drag-cancel", cbRefPtr)
}

// Emitted on the drag source when a drag is finished.
//
// A typical reason to connect to this signal is to undo
// things done in [signal@Gtk.DragSource::prepare] or
// [signal@Gtk.DragSource::drag-begin] handlers.
func (x *DragSource) ConnectDragEnd(cb *func(DragSource, uintptr, bool)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "drag-end", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, DragVarp uintptr, DeleteDataVarp bool) {
		fa := DragSource{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, DragVarp, DeleteDataVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "drag-end", cbRefPtr)
}

// Emitted when a drag is about to be initiated.
//
// It returns the `GdkContentProvider` to use for the drag that is about
// to start. The default handler for this signal returns the value of
// the [property@Gtk.DragSource:content] property, so if you set up that
// property ahead of time, you don't need to connect to this signal.
func (x *DragSource) ConnectPrepare(cb *func(DragSource, float64, float64) gdk.ContentProvider) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "prepare", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, XVarp float64, YVarp float64) uintptr {
		fa := DragSource{}
		fa.Ptr = clsPtr
		cbFn := *cb

		PrepareCls := cbFn(fa, XVarp, YVarp)
		return PrepareCls.Ptr

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "prepare", cbRefPtr)
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xDragSourceGLibType, lib, "gtk_drag_source_get_type")

	core.PuregoSafeRegister(&xNewDragSource, lib, "gtk_drag_source_new")

	core.PuregoSafeRegister(&xDragSourceDragCancel, lib, "gtk_drag_source_drag_cancel")
	core.PuregoSafeRegister(&xDragSourceGetActions, lib, "gtk_drag_source_get_actions")
	core.PuregoSafeRegister(&xDragSourceGetContent, lib, "gtk_drag_source_get_content")
	core.PuregoSafeRegister(&xDragSourceGetDrag, lib, "gtk_drag_source_get_drag")
	core.PuregoSafeRegister(&xDragSourceSetActions, lib, "gtk_drag_source_set_actions")
	core.PuregoSafeRegister(&xDragSourceSetContent, lib, "gtk_drag_source_set_content")
	core.PuregoSafeRegister(&xDragSourceSetIcon, lib, "gtk_drag_source_set_icon")

}
