// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type FileChooserNativeClass struct {
	ParentClass uintptr
}

func (x *FileChooserNativeClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GtkFileChooserNative` is an abstraction of a dialog suitable
// for use with “File Open” or “File Save as” commands.
//
// By default, this just uses a `GtkFileChooserDialog` to implement
// the actual dialog. However, on some platforms, such as Windows and
// macOS, the native platform file chooser is used instead. When the
// application is running in a sandboxed environment without direct
// filesystem access (such as Flatpak), `GtkFileChooserNative` may call
// the proper APIs (portals) to let the user choose a file and make it
// available to the application.
//
// While the API of `GtkFileChooserNative` closely mirrors `GtkFileChooserDialog`,
// the main difference is that there is no access to any `GtkWindow` or `GtkWidget`
// for the dialog. This is required, as there may not be one in the case of a
// platform native dialog.
//
// Showing, hiding and running the dialog is handled by the
// [class@Gtk.NativeDialog] functions.
//
// Note that unlike `GtkFileChooserDialog`, `GtkFileChooserNative` objects
// are not toplevel widgets, and GTK does not keep them alive. It is your
// responsibility to keep a reference until you are done with the
// object.
//
// ## Typical usage
//
// In the simplest of cases, you can the following code to use
// `GtkFileChooserNative` to select a file for opening:
//
// ```c
// static void
// on_response (GtkNativeDialog *native,
//
//	int              response)
//
//	{
//	  if (response == GTK_RESPONSE_ACCEPT)
//	    {
//	      GtkFileChooser *chooser = GTK_FILE_CHOOSER (native);
//	      GFile *file = gtk_file_chooser_get_file (chooser);
//
//	      open_file (file);
//
//	      g_object_unref (file);
//	    }
//
//	  g_object_unref (native);
//	}
//
//	// ...
//	GtkFileChooserNative *native;
//	GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//	native = gtk_file_chooser_native_new ("Open File",
//	                                      parent_window,
//	                                      action,
//	                                      "_Open",
//	                                      "_Cancel");
//
//	g_signal_connect (native, "response", G_CALLBACK (on_response), NULL);
//	gtk_native_dialog_show (GTK_NATIVE_DIALOG (native));
//
// ```
//
// To use a `GtkFileChooserNative` for saving, you can use this:
//
// ```c
// static void
// on_response (GtkNativeDialog *native,
//
//	int              response)
//
//	{
//	  if (response == GTK_RESPONSE_ACCEPT)
//	    {
//	      GtkFileChooser *chooser = GTK_FILE_CHOOSER (native);
//	      GFile *file = gtk_file_chooser_get_file (chooser);
//
//	      save_to_file (file);
//
//	      g_object_unref (file);
//	    }
//
//	  g_object_unref (native);
//	}
//
//	// ...
//	GtkFileChooserNative *native;
//	GtkFileChooser *chooser;
//	GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//
//	native = gtk_file_chooser_native_new ("Save File",
//	                                      parent_window,
//	                                      action,
//	                                      "_Save",
//	                                      "_Cancel");
//	chooser = GTK_FILE_CHOOSER (native);
//
//	if (user_edited_a_new_document)
//	  gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//	else
//	  gtk_file_chooser_set_file (chooser, existing_file, NULL);
//
//	g_signal_connect (native, "response", G_CALLBACK (on_response), NULL);
//	gtk_native_dialog_show (GTK_NATIVE_DIALOG (native));
//
// ```
//
// For more information on how to best set up a file dialog,
// see the [class@Gtk.FileChooserDialog] documentation.
//
// ## Response Codes
//
// `GtkFileChooserNative` inherits from [class@Gtk.NativeDialog],
// which means it will return %GTK_RESPONSE_ACCEPT if the user accepted,
// and %GTK_RESPONSE_CANCEL if he pressed cancel. It can also return
// %GTK_RESPONSE_DELETE_EVENT if the window was unexpectedly closed.
//
// ## Differences from `GtkFileChooserDialog`
//
// There are a few things in the [iface@Gtk.FileChooser] interface that
// are not possible to use with `GtkFileChooserNative`, as such use would
// prohibit the use of a native dialog.
//
// No operations that change the dialog work while the dialog is visible.
// Set all the properties that are required before showing the dialog.
//
// ## Win32 details
//
// On windows the `IFileDialog` implementation (added in Windows Vista) is
// used. It supports many of the features that `GtkFileChooser` has, but
// there are some things it does not handle:
//
// * Any [class@Gtk.FileFilter] added using a mimetype
//
// If any of these features are used the regular `GtkFileChooserDialog`
// will be used in place of the native one.
//
// ## Portal details
//
// When the `org.freedesktop.portal.FileChooser` portal is available on
// the session bus, it is used to bring up an out-of-process file chooser.
// Depending on the kind of session the application is running in, this may
// or may not be a GTK file chooser.
//
// ## macOS details
//
// On macOS the `NSSavePanel` and `NSOpenPanel` classes are used to provide
// native file chooser dialogs. Some features provided by `GtkFileChooser`
// are not supported:
//
// * Shortcut folders.
type FileChooserNative struct {
	NativeDialog
}

func FileChooserNativeNewFromInternalPtr(ptr uintptr) *FileChooserNative {
	cls := &FileChooserNative{}
	cls.Ptr = ptr
	return cls
}

var xNewFileChooserNative func(string, uintptr, FileChooserAction, string, string) uintptr

// Creates a new `GtkFileChooserNative`.
func NewFileChooserNative(TitleVar string, ParentVar *Window, ActionVar FileChooserAction, AcceptLabelVar string, CancelLabelVar string) *FileChooserNative {
	var cls *FileChooserNative

	cret := xNewFileChooserNative(TitleVar, ParentVar.GoPointer(), ActionVar, AcceptLabelVar, CancelLabelVar)

	if cret == 0 {
		return nil
	}
	cls = &FileChooserNative{}
	cls.Ptr = cret
	return cls
}

var xFileChooserNativeGetAcceptLabel func(uintptr) string

// Retrieves the custom label text for the accept button.
func (x *FileChooserNative) GetAcceptLabel() string {

	cret := xFileChooserNativeGetAcceptLabel(x.GoPointer())
	return cret
}

var xFileChooserNativeGetCancelLabel func(uintptr) string

// Retrieves the custom label text for the cancel button.
func (x *FileChooserNative) GetCancelLabel() string {

	cret := xFileChooserNativeGetCancelLabel(x.GoPointer())
	return cret
}

var xFileChooserNativeSetAcceptLabel func(uintptr, string)

// Sets the custom label text for the accept button.
//
// If characters in @label are preceded by an underscore, they are
// underlined. If you need a literal underscore character in a label,
// use “__” (two underscores). The first underlined character represents
// a keyboard accelerator called a mnemonic.
//
// Pressing Alt and that key should activate the button.
func (x *FileChooserNative) SetAcceptLabel(AcceptLabelVar string) {

	xFileChooserNativeSetAcceptLabel(x.GoPointer(), AcceptLabelVar)

}

var xFileChooserNativeSetCancelLabel func(uintptr, string)

// Sets the custom label text for the cancel button.
//
// If characters in @label are preceded by an underscore, they are
// underlined. If you need a literal underscore character in a label,
// use “__” (two underscores). The first underlined character represents
// a keyboard accelerator called a mnemonic.
//
// Pressing Alt and that key should activate the button.
func (x *FileChooserNative) SetCancelLabel(CancelLabelVar string) {

	xFileChooserNativeSetCancelLabel(x.GoPointer(), CancelLabelVar)

}

func (c *FileChooserNative) GoPointer() uintptr {
	return c.Ptr
}

func (c *FileChooserNative) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Adds a 'choice' to the file chooser.
//
// This is typically implemented as a combobox or, for boolean choices,
// as a checkbutton. You can select a value using
// [method@Gtk.FileChooser.set_choice] before the dialog is shown,
// and you can obtain the user-selected value in the
// [signal@Gtk.Dialog::response] signal handler using
// [method@Gtk.FileChooser.get_choice].
func (x *FileChooserNative) AddChoice(IdVar string, LabelVar string, OptionsVar []string, OptionLabelsVar []string) {

	XGtkFileChooserAddChoice(x.GoPointer(), IdVar, LabelVar, OptionsVar, OptionLabelsVar)

}

// Adds @filter to the list of filters that the user can select between.
//
// When a filter is selected, only files that are passed by that
// filter are displayed.
//
// Note that the @chooser takes ownership of the filter if it is floating,
// so you have to ref and sink it if you want to keep a reference.
func (x *FileChooserNative) AddFilter(FilterVar *FileFilter) {

	XGtkFileChooserAddFilter(x.GoPointer(), FilterVar.GoPointer())

}

// Adds a folder to be displayed with the shortcut folders
// in a file chooser.
func (x *FileChooserNative) AddShortcutFolder(FolderVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserAddShortcutFolder(x.GoPointer(), FolderVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Gets the type of operation that the file chooser is performing.
func (x *FileChooserNative) GetAction() FileChooserAction {

	cret := XGtkFileChooserGetAction(x.GoPointer())
	return cret
}

// Gets the currently selected option in the 'choice' with the given ID.
func (x *FileChooserNative) GetChoice(IdVar string) string {

	cret := XGtkFileChooserGetChoice(x.GoPointer(), IdVar)
	return cret
}

// Gets whether file chooser will offer to create new folders.
func (x *FileChooserNative) GetCreateFolders() bool {

	cret := XGtkFileChooserGetCreateFolders(x.GoPointer())
	return cret
}

// Gets the current folder of @chooser as `GFile`.
func (x *FileChooserNative) GetCurrentFolder() *gio.FileBase {
	var cls *gio.FileBase

	cret := XGtkFileChooserGetCurrentFolder(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.FileBase{}
	cls.Ptr = cret
	return cls
}

// Gets the current name in the file selector, as entered by the user.
//
// This is meant to be used in save dialogs, to get the currently typed
// filename when the file itself does not exist yet.
func (x *FileChooserNative) GetCurrentName() string {

	cret := XGtkFileChooserGetCurrentName(x.GoPointer())
	return cret
}

// Gets the `GFile` for the currently selected file in
// the file selector.
//
// If multiple files are selected, one of the files will be
// returned at random.
//
// If the file chooser is in folder mode, this function returns
// the selected folder.
func (x *FileChooserNative) GetFile() *gio.FileBase {
	var cls *gio.FileBase

	cret := XGtkFileChooserGetFile(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.FileBase{}
	cls.Ptr = cret
	return cls
}

// Lists all the selected files and subfolders in the current folder
// of @chooser as `GFile`.
func (x *FileChooserNative) GetFiles() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := XGtkFileChooserGetFiles(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

// Gets the current filter.
func (x *FileChooserNative) GetFilter() *FileFilter {
	var cls *FileFilter

	cret := XGtkFileChooserGetFilter(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FileFilter{}
	cls.Ptr = cret
	return cls
}

// Gets the current set of user-selectable filters, as a list model.
//
// See [method@Gtk.FileChooser.add_filter] and
// [method@Gtk.FileChooser.remove_filter] for changing individual filters.
//
// You should not modify the returned list model. Future changes to
// @chooser may or may not affect the returned model.
func (x *FileChooserNative) GetFilters() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := XGtkFileChooserGetFilters(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

// Gets whether multiple files can be selected in the file
// chooser.
func (x *FileChooserNative) GetSelectMultiple() bool {

	cret := XGtkFileChooserGetSelectMultiple(x.GoPointer())
	return cret
}

// Queries the list of shortcut folders in the file chooser.
//
// You should not modify the returned list model. Future changes to
// @chooser may or may not affect the returned model.
func (x *FileChooserNative) GetShortcutFolders() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := XGtkFileChooserGetShortcutFolders(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

// Removes a 'choice' that has been added with gtk_file_chooser_add_choice().
func (x *FileChooserNative) RemoveChoice(IdVar string) {

	XGtkFileChooserRemoveChoice(x.GoPointer(), IdVar)

}

// Removes @filter from the list of filters that the user can select between.
func (x *FileChooserNative) RemoveFilter(FilterVar *FileFilter) {

	XGtkFileChooserRemoveFilter(x.GoPointer(), FilterVar.GoPointer())

}

// Removes a folder from the shortcut folders in a file chooser.
func (x *FileChooserNative) RemoveShortcutFolder(FolderVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserRemoveShortcutFolder(x.GoPointer(), FolderVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the type of operation that the chooser is performing.
//
// The user interface is adapted to suit the selected action.
//
// For example, an option to create a new folder might be shown
// if the action is %GTK_FILE_CHOOSER_ACTION_SAVE but not if the
// action is %GTK_FILE_CHOOSER_ACTION_OPEN.
func (x *FileChooserNative) SetAction(ActionVar FileChooserAction) {

	XGtkFileChooserSetAction(x.GoPointer(), ActionVar)

}

// Selects an option in a 'choice' that has been added with
// gtk_file_chooser_add_choice().
//
// For a boolean choice, the possible options are "true" and "false".
func (x *FileChooserNative) SetChoice(IdVar string, OptionVar string) {

	XGtkFileChooserSetChoice(x.GoPointer(), IdVar, OptionVar)

}

// Sets whether file chooser will offer to create new folders.
//
// This is only relevant if the action is not set to be
// %GTK_FILE_CHOOSER_ACTION_OPEN.
func (x *FileChooserNative) SetCreateFolders(CreateFoldersVar bool) {

	XGtkFileChooserSetCreateFolders(x.GoPointer(), CreateFoldersVar)

}

// Sets the current folder for @chooser from a `GFile`.
func (x *FileChooserNative) SetCurrentFolder(FileVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserSetCurrentFolder(x.GoPointer(), FileVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the current name in the file selector, as if entered
// by the user.
//
// Note that the name passed in here is a UTF-8 string rather
// than a filename. This function is meant for such uses as a
// suggested name in a “Save As...” dialog.  You can pass
// “Untitled.doc” or a similarly suitable suggestion for the @name.
//
// If you want to preselect a particular existing file, you should
// use [method@Gtk.FileChooser.set_file] instead.
//
// Please see the documentation for those functions for an example
// of using [method@Gtk.FileChooser.set_current_name] as well.
func (x *FileChooserNative) SetCurrentName(NameVar string) {

	XGtkFileChooserSetCurrentName(x.GoPointer(), NameVar)

}

// Sets @file as the current filename for the file chooser.
//
// This includes changing to the file’s parent folder and actually selecting
// the file in list. If the @chooser is in %GTK_FILE_CHOOSER_ACTION_SAVE mode,
// the file’s base name will also appear in the dialog’s file name entry.
//
// If the file name isn’t in the current folder of @chooser, then the current
// folder of @chooser will be changed to the folder containing @file.
//
// Note that the file must exist, or nothing will be done except
// for the directory change.
//
// If you are implementing a save dialog, you should use this function if
// you already have a file name to which the user may save; for example,
// when the user opens an existing file and then does “Save As…”. If you
// don’t have a file name already — for example, if the user just created
// a new file and is saving it for the first time, do not call this function.
//
// Instead, use something similar to this:
//
// ```c
// static void
// prepare_file_chooser (GtkFileChooser *chooser,
//
//	GFile          *existing_file)
//
//	{
//	  gboolean document_is_new = (existing_file == NULL);
//
//	  if (document_is_new)
//	    {
//	      GFile *default_file_for_saving = g_file_new_for_path ("./out.txt");
//	      // the user just created a new document
//	      gtk_file_chooser_set_current_folder (chooser, default_file_for_saving, NULL);
//	      gtk_file_chooser_set_current_name (chooser, "Untitled document");
//	      g_object_unref (default_file_for_saving);
//	    }
//	  else
//	    {
//	      // the user edited an existing document
//	      gtk_file_chooser_set_file (chooser, existing_file, NULL);
//	    }
//	}
//
// ```
func (x *FileChooserNative) SetFile(FileVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserSetFile(x.GoPointer(), FileVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the current filter.
//
// Only the files that pass the filter will be displayed.
// If the user-selectable list of filters is non-empty, then
// the filter should be one of the filters in that list.
//
// Setting the current filter when the list of filters is
// empty is useful if you want to restrict the displayed
// set of files without letting the user change it.
func (x *FileChooserNative) SetFilter(FilterVar *FileFilter) {

	XGtkFileChooserSetFilter(x.GoPointer(), FilterVar.GoPointer())

}

// Sets whether multiple files can be selected in the file chooser.
//
// This is only relevant if the action is set to be
// %GTK_FILE_CHOOSER_ACTION_OPEN or
// %GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
func (x *FileChooserNative) SetSelectMultiple(SelectMultipleVar bool) {

	XGtkFileChooserSetSelectMultiple(x.GoPointer(), SelectMultipleVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewFileChooserNative, lib, "gtk_file_chooser_native_new")

	core.PuregoSafeRegister(&xFileChooserNativeGetAcceptLabel, lib, "gtk_file_chooser_native_get_accept_label")
	core.PuregoSafeRegister(&xFileChooserNativeGetCancelLabel, lib, "gtk_file_chooser_native_get_cancel_label")
	core.PuregoSafeRegister(&xFileChooserNativeSetAcceptLabel, lib, "gtk_file_chooser_native_set_accept_label")
	core.PuregoSafeRegister(&xFileChooserNativeSetCancelLabel, lib, "gtk_file_chooser_native_set_cancel_label")

}
