// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// Function type for determining whether @column can be dropped in a
// particular spot (as determined by @prev_column and @next_column).  In
// left to right locales, @prev_column is on the left of the potential drop
// spot, and @next_column is on the right.  In right to left mode, this is
// reversed.  This function should return %TRUE if the spot is a valid drop
// spot.  Please note that returning %TRUE does not actually indicate that
// the column drop was made, but is meant only to indicate a possible drop
// spot to the user.
type TreeViewColumnDropFunc func(uintptr, uintptr, uintptr, uintptr, uintptr) bool

// Function used for gtk_tree_view_map_expanded_rows().
type TreeViewMappingFunc func(uintptr, *TreePath, uintptr)

// Function type for determining whether the row pointed to by @iter should
// be rendered as a separator. A common way to implement this is to have a
// boolean column in the model, whose values the `GtkTreeViewRowSeparatorFunc`
// returns.
type TreeViewRowSeparatorFunc func(uintptr, *TreeIter, uintptr) bool

// A function used for checking whether a row in @model matches
// a search key string entered by the user. Note the return value
// is reversed from what you would normally expect, though it
// has some similarity to strcmp() returning 0 for equal strings.
type TreeViewSearchEqualFunc func(uintptr, int, string, *TreeIter, uintptr) bool

type TreeViewClass struct {
	ParentClass uintptr

	Reserved uintptr
}

func (x *TreeViewClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// An enum for determining where a dropped row goes.
type TreeViewDropPosition int

const (

	// dropped row is inserted before
	TreeViewDropBeforeValue TreeViewDropPosition = 0
	// dropped row is inserted after
	TreeViewDropAfterValue TreeViewDropPosition = 1
	// dropped row becomes a child or is inserted before
	TreeViewDropIntoOrBeforeValue TreeViewDropPosition = 2
	// dropped row becomes a child or is inserted after
	TreeViewDropIntoOrAfterValue TreeViewDropPosition = 3
)

// A widget for displaying both trees and lists
//
// Widget that displays any object that implements the [iface@Gtk.TreeModel] interface.
//
// Please refer to the [tree widget conceptual overview](section-tree-widget.html)
// for an overview of all the objects and data types related to the tree
// widget and how they work together.
//
// ## Coordinate systems in GtkTreeView API
//
// Several different coordinate systems are exposed in the `GtkTreeView` API.
// These are:
//
// ![](tree-view-coordinates.png)
//
// - Widget coordinates: Coordinates relative to the widget (usually `widget-&gt;window`).
//
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.
//
//   - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
//     coordinates start at (0, 0) for row 0 of the tree.
//
// Several functions are available for converting between the different
// coordinate systems.  The most common translations are between widget and bin
// window coordinates and between bin window and tree coordinates. For the
// former you can use [method@Gtk.TreeView.convert_widget_to_bin_window_coords]
// (and vice versa), for the latter [method@Gtk.TreeView.convert_bin_window_to_tree_coords]
// (and vice versa).
//
// ## `GtkTreeView` as `GtkBuildable`
//
// The `GtkTreeView` implementation of the `GtkBuildable` interface accepts
// [class@Gtk.TreeViewColumn] objects as `&lt;child&gt;` elements and exposes the
// internal [class@Gtk.TreeSelection] in UI definitions.
//
// An example of a UI definition fragment with `GtkTreeView`:
//
// ```xml
// &lt;object class="GtkTreeView" id="treeview"&gt;
//
//	&lt;property name="model"&gt;liststore1&lt;/property&gt;
//	&lt;child&gt;
//	  &lt;object class="GtkTreeViewColumn" id="test-column"&gt;
//	    &lt;property name="title"&gt;Test&lt;/property&gt;
//	    &lt;child&gt;
//	      &lt;object class="GtkCellRendererText" id="test-renderer"/&gt;
//	      &lt;attributes&gt;
//	        &lt;attribute name="text"&gt;1&lt;/attribute&gt;
//	      &lt;/attributes&gt;
//	    &lt;/child&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//	&lt;child internal-child="selection"&gt;
//	  &lt;object class="GtkTreeSelection" id="selection"&gt;
//	    &lt;signal name="changed" handler="on_treeview_selection_changed"/&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//
// &lt;/object&gt;
// ```
//
// ## CSS nodes
//
// ```
// treeview.view
// ├── header
// │   ├── button
// │   │   ╰── [sort-indicator]
// ┊   ┊
// │   ╰── button
// │       ╰── [sort-indicator]
// │
// ├── [rubberband]
// ╰── [dndtarget]
// ```
//
// `GtkTreeView` has a main CSS node with name `treeview` and style class `.view`.
// It has a subnode with name `header`, which is the parent for all the column
// header widgets' CSS nodes.
//
// Each column header consists of a `button`, which among other content, has a
// child with name `sort-indicator`, which carries the `.ascending` or `.descending`
// style classes when the column header should show a sort indicator. The CSS
// is expected to provide a suitable image using the `-gtk-icon-source` property.
//
// For rubberband selection, a subnode with name `rubberband` is used.
//
// For the drop target location during DND, a subnode with name `dndtarget` is used.
type TreeView struct {
	Widget
}

func TreeViewNewFromInternalPtr(ptr uintptr) *TreeView {
	cls := &TreeView{}
	cls.Ptr = ptr
	return cls
}

var xNewTreeView func() uintptr

// Creates a new `GtkTreeView` widget.
func NewTreeView() *TreeView {
	var cls *TreeView

	cret := xNewTreeView()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeView{}
	cls.Ptr = cret
	return cls
}

var xNewTreeViewWithModel func(uintptr) uintptr

// Creates a new `GtkTreeView` widget with the model initialized to @model.
func NewTreeViewWithModel(ModelVar TreeModel) *TreeView {
	var cls *TreeView

	cret := xNewTreeViewWithModel(ModelVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeView{}
	cls.Ptr = cret
	return cls
}

var xTreeViewAppendColumn func(uintptr, uintptr) int

// Appends @column to the list of columns. If @tree_view has “fixed_height”
// mode enabled, then @column must have its “sizing” property set to be
// GTK_TREE_VIEW_COLUMN_FIXED.
func (x *TreeView) AppendColumn(ColumnVar *TreeViewColumn) int {

	cret := xTreeViewAppendColumn(x.GoPointer(), ColumnVar.GoPointer())
	return cret
}

var xTreeViewCollapseAll func(uintptr)

// Recursively collapses all visible, expanded nodes in @tree_view.
func (x *TreeView) CollapseAll() {

	xTreeViewCollapseAll(x.GoPointer())

}

var xTreeViewCollapseRow func(uintptr, *TreePath) bool

// Collapses a row (hides its child rows, if they exist).
func (x *TreeView) CollapseRow(PathVar *TreePath) bool {

	cret := xTreeViewCollapseRow(x.GoPointer(), PathVar)
	return cret
}

var xTreeViewColumnsAutosize func(uintptr)

// Resizes all columns to their optimal width. Only works after the
// treeview has been realized.
func (x *TreeView) ColumnsAutosize() {

	xTreeViewColumnsAutosize(x.GoPointer())

}

var xTreeViewConvertBinWindowToTreeCoords func(uintptr, int, int, int, int)

// Converts bin_window coordinates to coordinates for the
// tree (the full scrollable area of the tree).
func (x *TreeView) ConvertBinWindowToTreeCoords(BxVar int, ByVar int, TxVar int, TyVar int) {

	xTreeViewConvertBinWindowToTreeCoords(x.GoPointer(), BxVar, ByVar, TxVar, TyVar)

}

var xTreeViewConvertBinWindowToWidgetCoords func(uintptr, int, int, int, int)

// Converts bin_window coordinates to widget relative coordinates.
func (x *TreeView) ConvertBinWindowToWidgetCoords(BxVar int, ByVar int, WxVar int, WyVar int) {

	xTreeViewConvertBinWindowToWidgetCoords(x.GoPointer(), BxVar, ByVar, WxVar, WyVar)

}

var xTreeViewConvertTreeToBinWindowCoords func(uintptr, int, int, int, int)

// Converts tree coordinates (coordinates in full scrollable area of the tree)
// to bin_window coordinates.
func (x *TreeView) ConvertTreeToBinWindowCoords(TxVar int, TyVar int, BxVar int, ByVar int) {

	xTreeViewConvertTreeToBinWindowCoords(x.GoPointer(), TxVar, TyVar, BxVar, ByVar)

}

var xTreeViewConvertTreeToWidgetCoords func(uintptr, int, int, int, int)

// Converts tree coordinates (coordinates in full scrollable area of the tree)
// to widget coordinates.
func (x *TreeView) ConvertTreeToWidgetCoords(TxVar int, TyVar int, WxVar int, WyVar int) {

	xTreeViewConvertTreeToWidgetCoords(x.GoPointer(), TxVar, TyVar, WxVar, WyVar)

}

var xTreeViewConvertWidgetToBinWindowCoords func(uintptr, int, int, int, int)

// Converts widget coordinates to coordinates for the bin_window.
func (x *TreeView) ConvertWidgetToBinWindowCoords(WxVar int, WyVar int, BxVar int, ByVar int) {

	xTreeViewConvertWidgetToBinWindowCoords(x.GoPointer(), WxVar, WyVar, BxVar, ByVar)

}

var xTreeViewConvertWidgetToTreeCoords func(uintptr, int, int, int, int)

// Converts widget coordinates to coordinates for the
// tree (the full scrollable area of the tree).
func (x *TreeView) ConvertWidgetToTreeCoords(WxVar int, WyVar int, TxVar int, TyVar int) {

	xTreeViewConvertWidgetToTreeCoords(x.GoPointer(), WxVar, WyVar, TxVar, TyVar)

}

var xTreeViewCreateRowDragIcon func(uintptr, *TreePath) uintptr

// Creates a `cairo_surface_t` representation of the row at @path.
// This image is used for a drag icon.
func (x *TreeView) CreateRowDragIcon(PathVar *TreePath) *gdk.PaintableBase {
	var cls *gdk.PaintableBase

	cret := xTreeViewCreateRowDragIcon(x.GoPointer(), PathVar)

	if cret == 0 {
		return nil
	}
	cls = &gdk.PaintableBase{}
	cls.Ptr = cret
	return cls
}

var xTreeViewEnableModelDragDest func(uintptr, *gdk.ContentFormats, gdk.DragAction)

// Turns @tree_view into a drop destination for automatic DND. Calling
// this method sets `GtkTreeView`:reorderable to %FALSE.
func (x *TreeView) EnableModelDragDest(FormatsVar *gdk.ContentFormats, ActionsVar gdk.DragAction) {

	xTreeViewEnableModelDragDest(x.GoPointer(), FormatsVar, ActionsVar)

}

var xTreeViewEnableModelDragSource func(uintptr, gdk.ModifierType, *gdk.ContentFormats, gdk.DragAction)

// Turns @tree_view into a drag source for automatic DND. Calling this
// method sets `GtkTreeView`:reorderable to %FALSE.
func (x *TreeView) EnableModelDragSource(StartButtonMaskVar gdk.ModifierType, FormatsVar *gdk.ContentFormats, ActionsVar gdk.DragAction) {

	xTreeViewEnableModelDragSource(x.GoPointer(), StartButtonMaskVar, FormatsVar, ActionsVar)

}

var xTreeViewExpandAll func(uintptr)

// Recursively expands all nodes in the @tree_view.
func (x *TreeView) ExpandAll() {

	xTreeViewExpandAll(x.GoPointer())

}

var xTreeViewExpandRow func(uintptr, *TreePath, bool) bool

// Opens the row so its children are visible.
func (x *TreeView) ExpandRow(PathVar *TreePath, OpenAllVar bool) bool {

	cret := xTreeViewExpandRow(x.GoPointer(), PathVar, OpenAllVar)
	return cret
}

var xTreeViewExpandToPath func(uintptr, *TreePath)

// Expands the row at @path. This will also expand all parent rows of
// @path as necessary.
func (x *TreeView) ExpandToPath(PathVar *TreePath) {

	xTreeViewExpandToPath(x.GoPointer(), PathVar)

}

var xTreeViewGetActivateOnSingleClick func(uintptr) bool

// Gets the setting set by gtk_tree_view_set_activate_on_single_click().
func (x *TreeView) GetActivateOnSingleClick() bool {

	cret := xTreeViewGetActivateOnSingleClick(x.GoPointer())
	return cret
}

var xTreeViewGetBackgroundArea func(uintptr, *TreePath, uintptr, *gdk.Rectangle)

// Fills the bounding rectangle in bin_window coordinates for the cell at the
// row specified by @path and the column specified by @column.  If @path is
// %NULL, or points to a node not found in the tree, the @y and @height fields of
// the rectangle will be filled with 0. If @column is %NULL, the @x and @width
// fields will be filled with 0.  The returned rectangle is equivalent to the
// @background_area passed to gtk_cell_renderer_render().  These background
// areas tile to cover the entire bin window.  Contrast with the @cell_area,
// returned by gtk_tree_view_get_cell_area(), which returns only the cell
// itself, excluding surrounding borders and the tree expander area.
func (x *TreeView) GetBackgroundArea(PathVar *TreePath, ColumnVar *TreeViewColumn, RectVar *gdk.Rectangle) {

	xTreeViewGetBackgroundArea(x.GoPointer(), PathVar, ColumnVar.GoPointer(), RectVar)

}

var xTreeViewGetCellArea func(uintptr, *TreePath, uintptr, *gdk.Rectangle)

// Fills the bounding rectangle in bin_window coordinates for the cell at the
// row specified by @path and the column specified by @column.  If @path is
// %NULL, or points to a path not currently displayed, the @y and @height fields
// of the rectangle will be filled with 0. If @column is %NULL, the @x and @width
// fields will be filled with 0.  The sum of all cell rects does not cover the
// entire tree; there are extra pixels in between rows, for example. The
// returned rectangle is equivalent to the @cell_area passed to
// gtk_cell_renderer_render().  This function is only valid if @tree_view is
// realized.
func (x *TreeView) GetCellArea(PathVar *TreePath, ColumnVar *TreeViewColumn, RectVar *gdk.Rectangle) {

	xTreeViewGetCellArea(x.GoPointer(), PathVar, ColumnVar.GoPointer(), RectVar)

}

var xTreeViewGetColumn func(uintptr, int) uintptr

// Gets the `GtkTreeViewColumn` at the given position in the #tree_view.
func (x *TreeView) GetColumn(NVar int) *TreeViewColumn {
	var cls *TreeViewColumn

	cret := xTreeViewGetColumn(x.GoPointer(), NVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeViewColumn{}
	cls.Ptr = cret
	return cls
}

var xTreeViewGetColumns func(uintptr) *glib.List

// Returns a `GList` of all the `GtkTreeViewColumn`s currently in @tree_view.
// The returned list must be freed with g_list_free ().
func (x *TreeView) GetColumns() *glib.List {

	cret := xTreeViewGetColumns(x.GoPointer())
	return cret
}

var xTreeViewGetCursor func(uintptr, **TreePath, *uintptr)

// Fills in @path and @focus_column with the current path and focus column.  If
// the cursor isn’t currently set, then *@path will be %NULL.  If no column
// currently has focus, then *@focus_column will be %NULL.
//
// The returned `GtkTreePath` must be freed with gtk_tree_path_free() when
// you are done with it.
func (x *TreeView) GetCursor(PathVar **TreePath, FocusColumnVar **TreeViewColumn) {

	xTreeViewGetCursor(x.GoPointer(), PathVar, gobject.ConvertPtr(FocusColumnVar))

}

var xTreeViewGetDestRowAtPos func(uintptr, int, int, **TreePath, *TreeViewDropPosition) bool

// Determines the destination row for a given position.  @drag_x and
// @drag_y are expected to be in widget coordinates.  This function is only
// meaningful if @tree_view is realized.  Therefore this function will always
// return %FALSE if @tree_view is not realized or does not have a model.
func (x *TreeView) GetDestRowAtPos(DragXVar int, DragYVar int, PathVar **TreePath, PosVar *TreeViewDropPosition) bool {

	cret := xTreeViewGetDestRowAtPos(x.GoPointer(), DragXVar, DragYVar, PathVar, PosVar)
	return cret
}

var xTreeViewGetDragDestRow func(uintptr, **TreePath, *TreeViewDropPosition)

// Gets information about the row that is highlighted for feedback.
func (x *TreeView) GetDragDestRow(PathVar **TreePath, PosVar *TreeViewDropPosition) {

	xTreeViewGetDragDestRow(x.GoPointer(), PathVar, PosVar)

}

var xTreeViewGetEnableSearch func(uintptr) bool

// Returns whether or not the tree allows to start interactive searching
// by typing in text.
func (x *TreeView) GetEnableSearch() bool {

	cret := xTreeViewGetEnableSearch(x.GoPointer())
	return cret
}

var xTreeViewGetEnableTreeLines func(uintptr) bool

// Returns whether or not tree lines are drawn in @tree_view.
func (x *TreeView) GetEnableTreeLines() bool {

	cret := xTreeViewGetEnableTreeLines(x.GoPointer())
	return cret
}

var xTreeViewGetExpanderColumn func(uintptr) uintptr

// Returns the column that is the current expander column,
// or %NULL if none has been set.
// This column has the expander arrow drawn next to it.
func (x *TreeView) GetExpanderColumn() *TreeViewColumn {
	var cls *TreeViewColumn

	cret := xTreeViewGetExpanderColumn(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeViewColumn{}
	cls.Ptr = cret
	return cls
}

var xTreeViewGetFixedHeightMode func(uintptr) bool

// Returns whether fixed height mode is turned on for @tree_view.
func (x *TreeView) GetFixedHeightMode() bool {

	cret := xTreeViewGetFixedHeightMode(x.GoPointer())
	return cret
}

var xTreeViewGetGridLines func(uintptr) TreeViewGridLines

// Returns which grid lines are enabled in @tree_view.
func (x *TreeView) GetGridLines() TreeViewGridLines {

	cret := xTreeViewGetGridLines(x.GoPointer())
	return cret
}

var xTreeViewGetHeadersClickable func(uintptr) bool

// Returns whether all header columns are clickable.
func (x *TreeView) GetHeadersClickable() bool {

	cret := xTreeViewGetHeadersClickable(x.GoPointer())
	return cret
}

var xTreeViewGetHeadersVisible func(uintptr) bool

// Returns %TRUE if the headers on the @tree_view are visible.
func (x *TreeView) GetHeadersVisible() bool {

	cret := xTreeViewGetHeadersVisible(x.GoPointer())
	return cret
}

var xTreeViewGetHoverExpand func(uintptr) bool

// Returns whether hover expansion mode is turned on for @tree_view.
func (x *TreeView) GetHoverExpand() bool {

	cret := xTreeViewGetHoverExpand(x.GoPointer())
	return cret
}

var xTreeViewGetHoverSelection func(uintptr) bool

// Returns whether hover selection mode is turned on for @tree_view.
func (x *TreeView) GetHoverSelection() bool {

	cret := xTreeViewGetHoverSelection(x.GoPointer())
	return cret
}

var xTreeViewGetLevelIndentation func(uintptr) int

// Returns the amount, in pixels, of extra indentation for child levels
// in @tree_view.
func (x *TreeView) GetLevelIndentation() int {

	cret := xTreeViewGetLevelIndentation(x.GoPointer())
	return cret
}

var xTreeViewGetModel func(uintptr) uintptr

// Returns the model the `GtkTreeView` is based on.  Returns %NULL if the
// model is unset.
func (x *TreeView) GetModel() *TreeModelBase {
	var cls *TreeModelBase

	cret := xTreeViewGetModel(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeModelBase{}
	cls.Ptr = cret
	return cls
}

var xTreeViewGetNColumns func(uintptr) uint

// Queries the number of columns in the given @tree_view.
func (x *TreeView) GetNColumns() uint {

	cret := xTreeViewGetNColumns(x.GoPointer())
	return cret
}

var xTreeViewGetPathAtPos func(uintptr, int, int, **TreePath, *uintptr, int, int) bool

// Finds the path at the point (@x, @y), relative to bin_window coordinates.
// That is, @x and @y are relative to an events coordinates. Widget-relative
// coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords(). It is primarily for
// things like popup menus. If @path is non-%NULL, then it will be filled
// with the `GtkTreePath` at that point.  This path should be freed with
// gtk_tree_path_free().  If @column is non-%NULL, then it will be filled
// with the column at that point.  @cell_x and @cell_y return the coordinates
// relative to the cell background (i.e. the @background_area passed to
// gtk_cell_renderer_render()).  This function is only meaningful if
// @tree_view is realized.  Therefore this function will always return %FALSE
// if @tree_view is not realized or does not have a model.
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
func (x *TreeView) GetPathAtPos(XVar int, YVar int, PathVar **TreePath, ColumnVar **TreeViewColumn, CellXVar int, CellYVar int) bool {

	cret := xTreeViewGetPathAtPos(x.GoPointer(), XVar, YVar, PathVar, gobject.ConvertPtr(ColumnVar), CellXVar, CellYVar)
	return cret
}

var xTreeViewGetReorderable func(uintptr) bool

// Retrieves whether the user can reorder the tree via drag-and-drop. See
// gtk_tree_view_set_reorderable().
func (x *TreeView) GetReorderable() bool {

	cret := xTreeViewGetReorderable(x.GoPointer())
	return cret
}

var xTreeViewGetRowSeparatorFunc func(uintptr) uintptr

// Returns the current row separator function.
func (x *TreeView) GetRowSeparatorFunc() uintptr {

	cret := xTreeViewGetRowSeparatorFunc(x.GoPointer())
	return cret
}

var xTreeViewGetRubberBanding func(uintptr) bool

// Returns whether rubber banding is turned on for @tree_view.  If the
// selection mode is %GTK_SELECTION_MULTIPLE, rubber banding will allow the
// user to select multiple rows by dragging the mouse.
func (x *TreeView) GetRubberBanding() bool {

	cret := xTreeViewGetRubberBanding(x.GoPointer())
	return cret
}

var xTreeViewGetSearchColumn func(uintptr) int

// Gets the column searched on by the interactive search code.
func (x *TreeView) GetSearchColumn() int {

	cret := xTreeViewGetSearchColumn(x.GoPointer())
	return cret
}

var xTreeViewGetSearchEntry func(uintptr) uintptr

// Returns the `GtkEntry` which is currently in use as interactive search
// entry for @tree_view.  In case the built-in entry is being used, %NULL
// will be returned.
func (x *TreeView) GetSearchEntry() *EditableBase {
	var cls *EditableBase

	cret := xTreeViewGetSearchEntry(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EditableBase{}
	cls.Ptr = cret
	return cls
}

var xTreeViewGetSearchEqualFunc func(uintptr) uintptr

// Returns the compare function currently in use.
func (x *TreeView) GetSearchEqualFunc() uintptr {

	cret := xTreeViewGetSearchEqualFunc(x.GoPointer())
	return cret
}

var xTreeViewGetSelection func(uintptr) uintptr

// Gets the `GtkTreeSelection` associated with @tree_view.
func (x *TreeView) GetSelection() *TreeSelection {
	var cls *TreeSelection

	cret := xTreeViewGetSelection(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeSelection{}
	cls.Ptr = cret
	return cls
}

var xTreeViewGetShowExpanders func(uintptr) bool

// Returns whether or not expanders are drawn in @tree_view.
func (x *TreeView) GetShowExpanders() bool {

	cret := xTreeViewGetShowExpanders(x.GoPointer())
	return cret
}

var xTreeViewGetTooltipColumn func(uintptr) int

// Returns the column of @tree_view’s model which is being used for
// displaying tooltips on @tree_view’s rows.
func (x *TreeView) GetTooltipColumn() int {

	cret := xTreeViewGetTooltipColumn(x.GoPointer())
	return cret
}

var xTreeViewGetTooltipContext func(uintptr, int, int, bool, *uintptr, **TreePath, *TreeIter) bool

// This function is supposed to be used in a ::query-tooltip
// signal handler for `GtkTreeView`. The @x, @y and @keyboard_tip values
// which are received in the signal handler, should be passed to this
// function without modification.
//
// The return value indicates whether there is a tree view row at the given
// coordinates (%TRUE) or not (%FALSE) for mouse tooltips. For keyboard
// tooltips the row returned will be the cursor row. When %TRUE, then any of
// @model, @path and @iter which have been provided will be set to point to
// that row and the corresponding model. @x and @y will always be converted
// to be relative to @tree_view’s bin_window if @keyboard_tooltip is %FALSE.
func (x *TreeView) GetTooltipContext(XVar int, YVar int, KeyboardTipVar bool, ModelVar *TreeModel, PathVar **TreePath, IterVar *TreeIter) bool {

	cret := xTreeViewGetTooltipContext(x.GoPointer(), XVar, YVar, KeyboardTipVar, gobject.ConvertPtr(ModelVar), PathVar, IterVar)
	return cret
}

var xTreeViewGetVisibleRange func(uintptr, **TreePath, **TreePath) bool

// Sets @start_path and @end_path to be the first and last visible path.
// Note that there may be invisible paths in between.
//
// The paths should be freed with gtk_tree_path_free() after use.
func (x *TreeView) GetVisibleRange(StartPathVar **TreePath, EndPathVar **TreePath) bool {

	cret := xTreeViewGetVisibleRange(x.GoPointer(), StartPathVar, EndPathVar)
	return cret
}

var xTreeViewGetVisibleRect func(uintptr, *gdk.Rectangle)

// Fills @visible_rect with the currently-visible region of the
// buffer, in tree coordinates. Convert to bin_window coordinates with
// gtk_tree_view_convert_tree_to_bin_window_coords().
// Tree coordinates start at 0,0 for row 0 of the tree, and cover the entire
// scrollable area of the tree.
func (x *TreeView) GetVisibleRect(VisibleRectVar *gdk.Rectangle) {

	xTreeViewGetVisibleRect(x.GoPointer(), VisibleRectVar)

}

var xTreeViewInsertColumn func(uintptr, uintptr, int) int

// This inserts the @column into the @tree_view at @position.  If @position is
// -1, then the column is inserted at the end. If @tree_view has
// “fixed_height” mode enabled, then @column must have its “sizing” property
// set to be GTK_TREE_VIEW_COLUMN_FIXED.
func (x *TreeView) InsertColumn(ColumnVar *TreeViewColumn, PositionVar int) int {

	cret := xTreeViewInsertColumn(x.GoPointer(), ColumnVar.GoPointer(), PositionVar)
	return cret
}

var xTreeViewInsertColumnWithAttributes func(uintptr, int, string, uintptr, ...interface{}) int

// Creates a new `GtkTreeViewColumn` and inserts it into the @tree_view at
// @position.  If @position is -1, then the newly created column is inserted at
// the end.  The column is initialized with the attributes given. If @tree_view
// has “fixed_height” mode enabled, then the new column will have its sizing
// property set to be GTK_TREE_VIEW_COLUMN_FIXED.
func (x *TreeView) InsertColumnWithAttributes(PositionVar int, TitleVar string, CellVar *CellRenderer, varArgs ...interface{}) int {

	cret := xTreeViewInsertColumnWithAttributes(x.GoPointer(), PositionVar, TitleVar, CellVar.GoPointer(), varArgs...)
	return cret
}

var xTreeViewInsertColumnWithDataFunc func(uintptr, int, string, uintptr, uintptr, uintptr, uintptr) int

// Convenience function that inserts a new column into the `GtkTreeView`
// with the given cell renderer and a `GtkTreeCellDataFunc` to set cell renderer
// attributes (normally using data from the model). See also
// gtk_tree_view_column_set_cell_data_func(), gtk_tree_view_column_pack_start().
// If @tree_view has “fixed_height” mode enabled, then the new column will have its
// “sizing” property set to be GTK_TREE_VIEW_COLUMN_FIXED.
func (x *TreeView) InsertColumnWithDataFunc(PositionVar int, TitleVar string, CellVar *CellRenderer, FuncVar *TreeCellDataFunc, DataVar uintptr, DnotifyVar *glib.DestroyNotify) int {

	cret := xTreeViewInsertColumnWithDataFunc(x.GoPointer(), PositionVar, TitleVar, CellVar.GoPointer(), glib.NewCallback(FuncVar), DataVar, glib.NewCallback(DnotifyVar))
	return cret
}

var xTreeViewIsBlankAtPos func(uintptr, int, int, **TreePath, *uintptr, int, int) bool

// Determine whether the point (@x, @y) in @tree_view is blank, that is no
// cell content nor an expander arrow is drawn at the location. If so, the
// location can be considered as the background. You might wish to take
// special action on clicks on the background, such as clearing a current
// selection, having a custom context menu or starting rubber banding.
//
// The @x and @y coordinate that are provided must be relative to bin_window
// coordinates.  Widget-relative coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// The @path, @column, @cell_x and @cell_y arguments will be filled in
// likewise as for gtk_tree_view_get_path_at_pos().  Please see
// gtk_tree_view_get_path_at_pos() for more information.
func (x *TreeView) IsBlankAtPos(XVar int, YVar int, PathVar **TreePath, ColumnVar **TreeViewColumn, CellXVar int, CellYVar int) bool {

	cret := xTreeViewIsBlankAtPos(x.GoPointer(), XVar, YVar, PathVar, gobject.ConvertPtr(ColumnVar), CellXVar, CellYVar)
	return cret
}

var xTreeViewIsRubberBandingActive func(uintptr) bool

// Returns whether a rubber banding operation is currently being done
// in @tree_view.
func (x *TreeView) IsRubberBandingActive() bool {

	cret := xTreeViewIsRubberBandingActive(x.GoPointer())
	return cret
}

var xTreeViewMapExpandedRows func(uintptr, uintptr, uintptr)

// Calls @func on all expanded rows.
func (x *TreeView) MapExpandedRows(FuncVar *TreeViewMappingFunc, DataVar uintptr) {

	xTreeViewMapExpandedRows(x.GoPointer(), glib.NewCallback(FuncVar), DataVar)

}

var xTreeViewMoveColumnAfter func(uintptr, uintptr, uintptr)

// Moves @column to be after to @base_column.  If @base_column is %NULL, then
// @column is placed in the first position.
func (x *TreeView) MoveColumnAfter(ColumnVar *TreeViewColumn, BaseColumnVar *TreeViewColumn) {

	xTreeViewMoveColumnAfter(x.GoPointer(), ColumnVar.GoPointer(), BaseColumnVar.GoPointer())

}

var xTreeViewRemoveColumn func(uintptr, uintptr) int

// Removes @column from @tree_view.
func (x *TreeView) RemoveColumn(ColumnVar *TreeViewColumn) int {

	cret := xTreeViewRemoveColumn(x.GoPointer(), ColumnVar.GoPointer())
	return cret
}

var xTreeViewRowActivated func(uintptr, *TreePath, uintptr)

// Activates the cell determined by @path and @column.
func (x *TreeView) RowActivated(PathVar *TreePath, ColumnVar *TreeViewColumn) {

	xTreeViewRowActivated(x.GoPointer(), PathVar, ColumnVar.GoPointer())

}

var xTreeViewRowExpanded func(uintptr, *TreePath) bool

// Returns %TRUE if the node pointed to by @path is expanded in @tree_view.
func (x *TreeView) RowExpanded(PathVar *TreePath) bool {

	cret := xTreeViewRowExpanded(x.GoPointer(), PathVar)
	return cret
}

var xTreeViewScrollToCell func(uintptr, *TreePath, uintptr, bool, float32, float32)

// Moves the alignments of @tree_view to the position specified by @column and
// @path.  If @column is %NULL, then no horizontal scrolling occurs.  Likewise,
// if @path is %NULL no vertical scrolling occurs.  At a minimum, one of @column
// or @path need to be non-%NULL.  @row_align determines where the row is
// placed, and @col_align determines where @column is placed.  Both are expected
// to be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means
// right/bottom alignment, 0.5 means center.
//
// If @use_align is %FALSE, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the cell onto the screen.
// This means that the cell will be scrolled to the edge closest to its current
// position.  If the cell is currently visible on the screen, nothing is done.
//
// This function only works if the model is set, and @path is a valid row on the
// model.  If the model changes before the @tree_view is realized, the centered
// path will be modified to reflect this change.
func (x *TreeView) ScrollToCell(PathVar *TreePath, ColumnVar *TreeViewColumn, UseAlignVar bool, RowAlignVar float32, ColAlignVar float32) {

	xTreeViewScrollToCell(x.GoPointer(), PathVar, ColumnVar.GoPointer(), UseAlignVar, RowAlignVar, ColAlignVar)

}

var xTreeViewScrollToPoint func(uintptr, int, int)

// Scrolls the tree view such that the top-left corner of the visible
// area is @tree_x, @tree_y, where @tree_x and @tree_y are specified
// in tree coordinates.  The @tree_view must be realized before
// this function is called.  If it isn't, you probably want to be
// using gtk_tree_view_scroll_to_cell().
//
// If either @tree_x or @tree_y are -1, then that direction isn’t scrolled.
func (x *TreeView) ScrollToPoint(TreeXVar int, TreeYVar int) {

	xTreeViewScrollToPoint(x.GoPointer(), TreeXVar, TreeYVar)

}

var xTreeViewSetActivateOnSingleClick func(uintptr, bool)

// Cause the `GtkTreeView`::row-activated signal to be emitted
// on a single click instead of a double click.
func (x *TreeView) SetActivateOnSingleClick(SingleVar bool) {

	xTreeViewSetActivateOnSingleClick(x.GoPointer(), SingleVar)

}

var xTreeViewSetColumnDragFunction func(uintptr, uintptr, uintptr, uintptr)

// Sets a user function for determining where a column may be dropped when
// dragged.  This function is called on every column pair in turn at the
// beginning of a column drag to determine where a drop can take place.  The
// arguments passed to @func are: the @tree_view, the `GtkTreeViewColumn` being
// dragged, the two `GtkTreeViewColumn`s determining the drop spot, and
// @user_data.  If either of the `GtkTreeViewColumn` arguments for the drop spot
// are %NULL, then they indicate an edge.  If @func is set to be %NULL, then
// @tree_view reverts to the default behavior of allowing all columns to be
// dropped everywhere.
func (x *TreeView) SetColumnDragFunction(FuncVar *TreeViewColumnDropFunc, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	xTreeViewSetColumnDragFunction(x.GoPointer(), glib.NewCallback(FuncVar), UserDataVar, glib.NewCallback(DestroyVar))

}

var xTreeViewSetCursor func(uintptr, *TreePath, uintptr, bool)

// Sets the current keyboard focus to be at @path, and selects it.  This is
// useful when you want to focus the user’s attention on a particular row.  If
// @focus_column is not %NULL, then focus is given to the column specified by
// it. Additionally, if @focus_column is specified, and @start_editing is
// %TRUE, then editing should be started in the specified cell.
// This function is often followed by @gtk_widget_grab_focus (@tree_view)
// in order to give keyboard focus to the widget.  Please note that editing
// can only happen when the widget is realized.
//
// If @path is invalid for @model, the current cursor (if any) will be unset
// and the function will return without failing.
func (x *TreeView) SetCursor(PathVar *TreePath, FocusColumnVar *TreeViewColumn, StartEditingVar bool) {

	xTreeViewSetCursor(x.GoPointer(), PathVar, FocusColumnVar.GoPointer(), StartEditingVar)

}

var xTreeViewSetCursorOnCell func(uintptr, *TreePath, uintptr, uintptr, bool)

// Sets the current keyboard focus to be at @path, and selects it.  This is
// useful when you want to focus the user’s attention on a particular row.  If
// @focus_column is not %NULL, then focus is given to the column specified by
// it. If @focus_column and @focus_cell are not %NULL, and @focus_column
// contains 2 or more editable or activatable cells, then focus is given to
// the cell specified by @focus_cell. Additionally, if @focus_column is
// specified, and @start_editing is %TRUE, then editing should be started in
// the specified cell.  This function is often followed by
// @gtk_widget_grab_focus (@tree_view) in order to give keyboard focus to the
// widget.  Please note that editing can only happen when the widget is
// realized.
//
// If @path is invalid for @model, the current cursor (if any) will be unset
// and the function will return without failing.
func (x *TreeView) SetCursorOnCell(PathVar *TreePath, FocusColumnVar *TreeViewColumn, FocusCellVar *CellRenderer, StartEditingVar bool) {

	xTreeViewSetCursorOnCell(x.GoPointer(), PathVar, FocusColumnVar.GoPointer(), FocusCellVar.GoPointer(), StartEditingVar)

}

var xTreeViewSetDragDestRow func(uintptr, *TreePath, TreeViewDropPosition)

// Sets the row that is highlighted for feedback.
// If @path is %NULL, an existing highlight is removed.
func (x *TreeView) SetDragDestRow(PathVar *TreePath, PosVar TreeViewDropPosition) {

	xTreeViewSetDragDestRow(x.GoPointer(), PathVar, PosVar)

}

var xTreeViewSetEnableSearch func(uintptr, bool)

// If @enable_search is set, then the user can type in text to search through
// the tree interactively (this is sometimes called "typeahead find").
//
// Note that even if this is %FALSE, the user can still initiate a search
// using the “start-interactive-search” key binding.
func (x *TreeView) SetEnableSearch(EnableSearchVar bool) {

	xTreeViewSetEnableSearch(x.GoPointer(), EnableSearchVar)

}

var xTreeViewSetEnableTreeLines func(uintptr, bool)

// Sets whether to draw lines interconnecting the expanders in @tree_view.
// This does not have any visible effects for lists.
func (x *TreeView) SetEnableTreeLines(EnabledVar bool) {

	xTreeViewSetEnableTreeLines(x.GoPointer(), EnabledVar)

}

var xTreeViewSetExpanderColumn func(uintptr, uintptr)

// Sets the column to draw the expander arrow at. It must be in @tree_view.
// If @column is %NULL, then the expander arrow is always at the first
// visible column.
//
// If you do not want expander arrow to appear in your tree, set the
// expander column to a hidden column.
func (x *TreeView) SetExpanderColumn(ColumnVar *TreeViewColumn) {

	xTreeViewSetExpanderColumn(x.GoPointer(), ColumnVar.GoPointer())

}

var xTreeViewSetFixedHeightMode func(uintptr, bool)

// Enables or disables the fixed height mode of @tree_view.
// Fixed height mode speeds up `GtkTreeView` by assuming that all
// rows have the same height.
// Only enable this option if all rows are the same height and all
// columns are of type %GTK_TREE_VIEW_COLUMN_FIXED.
func (x *TreeView) SetFixedHeightMode(EnableVar bool) {

	xTreeViewSetFixedHeightMode(x.GoPointer(), EnableVar)

}

var xTreeViewSetGridLines func(uintptr, TreeViewGridLines)

// Sets which grid lines to draw in @tree_view.
func (x *TreeView) SetGridLines(GridLinesVar TreeViewGridLines) {

	xTreeViewSetGridLines(x.GoPointer(), GridLinesVar)

}

var xTreeViewSetHeadersClickable func(uintptr, bool)

// Allow the column title buttons to be clicked.
func (x *TreeView) SetHeadersClickable(SettingVar bool) {

	xTreeViewSetHeadersClickable(x.GoPointer(), SettingVar)

}

var xTreeViewSetHeadersVisible func(uintptr, bool)

// Sets the visibility state of the headers.
func (x *TreeView) SetHeadersVisible(HeadersVisibleVar bool) {

	xTreeViewSetHeadersVisible(x.GoPointer(), HeadersVisibleVar)

}

var xTreeViewSetHoverExpand func(uintptr, bool)

// Enables or disables the hover expansion mode of @tree_view.
// Hover expansion makes rows expand or collapse if the pointer
// moves over them.
func (x *TreeView) SetHoverExpand(ExpandVar bool) {

	xTreeViewSetHoverExpand(x.GoPointer(), ExpandVar)

}

var xTreeViewSetHoverSelection func(uintptr, bool)

// Enables or disables the hover selection mode of @tree_view.
// Hover selection makes the selected row follow the pointer.
// Currently, this works only for the selection modes
// %GTK_SELECTION_SINGLE and %GTK_SELECTION_BROWSE.
func (x *TreeView) SetHoverSelection(HoverVar bool) {

	xTreeViewSetHoverSelection(x.GoPointer(), HoverVar)

}

var xTreeViewSetLevelIndentation func(uintptr, int)

// Sets the amount of extra indentation for child levels to use in @tree_view
// in addition to the default indentation.  The value should be specified in
// pixels, a value of 0 disables this feature and in this case only the default
// indentation will be used.
// This does not have any visible effects for lists.
func (x *TreeView) SetLevelIndentation(IndentationVar int) {

	xTreeViewSetLevelIndentation(x.GoPointer(), IndentationVar)

}

var xTreeViewSetModel func(uintptr, uintptr)

// Sets the model for a `GtkTreeView`.  If the @tree_view already has a model
// set, it will remove it before setting the new model.  If @model is %NULL,
// then it will unset the old model.
func (x *TreeView) SetModel(ModelVar TreeModel) {

	xTreeViewSetModel(x.GoPointer(), ModelVar.GoPointer())

}

var xTreeViewSetReorderable func(uintptr, bool)

// This function is a convenience function to allow you to reorder
// models that support the `GtkTreeDragSourceIface` and the
// `GtkTreeDragDestIface`.  Both `GtkTreeStore` and `GtkListStore` support
// these.  If @reorderable is %TRUE, then the user can reorder the
// model by dragging and dropping rows. The developer can listen to
// these changes by connecting to the model’s `GtkTreeModel::row-inserted`
// and `GtkTreeModel::row-deleted` signals. The reordering is implemented
// by setting up the tree view as a drag source and destination.
// Therefore, drag and drop can not be used in a reorderable view for any
// other purpose.
//
// This function does not give you any degree of control over the order -- any
// reordering is allowed.  If more control is needed, you should probably
// handle drag and drop manually.
func (x *TreeView) SetReorderable(ReorderableVar bool) {

	xTreeViewSetReorderable(x.GoPointer(), ReorderableVar)

}

var xTreeViewSetRowSeparatorFunc func(uintptr, uintptr, uintptr, uintptr)

// Sets the row separator function, which is used to determine
// whether a row should be drawn as a separator. If the row separator
// function is %NULL, no separators are drawn. This is the default value.
func (x *TreeView) SetRowSeparatorFunc(FuncVar *TreeViewRowSeparatorFunc, DataVar uintptr, DestroyVar *glib.DestroyNotify) {

	xTreeViewSetRowSeparatorFunc(x.GoPointer(), glib.NewCallback(FuncVar), DataVar, glib.NewCallback(DestroyVar))

}

var xTreeViewSetRubberBanding func(uintptr, bool)

// Enables or disables rubber banding in @tree_view.  If the selection mode
// is %GTK_SELECTION_MULTIPLE, rubber banding will allow the user to select
// multiple rows by dragging the mouse.
func (x *TreeView) SetRubberBanding(EnableVar bool) {

	xTreeViewSetRubberBanding(x.GoPointer(), EnableVar)

}

var xTreeViewSetSearchColumn func(uintptr, int)

// Sets @column as the column where the interactive search code should
// search in for the current model.
//
// If the search column is set, users can use the “start-interactive-search”
// key binding to bring up search popup. The enable-search property controls
// whether simply typing text will also start an interactive search.
//
// Note that @column refers to a column of the current model. The search
// column is reset to -1 when the model is changed.
func (x *TreeView) SetSearchColumn(ColumnVar int) {

	xTreeViewSetSearchColumn(x.GoPointer(), ColumnVar)

}

var xTreeViewSetSearchEntry func(uintptr, uintptr)

// Sets the entry which the interactive search code will use for this
// @tree_view.  This is useful when you want to provide a search entry
// in our interface at all time at a fixed position.  Passing %NULL for
// @entry will make the interactive search code use the built-in popup
// entry again.
func (x *TreeView) SetSearchEntry(EntryVar Editable) {

	xTreeViewSetSearchEntry(x.GoPointer(), EntryVar.GoPointer())

}

var xTreeViewSetSearchEqualFunc func(uintptr, uintptr, uintptr, uintptr)

// Sets the compare function for the interactive search capabilities; note
// that somewhat like strcmp() returning 0 for equality
// `GtkTreeView`SearchEqualFunc returns %FALSE on matches.
func (x *TreeView) SetSearchEqualFunc(SearchEqualFuncVar *TreeViewSearchEqualFunc, SearchUserDataVar uintptr, SearchDestroyVar *glib.DestroyNotify) {

	xTreeViewSetSearchEqualFunc(x.GoPointer(), glib.NewCallback(SearchEqualFuncVar), SearchUserDataVar, glib.NewCallback(SearchDestroyVar))

}

var xTreeViewSetShowExpanders func(uintptr, bool)

// Sets whether to draw and enable expanders and indent child rows in
// @tree_view.  When disabled there will be no expanders visible in trees
// and there will be no way to expand and collapse rows by default.  Also
// note that hiding the expanders will disable the default indentation.  You
// can set a custom indentation in this case using
// gtk_tree_view_set_level_indentation().
// This does not have any visible effects for lists.
func (x *TreeView) SetShowExpanders(EnabledVar bool) {

	xTreeViewSetShowExpanders(x.GoPointer(), EnabledVar)

}

var xTreeViewSetTooltipCell func(uintptr, uintptr, *TreePath, uintptr, uintptr)

// Sets the tip area of @tooltip to the area @path, @column and @cell have
// in common.  For example if @path is %NULL and @column is set, the tip
// area will be set to the full area covered by @column.  See also
// gtk_tooltip_set_tip_area().
//
// Note that if @path is not specified and @cell is set and part of a column
// containing the expander, the tooltip might not show and hide at the correct
// position.  In such cases @path must be set to the current node under the
// mouse cursor for this function to operate correctly.
//
// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
func (x *TreeView) SetTooltipCell(TooltipVar *Tooltip, PathVar *TreePath, ColumnVar *TreeViewColumn, CellVar *CellRenderer) {

	xTreeViewSetTooltipCell(x.GoPointer(), TooltipVar.GoPointer(), PathVar, ColumnVar.GoPointer(), CellVar.GoPointer())

}

var xTreeViewSetTooltipColumn func(uintptr, int)

// If you only plan to have simple (text-only) tooltips on full rows, you
// can use this function to have `GtkTreeView` handle these automatically
// for you. @column should be set to the column in @tree_view’s model
// containing the tooltip texts, or -1 to disable this feature.
//
// When enabled, `GtkWidget:has-tooltip` will be set to %TRUE and
// @tree_view will connect a `GtkWidget::query-tooltip` signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
// so &amp;, &lt;, etc have to be escaped in the text.
func (x *TreeView) SetTooltipColumn(ColumnVar int) {

	xTreeViewSetTooltipColumn(x.GoPointer(), ColumnVar)

}

var xTreeViewSetTooltipRow func(uintptr, uintptr, *TreePath)

// Sets the tip area of @tooltip to be the area covered by the row at @path.
// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
// See also gtk_tooltip_set_tip_area().
func (x *TreeView) SetTooltipRow(TooltipVar *Tooltip, PathVar *TreePath) {

	xTreeViewSetTooltipRow(x.GoPointer(), TooltipVar.GoPointer(), PathVar)

}

var xTreeViewUnsetRowsDragDest func(uintptr)

// Undoes the effect of
// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
// `GtkTreeView`:reorderable to %FALSE.
func (x *TreeView) UnsetRowsDragDest() {

	xTreeViewUnsetRowsDragDest(x.GoPointer())

}

var xTreeViewUnsetRowsDragSource func(uintptr)

// Undoes the effect of
// gtk_tree_view_enable_model_drag_source(). Calling this method sets
// `GtkTreeView`:reorderable to %FALSE.
func (x *TreeView) UnsetRowsDragSource() {

	xTreeViewUnsetRowsDragSource(x.GoPointer())

}

func (c *TreeView) GoPointer() uintptr {
	return c.Ptr
}

func (c *TreeView) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// The number of columns of the treeview has changed.
func (x *TreeView) ConnectColumnsChanged(cb *func(TreeView)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "columns-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "columns-changed", cbRefPtr)
}

// The position of the cursor (focused cell) has changed.
func (x *TreeView) ConnectCursorChanged(cb *func(TreeView)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "cursor-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "cursor-changed", cbRefPtr)
}

func (x *TreeView) ConnectExpandCollapseCursorRow(cb *func(TreeView, bool, bool, bool) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "expand-collapse-cursor-row", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ObjectVarp bool, P0Varp bool, P1Varp bool) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ObjectVarp, P0Varp, P1Varp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "expand-collapse-cursor-row", cbRefPtr)
}

// The `GtkTreeView`::move-cursor signal is a [keybinding
// signal][class@Gtk.SignalAction] which gets emitted when the user
// presses one of the cursor keys.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor
// programmatically. In contrast to gtk_tree_view_set_cursor() and
// gtk_tree_view_set_cursor_on_cell() when moving horizontally
// `GtkTreeView`::move-cursor does not reset the current selection.
func (x *TreeView) ConnectMoveCursor(cb *func(TreeView, MovementStep, int, bool, bool) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, StepVarp MovementStep, DirectionVarp int, ExtendVarp bool, ModifyVarp bool) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, StepVarp, DirectionVarp, ExtendVarp, ModifyVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
}

// The "row-activated" signal is emitted when the method
// [`method@Gtk.TreeView.row_activated`] is called.
//
// This signal is emitted when the user double-clicks a treeview row with the
// [property@Gtk.TreeView:activate-on-single-click] property set to %FALSE,
// or when the user single-clicks a row when that property set to %TRUE.
//
// This signal is also emitted when a non-editable row is selected and one
// of the keys: &lt;kbd&gt;Space&lt;/kbd&gt;, &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Space&lt;/kbd&gt;,
// &lt;kbd&gt;Return&lt;/kbd&gt; or &lt;kbd&gt;Enter&lt;/kbd&gt; is pressed.
//
// For selection handling refer to the
// [tree widget conceptual overview](section-tree-widget.html)
// as well as `GtkTreeSelection`.
func (x *TreeView) ConnectRowActivated(cb *func(TreeView, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "row-activated", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PathVarp uintptr, ColumnVarp uintptr) {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PathVarp, ColumnVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "row-activated", cbRefPtr)
}

// The given row has been collapsed (child nodes are hidden).
func (x *TreeView) ConnectRowCollapsed(cb *func(TreeView, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "row-collapsed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, IterVarp uintptr, PathVarp uintptr) {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, IterVarp, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "row-collapsed", cbRefPtr)
}

// The given row has been expanded (child nodes are shown).
func (x *TreeView) ConnectRowExpanded(cb *func(TreeView, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "row-expanded", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, IterVarp uintptr, PathVarp uintptr) {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, IterVarp, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "row-expanded", cbRefPtr)
}

func (x *TreeView) ConnectSelectAll(cb *func(TreeView) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "select-all", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "select-all", cbRefPtr)
}

func (x *TreeView) ConnectSelectCursorParent(cb *func(TreeView) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "select-cursor-parent", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "select-cursor-parent", cbRefPtr)
}

func (x *TreeView) ConnectSelectCursorRow(cb *func(TreeView, bool) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "select-cursor-row", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ObjectVarp bool) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ObjectVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "select-cursor-row", cbRefPtr)
}

func (x *TreeView) ConnectStartInteractiveSearch(cb *func(TreeView) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "start-interactive-search", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "start-interactive-search", cbRefPtr)
}

// The given row is about to be collapsed (hide its children nodes). Use this
// signal if you need to control the collapsibility of individual rows.
func (x *TreeView) ConnectTestCollapseRow(cb *func(TreeView, uintptr, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "test-collapse-row", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, IterVarp uintptr, PathVarp uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, IterVarp, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "test-collapse-row", cbRefPtr)
}

// The given row is about to be expanded (show its children nodes). Use this
// signal if you need to control the expandability of individual rows.
func (x *TreeView) ConnectTestExpandRow(cb *func(TreeView, uintptr, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "test-expand-row", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, IterVarp uintptr, PathVarp uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, IterVarp, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "test-expand-row", cbRefPtr)
}

func (x *TreeView) ConnectToggleCursorRow(cb *func(TreeView) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "toggle-cursor-row", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "toggle-cursor-row", cbRefPtr)
}

func (x *TreeView) ConnectUnselectAll(cb *func(TreeView) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "unselect-all", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := TreeView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "unselect-all", cbRefPtr)
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *TreeView) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *TreeView) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *TreeView) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *TreeView) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *TreeView) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TreeView) UpdatePropertyValue(NPropertiesVar int, PropertiesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *TreeView) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TreeView) UpdateRelationValue(NRelationsVar int, RelationsVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *TreeView) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *TreeView) UpdateStateValue(NStatesVar int, StatesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *TreeView) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Returns the size of a non-scrolling border around the
// outside of the scrollable.
//
// An example for this would be treeview headers. GTK can use
// this information to display overlaid graphics, like the
// overshoot indication, at the right position.
func (x *TreeView) GetBorder(BorderVar *Border) bool {

	cret := XGtkScrollableGetBorder(x.GoPointer(), BorderVar)
	return cret
}

// Retrieves the `GtkAdjustment` used for horizontal scrolling.
func (x *TreeView) GetHadjustment() *Adjustment {
	var cls *Adjustment

	cret := XGtkScrollableGetHadjustment(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Adjustment{}
	cls.Ptr = cret
	return cls
}

// Gets the horizontal `GtkScrollablePolicy`.
func (x *TreeView) GetHscrollPolicy() ScrollablePolicy {

	cret := XGtkScrollableGetHscrollPolicy(x.GoPointer())
	return cret
}

// Retrieves the `GtkAdjustment` used for vertical scrolling.
func (x *TreeView) GetVadjustment() *Adjustment {
	var cls *Adjustment

	cret := XGtkScrollableGetVadjustment(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Adjustment{}
	cls.Ptr = cret
	return cls
}

// Gets the vertical `GtkScrollablePolicy`.
func (x *TreeView) GetVscrollPolicy() ScrollablePolicy {

	cret := XGtkScrollableGetVscrollPolicy(x.GoPointer())
	return cret
}

// Sets the horizontal adjustment of the `GtkScrollable`.
func (x *TreeView) SetHadjustment(HadjustmentVar *Adjustment) {

	XGtkScrollableSetHadjustment(x.GoPointer(), HadjustmentVar.GoPointer())

}

// Sets the `GtkScrollablePolicy`.
//
// The policy determines whether horizontal scrolling should start
// below the minimum width or below the natural width.
func (x *TreeView) SetHscrollPolicy(PolicyVar ScrollablePolicy) {

	XGtkScrollableSetHscrollPolicy(x.GoPointer(), PolicyVar)

}

// Sets the vertical adjustment of the `GtkScrollable`.
func (x *TreeView) SetVadjustment(VadjustmentVar *Adjustment) {

	XGtkScrollableSetVadjustment(x.GoPointer(), VadjustmentVar.GoPointer())

}

// Sets the `GtkScrollablePolicy`.
//
// The policy determines whether vertical scrolling should start
// below the minimum height or below the natural height.
func (x *TreeView) SetVscrollPolicy(PolicyVar ScrollablePolicy) {

	XGtkScrollableSetVscrollPolicy(x.GoPointer(), PolicyVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewTreeView, lib, "gtk_tree_view_new")
	core.PuregoSafeRegister(&xNewTreeViewWithModel, lib, "gtk_tree_view_new_with_model")

	core.PuregoSafeRegister(&xTreeViewAppendColumn, lib, "gtk_tree_view_append_column")
	core.PuregoSafeRegister(&xTreeViewCollapseAll, lib, "gtk_tree_view_collapse_all")
	core.PuregoSafeRegister(&xTreeViewCollapseRow, lib, "gtk_tree_view_collapse_row")
	core.PuregoSafeRegister(&xTreeViewColumnsAutosize, lib, "gtk_tree_view_columns_autosize")
	core.PuregoSafeRegister(&xTreeViewConvertBinWindowToTreeCoords, lib, "gtk_tree_view_convert_bin_window_to_tree_coords")
	core.PuregoSafeRegister(&xTreeViewConvertBinWindowToWidgetCoords, lib, "gtk_tree_view_convert_bin_window_to_widget_coords")
	core.PuregoSafeRegister(&xTreeViewConvertTreeToBinWindowCoords, lib, "gtk_tree_view_convert_tree_to_bin_window_coords")
	core.PuregoSafeRegister(&xTreeViewConvertTreeToWidgetCoords, lib, "gtk_tree_view_convert_tree_to_widget_coords")
	core.PuregoSafeRegister(&xTreeViewConvertWidgetToBinWindowCoords, lib, "gtk_tree_view_convert_widget_to_bin_window_coords")
	core.PuregoSafeRegister(&xTreeViewConvertWidgetToTreeCoords, lib, "gtk_tree_view_convert_widget_to_tree_coords")
	core.PuregoSafeRegister(&xTreeViewCreateRowDragIcon, lib, "gtk_tree_view_create_row_drag_icon")
	core.PuregoSafeRegister(&xTreeViewEnableModelDragDest, lib, "gtk_tree_view_enable_model_drag_dest")
	core.PuregoSafeRegister(&xTreeViewEnableModelDragSource, lib, "gtk_tree_view_enable_model_drag_source")
	core.PuregoSafeRegister(&xTreeViewExpandAll, lib, "gtk_tree_view_expand_all")
	core.PuregoSafeRegister(&xTreeViewExpandRow, lib, "gtk_tree_view_expand_row")
	core.PuregoSafeRegister(&xTreeViewExpandToPath, lib, "gtk_tree_view_expand_to_path")
	core.PuregoSafeRegister(&xTreeViewGetActivateOnSingleClick, lib, "gtk_tree_view_get_activate_on_single_click")
	core.PuregoSafeRegister(&xTreeViewGetBackgroundArea, lib, "gtk_tree_view_get_background_area")
	core.PuregoSafeRegister(&xTreeViewGetCellArea, lib, "gtk_tree_view_get_cell_area")
	core.PuregoSafeRegister(&xTreeViewGetColumn, lib, "gtk_tree_view_get_column")
	core.PuregoSafeRegister(&xTreeViewGetColumns, lib, "gtk_tree_view_get_columns")
	core.PuregoSafeRegister(&xTreeViewGetCursor, lib, "gtk_tree_view_get_cursor")
	core.PuregoSafeRegister(&xTreeViewGetDestRowAtPos, lib, "gtk_tree_view_get_dest_row_at_pos")
	core.PuregoSafeRegister(&xTreeViewGetDragDestRow, lib, "gtk_tree_view_get_drag_dest_row")
	core.PuregoSafeRegister(&xTreeViewGetEnableSearch, lib, "gtk_tree_view_get_enable_search")
	core.PuregoSafeRegister(&xTreeViewGetEnableTreeLines, lib, "gtk_tree_view_get_enable_tree_lines")
	core.PuregoSafeRegister(&xTreeViewGetExpanderColumn, lib, "gtk_tree_view_get_expander_column")
	core.PuregoSafeRegister(&xTreeViewGetFixedHeightMode, lib, "gtk_tree_view_get_fixed_height_mode")
	core.PuregoSafeRegister(&xTreeViewGetGridLines, lib, "gtk_tree_view_get_grid_lines")
	core.PuregoSafeRegister(&xTreeViewGetHeadersClickable, lib, "gtk_tree_view_get_headers_clickable")
	core.PuregoSafeRegister(&xTreeViewGetHeadersVisible, lib, "gtk_tree_view_get_headers_visible")
	core.PuregoSafeRegister(&xTreeViewGetHoverExpand, lib, "gtk_tree_view_get_hover_expand")
	core.PuregoSafeRegister(&xTreeViewGetHoverSelection, lib, "gtk_tree_view_get_hover_selection")
	core.PuregoSafeRegister(&xTreeViewGetLevelIndentation, lib, "gtk_tree_view_get_level_indentation")
	core.PuregoSafeRegister(&xTreeViewGetModel, lib, "gtk_tree_view_get_model")
	core.PuregoSafeRegister(&xTreeViewGetNColumns, lib, "gtk_tree_view_get_n_columns")
	core.PuregoSafeRegister(&xTreeViewGetPathAtPos, lib, "gtk_tree_view_get_path_at_pos")
	core.PuregoSafeRegister(&xTreeViewGetReorderable, lib, "gtk_tree_view_get_reorderable")
	core.PuregoSafeRegister(&xTreeViewGetRowSeparatorFunc, lib, "gtk_tree_view_get_row_separator_func")
	core.PuregoSafeRegister(&xTreeViewGetRubberBanding, lib, "gtk_tree_view_get_rubber_banding")
	core.PuregoSafeRegister(&xTreeViewGetSearchColumn, lib, "gtk_tree_view_get_search_column")
	core.PuregoSafeRegister(&xTreeViewGetSearchEntry, lib, "gtk_tree_view_get_search_entry")
	core.PuregoSafeRegister(&xTreeViewGetSearchEqualFunc, lib, "gtk_tree_view_get_search_equal_func")
	core.PuregoSafeRegister(&xTreeViewGetSelection, lib, "gtk_tree_view_get_selection")
	core.PuregoSafeRegister(&xTreeViewGetShowExpanders, lib, "gtk_tree_view_get_show_expanders")
	core.PuregoSafeRegister(&xTreeViewGetTooltipColumn, lib, "gtk_tree_view_get_tooltip_column")
	core.PuregoSafeRegister(&xTreeViewGetTooltipContext, lib, "gtk_tree_view_get_tooltip_context")
	core.PuregoSafeRegister(&xTreeViewGetVisibleRange, lib, "gtk_tree_view_get_visible_range")
	core.PuregoSafeRegister(&xTreeViewGetVisibleRect, lib, "gtk_tree_view_get_visible_rect")
	core.PuregoSafeRegister(&xTreeViewInsertColumn, lib, "gtk_tree_view_insert_column")
	core.PuregoSafeRegister(&xTreeViewInsertColumnWithAttributes, lib, "gtk_tree_view_insert_column_with_attributes")
	core.PuregoSafeRegister(&xTreeViewInsertColumnWithDataFunc, lib, "gtk_tree_view_insert_column_with_data_func")
	core.PuregoSafeRegister(&xTreeViewIsBlankAtPos, lib, "gtk_tree_view_is_blank_at_pos")
	core.PuregoSafeRegister(&xTreeViewIsRubberBandingActive, lib, "gtk_tree_view_is_rubber_banding_active")
	core.PuregoSafeRegister(&xTreeViewMapExpandedRows, lib, "gtk_tree_view_map_expanded_rows")
	core.PuregoSafeRegister(&xTreeViewMoveColumnAfter, lib, "gtk_tree_view_move_column_after")
	core.PuregoSafeRegister(&xTreeViewRemoveColumn, lib, "gtk_tree_view_remove_column")
	core.PuregoSafeRegister(&xTreeViewRowActivated, lib, "gtk_tree_view_row_activated")
	core.PuregoSafeRegister(&xTreeViewRowExpanded, lib, "gtk_tree_view_row_expanded")
	core.PuregoSafeRegister(&xTreeViewScrollToCell, lib, "gtk_tree_view_scroll_to_cell")
	core.PuregoSafeRegister(&xTreeViewScrollToPoint, lib, "gtk_tree_view_scroll_to_point")
	core.PuregoSafeRegister(&xTreeViewSetActivateOnSingleClick, lib, "gtk_tree_view_set_activate_on_single_click")
	core.PuregoSafeRegister(&xTreeViewSetColumnDragFunction, lib, "gtk_tree_view_set_column_drag_function")
	core.PuregoSafeRegister(&xTreeViewSetCursor, lib, "gtk_tree_view_set_cursor")
	core.PuregoSafeRegister(&xTreeViewSetCursorOnCell, lib, "gtk_tree_view_set_cursor_on_cell")
	core.PuregoSafeRegister(&xTreeViewSetDragDestRow, lib, "gtk_tree_view_set_drag_dest_row")
	core.PuregoSafeRegister(&xTreeViewSetEnableSearch, lib, "gtk_tree_view_set_enable_search")
	core.PuregoSafeRegister(&xTreeViewSetEnableTreeLines, lib, "gtk_tree_view_set_enable_tree_lines")
	core.PuregoSafeRegister(&xTreeViewSetExpanderColumn, lib, "gtk_tree_view_set_expander_column")
	core.PuregoSafeRegister(&xTreeViewSetFixedHeightMode, lib, "gtk_tree_view_set_fixed_height_mode")
	core.PuregoSafeRegister(&xTreeViewSetGridLines, lib, "gtk_tree_view_set_grid_lines")
	core.PuregoSafeRegister(&xTreeViewSetHeadersClickable, lib, "gtk_tree_view_set_headers_clickable")
	core.PuregoSafeRegister(&xTreeViewSetHeadersVisible, lib, "gtk_tree_view_set_headers_visible")
	core.PuregoSafeRegister(&xTreeViewSetHoverExpand, lib, "gtk_tree_view_set_hover_expand")
	core.PuregoSafeRegister(&xTreeViewSetHoverSelection, lib, "gtk_tree_view_set_hover_selection")
	core.PuregoSafeRegister(&xTreeViewSetLevelIndentation, lib, "gtk_tree_view_set_level_indentation")
	core.PuregoSafeRegister(&xTreeViewSetModel, lib, "gtk_tree_view_set_model")
	core.PuregoSafeRegister(&xTreeViewSetReorderable, lib, "gtk_tree_view_set_reorderable")
	core.PuregoSafeRegister(&xTreeViewSetRowSeparatorFunc, lib, "gtk_tree_view_set_row_separator_func")
	core.PuregoSafeRegister(&xTreeViewSetRubberBanding, lib, "gtk_tree_view_set_rubber_banding")
	core.PuregoSafeRegister(&xTreeViewSetSearchColumn, lib, "gtk_tree_view_set_search_column")
	core.PuregoSafeRegister(&xTreeViewSetSearchEntry, lib, "gtk_tree_view_set_search_entry")
	core.PuregoSafeRegister(&xTreeViewSetSearchEqualFunc, lib, "gtk_tree_view_set_search_equal_func")
	core.PuregoSafeRegister(&xTreeViewSetShowExpanders, lib, "gtk_tree_view_set_show_expanders")
	core.PuregoSafeRegister(&xTreeViewSetTooltipCell, lib, "gtk_tree_view_set_tooltip_cell")
	core.PuregoSafeRegister(&xTreeViewSetTooltipColumn, lib, "gtk_tree_view_set_tooltip_column")
	core.PuregoSafeRegister(&xTreeViewSetTooltipRow, lib, "gtk_tree_view_set_tooltip_row")
	core.PuregoSafeRegister(&xTreeViewUnsetRowsDragDest, lib, "gtk_tree_view_unset_rows_drag_dest")
	core.PuregoSafeRegister(&xTreeViewUnsetRowsDragSource, lib, "gtk_tree_view_unset_rows_drag_source")

}
