// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// The class structure for `GtkTextBuffer`.
type TextBufferClass struct {
	ParentClass uintptr
}

func (x *TextBufferClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type TextBufferPrivate struct {
}

func (x *TextBufferPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Stores text and attributes for display in a `GtkTextView`.
//
// You may wish to begin by reading the
// [text widget conceptual overview](section-text-widget.html),
// which gives an overview of all the objects and data types
// related to the text widget and how they work together.
//
// GtkTextBuffer can support undoing changes to the buffer
// content, see [method@Gtk.TextBuffer.set_enable_undo].
type TextBuffer struct {
	gobject.Object
}

func TextBufferNewFromInternalPtr(ptr uintptr) *TextBuffer {
	cls := &TextBuffer{}
	cls.Ptr = ptr
	return cls
}

var xNewTextBuffer func(uintptr) uintptr

// Creates a new text buffer.
func NewTextBuffer(TableVar *TextTagTable) *TextBuffer {
	var cls *TextBuffer

	cret := xNewTextBuffer(TableVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &TextBuffer{}
	cls.Ptr = cret
	return cls
}

var xTextBufferAddMark func(uintptr, uintptr, *TextIter)

// Adds the mark at position @where.
//
// The mark must not be added to another buffer, and if its name
// is not %NULL then there must not be another mark in the buffer
// with the same name.
//
// Emits the [signal@Gtk.TextBuffer::mark-set] signal as notification
// of the mark's initial placement.
func (x *TextBuffer) AddMark(MarkVar *TextMark, WhereVar *TextIter) {

	xTextBufferAddMark(x.GoPointer(), MarkVar.GoPointer(), WhereVar)

}

var xTextBufferAddSelectionClipboard func(uintptr, uintptr)

// Adds @clipboard to the list of clipboards in which the selection
// contents of @buffer are available.
//
// In most cases, @clipboard will be the `GdkClipboard` returned by
// [method@Gtk.Widget.get_primary_clipboard] for a view of @buffer.
func (x *TextBuffer) AddSelectionClipboard(ClipboardVar *gdk.Clipboard) {

	xTextBufferAddSelectionClipboard(x.GoPointer(), ClipboardVar.GoPointer())

}

var xTextBufferApplyTag func(uintptr, uintptr, *TextIter, *TextIter)

// Emits the “apply-tag” signal on @buffer.
//
// The default handler for the signal applies
// @tag to the given range. @start and @end do
// not have to be in order.
func (x *TextBuffer) ApplyTag(TagVar *TextTag, StartVar *TextIter, EndVar *TextIter) {

	xTextBufferApplyTag(x.GoPointer(), TagVar.GoPointer(), StartVar, EndVar)

}

var xTextBufferApplyTagByName func(uintptr, string, *TextIter, *TextIter)

// Emits the “apply-tag” signal on @buffer.
//
// Calls [method@Gtk.TextTagTable.lookup] on the buffer’s
// tag table to get a `GtkTextTag`, then calls
// [method@Gtk.TextBuffer.apply_tag].
func (x *TextBuffer) ApplyTagByName(NameVar string, StartVar *TextIter, EndVar *TextIter) {

	xTextBufferApplyTagByName(x.GoPointer(), NameVar, StartVar, EndVar)

}

var xTextBufferBackspace func(uintptr, *TextIter, bool, bool) bool

// Performs the appropriate action as if the user hit the delete
// key with the cursor at the position specified by @iter.
//
// In the normal case a single character will be deleted, but when
// combining accents are involved, more than one character can
// be deleted, and when precomposed character and accent combinations
// are involved, less than one character will be deleted.
//
// Because the buffer is modified, all outstanding iterators become
// invalid after calling this function; however, the @iter will be
// re-initialized to point to the location where text was deleted.
func (x *TextBuffer) Backspace(IterVar *TextIter, InteractiveVar bool, DefaultEditableVar bool) bool {

	cret := xTextBufferBackspace(x.GoPointer(), IterVar, InteractiveVar, DefaultEditableVar)
	return cret
}

var xTextBufferBeginIrreversibleAction func(uintptr)

// Denotes the beginning of an action that may not be undone.
//
// This will cause any previous operations in the undo/redo queue
// to be cleared.
//
// This should be paired with a call to
// [method@Gtk.TextBuffer.end_irreversible_action] after the irreversible
// action has completed.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action()
// and gtk_text_buffer_end_irreversible_action() pairs.
func (x *TextBuffer) BeginIrreversibleAction() {

	xTextBufferBeginIrreversibleAction(x.GoPointer())

}

var xTextBufferBeginUserAction func(uintptr)

// Called to indicate that the buffer operations between here and a
// call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation.
//
// The operations between gtk_text_buffer_begin_user_action() and
// gtk_text_buffer_end_user_action() can then be grouped when creating
// an undo stack. `GtkTextBuffer` maintains a count of calls to
// gtk_text_buffer_begin_user_action() that have not been closed with
// a call to gtk_text_buffer_end_user_action(), and emits the
// “begin-user-action” and “end-user-action” signals only for the
// outermost pair of calls. This allows you to build user actions
// from other user actions.
//
// The “interactive” buffer mutation functions, such as
// [method@Gtk.TextBuffer.insert_interactive], automatically call
// begin/end user action around the buffer operations they perform,
// so there's no need to add extra calls if you user action consists
// solely of a single call to one of those functions.
func (x *TextBuffer) BeginUserAction() {

	xTextBufferBeginUserAction(x.GoPointer())

}

var xTextBufferCopyClipboard func(uintptr, uintptr)

// Copies the currently-selected text to a clipboard.
func (x *TextBuffer) CopyClipboard(ClipboardVar *gdk.Clipboard) {

	xTextBufferCopyClipboard(x.GoPointer(), ClipboardVar.GoPointer())

}

var xTextBufferCreateChildAnchor func(uintptr, *TextIter) uintptr

// Creates and inserts a child anchor.
//
// This is a convenience function which simply creates a child anchor
// with [ctor@Gtk.TextChildAnchor.new] and inserts it into the buffer
// with [method@Gtk.TextBuffer.insert_child_anchor].
//
// The new anchor is owned by the buffer; no reference count is
// returned to the caller of this function.
func (x *TextBuffer) CreateChildAnchor(IterVar *TextIter) *TextChildAnchor {
	var cls *TextChildAnchor

	cret := xTextBufferCreateChildAnchor(x.GoPointer(), IterVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextChildAnchor{}
	cls.Ptr = cret
	return cls
}

var xTextBufferCreateMark func(uintptr, string, *TextIter, bool) uintptr

// Creates a mark at position @where.
//
// If @mark_name is %NULL, the mark is anonymous; otherwise, the mark
// can be retrieved by name using [method@Gtk.TextBuffer.get_mark].
// If a mark has left gravity, and text is inserted at the mark’s
// current location, the mark will be moved to the left of the
// newly-inserted text. If the mark has right gravity
// (@left_gravity = %FALSE), the mark will end up on the right of
// newly-inserted text. The standard left-to-right cursor is a mark
// with right gravity (when you type, the cursor stays on the right
// side of the text you’re typing).
//
// The caller of this function does not own a
// reference to the returned `GtkTextMark`, so you can ignore the
// return value if you like. Marks are owned by the buffer and go
// away when the buffer does.
//
// Emits the [signal@Gtk.TextBuffer::mark-set] signal as notification
// of the mark's initial placement.
func (x *TextBuffer) CreateMark(MarkNameVar string, WhereVar *TextIter, LeftGravityVar bool) *TextMark {
	var cls *TextMark

	cret := xTextBufferCreateMark(x.GoPointer(), MarkNameVar, WhereVar, LeftGravityVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextMark{}
	cls.Ptr = cret
	return cls
}

var xTextBufferCreateTag func(uintptr, string, string, ...interface{}) uintptr

// Creates a tag and adds it to the tag table for @buffer.
//
// Equivalent to calling [ctor@Gtk.TextTag.new] and then adding the
// tag to the buffer’s tag table. The returned tag is owned by
// the buffer’s tag table, so the ref count will be equal to one.
//
// If @tag_name is %NULL, the tag is anonymous.
//
// If @tag_name is non-%NULL, a tag called @tag_name must not already
// exist in the tag table for this buffer.
//
// The @first_property_name argument and subsequent arguments are a list
// of properties to set on the tag, as with g_object_set().
func (x *TextBuffer) CreateTag(TagNameVar string, FirstPropertyNameVar string, varArgs ...interface{}) *TextTag {
	var cls *TextTag

	cret := xTextBufferCreateTag(x.GoPointer(), TagNameVar, FirstPropertyNameVar, varArgs...)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextTag{}
	cls.Ptr = cret
	return cls
}

var xTextBufferCutClipboard func(uintptr, uintptr, bool)

// Copies the currently-selected text to a clipboard,
// then deletes said text if it’s editable.
func (x *TextBuffer) CutClipboard(ClipboardVar *gdk.Clipboard, DefaultEditableVar bool) {

	xTextBufferCutClipboard(x.GoPointer(), ClipboardVar.GoPointer(), DefaultEditableVar)

}

var xTextBufferDelete func(uintptr, *TextIter, *TextIter)

// Deletes text between @start and @end.
//
// The order of @start and @end is not actually relevant;
// gtk_text_buffer_delete() will reorder them.
//
// This function actually emits the “delete-range” signal, and
// the default handler of that signal deletes the text. Because the
// buffer is modified, all outstanding iterators become invalid after
// calling this function; however, the @start and @end will be
// re-initialized to point to the location where text was deleted.
func (x *TextBuffer) Delete(StartVar *TextIter, EndVar *TextIter) {

	xTextBufferDelete(x.GoPointer(), StartVar, EndVar)

}

var xTextBufferDeleteInteractive func(uintptr, *TextIter, *TextIter, bool) bool

// Deletes all editable text in the given range.
//
// Calls [method@Gtk.TextBuffer.delete] for each editable
// sub-range of [@start,@end). @start and @end are revalidated
// to point to the location of the last deleted range, or left
// untouched if no text was deleted.
func (x *TextBuffer) DeleteInteractive(StartIterVar *TextIter, EndIterVar *TextIter, DefaultEditableVar bool) bool {

	cret := xTextBufferDeleteInteractive(x.GoPointer(), StartIterVar, EndIterVar, DefaultEditableVar)
	return cret
}

var xTextBufferDeleteMark func(uintptr, uintptr)

// Deletes @mark, so that it’s no longer located anywhere in the
// buffer.
//
// Removes the reference the buffer holds to the mark, so if
// you haven’t called g_object_ref() on the mark, it will be freed.
// Even if the mark isn’t freed, most operations on @mark become
// invalid, until it gets added to a buffer again with
// [method@Gtk.TextBuffer.add_mark]. Use [method@Gtk.TextMark.get_deleted]
// to find out if a mark has been removed from its buffer.
//
// The [signal@Gtk.TextBuffer::mark-deleted] signal will be emitted as
// notification after the mark is deleted.
func (x *TextBuffer) DeleteMark(MarkVar *TextMark) {

	xTextBufferDeleteMark(x.GoPointer(), MarkVar.GoPointer())

}

var xTextBufferDeleteMarkByName func(uintptr, string)

// Deletes the mark named @name; the mark must exist.
//
// See [method@Gtk.TextBuffer.delete_mark] for details.
func (x *TextBuffer) DeleteMarkByName(NameVar string) {

	xTextBufferDeleteMarkByName(x.GoPointer(), NameVar)

}

var xTextBufferDeleteSelection func(uintptr, bool, bool) bool

// Deletes the range between the “insert” and “selection_bound” marks,
// that is, the currently-selected text.
//
// If @interactive is %TRUE, the editability of the selection will be
// considered (users can’t delete uneditable text).
func (x *TextBuffer) DeleteSelection(InteractiveVar bool, DefaultEditableVar bool) bool {

	cret := xTextBufferDeleteSelection(x.GoPointer(), InteractiveVar, DefaultEditableVar)
	return cret
}

var xTextBufferEndIrreversibleAction func(uintptr)

// Denotes the end of an action that may not be undone.
//
// This will cause any previous operations in the undo/redo
// queue to be cleared.
//
// This should be called after completing modifications to the
// text buffer after [method@Gtk.TextBuffer.begin_irreversible_action]
// was called.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action()
// and gtk_text_buffer_end_irreversible_action() pairs.
func (x *TextBuffer) EndIrreversibleAction() {

	xTextBufferEndIrreversibleAction(x.GoPointer())

}

var xTextBufferEndUserAction func(uintptr)

// Ends a user-visible operation.
//
// Should be paired with a call to
// [method@Gtk.TextBuffer.begin_user_action].
// See that function for a full explanation.
func (x *TextBuffer) EndUserAction() {

	xTextBufferEndUserAction(x.GoPointer())

}

var xTextBufferGetBounds func(uintptr, *TextIter, *TextIter)

// Retrieves the first and last iterators in the buffer, i.e. the
// entire buffer lies within the range [@start,@end).
func (x *TextBuffer) GetBounds(StartVar *TextIter, EndVar *TextIter) {

	xTextBufferGetBounds(x.GoPointer(), StartVar, EndVar)

}

var xTextBufferGetCanRedo func(uintptr) bool

// Gets whether there is a redoable action in the history.
func (x *TextBuffer) GetCanRedo() bool {

	cret := xTextBufferGetCanRedo(x.GoPointer())
	return cret
}

var xTextBufferGetCanUndo func(uintptr) bool

// Gets whether there is an undoable action in the history.
func (x *TextBuffer) GetCanUndo() bool {

	cret := xTextBufferGetCanUndo(x.GoPointer())
	return cret
}

var xTextBufferGetCharCount func(uintptr) int

// Gets the number of characters in the buffer.
//
// Note that characters and bytes are not the same, you can’t e.g.
// expect the contents of the buffer in string form to be this
// many bytes long.
//
// The character count is cached, so this function is very fast.
func (x *TextBuffer) GetCharCount() int {

	cret := xTextBufferGetCharCount(x.GoPointer())
	return cret
}

var xTextBufferGetEnableUndo func(uintptr) bool

// Gets whether the buffer is saving modifications to the buffer
// to allow for undo and redo actions.
//
// See [method@Gtk.TextBuffer.begin_irreversible_action] and
// [method@Gtk.TextBuffer.end_irreversible_action] to create
// changes to the buffer that cannot be undone.
func (x *TextBuffer) GetEnableUndo() bool {

	cret := xTextBufferGetEnableUndo(x.GoPointer())
	return cret
}

var xTextBufferGetEndIter func(uintptr, *TextIter)

// Initializes @iter with the “end iterator,” one past the last valid
// character in the text buffer.
//
// If dereferenced with [method@Gtk.TextIter.get_char], the end
// iterator has a character value of 0.
// The entire buffer lies in the range from the first position in
// the buffer (call [method@Gtk.TextBuffer.get_start_iter] to get
// character position 0) to the end iterator.
func (x *TextBuffer) GetEndIter(IterVar *TextIter) {

	xTextBufferGetEndIter(x.GoPointer(), IterVar)

}

var xTextBufferGetHasSelection func(uintptr) bool

// Indicates whether the buffer has some text currently selected.
func (x *TextBuffer) GetHasSelection() bool {

	cret := xTextBufferGetHasSelection(x.GoPointer())
	return cret
}

var xTextBufferGetInsert func(uintptr) uintptr

// Returns the mark that represents the cursor (insertion point).
//
// Equivalent to calling [method@Gtk.TextBuffer.get_mark]
// to get the mark named “insert”, but very slightly more
// efficient, and involves less typing.
func (x *TextBuffer) GetInsert() *TextMark {
	var cls *TextMark

	cret := xTextBufferGetInsert(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextMark{}
	cls.Ptr = cret
	return cls
}

var xTextBufferGetIterAtChildAnchor func(uintptr, *TextIter, uintptr)

// Obtains the location of @anchor within @buffer.
func (x *TextBuffer) GetIterAtChildAnchor(IterVar *TextIter, AnchorVar *TextChildAnchor) {

	xTextBufferGetIterAtChildAnchor(x.GoPointer(), IterVar, AnchorVar.GoPointer())

}

var xTextBufferGetIterAtLine func(uintptr, *TextIter, int) bool

// Initializes @iter to the start of the given line.
//
// If @line_number is greater than or equal to the number of lines
// in the @buffer, the end iterator is returned.
func (x *TextBuffer) GetIterAtLine(IterVar *TextIter, LineNumberVar int) bool {

	cret := xTextBufferGetIterAtLine(x.GoPointer(), IterVar, LineNumberVar)
	return cret
}

var xTextBufferGetIterAtLineIndex func(uintptr, *TextIter, int, int) bool

// Obtains an iterator pointing to @byte_index within the given line.
//
// @byte_index must be the start of a UTF-8 character. Note bytes, not
// characters; UTF-8 may encode one character as multiple bytes.
//
// If @line_number is greater than or equal to the number of lines in the @buffer,
// the end iterator is returned. And if @byte_index is off the
// end of the line, the iterator at the end of the line is returned.
func (x *TextBuffer) GetIterAtLineIndex(IterVar *TextIter, LineNumberVar int, ByteIndexVar int) bool {

	cret := xTextBufferGetIterAtLineIndex(x.GoPointer(), IterVar, LineNumberVar, ByteIndexVar)
	return cret
}

var xTextBufferGetIterAtLineOffset func(uintptr, *TextIter, int, int) bool

// Obtains an iterator pointing to @char_offset within the given line.
//
// Note characters, not bytes; UTF-8 may encode one character as multiple
// bytes.
//
// If @line_number is greater than or equal to the number of lines in the @buffer,
// the end iterator is returned. And if @char_offset is off the
// end of the line, the iterator at the end of the line is returned.
func (x *TextBuffer) GetIterAtLineOffset(IterVar *TextIter, LineNumberVar int, CharOffsetVar int) bool {

	cret := xTextBufferGetIterAtLineOffset(x.GoPointer(), IterVar, LineNumberVar, CharOffsetVar)
	return cret
}

var xTextBufferGetIterAtMark func(uintptr, *TextIter, uintptr)

// Initializes @iter with the current position of @mark.
func (x *TextBuffer) GetIterAtMark(IterVar *TextIter, MarkVar *TextMark) {

	xTextBufferGetIterAtMark(x.GoPointer(), IterVar, MarkVar.GoPointer())

}

var xTextBufferGetIterAtOffset func(uintptr, *TextIter, int)

// Initializes @iter to a position @char_offset chars from the start
// of the entire buffer.
//
// If @char_offset is -1 or greater than the number
// of characters in the buffer, @iter is initialized to the end iterator,
// the iterator one past the last valid character in the buffer.
func (x *TextBuffer) GetIterAtOffset(IterVar *TextIter, CharOffsetVar int) {

	xTextBufferGetIterAtOffset(x.GoPointer(), IterVar, CharOffsetVar)

}

var xTextBufferGetLineCount func(uintptr) int

// Obtains the number of lines in the buffer.
//
// This value is cached, so the function is very fast.
func (x *TextBuffer) GetLineCount() int {

	cret := xTextBufferGetLineCount(x.GoPointer())
	return cret
}

var xTextBufferGetMark func(uintptr, string) uintptr

// Returns the mark named @name in buffer @buffer, or %NULL if no such
// mark exists in the buffer.
func (x *TextBuffer) GetMark(NameVar string) *TextMark {
	var cls *TextMark

	cret := xTextBufferGetMark(x.GoPointer(), NameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextMark{}
	cls.Ptr = cret
	return cls
}

var xTextBufferGetMaxUndoLevels func(uintptr) uint

// Gets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may
// have a memory usage impact as it requires storing an additional
// copy of the inserted or removed text within the text buffer.
func (x *TextBuffer) GetMaxUndoLevels() uint {

	cret := xTextBufferGetMaxUndoLevels(x.GoPointer())
	return cret
}

var xTextBufferGetModified func(uintptr) bool

// Indicates whether the buffer has been modified since the last call
// to [method@Gtk.TextBuffer.set_modified] set the modification flag to
// %FALSE.
//
// Used for example to enable a “save” function in a text editor.
func (x *TextBuffer) GetModified() bool {

	cret := xTextBufferGetModified(x.GoPointer())
	return cret
}

var xTextBufferGetSelectionBound func(uintptr) uintptr

// Returns the mark that represents the selection bound.
//
// Equivalent to calling [method@Gtk.TextBuffer.get_mark]
// to get the mark named “selection_bound”, but very slightly
// more efficient, and involves less typing.
//
// The currently-selected text in @buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and
// “insert” are in the same place, then there is no current selection.
// [method@Gtk.TextBuffer.get_selection_bounds] is another convenient
// function for handling the selection, if you just want to know whether
// there’s a selection and what its bounds are.
func (x *TextBuffer) GetSelectionBound() *TextMark {
	var cls *TextMark

	cret := xTextBufferGetSelectionBound(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextMark{}
	cls.Ptr = cret
	return cls
}

var xTextBufferGetSelectionBounds func(uintptr, *TextIter, *TextIter) bool

// Returns %TRUE if some text is selected; places the bounds
// of the selection in @start and @end.
//
// If the selection has length 0, then @start and @end are filled
// in with the same value. @start and @end will be in ascending order.
// If @start and @end are %NULL, then they are not filled in, but the
// return value still indicates whether text is selected.
func (x *TextBuffer) GetSelectionBounds(StartVar *TextIter, EndVar *TextIter) bool {

	cret := xTextBufferGetSelectionBounds(x.GoPointer(), StartVar, EndVar)
	return cret
}

var xTextBufferGetSelectionContent func(uintptr) uintptr

// Get a content provider for this buffer.
//
// It can be used to make the content of @buffer available
// in a `GdkClipboard`, see [method@Gdk.Clipboard.set_content].
func (x *TextBuffer) GetSelectionContent() *gdk.ContentProvider {
	var cls *gdk.ContentProvider

	cret := xTextBufferGetSelectionContent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gdk.ContentProvider{}
	cls.Ptr = cret
	return cls
}

var xTextBufferGetSlice func(uintptr, *TextIter, *TextIter, bool) string

// Returns the text in the range [@start,@end).
//
// Excludes undisplayed text (text marked with tags that set the
// invisibility attribute) if @include_hidden_chars is %FALSE.
// The returned string includes a 0xFFFC character whenever the
// buffer contains embedded images, so byte and character indexes
// into the returned string do correspond to byte and character
// indexes into the buffer. Contrast with [method@Gtk.TextBuffer.get_text].
// Note that 0xFFFC can occur in normal text as well, so it is not a
// reliable indicator that a paintable or widget is in the buffer.
func (x *TextBuffer) GetSlice(StartVar *TextIter, EndVar *TextIter, IncludeHiddenCharsVar bool) string {

	cret := xTextBufferGetSlice(x.GoPointer(), StartVar, EndVar, IncludeHiddenCharsVar)
	return cret
}

var xTextBufferGetStartIter func(uintptr, *TextIter)

// Initialized @iter with the first position in the text buffer.
//
// This is the same as using [method@Gtk.TextBuffer.get_iter_at_offset]
// to get the iter at character offset 0.
func (x *TextBuffer) GetStartIter(IterVar *TextIter) {

	xTextBufferGetStartIter(x.GoPointer(), IterVar)

}

var xTextBufferGetTagTable func(uintptr) uintptr

// Get the `GtkTextTagTable` associated with this buffer.
func (x *TextBuffer) GetTagTable() *TextTagTable {
	var cls *TextTagTable

	cret := xTextBufferGetTagTable(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextTagTable{}
	cls.Ptr = cret
	return cls
}

var xTextBufferGetText func(uintptr, *TextIter, *TextIter, bool) string

// Returns the text in the range [@start,@end).
//
// Excludes undisplayed text (text marked with tags that set the
// invisibility attribute) if @include_hidden_chars is %FALSE.
// Does not include characters representing embedded images, so
// byte and character indexes into the returned string do not
// correspond to byte and character indexes into the buffer.
// Contrast with [method@Gtk.TextBuffer.get_slice].
func (x *TextBuffer) GetText(StartVar *TextIter, EndVar *TextIter, IncludeHiddenCharsVar bool) string {

	cret := xTextBufferGetText(x.GoPointer(), StartVar, EndVar, IncludeHiddenCharsVar)
	return cret
}

var xTextBufferInsert func(uintptr, *TextIter, string, int)

// Inserts @len bytes of @text at position @iter.
//
// If @len is -1, @text must be nul-terminated and will be inserted in its
// entirety. Emits the “insert-text” signal; insertion actually occurs
// in the default handler for the signal. @iter is invalidated when
// insertion occurs (because the buffer contents change), but the
// default signal handler revalidates it to point to the end of the
// inserted text.
func (x *TextBuffer) Insert(IterVar *TextIter, TextVar string, LenVar int) {

	xTextBufferInsert(x.GoPointer(), IterVar, TextVar, LenVar)

}

var xTextBufferInsertAtCursor func(uintptr, string, int)

// Inserts @text in @buffer.
//
// Simply calls [method@Gtk.TextBuffer.insert],
// using the current cursor position as the insertion point.
func (x *TextBuffer) InsertAtCursor(TextVar string, LenVar int) {

	xTextBufferInsertAtCursor(x.GoPointer(), TextVar, LenVar)

}

var xTextBufferInsertChildAnchor func(uintptr, *TextIter, uintptr)

// Inserts a child widget anchor into the text buffer at @iter.
//
// The anchor will be counted as one character in character counts, and
// when obtaining the buffer contents as a string, will be represented
// by the Unicode “object replacement character” 0xFFFC. Note that the
// “slice” variants for obtaining portions of the buffer as a string
// include this character for child anchors, but the “text” variants do
// not. E.g. see [method@Gtk.TextBuffer.get_slice] and
// [method@Gtk.TextBuffer.get_text].
//
// Consider [method@Gtk.TextBuffer.create_child_anchor] as a more
// convenient alternative to this function. The buffer will add a
// reference to the anchor, so you can unref it after insertion.
func (x *TextBuffer) InsertChildAnchor(IterVar *TextIter, AnchorVar *TextChildAnchor) {

	xTextBufferInsertChildAnchor(x.GoPointer(), IterVar, AnchorVar.GoPointer())

}

var xTextBufferInsertInteractive func(uintptr, *TextIter, string, int, bool) bool

// Inserts @text in @buffer.
//
// Like [method@Gtk.TextBuffer.insert], but the insertion will not occur
// if @iter is at a non-editable location in the buffer. Usually you
// want to prevent insertions at ineditable locations if the insertion
// results from a user action (is interactive).
//
// @default_editable indicates the editability of text that doesn't
// have a tag affecting editability applied to it. Typically the
// result of [method@Gtk.TextView.get_editable] is appropriate here.
func (x *TextBuffer) InsertInteractive(IterVar *TextIter, TextVar string, LenVar int, DefaultEditableVar bool) bool {

	cret := xTextBufferInsertInteractive(x.GoPointer(), IterVar, TextVar, LenVar, DefaultEditableVar)
	return cret
}

var xTextBufferInsertInteractiveAtCursor func(uintptr, string, int, bool) bool

// Inserts @text in @buffer.
//
// Calls [method@Gtk.TextBuffer.insert_interactive]
// at the cursor position.
//
// @default_editable indicates the editability of text that doesn't
// have a tag affecting editability applied to it. Typically the
// result of [method@Gtk.TextView.get_editable] is appropriate here.
func (x *TextBuffer) InsertInteractiveAtCursor(TextVar string, LenVar int, DefaultEditableVar bool) bool {

	cret := xTextBufferInsertInteractiveAtCursor(x.GoPointer(), TextVar, LenVar, DefaultEditableVar)
	return cret
}

var xTextBufferInsertMarkup func(uintptr, *TextIter, string, int)

// Inserts the text in @markup at position @iter.
//
// @markup will be inserted in its entirety and must be nul-terminated
// and valid UTF-8. Emits the [signal@Gtk.TextBuffer::insert-text] signal,
// possibly multiple times; insertion actually occurs in the default handler
// for the signal. @iter will point to the end of the inserted text on return.
func (x *TextBuffer) InsertMarkup(IterVar *TextIter, MarkupVar string, LenVar int) {

	xTextBufferInsertMarkup(x.GoPointer(), IterVar, MarkupVar, LenVar)

}

var xTextBufferInsertPaintable func(uintptr, *TextIter, uintptr)

// Inserts an image into the text buffer at @iter.
//
// The image will be counted as one character in character counts,
// and when obtaining the buffer contents as a string, will be
// represented by the Unicode “object replacement character” 0xFFFC.
// Note that the “slice” variants for obtaining portions of the buffer
// as a string include this character for paintable, but the “text”
// variants do not. e.g. see [method@Gtk.TextBuffer.get_slice] and
// [method@Gtk.TextBuffer.get_text].
func (x *TextBuffer) InsertPaintable(IterVar *TextIter, PaintableVar gdk.Paintable) {

	xTextBufferInsertPaintable(x.GoPointer(), IterVar, PaintableVar.GoPointer())

}

var xTextBufferInsertRange func(uintptr, *TextIter, *TextIter, *TextIter)

// Copies text, tags, and paintables between @start and @end
// and inserts the copy at @iter.
//
// The order of @start and @end doesn’t matter.
//
// Used instead of simply getting/inserting text because it preserves
// images and tags. If @start and @end are in a different buffer from
// @buffer, the two buffers must share the same tag table.
//
// Implemented via emissions of the ::insert-text and ::apply-tag signals,
// so expect those.
func (x *TextBuffer) InsertRange(IterVar *TextIter, StartVar *TextIter, EndVar *TextIter) {

	xTextBufferInsertRange(x.GoPointer(), IterVar, StartVar, EndVar)

}

var xTextBufferInsertRangeInteractive func(uintptr, *TextIter, *TextIter, *TextIter, bool) bool

// Copies text, tags, and paintables between @start and @end
// and inserts the copy at @iter.
//
// Same as [method@Gtk.TextBuffer.insert_range], but does nothing
// if the insertion point isn’t editable. The @default_editable
// parameter indicates whether the text is editable at @iter if
// no tags enclosing @iter affect editability. Typically the result
// of [method@Gtk.TextView.get_editable] is appropriate here.
func (x *TextBuffer) InsertRangeInteractive(IterVar *TextIter, StartVar *TextIter, EndVar *TextIter, DefaultEditableVar bool) bool {

	cret := xTextBufferInsertRangeInteractive(x.GoPointer(), IterVar, StartVar, EndVar, DefaultEditableVar)
	return cret
}

var xTextBufferInsertWithTags func(uintptr, *TextIter, string, int, uintptr, ...interface{})

// Inserts @text into @buffer at @iter, applying the list of tags to
// the newly-inserted text.
//
// The last tag specified must be %NULL to terminate the list.
// Equivalent to calling [method@Gtk.TextBuffer.insert],
// then [method@Gtk.TextBuffer.apply_tag] on the inserted text;
// this is just a convenience function.
func (x *TextBuffer) InsertWithTags(IterVar *TextIter, TextVar string, LenVar int, FirstTagVar *TextTag, varArgs ...interface{}) {

	xTextBufferInsertWithTags(x.GoPointer(), IterVar, TextVar, LenVar, FirstTagVar.GoPointer(), varArgs...)

}

var xTextBufferInsertWithTagsByName func(uintptr, *TextIter, string, int, string, ...interface{})

// Inserts @text into @buffer at @iter, applying the list of tags to
// the newly-inserted text.
//
// Same as [method@Gtk.TextBuffer.insert_with_tags], but allows you
// to pass in tag names instead of tag objects.
func (x *TextBuffer) InsertWithTagsByName(IterVar *TextIter, TextVar string, LenVar int, FirstTagNameVar string, varArgs ...interface{}) {

	xTextBufferInsertWithTagsByName(x.GoPointer(), IterVar, TextVar, LenVar, FirstTagNameVar, varArgs...)

}

var xTextBufferMoveMark func(uintptr, uintptr, *TextIter)

// Moves @mark to the new location @where.
//
// Emits the [signal@Gtk.TextBuffer::mark-set] signal
// as notification of the move.
func (x *TextBuffer) MoveMark(MarkVar *TextMark, WhereVar *TextIter) {

	xTextBufferMoveMark(x.GoPointer(), MarkVar.GoPointer(), WhereVar)

}

var xTextBufferMoveMarkByName func(uintptr, string, *TextIter)

// Moves the mark named @name (which must exist) to location @where.
//
// See [method@Gtk.TextBuffer.move_mark] for details.
func (x *TextBuffer) MoveMarkByName(NameVar string, WhereVar *TextIter) {

	xTextBufferMoveMarkByName(x.GoPointer(), NameVar, WhereVar)

}

var xTextBufferPasteClipboard func(uintptr, uintptr, *TextIter, bool)

// Pastes the contents of a clipboard.
//
// If @override_location is %NULL, the pasted text will be inserted
// at the cursor position, or the buffer selection will be replaced
// if the selection is non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data
// and return, and at some point later after the main loop runs, the paste
// data will be inserted.
func (x *TextBuffer) PasteClipboard(ClipboardVar *gdk.Clipboard, OverrideLocationVar *TextIter, DefaultEditableVar bool) {

	xTextBufferPasteClipboard(x.GoPointer(), ClipboardVar.GoPointer(), OverrideLocationVar, DefaultEditableVar)

}

var xTextBufferPlaceCursor func(uintptr, *TextIter)

// This function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them to the same place in two steps with
// [method@Gtk.TextBuffer.move_mark], you will temporarily select a
// region in between their old and new locations, which can be pretty
// inefficient since the temporarily-selected region will force stuff
// to be recalculated. This function moves them as a unit, which can
// be optimized.
func (x *TextBuffer) PlaceCursor(WhereVar *TextIter) {

	xTextBufferPlaceCursor(x.GoPointer(), WhereVar)

}

var xTextBufferRedo func(uintptr)

// Redoes the next redoable action on the buffer, if there is one.
func (x *TextBuffer) Redo() {

	xTextBufferRedo(x.GoPointer())

}

var xTextBufferRemoveAllTags func(uintptr, *TextIter, *TextIter)

// Removes all tags in the range between @start and @end.
//
// Be careful with this function; it could remove tags added in code
// unrelated to the code you’re currently writing. That is, using this
// function is probably a bad idea if you have two or more unrelated
// code sections that add tags.
func (x *TextBuffer) RemoveAllTags(StartVar *TextIter, EndVar *TextIter) {

	xTextBufferRemoveAllTags(x.GoPointer(), StartVar, EndVar)

}

var xTextBufferRemoveSelectionClipboard func(uintptr, uintptr)

// Removes a `GdkClipboard` added with
// gtk_text_buffer_add_selection_clipboard().
func (x *TextBuffer) RemoveSelectionClipboard(ClipboardVar *gdk.Clipboard) {

	xTextBufferRemoveSelectionClipboard(x.GoPointer(), ClipboardVar.GoPointer())

}

var xTextBufferRemoveTag func(uintptr, uintptr, *TextIter, *TextIter)

// Emits the “remove-tag” signal.
//
// The default handler for the signal removes all occurrences
// of @tag from the given range. @start and @end don’t have
// to be in order.
func (x *TextBuffer) RemoveTag(TagVar *TextTag, StartVar *TextIter, EndVar *TextIter) {

	xTextBufferRemoveTag(x.GoPointer(), TagVar.GoPointer(), StartVar, EndVar)

}

var xTextBufferRemoveTagByName func(uintptr, string, *TextIter, *TextIter)

// Emits the “remove-tag” signal.
//
// Calls [method@Gtk.TextTagTable.lookup] on the buffer’s
// tag table to get a `GtkTextTag`, then calls
// [method@Gtk.TextBuffer.remove_tag].
func (x *TextBuffer) RemoveTagByName(NameVar string, StartVar *TextIter, EndVar *TextIter) {

	xTextBufferRemoveTagByName(x.GoPointer(), NameVar, StartVar, EndVar)

}

var xTextBufferSelectRange func(uintptr, *TextIter, *TextIter)

// This function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them in two steps with
// [method@Gtk.TextBuffer.move_mark], you will temporarily select a
// region in between their old and new locations, which can be pretty
// inefficient since the temporarily-selected region will force stuff
// to be recalculated. This function moves them as a unit, which can
// be optimized.
func (x *TextBuffer) SelectRange(InsVar *TextIter, BoundVar *TextIter) {

	xTextBufferSelectRange(x.GoPointer(), InsVar, BoundVar)

}

var xTextBufferSetEnableUndo func(uintptr, bool)

// Sets whether or not to enable undoable actions in the text buffer.
//
// Undoable actions in this context are changes to the text content of
// the buffer. Changes to tags and marks are not tracked.
//
// If enabled, the user will be able to undo the last number of actions
// up to [method@Gtk.TextBuffer.get_max_undo_levels].
//
// See [method@Gtk.TextBuffer.begin_irreversible_action] and
// [method@Gtk.TextBuffer.end_irreversible_action] to create
// changes to the buffer that cannot be undone.
func (x *TextBuffer) SetEnableUndo(EnableUndoVar bool) {

	xTextBufferSetEnableUndo(x.GoPointer(), EnableUndoVar)

}

var xTextBufferSetMaxUndoLevels func(uintptr, uint)

// Sets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may
// have a memory usage impact as it requires storing an additional
// copy of the inserted or removed text within the text buffer.
func (x *TextBuffer) SetMaxUndoLevels(MaxUndoLevelsVar uint) {

	xTextBufferSetMaxUndoLevels(x.GoPointer(), MaxUndoLevelsVar)

}

var xTextBufferSetModified func(uintptr, bool)

// Used to keep track of whether the buffer has been
// modified since the last time it was saved.
//
// Whenever the buffer is saved to disk, call
// `gtk_text_buffer_set_modified (@buffer, FALSE)`.
// When the buffer is modified, it will automatically
// toggled on the modified bit again. When the modified
// bit flips, the buffer emits the
// [signal@Gtk.TextBuffer::modified-changed] signal.
func (x *TextBuffer) SetModified(SettingVar bool) {

	xTextBufferSetModified(x.GoPointer(), SettingVar)

}

var xTextBufferSetText func(uintptr, string, int)

// Deletes current contents of @buffer, and inserts @text instead. This is
// automatically marked as an irreversible action in the undo stack. If you
// wish to mark this action as part of a larger undo operation, call
// [method@TextBuffer.delete] and [method@TextBuffer.insert] directly instead.
//
// If @len is -1, @text must be nul-terminated.
// @text must be valid UTF-8.
func (x *TextBuffer) SetText(TextVar string, LenVar int) {

	xTextBufferSetText(x.GoPointer(), TextVar, LenVar)

}

var xTextBufferUndo func(uintptr)

// Undoes the last undoable action on the buffer, if there is one.
func (x *TextBuffer) Undo() {

	xTextBufferUndo(x.GoPointer())

}

func (c *TextBuffer) GoPointer() uintptr {
	return c.Ptr
}

func (c *TextBuffer) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted to apply a tag to a range of text in a `GtkTextBuffer`.
//
// Applying actually occurs in the default handler.
//
// Note that if your handler runs before the default handler
// it must not invalidate the @start and @end iters (or has to
// revalidate them).
//
// See also:
// [method@Gtk.TextBuffer.apply_tag],
// [method@Gtk.TextBuffer.insert_with_tags],
// [method@Gtk.TextBuffer.insert_range].
func (x *TextBuffer) ConnectApplyTag(cb *func(TextBuffer, uintptr, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "apply-tag", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, TagVarp uintptr, StartVarp uintptr, EndVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, TagVarp, StartVarp, EndVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "apply-tag", cbRefPtr)
}

// Emitted at the beginning of a single user-visible
// operation on a `GtkTextBuffer`.
//
// See also:
// [method@Gtk.TextBuffer.begin_user_action],
// [method@Gtk.TextBuffer.insert_interactive],
// [method@Gtk.TextBuffer.insert_range_interactive],
// [method@Gtk.TextBuffer.delete_interactive],
// [method@Gtk.TextBuffer.backspace],
// [method@Gtk.TextBuffer.delete_selection].
func (x *TextBuffer) ConnectBeginUserAction(cb *func(TextBuffer)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "begin-user-action", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "begin-user-action", cbRefPtr)
}

// Emitted when the content of a `GtkTextBuffer` has changed.
func (x *TextBuffer) ConnectChanged(cb *func(TextBuffer)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
}

// Emitted to delete a range from a `GtkTextBuffer`.
//
// Note that if your handler runs before the default handler
// it must not invalidate the @start and @end iters (or has
// to revalidate them). The default signal handler revalidates
// the @start and @end iters to both point to the location
// where text was deleted. Handlers which run after the default
// handler (see g_signal_connect_after()) do not have access to
// the deleted text.
//
// See also: [method@Gtk.TextBuffer.delete].
func (x *TextBuffer) ConnectDeleteRange(cb *func(TextBuffer, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "delete-range", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, StartVarp uintptr, EndVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, StartVarp, EndVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "delete-range", cbRefPtr)
}

// Emitted at the end of a single user-visible
// operation on the `GtkTextBuffer`.
//
// See also:
// [method@Gtk.TextBuffer.end_user_action],
// [method@Gtk.TextBuffer.insert_interactive],
// [method@Gtk.TextBuffer.insert_range_interactive],
// [method@Gtk.TextBuffer.delete_interactive],
// [method@Gtk.TextBuffer.backspace],
// [method@Gtk.TextBuffer.delete_selection],
// [method@Gtk.TextBuffer.backspace].
func (x *TextBuffer) ConnectEndUserAction(cb *func(TextBuffer)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "end-user-action", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "end-user-action", cbRefPtr)
}

// Emitted to insert a `GtkTextChildAnchor` in a `GtkTextBuffer`.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler
// it must not invalidate the @location iter (or has to
// revalidate it). The default signal handler revalidates
// it to be placed after the inserted @anchor.
//
// See also: [method@Gtk.TextBuffer.insert_child_anchor].
func (x *TextBuffer) ConnectInsertChildAnchor(cb *func(TextBuffer, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "insert-child-anchor", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, LocationVarp uintptr, AnchorVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, LocationVarp, AnchorVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "insert-child-anchor", cbRefPtr)
}

// Emitted to insert a `GdkPaintable` in a `GtkTextBuffer`.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler
// it must not invalidate the @location iter (or has to
// revalidate it). The default signal handler revalidates
// it to be placed after the inserted @paintable.
//
// See also: [method@Gtk.TextBuffer.insert_paintable].
func (x *TextBuffer) ConnectInsertPaintable(cb *func(TextBuffer, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "insert-paintable", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, LocationVarp uintptr, PaintableVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, LocationVarp, PaintableVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "insert-paintable", cbRefPtr)
}

// Emitted to insert text in a `GtkTextBuffer`.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler
// it must not invalidate the @location iter (or has to
// revalidate it). The default signal handler revalidates
// it to point to the end of the inserted text.
//
// See also: [method@Gtk.TextBuffer.insert],
// [method@Gtk.TextBuffer.insert_range].
func (x *TextBuffer) ConnectInsertText(cb *func(TextBuffer, uintptr, string, int)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "insert-text", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, LocationVarp uintptr, TextVarp string, LenVarp int) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, LocationVarp, TextVarp, LenVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "insert-text", cbRefPtr)
}

// Emitted as notification after a `GtkTextMark` is deleted.
//
// See also: [method@Gtk.TextBuffer.delete_mark].
func (x *TextBuffer) ConnectMarkDeleted(cb *func(TextBuffer, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "mark-deleted", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, MarkVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, MarkVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "mark-deleted", cbRefPtr)
}

// Emitted as notification after a `GtkTextMark` is set.
//
// See also:
// [method@Gtk.TextBuffer.create_mark],
// [method@Gtk.TextBuffer.move_mark].
func (x *TextBuffer) ConnectMarkSet(cb *func(TextBuffer, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "mark-set", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, LocationVarp uintptr, MarkVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, LocationVarp, MarkVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "mark-set", cbRefPtr)
}

// Emitted when the modified bit of a `GtkTextBuffer` flips.
//
// See also: [method@Gtk.TextBuffer.set_modified].
func (x *TextBuffer) ConnectModifiedChanged(cb *func(TextBuffer)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "modified-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "modified-changed", cbRefPtr)
}

// Emitted after paste operation has been completed.
//
// This is useful to properly scroll the view to the end
// of the pasted text. See [method@Gtk.TextBuffer.paste_clipboard]
// for more details.
func (x *TextBuffer) ConnectPasteDone(cb *func(TextBuffer, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "paste-done", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ClipboardVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ClipboardVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "paste-done", cbRefPtr)
}

// Emitted when a request has been made to redo the
// previously undone operation.
func (x *TextBuffer) ConnectRedo(cb *func(TextBuffer)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "redo", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "redo", cbRefPtr)
}

// Emitted to remove all occurrences of @tag from a range
// of text in a `GtkTextBuffer`.
//
// Removal actually occurs in the default handler.
//
// Note that if your handler runs before the default handler
// it must not invalidate the @start and @end iters (or has
// to revalidate them).
//
// See also: [method@Gtk.TextBuffer.remove_tag].
func (x *TextBuffer) ConnectRemoveTag(cb *func(TextBuffer, uintptr, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "remove-tag", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, TagVarp uintptr, StartVarp uintptr, EndVarp uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, TagVarp, StartVarp, EndVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "remove-tag", cbRefPtr)
}

// Emitted when a request has been made to undo the
// previous operation or set of operations that have
// been grouped together.
func (x *TextBuffer) ConnectUndo(cb *func(TextBuffer)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "undo", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := TextBuffer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "undo", cbRefPtr)
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewTextBuffer, lib, "gtk_text_buffer_new")

	core.PuregoSafeRegister(&xTextBufferAddMark, lib, "gtk_text_buffer_add_mark")
	core.PuregoSafeRegister(&xTextBufferAddSelectionClipboard, lib, "gtk_text_buffer_add_selection_clipboard")
	core.PuregoSafeRegister(&xTextBufferApplyTag, lib, "gtk_text_buffer_apply_tag")
	core.PuregoSafeRegister(&xTextBufferApplyTagByName, lib, "gtk_text_buffer_apply_tag_by_name")
	core.PuregoSafeRegister(&xTextBufferBackspace, lib, "gtk_text_buffer_backspace")
	core.PuregoSafeRegister(&xTextBufferBeginIrreversibleAction, lib, "gtk_text_buffer_begin_irreversible_action")
	core.PuregoSafeRegister(&xTextBufferBeginUserAction, lib, "gtk_text_buffer_begin_user_action")
	core.PuregoSafeRegister(&xTextBufferCopyClipboard, lib, "gtk_text_buffer_copy_clipboard")
	core.PuregoSafeRegister(&xTextBufferCreateChildAnchor, lib, "gtk_text_buffer_create_child_anchor")
	core.PuregoSafeRegister(&xTextBufferCreateMark, lib, "gtk_text_buffer_create_mark")
	core.PuregoSafeRegister(&xTextBufferCreateTag, lib, "gtk_text_buffer_create_tag")
	core.PuregoSafeRegister(&xTextBufferCutClipboard, lib, "gtk_text_buffer_cut_clipboard")
	core.PuregoSafeRegister(&xTextBufferDelete, lib, "gtk_text_buffer_delete")
	core.PuregoSafeRegister(&xTextBufferDeleteInteractive, lib, "gtk_text_buffer_delete_interactive")
	core.PuregoSafeRegister(&xTextBufferDeleteMark, lib, "gtk_text_buffer_delete_mark")
	core.PuregoSafeRegister(&xTextBufferDeleteMarkByName, lib, "gtk_text_buffer_delete_mark_by_name")
	core.PuregoSafeRegister(&xTextBufferDeleteSelection, lib, "gtk_text_buffer_delete_selection")
	core.PuregoSafeRegister(&xTextBufferEndIrreversibleAction, lib, "gtk_text_buffer_end_irreversible_action")
	core.PuregoSafeRegister(&xTextBufferEndUserAction, lib, "gtk_text_buffer_end_user_action")
	core.PuregoSafeRegister(&xTextBufferGetBounds, lib, "gtk_text_buffer_get_bounds")
	core.PuregoSafeRegister(&xTextBufferGetCanRedo, lib, "gtk_text_buffer_get_can_redo")
	core.PuregoSafeRegister(&xTextBufferGetCanUndo, lib, "gtk_text_buffer_get_can_undo")
	core.PuregoSafeRegister(&xTextBufferGetCharCount, lib, "gtk_text_buffer_get_char_count")
	core.PuregoSafeRegister(&xTextBufferGetEnableUndo, lib, "gtk_text_buffer_get_enable_undo")
	core.PuregoSafeRegister(&xTextBufferGetEndIter, lib, "gtk_text_buffer_get_end_iter")
	core.PuregoSafeRegister(&xTextBufferGetHasSelection, lib, "gtk_text_buffer_get_has_selection")
	core.PuregoSafeRegister(&xTextBufferGetInsert, lib, "gtk_text_buffer_get_insert")
	core.PuregoSafeRegister(&xTextBufferGetIterAtChildAnchor, lib, "gtk_text_buffer_get_iter_at_child_anchor")
	core.PuregoSafeRegister(&xTextBufferGetIterAtLine, lib, "gtk_text_buffer_get_iter_at_line")
	core.PuregoSafeRegister(&xTextBufferGetIterAtLineIndex, lib, "gtk_text_buffer_get_iter_at_line_index")
	core.PuregoSafeRegister(&xTextBufferGetIterAtLineOffset, lib, "gtk_text_buffer_get_iter_at_line_offset")
	core.PuregoSafeRegister(&xTextBufferGetIterAtMark, lib, "gtk_text_buffer_get_iter_at_mark")
	core.PuregoSafeRegister(&xTextBufferGetIterAtOffset, lib, "gtk_text_buffer_get_iter_at_offset")
	core.PuregoSafeRegister(&xTextBufferGetLineCount, lib, "gtk_text_buffer_get_line_count")
	core.PuregoSafeRegister(&xTextBufferGetMark, lib, "gtk_text_buffer_get_mark")
	core.PuregoSafeRegister(&xTextBufferGetMaxUndoLevels, lib, "gtk_text_buffer_get_max_undo_levels")
	core.PuregoSafeRegister(&xTextBufferGetModified, lib, "gtk_text_buffer_get_modified")
	core.PuregoSafeRegister(&xTextBufferGetSelectionBound, lib, "gtk_text_buffer_get_selection_bound")
	core.PuregoSafeRegister(&xTextBufferGetSelectionBounds, lib, "gtk_text_buffer_get_selection_bounds")
	core.PuregoSafeRegister(&xTextBufferGetSelectionContent, lib, "gtk_text_buffer_get_selection_content")
	core.PuregoSafeRegister(&xTextBufferGetSlice, lib, "gtk_text_buffer_get_slice")
	core.PuregoSafeRegister(&xTextBufferGetStartIter, lib, "gtk_text_buffer_get_start_iter")
	core.PuregoSafeRegister(&xTextBufferGetTagTable, lib, "gtk_text_buffer_get_tag_table")
	core.PuregoSafeRegister(&xTextBufferGetText, lib, "gtk_text_buffer_get_text")
	core.PuregoSafeRegister(&xTextBufferInsert, lib, "gtk_text_buffer_insert")
	core.PuregoSafeRegister(&xTextBufferInsertAtCursor, lib, "gtk_text_buffer_insert_at_cursor")
	core.PuregoSafeRegister(&xTextBufferInsertChildAnchor, lib, "gtk_text_buffer_insert_child_anchor")
	core.PuregoSafeRegister(&xTextBufferInsertInteractive, lib, "gtk_text_buffer_insert_interactive")
	core.PuregoSafeRegister(&xTextBufferInsertInteractiveAtCursor, lib, "gtk_text_buffer_insert_interactive_at_cursor")
	core.PuregoSafeRegister(&xTextBufferInsertMarkup, lib, "gtk_text_buffer_insert_markup")
	core.PuregoSafeRegister(&xTextBufferInsertPaintable, lib, "gtk_text_buffer_insert_paintable")
	core.PuregoSafeRegister(&xTextBufferInsertRange, lib, "gtk_text_buffer_insert_range")
	core.PuregoSafeRegister(&xTextBufferInsertRangeInteractive, lib, "gtk_text_buffer_insert_range_interactive")
	core.PuregoSafeRegister(&xTextBufferInsertWithTags, lib, "gtk_text_buffer_insert_with_tags")
	core.PuregoSafeRegister(&xTextBufferInsertWithTagsByName, lib, "gtk_text_buffer_insert_with_tags_by_name")
	core.PuregoSafeRegister(&xTextBufferMoveMark, lib, "gtk_text_buffer_move_mark")
	core.PuregoSafeRegister(&xTextBufferMoveMarkByName, lib, "gtk_text_buffer_move_mark_by_name")
	core.PuregoSafeRegister(&xTextBufferPasteClipboard, lib, "gtk_text_buffer_paste_clipboard")
	core.PuregoSafeRegister(&xTextBufferPlaceCursor, lib, "gtk_text_buffer_place_cursor")
	core.PuregoSafeRegister(&xTextBufferRedo, lib, "gtk_text_buffer_redo")
	core.PuregoSafeRegister(&xTextBufferRemoveAllTags, lib, "gtk_text_buffer_remove_all_tags")
	core.PuregoSafeRegister(&xTextBufferRemoveSelectionClipboard, lib, "gtk_text_buffer_remove_selection_clipboard")
	core.PuregoSafeRegister(&xTextBufferRemoveTag, lib, "gtk_text_buffer_remove_tag")
	core.PuregoSafeRegister(&xTextBufferRemoveTagByName, lib, "gtk_text_buffer_remove_tag_by_name")
	core.PuregoSafeRegister(&xTextBufferSelectRange, lib, "gtk_text_buffer_select_range")
	core.PuregoSafeRegister(&xTextBufferSetEnableUndo, lib, "gtk_text_buffer_set_enable_undo")
	core.PuregoSafeRegister(&xTextBufferSetMaxUndoLevels, lib, "gtk_text_buffer_set_max_undo_levels")
	core.PuregoSafeRegister(&xTextBufferSetModified, lib, "gtk_text_buffer_set_modified")
	core.PuregoSafeRegister(&xTextBufferSetText, lib, "gtk_text_buffer_set_text")
	core.PuregoSafeRegister(&xTextBufferUndo, lib, "gtk_text_buffer_undo")

}
