// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// Prototype of the function called to create new child models when
// gtk_tree_list_row_set_expanded() is called.
//
// This function can return %NULL to indicate that @item is guaranteed to be
// a leaf node and will never have children. If it does not have children but
// may get children later, it should return an empty model that is filled once
// children arrive.
type TreeListModelCreateModelFunc func(uintptr, uintptr) uintptr

type TreeListModelClass struct {
	ParentClass uintptr
}

func (x *TreeListModelClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type TreeListRowClass struct {
	ParentClass uintptr
}

func (x *TreeListRowClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GtkTreeListModel` is a list model that can create child models on demand.
type TreeListModel struct {
	gobject.Object
}

func TreeListModelNewFromInternalPtr(ptr uintptr) *TreeListModel {
	cls := &TreeListModel{}
	cls.Ptr = ptr
	return cls
}

var xNewTreeListModel func(uintptr, bool, bool, uintptr, uintptr, uintptr) uintptr

// Creates a new empty `GtkTreeListModel` displaying @root
// with all rows collapsed.
func NewTreeListModel(RootVar gio.ListModel, PassthroughVar bool, AutoexpandVar bool, CreateFuncVar *TreeListModelCreateModelFunc, UserDataVar uintptr, UserDestroyVar *glib.DestroyNotify) *TreeListModel {
	var cls *TreeListModel

	cret := xNewTreeListModel(RootVar.GoPointer(), PassthroughVar, AutoexpandVar, glib.NewCallback(CreateFuncVar), UserDataVar, glib.NewCallback(UserDestroyVar))

	if cret == 0 {
		return nil
	}
	cls = &TreeListModel{}
	cls.Ptr = cret
	return cls
}

var xTreeListModelGetAutoexpand func(uintptr) bool

// Gets whether the model is set to automatically expand new rows
// that get added.
//
// This can be either rows added by changes to the underlying
// models or via [method@Gtk.TreeListRow.set_expanded].
func (x *TreeListModel) GetAutoexpand() bool {

	cret := xTreeListModelGetAutoexpand(x.GoPointer())
	return cret
}

var xTreeListModelGetChildRow func(uintptr, uint) uintptr

// Gets the row item corresponding to the child at index @position for
// @self's root model.
//
// If @position is greater than the number of children in the root model,
// %NULL is returned.
//
// Do not confuse this function with [method@Gtk.TreeListModel.get_row].
func (x *TreeListModel) GetChildRow(PositionVar uint) *TreeListRow {
	var cls *TreeListRow

	cret := xTreeListModelGetChildRow(x.GoPointer(), PositionVar)

	if cret == 0 {
		return nil
	}
	cls = &TreeListRow{}
	cls.Ptr = cret
	return cls
}

var xTreeListModelGetModel func(uintptr) uintptr

// Gets the root model that @self was created with.
func (x *TreeListModel) GetModel() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xTreeListModelGetModel(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xTreeListModelGetPassthrough func(uintptr) bool

// Gets whether the model is passing through original row items.
//
// If this function returns %FALSE, the `GListModel` functions for @self
// return custom `GtkTreeListRow` objects. You need to call
// [method@Gtk.TreeListRow.get_item] on these objects to get the original
// item.
//
// If %TRUE, the values of the child models are passed through in their
// original state. You then need to call [method@Gtk.TreeListModel.get_row]
// to get the custom `GtkTreeListRow`s.
func (x *TreeListModel) GetPassthrough() bool {

	cret := xTreeListModelGetPassthrough(x.GoPointer())
	return cret
}

var xTreeListModelGetRow func(uintptr, uint) uintptr

// Gets the row object for the given row.
//
// If @position is greater than the number of items in @self,
// %NULL is returned.
//
// The row object can be used to expand and collapse rows as
// well as to inspect its position in the tree. See its
// documentation for details.
//
// This row object is persistent and will refer to the current
// item as long as the row is present in @self, independent of
// other rows being added or removed.
//
// If @self is set to not be passthrough, this function is
// equivalent to calling g_list_model_get_item().
//
// Do not confuse this function with [method@Gtk.TreeListModel.get_child_row].
func (x *TreeListModel) GetRow(PositionVar uint) *TreeListRow {
	var cls *TreeListRow

	cret := xTreeListModelGetRow(x.GoPointer(), PositionVar)

	if cret == 0 {
		return nil
	}
	cls = &TreeListRow{}
	cls.Ptr = cret
	return cls
}

var xTreeListModelSetAutoexpand func(uintptr, bool)

// Sets whether the model should autoexpand.
//
// If set to %TRUE, the model will recursively expand all rows that
// get added to the model. This can be either rows added by changes
// to the underlying models or via [method@Gtk.TreeListRow.set_expanded].
func (x *TreeListModel) SetAutoexpand(AutoexpandVar bool) {

	xTreeListModelSetAutoexpand(x.GoPointer(), AutoexpandVar)

}

func (c *TreeListModel) GoPointer() uintptr {
	return c.Ptr
}

func (c *TreeListModel) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// See also: g_list_model_get_n_items()
func (x *TreeListModel) GetItem(PositionVar uint) uintptr {

	cret := gio.XGListModelGetItem(x.GoPointer(), PositionVar)
	return cret
}

// Gets the type of the items in @list.
//
// All items returned from g_list_model_get_item() are of the type
// returned by this function, or a subtype, or if the type is an
// interface, they are an implementation of that interface.
//
// The item type of a #GListModel can not change during the life of the
// model.
func (x *TreeListModel) GetItemType() []interface{} {

	cret := gio.XGListModelGetItemType(x.GoPointer())
	return cret
}

// Gets the number of items in @list.
//
// Depending on the model implementation, calling this function may be
// less efficient than iterating the list with increasing values for
// @position until g_list_model_get_item() returns %NULL.
func (x *TreeListModel) GetNItems() uint {

	cret := gio.XGListModelGetNItems(x.GoPointer())
	return cret
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// This function is meant to be used by language bindings in place
// of g_list_model_get_item().
//
// See also: g_list_model_get_n_items()
func (x *TreeListModel) GetObject(PositionVar uint) *gobject.Object {
	var cls *gobject.Object

	cret := gio.XGListModelGetObject(x.GoPointer(), PositionVar)

	if cret == 0 {
		return nil
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

// Emits the #GListModel::items-changed signal on @list.
//
// This function should only be called by classes implementing
// #GListModel. It has to be called after the internal representation
// of @list has been updated, because handlers connected to this signal
// might query the new state of the list.
//
// Implementations must only make changes to the model (as visible to
// its consumer) in places that will not cause problems for that
// consumer.  For models that are driven directly by a write API (such
// as #GListStore), changes can be reported in response to uses of that
// API.  For models that represent remote data, changes should only be
// made from a fresh mainloop dispatch.  It is particularly not
// permitted to make changes in response to a call to the #GListModel
// consumer API.
//
// Stated another way: in general, it is assumed that code making a
// series of accesses to the model via the API, without returning to the
// mainloop, and without calling other code, will continue to view the
// same contents of the model.
func (x *TreeListModel) ItemsChanged(PositionVar uint, RemovedVar uint, AddedVar uint) {

	gio.XGListModelItemsChanged(x.GoPointer(), PositionVar, RemovedVar, AddedVar)

}

// `GtkTreeListRow` is used by `GtkTreeListModel` to represent items.
//
// It allows navigating the model as a tree and modify the state of rows.
//
// `GtkTreeListRow` instances are created by a `GtkTreeListModel` only
// when the [property@Gtk.TreeListModel:passthrough] property is not set.
//
// There are various support objects that can make use of `GtkTreeListRow`
// objects, such as the [class@Gtk.TreeExpander] widget that allows displaying
// an icon to expand or collapse a row or [class@Gtk.TreeListRowSorter] that
// makes it possible to sort trees properly.
type TreeListRow struct {
	gobject.Object
}

func TreeListRowNewFromInternalPtr(ptr uintptr) *TreeListRow {
	cls := &TreeListRow{}
	cls.Ptr = ptr
	return cls
}

var xTreeListRowGetChildRow func(uintptr, uint) uintptr

// If @self is not expanded or @position is greater than the
// number of children, %NULL is returned.
func (x *TreeListRow) GetChildRow(PositionVar uint) *TreeListRow {
	var cls *TreeListRow

	cret := xTreeListRowGetChildRow(x.GoPointer(), PositionVar)

	if cret == 0 {
		return nil
	}
	cls = &TreeListRow{}
	cls.Ptr = cret
	return cls
}

var xTreeListRowGetChildren func(uintptr) uintptr

// If the row is expanded, gets the model holding the children of @self.
//
// This model is the model created by the
// [callback@Gtk.TreeListModelCreateModelFunc]
// and contains the original items, no matter what value
// [property@Gtk.TreeListModel:passthrough] is set to.
func (x *TreeListRow) GetChildren() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xTreeListRowGetChildren(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xTreeListRowGetDepth func(uintptr) uint

// Gets the depth of this row.
//
// Rows that correspond to items in the root model have a depth
// of zero, rows corresponding to items of models of direct children
// of the root model have a depth of 1 and so on.
//
// The depth of a row never changes until the row is destroyed.
func (x *TreeListRow) GetDepth() uint {

	cret := xTreeListRowGetDepth(x.GoPointer())
	return cret
}

var xTreeListRowGetExpanded func(uintptr) bool

// Gets if a row is currently expanded.
func (x *TreeListRow) GetExpanded() bool {

	cret := xTreeListRowGetExpanded(x.GoPointer())
	return cret
}

var xTreeListRowGetItem func(uintptr) uintptr

// Gets the item corresponding to this row,
//
// The value returned by this function never changes until the
// row is destroyed.
func (x *TreeListRow) GetItem() *gobject.Object {
	var cls *gobject.Object

	cret := xTreeListRowGetItem(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

var xTreeListRowGetParent func(uintptr) uintptr

// Gets the row representing the parent for @self.
//
// That is the row that would need to be collapsed
// to make this row disappear.
//
// If @self is a row corresponding to the root model,
// %NULL is returned.
//
// The value returned by this function never changes
// until the row is destroyed.
func (x *TreeListRow) GetParent() *TreeListRow {
	var cls *TreeListRow

	cret := xTreeListRowGetParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &TreeListRow{}
	cls.Ptr = cret
	return cls
}

var xTreeListRowGetPosition func(uintptr) uint

// Returns the position in the `GtkTreeListModel` that @self occupies
// at the moment.
func (x *TreeListRow) GetPosition() uint {

	cret := xTreeListRowGetPosition(x.GoPointer())
	return cret
}

var xTreeListRowIsExpandable func(uintptr) bool

// Checks if a row can be expanded.
//
// This does not mean that the row is actually expanded,
// this can be checked with [method@Gtk.TreeListRow.get_expanded].
//
// If a row is expandable never changes until the row is destroyed.
func (x *TreeListRow) IsExpandable() bool {

	cret := xTreeListRowIsExpandable(x.GoPointer())
	return cret
}

var xTreeListRowSetExpanded func(uintptr, bool)

// Expands or collapses a row.
//
// If a row is expanded, the model of calling the
// [callback@Gtk.TreeListModelCreateModelFunc] for the row's
// item will be inserted after this row. If a row is collapsed,
// those items will be removed from the model.
//
// If the row is not expandable, this function does nothing.
func (x *TreeListRow) SetExpanded(ExpandedVar bool) {

	xTreeListRowSetExpanded(x.GoPointer(), ExpandedVar)

}

func (c *TreeListRow) GoPointer() uintptr {
	return c.Ptr
}

func (c *TreeListRow) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewTreeListModel, lib, "gtk_tree_list_model_new")

	core.PuregoSafeRegister(&xTreeListModelGetAutoexpand, lib, "gtk_tree_list_model_get_autoexpand")
	core.PuregoSafeRegister(&xTreeListModelGetChildRow, lib, "gtk_tree_list_model_get_child_row")
	core.PuregoSafeRegister(&xTreeListModelGetModel, lib, "gtk_tree_list_model_get_model")
	core.PuregoSafeRegister(&xTreeListModelGetPassthrough, lib, "gtk_tree_list_model_get_passthrough")
	core.PuregoSafeRegister(&xTreeListModelGetRow, lib, "gtk_tree_list_model_get_row")
	core.PuregoSafeRegister(&xTreeListModelSetAutoexpand, lib, "gtk_tree_list_model_set_autoexpand")

	core.PuregoSafeRegister(&xTreeListRowGetChildRow, lib, "gtk_tree_list_row_get_child_row")
	core.PuregoSafeRegister(&xTreeListRowGetChildren, lib, "gtk_tree_list_row_get_children")
	core.PuregoSafeRegister(&xTreeListRowGetDepth, lib, "gtk_tree_list_row_get_depth")
	core.PuregoSafeRegister(&xTreeListRowGetExpanded, lib, "gtk_tree_list_row_get_expanded")
	core.PuregoSafeRegister(&xTreeListRowGetItem, lib, "gtk_tree_list_row_get_item")
	core.PuregoSafeRegister(&xTreeListRowGetParent, lib, "gtk_tree_list_row_get_parent")
	core.PuregoSafeRegister(&xTreeListRowGetPosition, lib, "gtk_tree_list_row_get_position")
	core.PuregoSafeRegister(&xTreeListRowIsExpandable, lib, "gtk_tree_list_row_is_expandable")
	core.PuregoSafeRegister(&xTreeListRowSetExpanded, lib, "gtk_tree_list_row_set_expanded")

}
