// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type TreeDragDestIface struct {
	GIface uintptr
}

func (x *TreeDragDestIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type TreeDragSourceIface struct {
	GIface uintptr
}

func (x *TreeDragSourceIface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Interface for Drag-and-Drop destinations in `GtkTreeView`.
type TreeDragDest interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	DragDataReceived(DestVar *TreePath, ValueVar *gobject.Value) bool
	RowDropPossible(DestPathVar *TreePath, ValueVar *gobject.Value) bool
}
type TreeDragDestBase struct {
	Ptr uintptr
}

func (x *TreeDragDestBase) GoPointer() uintptr {
	return x.Ptr
}

func (x *TreeDragDestBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Asks the `GtkTreeDragDest` to insert a row before the path @dest,
// deriving the contents of the row from @value. If @dest is
// outside the tree so that inserting before it is impossible, %FALSE
// will be returned. Also, %FALSE may be returned if the new row is
// not created for some model-specific reason.  Should robustly handle
// a @dest no longer found in the model!
func (x *TreeDragDestBase) DragDataReceived(DestVar *TreePath, ValueVar *gobject.Value) bool {

	cret := XGtkTreeDragDestDragDataReceived(x.GoPointer(), DestVar, ValueVar)
	return cret
}

// Determines whether a drop is possible before the given @dest_path,
// at the same depth as @dest_path. i.e., can we drop the data in
// @value at that location. @dest_path does not have to
// exist; the return value will almost certainly be %FALSE if the
// parent of @dest_path doesn’t exist, though.
func (x *TreeDragDestBase) RowDropPossible(DestPathVar *TreePath, ValueVar *gobject.Value) bool {

	cret := XGtkTreeDragDestRowDropPossible(x.GoPointer(), DestPathVar, ValueVar)
	return cret
}

var XGtkTreeDragDestDragDataReceived func(uintptr, *TreePath, *gobject.Value) bool
var XGtkTreeDragDestRowDropPossible func(uintptr, *TreePath, *gobject.Value) bool

// Interface for Drag-and-Drop destinations in `GtkTreeView`.
type TreeDragSource interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	DragDataDelete(PathVar *TreePath) bool
	DragDataGet(PathVar *TreePath) *gdk.ContentProvider
	RowDraggable(PathVar *TreePath) bool
}
type TreeDragSourceBase struct {
	Ptr uintptr
}

func (x *TreeDragSourceBase) GoPointer() uintptr {
	return x.Ptr
}

func (x *TreeDragSourceBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Asks the `GtkTreeDragSource` to delete the row at @path, because
// it was moved somewhere else via drag-and-drop. Returns %FALSE
// if the deletion fails because @path no longer exists, or for
// some model-specific reason. Should robustly handle a @path no
// longer found in the model!
func (x *TreeDragSourceBase) DragDataDelete(PathVar *TreePath) bool {

	cret := XGtkTreeDragSourceDragDataDelete(x.GoPointer(), PathVar)
	return cret
}

// Asks the `GtkTreeDragSource` to return a `GdkContentProvider` representing
// the row at @path. Should robustly handle a @path no
// longer found in the model!
func (x *TreeDragSourceBase) DragDataGet(PathVar *TreePath) *gdk.ContentProvider {
	var cls *gdk.ContentProvider

	cret := XGtkTreeDragSourceDragDataGet(x.GoPointer(), PathVar)

	if cret == 0 {
		return nil
	}
	cls = &gdk.ContentProvider{}
	cls.Ptr = cret
	return cls
}

// Asks the `GtkTreeDragSource` whether a particular row can be used as
// the source of a DND operation. If the source doesn’t implement
// this interface, the row is assumed draggable.
func (x *TreeDragSourceBase) RowDraggable(PathVar *TreePath) bool {

	cret := XGtkTreeDragSourceRowDraggable(x.GoPointer(), PathVar)
	return cret
}

var XGtkTreeDragSourceDragDataDelete func(uintptr, *TreePath) bool
var XGtkTreeDragSourceDragDataGet func(uintptr, *TreePath) uintptr
var XGtkTreeDragSourceRowDraggable func(uintptr, *TreePath) bool

var xTreeCreateRowDragContent func(uintptr, *TreePath) uintptr

// Creates a content provider for dragging @path from @tree_model.
func TreeCreateRowDragContent(TreeModelVar TreeModel, PathVar *TreePath) *gdk.ContentProvider {
	var cls *gdk.ContentProvider

	cret := xTreeCreateRowDragContent(TreeModelVar.GoPointer(), PathVar)

	if cret == 0 {
		return nil
	}
	cls = &gdk.ContentProvider{}
	cls.Ptr = cret
	return cls
}

var xTreeGetRowDragData func(*gobject.Value, *uintptr, **TreePath) bool

// Obtains a @tree_model and @path from value of target type
// %GTK_TYPE_TREE_ROW_DATA.
//
// The returned path must be freed with gtk_tree_path_free().
func TreeGetRowDragData(ValueVar *gobject.Value, TreeModelVar *TreeModel, PathVar **TreePath) bool {

	cret := xTreeGetRowDragData(ValueVar, gobject.ConvertPtr(TreeModelVar), PathVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xTreeCreateRowDragContent, lib, "gtk_tree_create_row_drag_content")
	core.PuregoSafeRegister(&xTreeGetRowDragData, lib, "gtk_tree_get_row_drag_data")

	core.PuregoSafeRegister(&XGtkTreeDragDestDragDataReceived, lib, "gtk_tree_drag_dest_drag_data_received")
	core.PuregoSafeRegister(&XGtkTreeDragDestRowDropPossible, lib, "gtk_tree_drag_dest_row_drop_possible")

	core.PuregoSafeRegister(&XGtkTreeDragSourceDragDataDelete, lib, "gtk_tree_drag_source_drag_data_delete")
	core.PuregoSafeRegister(&XGtkTreeDragSourceDragDataGet, lib, "gtk_tree_drag_source_drag_data_get")
	core.PuregoSafeRegister(&XGtkTreeDragSourceRowDraggable, lib, "gtk_tree_drag_source_row_draggable")

}
