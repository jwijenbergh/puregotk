// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// The type of function that is passed to
// gtk_print_run_page_setup_dialog_async().
//
// This function will be called when the page setup dialog
// is dismissed, and also serves as destroy notify for @data.
type PageSetupDoneFunc func(uintptr, uintptr)

type PrintOperationClass struct {
	ParentClass uintptr

	Padding uintptr
}

func (x *PrintOperationClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type PrintOperationPrivate struct {
}

func (x *PrintOperationPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Error codes that identify various errors that can occur while
// using the GTK printing support.
type PrintError int

const (

	// An unspecified error occurred.
	PrintErrorGeneralValue PrintError = 0
	// An internal error occurred.
	PrintErrorInternalErrorValue PrintError = 1
	// A memory allocation failed.
	PrintErrorNomemValue PrintError = 2
	// An error occurred while loading a page setup
	//   or paper size from a key file.
	PrintErrorInvalidFileValue PrintError = 3
)

// Determines what action the print operation should perform.
//
// A parameter of this typs is passed to [method@Gtk.PrintOperation.run].
type PrintOperationAction int

const (

	// Show the print dialog.
	PrintOperationActionPrintDialogValue PrintOperationAction = 0
	// Start to print without showing
	//   the print dialog, based on the current print settings.
	PrintOperationActionPrintValue PrintOperationAction = 1
	// Show the print preview.
	PrintOperationActionPreviewValue PrintOperationAction = 2
	// Export to a file. This requires
	//   the export-filename property to be set.
	PrintOperationActionExportValue PrintOperationAction = 3
)

// The result of a print operation.
//
// A value of this type is returned by [method@Gtk.PrintOperation.run].
type PrintOperationResult int

const (

	// An error has occurred.
	PrintOperationResultErrorValue PrintOperationResult = 0
	// The print settings should be stored.
	PrintOperationResultApplyValue PrintOperationResult = 1
	// The print operation has been canceled,
	//   the print settings should not be stored.
	PrintOperationResultCancelValue PrintOperationResult = 2
	// The print operation is not complete
	//   yet. This value will only be returned when running asynchronously.
	PrintOperationResultInProgressValue PrintOperationResult = 3
)

// The status gives a rough indication of the completion of a running
// print operation.
type PrintStatus int

const (

	// The printing has not started yet; this
	//   status is set initially, and while the print dialog is shown.
	PrintStatusInitialValue PrintStatus = 0
	// This status is set while the begin-print
	//   signal is emitted and during pagination.
	PrintStatusPreparingValue PrintStatus = 1
	// This status is set while the
	//   pages are being rendered.
	PrintStatusGeneratingDataValue PrintStatus = 2
	// The print job is being sent off to the
	//   printer.
	PrintStatusSendingDataValue PrintStatus = 3
	// The print job has been sent to the printer,
	//   but is not printed for some reason, e.g. the printer may be stopped.
	PrintStatusPendingValue PrintStatus = 4
	// Some problem has occurred during
	//   printing, e.g. a paper jam.
	PrintStatusPendingIssueValue PrintStatus = 5
	// The printer is processing the print job.
	PrintStatusPrintingValue PrintStatus = 6
	// The printing has been completed successfully.
	PrintStatusFinishedValue PrintStatus = 7
	// The printing has been aborted.
	PrintStatusFinishedAbortedValue PrintStatus = 8
)

var xPrintErrorQuark func() glib.Quark

// Registers an error quark for `GtkPrintOperation` if necessary.
func PrintErrorQuark() glib.Quark {

	cret := xPrintErrorQuark()
	return cret
}

var xPrintRunPageSetupDialog func(uintptr, uintptr, uintptr) uintptr

// Runs a page setup dialog, letting the user modify the values from
// @page_setup. If the user cancels the dialog, the returned `GtkPageSetup`
// is identical to the passed in @page_setup, otherwise it contains the
// modifications done in the dialog.
//
// Note that this function may use a recursive mainloop to show the page
// setup dialog. See gtk_print_run_page_setup_dialog_async() if this is
// a problem.
func PrintRunPageSetupDialog(ParentVar *Window, PageSetupVar *PageSetup, SettingsVar *PrintSettings) *PageSetup {
	var cls *PageSetup

	cret := xPrintRunPageSetupDialog(ParentVar.GoPointer(), PageSetupVar.GoPointer(), SettingsVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &PageSetup{}
	cls.Ptr = cret
	return cls
}

var xPrintRunPageSetupDialogAsync func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Runs a page setup dialog, letting the user modify the values from @page_setup.
//
// In contrast to gtk_print_run_page_setup_dialog(), this function  returns after
// showing the page setup dialog on platforms that support this, and calls @done_cb
// from a signal handler for the ::response signal of the dialog.
func PrintRunPageSetupDialogAsync(ParentVar *Window, PageSetupVar *PageSetup, SettingsVar *PrintSettings, DoneCbVar *PageSetupDoneFunc, DataVar uintptr) {

	xPrintRunPageSetupDialogAsync(ParentVar.GoPointer(), PageSetupVar.GoPointer(), SettingsVar.GoPointer(), glib.NewCallback(DoneCbVar), DataVar)

}

// `GtkPrintOperation` is the high-level, portable printing API.
//
// It looks a bit different than other GTK dialogs such as the
// `GtkFileChooser`, since some platforms don’t expose enough
// infrastructure to implement a good print dialog. On such
// platforms, `GtkPrintOperation` uses the native print dialog.
// On platforms which do not provide a native print dialog, GTK
// uses its own, see [class@Gtk.PrintUnixDialog].
//
// The typical way to use the high-level printing API is to create
// a `GtkPrintOperation` object with [ctor@Gtk.PrintOperation.new]
// when the user selects to print. Then you set some properties on it,
// e.g. the page size, any [class@Gtk.PrintSettings] from previous print
// operations, the number of pages, the current page, etc.
//
// Then you start the print operation by calling [method@Gtk.PrintOperation.run].
// It will then show a dialog, let the user select a printer and options.
// When the user finished the dialog, various signals will be emitted on
// the `GtkPrintOperation`, the main one being
// [signal@Gtk.PrintOperation::draw-page], which you are supposed to handle
// and render the page on the provided [class@Gtk.PrintContext] using Cairo.
//
// # The high-level printing API
//
// ```c
// static GtkPrintSettings *settings = NULL;
//
// static void
// do_print (void)
//
//	{
//	  GtkPrintOperation *print;
//	  GtkPrintOperationResult res;
//
//	  print = gtk_print_operation_new ();
//
//	  if (settings != NULL)
//	    gtk_print_operation_set_print_settings (print, settings);
//
//	  g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
//	  g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
//
//	  res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//	                                 GTK_WINDOW (main_window), NULL);
//
//	  if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//	    {
//	      if (settings != NULL)
//	        g_object_unref (settings);
//	      settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//	    }
//
//	  g_object_unref (print);
//	}
//
// ```
//
// By default `GtkPrintOperation` uses an external application to do
// print preview. To implement a custom print preview, an application
// must connect to the preview signal. The functions
// [method@Gtk.PrintOperationPreview.render_page],
// [method@Gtk.PrintOperationPreview.end_preview] and
// [method@Gtk.PrintOperationPreview.is_selected]
// are useful when implementing a print preview.
type PrintOperation struct {
	gobject.Object
}

func PrintOperationNewFromInternalPtr(ptr uintptr) *PrintOperation {
	cls := &PrintOperation{}
	cls.Ptr = ptr
	return cls
}

var xNewPrintOperation func() uintptr

// Creates a new `GtkPrintOperation`.
func NewPrintOperation() *PrintOperation {
	var cls *PrintOperation

	cret := xNewPrintOperation()

	if cret == 0 {
		return nil
	}
	cls = &PrintOperation{}
	cls.Ptr = cret
	return cls
}

var xPrintOperationCancel func(uintptr)

// Cancels a running print operation.
//
// This function may be called from a [signal@Gtk.PrintOperation::begin-print],
// [signal@Gtk.PrintOperation::paginate] or [signal@Gtk.PrintOperation::draw-page]
// signal handler to stop the currently running print operation.
func (x *PrintOperation) Cancel() {

	xPrintOperationCancel(x.GoPointer())

}

var xPrintOperationDrawPageFinish func(uintptr)

// Signal that drawing of particular page is complete.
//
// It is called after completion of page drawing (e.g. drawing
// in another thread). If [method@Gtk.PrintOperation.set_defer_drawing]
// was called before, then this function has to be called by application.
// Otherwise it is called by GTK itself.
func (x *PrintOperation) DrawPageFinish() {

	xPrintOperationDrawPageFinish(x.GoPointer())

}

var xPrintOperationGetDefaultPageSetup func(uintptr) uintptr

// Returns the default page setup.
func (x *PrintOperation) GetDefaultPageSetup() *PageSetup {
	var cls *PageSetup

	cret := xPrintOperationGetDefaultPageSetup(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &PageSetup{}
	cls.Ptr = cret
	return cls
}

var xPrintOperationGetEmbedPageSetup func(uintptr) bool

// Gets whether page setup selection combos are embedded
func (x *PrintOperation) GetEmbedPageSetup() bool {

	cret := xPrintOperationGetEmbedPageSetup(x.GoPointer())
	return cret
}

var xPrintOperationGetError func(uintptr)

// Call this when the result of a print operation is
// %GTK_PRINT_OPERATION_RESULT_ERROR.
//
// It can be called either after [method@Gtk.PrintOperation.run]
// returns, or in the [signal@Gtk.PrintOperation::done] signal
// handler.
//
// The returned `GError` will contain more details on what went wrong.
func (x *PrintOperation) GetError() error {
	var cerr *glib.Error

	xPrintOperationGetError(x.GoPointer())
	if cerr == nil {
		return nil
	}
	return cerr

}

var xPrintOperationGetHasSelection func(uintptr) bool

// Gets whether there is a selection.
func (x *PrintOperation) GetHasSelection() bool {

	cret := xPrintOperationGetHasSelection(x.GoPointer())
	return cret
}

var xPrintOperationGetNPagesToPrint func(uintptr) int

// Returns the number of pages that will be printed.
//
// Note that this value is set during print preparation phase
// (%GTK_PRINT_STATUS_PREPARING), so this function should never be
// called before the data generation phase (%GTK_PRINT_STATUS_GENERATING_DATA).
// You can connect to the [signal@Gtk.PrintOperation::status-changed]
// signal and call gtk_print_operation_get_n_pages_to_print() when
// print status is %GTK_PRINT_STATUS_GENERATING_DATA.
//
// This is typically used to track the progress of print operation.
func (x *PrintOperation) GetNPagesToPrint() int {

	cret := xPrintOperationGetNPagesToPrint(x.GoPointer())
	return cret
}

var xPrintOperationGetPrintSettings func(uintptr) uintptr

// Returns the current print settings.
//
// Note that the return value is %NULL until either
// [method@Gtk.PrintOperation.set_print_settings] or
// [method@Gtk.PrintOperation.run] have been called.
func (x *PrintOperation) GetPrintSettings() *PrintSettings {
	var cls *PrintSettings

	cret := xPrintOperationGetPrintSettings(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &PrintSettings{}
	cls.Ptr = cret
	return cls
}

var xPrintOperationGetStatus func(uintptr) PrintStatus

// Returns the status of the print operation.
//
// Also see [method@Gtk.PrintOperation.get_status_string].
func (x *PrintOperation) GetStatus() PrintStatus {

	cret := xPrintOperationGetStatus(x.GoPointer())
	return cret
}

var xPrintOperationGetStatusString func(uintptr) string

// Returns a string representation of the status of the
// print operation.
//
// The string is translated and suitable for displaying
// the print status e.g. in a `GtkStatusbar`.
//
// Use [method@Gtk.PrintOperation.get_status] to obtain
// a status value that is suitable for programmatic use.
func (x *PrintOperation) GetStatusString() string {

	cret := xPrintOperationGetStatusString(x.GoPointer())
	return cret
}

var xPrintOperationGetSupportSelection func(uintptr) bool

// Gets whether the application supports print of selection
func (x *PrintOperation) GetSupportSelection() bool {

	cret := xPrintOperationGetSupportSelection(x.GoPointer())
	return cret
}

var xPrintOperationIsFinished func(uintptr) bool

// A convenience function to find out if the print operation
// is finished.
//
// a print operation is finished if its status is either
// %GTK_PRINT_STATUS_FINISHED or %GTK_PRINT_STATUS_FINISHED_ABORTED.
//
// Note: when you enable print status tracking the print operation
// can be in a non-finished state even after done has been called, as
// the operation status then tracks the print job status on the printer.
func (x *PrintOperation) IsFinished() bool {

	cret := xPrintOperationIsFinished(x.GoPointer())
	return cret
}

var xPrintOperationRun func(uintptr, PrintOperationAction, uintptr, **glib.Error) PrintOperationResult

// Runs the print operation.
//
// Normally that this function does not return until the rendering
// of all pages is complete. You can connect to the
// [signal@Gtk.PrintOperation::status-changed] signal on @op to obtain
// some information about the progress of the print operation.
//
// Furthermore, it may use a recursive mainloop to show the print dialog.
//
// If you set the [Gtk.PrintOperation:allow-async] property, the operation
// will run asynchronously if this is supported on the platform. The
// [signal@Gtk.PrintOperation::done] signal will be emitted with the result
// of the operation when the it is done (i.e. when the dialog is canceled,
// or when the print succeeds or fails).
//
// ```c
// if (settings != NULL)
//
//	gtk_print_operation_set_print_settings (print, settings);
//
// if (page_setup != NULL)
//
//	gtk_print_operation_set_default_page_setup (print, page_setup);
//
// g_signal_connect (print, "begin-print",
//
//	G_CALLBACK (begin_print), &amp;data);
//
// g_signal_connect (print, "draw-page",
//
//	G_CALLBACK (draw_page), &amp;data);
//
// res = gtk_print_operation_run (print,
//
//	GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//	parent,
//	&amp;error);
//
// if (res == GTK_PRINT_OPERATION_RESULT_ERROR)
//
//	 {
//	   error_dialog = gtk_message_dialog_new (GTK_WINDOW (parent),
//	  			                     GTK_DIALOG_DESTROY_WITH_PARENT,
//						     GTK_MESSAGE_ERROR,
//						     GTK_BUTTONS_CLOSE,
//						     "Error printing file:\n%s",
//						     error-&gt;message);
//	   g_signal_connect (error_dialog, "response",
//	                     G_CALLBACK (gtk_window_destroy), NULL);
//	   gtk_widget_show (error_dialog);
//	   g_error_free (error);
//	 }
//
// else if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//
//	{
//	  if (settings != NULL)
//
// g_object_unref (settings);
//
//	  settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//	}
//
// ```
//
// Note that gtk_print_operation_run() can only be called once on a
// given `GtkPrintOperation`.
func (x *PrintOperation) Run(ActionVar PrintOperationAction, ParentVar *Window) (PrintOperationResult, error) {
	var cerr *glib.Error

	cret := xPrintOperationRun(x.GoPointer(), ActionVar, ParentVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPrintOperationSetAllowAsync func(uintptr, bool)

// Sets whether gtk_print_operation_run() may return
// before the print operation is completed.
//
// Note that some platforms may not allow asynchronous
// operation.
func (x *PrintOperation) SetAllowAsync(AllowAsyncVar bool) {

	xPrintOperationSetAllowAsync(x.GoPointer(), AllowAsyncVar)

}

var xPrintOperationSetCurrentPage func(uintptr, int)

// Sets the current page.
//
// If this is called before [method@Gtk.PrintOperation.run],
// the user will be able to select to print only the current page.
//
// Note that this only makes sense for pre-paginated documents.
func (x *PrintOperation) SetCurrentPage(CurrentPageVar int) {

	xPrintOperationSetCurrentPage(x.GoPointer(), CurrentPageVar)

}

var xPrintOperationSetCustomTabLabel func(uintptr, string)

// Sets the label for the tab holding custom widgets.
func (x *PrintOperation) SetCustomTabLabel(LabelVar string) {

	xPrintOperationSetCustomTabLabel(x.GoPointer(), LabelVar)

}

var xPrintOperationSetDefaultPageSetup func(uintptr, uintptr)

// Makes @default_page_setup the default page setup for @op.
//
// This page setup will be used by [method@Gtk.PrintOperation.run],
// but it can be overridden on a per-page basis by connecting
// to the [signal@Gtk.PrintOperation::request-page-setup] signal.
func (x *PrintOperation) SetDefaultPageSetup(DefaultPageSetupVar *PageSetup) {

	xPrintOperationSetDefaultPageSetup(x.GoPointer(), DefaultPageSetupVar.GoPointer())

}

var xPrintOperationSetDeferDrawing func(uintptr)

// Sets up the `GtkPrintOperation` to wait for calling of
// [method@Gtk.PrintOperation.draw_page_finish from application.
//
// This can be used for drawing page in another thread.
//
// This function must be called in the callback of the
// [signal@Gtk.PrintOperation::draw-page] signal.
func (x *PrintOperation) SetDeferDrawing() {

	xPrintOperationSetDeferDrawing(x.GoPointer())

}

var xPrintOperationSetEmbedPageSetup func(uintptr, bool)

// Embed page size combo box and orientation combo box into page setup page.
//
// Selected page setup is stored as default page setup in `GtkPrintOperation`.
func (x *PrintOperation) SetEmbedPageSetup(EmbedVar bool) {

	xPrintOperationSetEmbedPageSetup(x.GoPointer(), EmbedVar)

}

var xPrintOperationSetExportFilename func(uintptr, string)

// Sets up the `GtkPrintOperation` to generate a file instead
// of showing the print dialog.
//
// The intended use of this function is for implementing
// “Export to PDF” actions. Currently, PDF is the only supported
// format.
//
// “Print to PDF” support is independent of this and is done
// by letting the user pick the “Print to PDF” item from the list
// of printers in the print dialog.
func (x *PrintOperation) SetExportFilename(FilenameVar string) {

	xPrintOperationSetExportFilename(x.GoPointer(), FilenameVar)

}

var xPrintOperationSetHasSelection func(uintptr, bool)

// Sets whether there is a selection to print.
//
// Application has to set number of pages to which the selection
// will draw by [method@Gtk.PrintOperation.set_n_pages] in a handler
// for the [signal@Gtk.PrintOperation::begin-print] signal.
func (x *PrintOperation) SetHasSelection(HasSelectionVar bool) {

	xPrintOperationSetHasSelection(x.GoPointer(), HasSelectionVar)

}

var xPrintOperationSetJobName func(uintptr, string)

// Sets the name of the print job.
//
// The name is used to identify the job (e.g. in monitoring
// applications like eggcups).
//
// If you don’t set a job name, GTK picks a default one by
// numbering successive print jobs.
func (x *PrintOperation) SetJobName(JobNameVar string) {

	xPrintOperationSetJobName(x.GoPointer(), JobNameVar)

}

var xPrintOperationSetNPages func(uintptr, int)

// Sets the number of pages in the document.
//
// This must be set to a positive number before the rendering
// starts. It may be set in a [signal@Gtk.PrintOperation::begin-print]
// signal handler.
//
// Note that the page numbers passed to the
// [signal@Gtk.PrintOperation::request-page-setup]
// and [signal@Gtk.PrintOperation::draw-page] signals are 0-based, i.e.
// if the user chooses to print all pages, the last ::draw-page signal
// will be for page @n_pages - 1.
func (x *PrintOperation) SetNPages(NPagesVar int) {

	xPrintOperationSetNPages(x.GoPointer(), NPagesVar)

}

var xPrintOperationSetPrintSettings func(uintptr, uintptr)

// Sets the print settings for @op.
//
// This is typically used to re-establish print settings
// from a previous print operation, see [method@Gtk.PrintOperation.run].
func (x *PrintOperation) SetPrintSettings(PrintSettingsVar *PrintSettings) {

	xPrintOperationSetPrintSettings(x.GoPointer(), PrintSettingsVar.GoPointer())

}

var xPrintOperationSetShowProgress func(uintptr, bool)

// If @show_progress is %TRUE, the print operation will show
// a progress dialog during the print operation.
func (x *PrintOperation) SetShowProgress(ShowProgressVar bool) {

	xPrintOperationSetShowProgress(x.GoPointer(), ShowProgressVar)

}

var xPrintOperationSetSupportSelection func(uintptr, bool)

// Sets whether selection is supported by `GtkPrintOperation`.
func (x *PrintOperation) SetSupportSelection(SupportSelectionVar bool) {

	xPrintOperationSetSupportSelection(x.GoPointer(), SupportSelectionVar)

}

var xPrintOperationSetTrackPrintStatus func(uintptr, bool)

// If track_status is %TRUE, the print operation will try to continue
// report on the status of the print job in the printer queues and printer.
//
// This can allow your application to show things like “out of paper”
// issues, and when the print job actually reaches the printer.
//
// This function is often implemented using some form of polling,
// so it should not be enabled unless needed.
func (x *PrintOperation) SetTrackPrintStatus(TrackStatusVar bool) {

	xPrintOperationSetTrackPrintStatus(x.GoPointer(), TrackStatusVar)

}

var xPrintOperationSetUnit func(uintptr, Unit)

// Sets up the transformation for the cairo context obtained from
// `GtkPrintContext` in such a way that distances are measured in
// units of @unit.
func (x *PrintOperation) SetUnit(UnitVar Unit) {

	xPrintOperationSetUnit(x.GoPointer(), UnitVar)

}

var xPrintOperationSetUseFullPage func(uintptr, bool)

// If @full_page is %TRUE, the transformation for the cairo context
// obtained from `GtkPrintContext` puts the origin at the top left
// corner of the page.
//
// This may not be the top left corner of the sheet, depending on page
// orientation and the number of pages per sheet). Otherwise, the origin
// is at the top left corner of the imageable area (i.e. inside the margins).
func (x *PrintOperation) SetUseFullPage(FullPageVar bool) {

	xPrintOperationSetUseFullPage(x.GoPointer(), FullPageVar)

}

func (c *PrintOperation) GoPointer() uintptr {
	return c.Ptr
}

func (c *PrintOperation) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted after the user has finished changing print settings
// in the dialog, before the actual rendering starts.
//
// A typical use for ::begin-print is to use the parameters from the
// [class@Gtk.PrintContext] and paginate the document accordingly,
// and then set the number of pages with
// [method@Gtk.PrintOperation.set_n_pages].
func (x *PrintOperation) ConnectBeginPrint(cb *func(PrintOperation, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "begin-print", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ContextVarp uintptr) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ContextVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "begin-print", cbRefPtr)
}

// Emitted when displaying the print dialog.
//
// If you return a widget in a handler for this signal it will be
// added to a custom tab in the print dialog. You typically return a
// container widget with multiple widgets in it.
//
// The print dialog owns the returned widget, and its lifetime is not
// controlled by the application. However, the widget is guaranteed
// to stay around until the [signal@Gtk.PrintOperation::custom-widget-apply]
// signal is emitted on the operation. Then you can read out any
// information you need from the widgets.
func (x *PrintOperation) ConnectCreateCustomWidget(cb *func(PrintOperation) gobject.Object) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "create-custom-widget", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) uintptr {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		CreateCustomWidgetCls := cbFn(fa)
		return CreateCustomWidgetCls.Ptr

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "create-custom-widget", cbRefPtr)
}

// Emitted right before ::begin-print if you added
// a custom widget in the ::create-custom-widget handler.
//
// When you get this signal you should read the information from the
// custom widgets, as the widgets are not guaranteed to be around at a
// later time.
func (x *PrintOperation) ConnectCustomWidgetApply(cb *func(PrintOperation, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "custom-widget-apply", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, WidgetVarp uintptr) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, WidgetVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "custom-widget-apply", cbRefPtr)
}

// Emitted when the print operation run has finished doing
// everything required for printing.
//
// @result gives you information about what happened during the run.
// If @result is %GTK_PRINT_OPERATION_RESULT_ERROR then you can call
// [method@Gtk.PrintOperation.get_error] for more information.
//
// If you enabled print status tracking then
// [method@Gtk.PrintOperation.is_finished] may still return %FALSE
// after the ::done signal was emitted.
func (x *PrintOperation) ConnectDone(cb *func(PrintOperation, PrintOperationResult)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "done", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ResultVarp PrintOperationResult) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ResultVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "done", cbRefPtr)
}

// Emitted for every page that is printed.
//
// The signal handler must render the @page_nr's page onto the cairo
// context obtained from @context using
// [method@Gtk.PrintContext.get_cairo_context].
//
// ```c
// static void
// draw_page (GtkPrintOperation *operation,
//
//	GtkPrintContext   *context,
//	int                page_nr,
//	gpointer           user_data)
//
//	{
//	  cairo_t *cr;
//	  PangoLayout *layout;
//	  double width, text_height;
//	  int layout_height;
//	  PangoFontDescription *desc;
//
//	  cr = gtk_print_context_get_cairo_context (context);
//	  width = gtk_print_context_get_width (context);
//
//	  cairo_rectangle (cr, 0, 0, width, HEADER_HEIGHT);
//
//	  cairo_set_source_rgb (cr, 0.8, 0.8, 0.8);
//	  cairo_fill (cr);
//
//	  layout = gtk_print_context_create_pango_layout (context);
//
//	  desc = pango_font_description_from_string ("sans 14");
//	  pango_layout_set_font_description (layout, desc);
//	  pango_font_description_free (desc);
//
//	  pango_layout_set_text (layout, "some text", -1);
//	  pango_layout_set_width (layout, width * PANGO_SCALE);
//	  pango_layout_set_alignment (layout, PANGO_ALIGN_CENTER);
//
//	  pango_layout_get_size (layout, NULL, &amp;layout_height);
//	  text_height = (double)layout_height / PANGO_SCALE;
//
//	  cairo_move_to (cr, width / 2,  (HEADER_HEIGHT - text_height) / 2);
//	  pango_cairo_show_layout (cr, layout);
//
//	  g_object_unref (layout);
//	}
//
// ```
//
// Use [method@Gtk.PrintOperation.set_use_full_page] and
// [method@Gtk.PrintOperation.set_unit] before starting the print
// operation to set up the transformation of the cairo context
// according to your needs.
func (x *PrintOperation) ConnectDrawPage(cb *func(PrintOperation, uintptr, int)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "draw-page", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ContextVarp uintptr, PageNrVarp int) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ContextVarp, PageNrVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "draw-page", cbRefPtr)
}

// Emitted after all pages have been rendered.
//
// A handler for this signal can clean up any resources that have
// been allocated in the [signal@Gtk.PrintOperation::begin-print] handler.
func (x *PrintOperation) ConnectEndPrint(cb *func(PrintOperation, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "end-print", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ContextVarp uintptr) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ContextVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "end-print", cbRefPtr)
}

// Emitted after the ::begin-print signal, but before the actual rendering
// starts.
//
// It keeps getting emitted until a connected signal handler returns %TRUE.
//
// The ::paginate signal is intended to be used for paginating a document
// in small chunks, to avoid blocking the user interface for a long
// time. The signal handler should update the number of pages using
// [method@Gtk.PrintOperation.set_n_pages], and return %TRUE if the document
// has been completely paginated.
//
// If you don't need to do pagination in chunks, you can simply do
// it all in the ::begin-print handler, and set the number of pages
// from there.
func (x *PrintOperation) ConnectPaginate(cb *func(PrintOperation, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "paginate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ContextVarp uintptr) bool {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ContextVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "paginate", cbRefPtr)
}

// Gets emitted when a preview is requested from the native dialog.
//
// The default handler for this signal uses an external viewer
// application to preview.
//
// To implement a custom print preview, an application must return
// %TRUE from its handler for this signal. In order to use the
// provided @context for the preview implementation, it must be
// given a suitable cairo context with
// [method@Gtk.PrintContext.set_cairo_context].
//
// The custom preview implementation can use
// [method@Gtk.PrintOperationPreview.is_selected] and
// [method@Gtk.PrintOperationPreview.render_page] to find pages which
// are selected for print and render them. The preview must be
// finished by calling [method@Gtk.PrintOperationPreview.end_preview]
// (typically in response to the user clicking a close button).
func (x *PrintOperation) ConnectPreview(cb *func(PrintOperation, uintptr, uintptr, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "preview", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PreviewVarp uintptr, ContextVarp uintptr, ParentVarp uintptr) bool {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, PreviewVarp, ContextVarp, ParentVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "preview", cbRefPtr)
}

// Emitted once for every page that is printed.
//
// This gives the application a chance to modify the page setup.
// Any changes done to @setup will be in force only for printing
// this page.
func (x *PrintOperation) ConnectRequestPageSetup(cb *func(PrintOperation, uintptr, int, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "request-page-setup", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ContextVarp uintptr, PageNrVarp int, SetupVarp uintptr) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ContextVarp, PageNrVarp, SetupVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "request-page-setup", cbRefPtr)
}

// Emitted at between the various phases of the print operation.
//
// See [enum@Gtk.PrintStatus] for the phases that are being discriminated.
// Use [method@Gtk.PrintOperation.get_status] to find out the current
// status.
func (x *PrintOperation) ConnectStatusChanged(cb *func(PrintOperation)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "status-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "status-changed", cbRefPtr)
}

// Emitted after change of selected printer.
//
// The actual page setup and print settings are passed to the custom
// widget, which can actualize itself according to this change.
func (x *PrintOperation) ConnectUpdateCustomWidget(cb *func(PrintOperation, uintptr, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "update-custom-widget", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, WidgetVarp uintptr, SetupVarp uintptr, SettingsVarp uintptr) {
		fa := PrintOperation{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, WidgetVarp, SetupVarp, SettingsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "update-custom-widget", cbRefPtr)
}

// Ends a preview.
//
// This function must be called to finish a custom print preview.
func (x *PrintOperation) EndPreview() {

	XGtkPrintOperationPreviewEndPreview(x.GoPointer())

}

// Returns whether the given page is included in the set of pages that
// have been selected for printing.
func (x *PrintOperation) IsSelected(PageNrVar int) bool {

	cret := XGtkPrintOperationPreviewIsSelected(x.GoPointer(), PageNrVar)
	return cret
}

// Renders a page to the preview.
//
// This is using the print context that was passed to the
// [signal@Gtk.PrintOperation::preview] handler together
// with @preview.
//
// A custom print preview should use this function to render
// the currently selected page.
//
// Note that this function requires a suitable cairo context to
// be associated with the print context.
func (x *PrintOperation) RenderPage(PageNrVar int) {

	XGtkPrintOperationPreviewRenderPage(x.GoPointer(), PageNrVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xPrintErrorQuark, lib, "gtk_print_error_quark")
	core.PuregoSafeRegister(&xPrintRunPageSetupDialog, lib, "gtk_print_run_page_setup_dialog")
	core.PuregoSafeRegister(&xPrintRunPageSetupDialogAsync, lib, "gtk_print_run_page_setup_dialog_async")

	core.PuregoSafeRegister(&xNewPrintOperation, lib, "gtk_print_operation_new")

	core.PuregoSafeRegister(&xPrintOperationCancel, lib, "gtk_print_operation_cancel")
	core.PuregoSafeRegister(&xPrintOperationDrawPageFinish, lib, "gtk_print_operation_draw_page_finish")
	core.PuregoSafeRegister(&xPrintOperationGetDefaultPageSetup, lib, "gtk_print_operation_get_default_page_setup")
	core.PuregoSafeRegister(&xPrintOperationGetEmbedPageSetup, lib, "gtk_print_operation_get_embed_page_setup")
	core.PuregoSafeRegister(&xPrintOperationGetError, lib, "gtk_print_operation_get_error")
	core.PuregoSafeRegister(&xPrintOperationGetHasSelection, lib, "gtk_print_operation_get_has_selection")
	core.PuregoSafeRegister(&xPrintOperationGetNPagesToPrint, lib, "gtk_print_operation_get_n_pages_to_print")
	core.PuregoSafeRegister(&xPrintOperationGetPrintSettings, lib, "gtk_print_operation_get_print_settings")
	core.PuregoSafeRegister(&xPrintOperationGetStatus, lib, "gtk_print_operation_get_status")
	core.PuregoSafeRegister(&xPrintOperationGetStatusString, lib, "gtk_print_operation_get_status_string")
	core.PuregoSafeRegister(&xPrintOperationGetSupportSelection, lib, "gtk_print_operation_get_support_selection")
	core.PuregoSafeRegister(&xPrintOperationIsFinished, lib, "gtk_print_operation_is_finished")
	core.PuregoSafeRegister(&xPrintOperationRun, lib, "gtk_print_operation_run")
	core.PuregoSafeRegister(&xPrintOperationSetAllowAsync, lib, "gtk_print_operation_set_allow_async")
	core.PuregoSafeRegister(&xPrintOperationSetCurrentPage, lib, "gtk_print_operation_set_current_page")
	core.PuregoSafeRegister(&xPrintOperationSetCustomTabLabel, lib, "gtk_print_operation_set_custom_tab_label")
	core.PuregoSafeRegister(&xPrintOperationSetDefaultPageSetup, lib, "gtk_print_operation_set_default_page_setup")
	core.PuregoSafeRegister(&xPrintOperationSetDeferDrawing, lib, "gtk_print_operation_set_defer_drawing")
	core.PuregoSafeRegister(&xPrintOperationSetEmbedPageSetup, lib, "gtk_print_operation_set_embed_page_setup")
	core.PuregoSafeRegister(&xPrintOperationSetExportFilename, lib, "gtk_print_operation_set_export_filename")
	core.PuregoSafeRegister(&xPrintOperationSetHasSelection, lib, "gtk_print_operation_set_has_selection")
	core.PuregoSafeRegister(&xPrintOperationSetJobName, lib, "gtk_print_operation_set_job_name")
	core.PuregoSafeRegister(&xPrintOperationSetNPages, lib, "gtk_print_operation_set_n_pages")
	core.PuregoSafeRegister(&xPrintOperationSetPrintSettings, lib, "gtk_print_operation_set_print_settings")
	core.PuregoSafeRegister(&xPrintOperationSetShowProgress, lib, "gtk_print_operation_set_show_progress")
	core.PuregoSafeRegister(&xPrintOperationSetSupportSelection, lib, "gtk_print_operation_set_support_selection")
	core.PuregoSafeRegister(&xPrintOperationSetTrackPrintStatus, lib, "gtk_print_operation_set_track_print_status")
	core.PuregoSafeRegister(&xPrintOperationSetUnit, lib, "gtk_print_operation_set_unit")
	core.PuregoSafeRegister(&xPrintOperationSetUseFullPage, lib, "gtk_print_operation_set_use_full_page")

}
