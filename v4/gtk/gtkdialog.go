// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gsk"
)

type DialogClass struct {
	ParentClass uintptr

	Padding uintptr
}

func (x *DialogClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Flags used to influence dialog construction.
type DialogFlags int

const (

	// Make the constructed dialog modal
	DialogModalValue DialogFlags = 1
	// Destroy the dialog when its parent is destroyed
	DialogDestroyWithParentValue DialogFlags = 2
	// Create dialog with actions in header
	//   bar instead of action area
	DialogUseHeaderBarValue DialogFlags = 4
)

// Predefined values for use as response ids in gtk_dialog_add_button().
//
// All predefined values are negative; GTK leaves values of 0 or greater for
// application-defined response ids.
type ResponseType int

const (

	// Returned if an action widget has no response id,
	//   or if the dialog gets programmatically hidden or destroyed
	ResponseNoneValue ResponseType = -1
	// Generic response id, not used by GTK dialogs
	ResponseRejectValue ResponseType = -2
	// Generic response id, not used by GTK dialogs
	ResponseAcceptValue ResponseType = -3
	// Returned if the dialog is deleted
	ResponseDeleteEventValue ResponseType = -4
	// Returned by OK buttons in GTK dialogs
	ResponseOkValue ResponseType = -5
	// Returned by Cancel buttons in GTK dialogs
	ResponseCancelValue ResponseType = -6
	// Returned by Close buttons in GTK dialogs
	ResponseCloseValue ResponseType = -7
	// Returned by Yes buttons in GTK dialogs
	ResponseYesValue ResponseType = -8
	// Returned by No buttons in GTK dialogs
	ResponseNoValue ResponseType = -9
	// Returned by Apply buttons in GTK dialogs
	ResponseApplyValue ResponseType = -10
	// Returned by Help buttons in GTK dialogs
	ResponseHelpValue ResponseType = -11
)

// Dialogs are a convenient way to prompt the user for a small amount
// of input.
//
// ![An example GtkDialog](dialog.png)
//
// Typical uses are to display a message, ask a question, or anything else
// that does not require extensive effort on the user’s part.
//
// The main area of a `GtkDialog` is called the "content area", and is yours
// to populate with widgets such a `GtkLabel` or `GtkEntry`, to present
// your information, questions, or tasks to the user.
//
// In addition, dialogs allow you to add "action widgets". Most commonly,
// action widgets are buttons. Depending on the platform, action widgets may
// be presented in the header bar at the top of the window, or at the bottom
// of the window. To add action widgets, create your `GtkDialog` using
// [ctor@Gtk.Dialog.new_with_buttons], or use
// [method@Gtk.Dialog.add_button], [method@Gtk.Dialog.add_buttons],
// or [method@Gtk.Dialog.add_action_widget].
//
// `GtkDialogs` uses some heuristics to decide whether to add a close
// button to the window decorations. If any of the action buttons use
// the response ID %GTK_RESPONSE_CLOSE or %GTK_RESPONSE_CANCEL, the
// close button is omitted.
//
// Clicking a button that was added as an action widget will emit the
// [signal@Gtk.Dialog::response] signal with a response ID that you specified.
// GTK will never assign a meaning to positive response IDs; these are
// entirely user-defined. But for convenience, you can use the response
// IDs in the [enum@Gtk.ResponseType] enumeration (these all have values
// less than zero). If a dialog receives a delete event, the
// [signal@Gtk.Dialog::response] signal will be emitted with the
// %GTK_RESPONSE_DELETE_EVENT response ID.
//
// Dialogs are created with a call to [ctor@Gtk.Dialog.new] or
// [ctor@Gtk.Dialog.new_with_buttons]. The latter is recommended; it allows
// you to set the dialog title, some convenient flags, and add buttons.
//
// A “modal” dialog (that is, one which freezes the rest of the application
// from user input), can be created by calling [method@Gtk.Window.set_modal]
// on the dialog. When using [ctor@Gtk.Dialog.new_with_buttons], you can also
// pass the %GTK_DIALOG_MODAL flag to make a dialog modal.
//
// For the simple dialog in the following example, a [class@Gtk.MessageDialog]
// would save some effort. But you’d need to create the dialog contents manually
// if you had more than a simple message in the dialog.
//
// An example for simple `GtkDialog` usage:
//
// ```c
// // Function to open a dialog box with a message
// void
// quick_message (GtkWindow *parent, char *message)
//
//	{
//	 GtkWidget *dialog, *label, *content_area;
//	 GtkDialogFlags flags;
//
//	 // Create the widgets
//	 flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//	 dialog = gtk_dialog_new_with_buttons ("Message",
//	                                       parent,
//	                                       flags,
//	                                       _("_OK"),
//	                                       GTK_RESPONSE_NONE,
//	                                       NULL);
//	 content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
//	 label = gtk_label_new (message);
//
//	 // Ensure that the dialog box is destroyed when the user responds
//
//	 g_signal_connect_swapped (dialog,
//	                           "response",
//	                           G_CALLBACK (gtk_window_destroy),
//	                           dialog);
//
//	 // Add the label, and show everything we’ve added
//
//	 gtk_box_append (GTK_BOX (content_area), label);
//	 gtk_widget_show (dialog);
//	}
//
// ```
//
// # GtkDialog as GtkBuildable
//
// The `GtkDialog` implementation of the `GtkBuildable` interface exposes the
// @content_area as an internal child with the name “content_area”.
//
// `GtkDialog` supports a custom `&lt;action-widgets&gt;` element, which can contain
// multiple `&lt;action-widget&gt;` elements. The “response” attribute specifies a
// numeric response, and the content of the element is the id of widget
// (which should be a child of the dialogs @action_area). To mark a response
// as default, set the “default” attribute of the `&lt;action-widget&gt;` element
// to true.
//
// `GtkDialog` supports adding action widgets by specifying “action” as
// the “type” attribute of a `&lt;child&gt;` element. The widget will be added
// either to the action area or the headerbar of the dialog, depending
// on the “use-header-bar” property. The response id has to be associated
// with the action widget using the `&lt;action-widgets&gt;` element.
//
// An example of a `GtkDialog` UI definition fragment:
//
// ```xml
// &lt;object class="GtkDialog" id="dialog1"&gt;
//
//	&lt;child type="action"&gt;
//	  &lt;object class="GtkButton" id="button_cancel"/&gt;
//	&lt;/child&gt;
//	&lt;child type="action"&gt;
//	  &lt;object class="GtkButton" id="button_ok"&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//	&lt;action-widgets&gt;
//	  &lt;action-widget response="cancel"&gt;button_cancel&lt;/action-widget&gt;
//	  &lt;action-widget response="ok" default="true"&gt;button_ok&lt;/action-widget&gt;
//	&lt;/action-widgets&gt;
//
// &lt;/object&gt;
// ```
//
// # Accessibility
//
// `GtkDialog` uses the %GTK_ACCESSIBLE_ROLE_DIALOG role.
type Dialog struct {
	Window
}

func DialogNewFromInternalPtr(ptr uintptr) *Dialog {
	cls := &Dialog{}
	cls.Ptr = ptr
	return cls
}

var xNewDialog func() uintptr

// Creates a new dialog box.
//
// Widgets should not be packed into the `GtkWindow`
// directly, but into the @content_area and @action_area,
// as described above.
func NewDialog() *Dialog {
	var cls *Dialog

	cret := xNewDialog()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Dialog{}
	cls.Ptr = cret
	return cls
}

var xNewDialogWithButtons func(string, uintptr, DialogFlags, string, ...interface{}) uintptr

// Creates a new `GtkDialog` with the given title and transient parent.
//
// The @flags argument can be used to make the dialog modal, have it
// destroyed along with its transient parent, or make it use a headerbar.
//
// Button text/response ID pairs should be listed in pairs, with a %NULL
// pointer ending the list. Button text can be arbitrary text. A response
// ID can be any positive number, or one of the values in the
// [enum@Gtk.ResponseType] enumeration. If the user clicks one of these
// buttons, `GtkDialog` will emit the [signal@Gtk.Dialog::response] signal
// with the corresponding response ID.
//
// If a `GtkDialog` receives a delete event, it will emit ::response with a
// response ID of %GTK_RESPONSE_DELETE_EVENT.
//
// However, destroying a dialog does not emit the ::response signal;
// so be careful relying on ::response when using the
// %GTK_DIALOG_DESTROY_WITH_PARENT flag.
//
// Here’s a simple example:
// ```c
// GtkWindow *main_app_window; // Window the dialog should show up on
// GtkWidget *dialog;
// GtkDialogFlags flags = GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT;
// dialog = gtk_dialog_new_with_buttons ("My dialog",
//
//	main_app_window,
//	flags,
//	_("_OK"),
//	GTK_RESPONSE_ACCEPT,
//	_("_Cancel"),
//	GTK_RESPONSE_REJECT,
//	NULL);
//
// ```
func NewDialogWithButtons(TitleVar string, ParentVar *Window, FlagsVar DialogFlags, FirstButtonTextVar string, varArgs ...interface{}) *Dialog {
	var cls *Dialog

	cret := xNewDialogWithButtons(TitleVar, ParentVar.GoPointer(), FlagsVar, FirstButtonTextVar, varArgs...)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Dialog{}
	cls.Ptr = cret
	return cls
}

var xDialogAddActionWidget func(uintptr, uintptr, int)

// Adds an activatable widget to the action area of a `GtkDialog`.
//
// GTK connects a signal handler that will emit the
// [signal@Gtk.Dialog::response] signal on the dialog when the widget
// is activated. The widget is appended to the end of the dialog’s action
// area.
//
// If you want to add a non-activatable widget, simply pack it into
// the @action_area field of the `GtkDialog` struct.
func (x *Dialog) AddActionWidget(ChildVar *Widget, ResponseIdVar int) {

	xDialogAddActionWidget(x.GoPointer(), ChildVar.GoPointer(), ResponseIdVar)

}

var xDialogAddButton func(uintptr, string, int) uintptr

// Adds a button with the given text.
//
// GTK arranges things so that clicking the button will emit the
// [signal@Gtk.Dialog::response] signal with the given @response_id.
// The button is appended to the end of the dialog’s action area.
// The button widget is returned, but usually you don’t need it.
func (x *Dialog) AddButton(ButtonTextVar string, ResponseIdVar int) *Widget {
	var cls *Widget

	cret := xDialogAddButton(x.GoPointer(), ButtonTextVar, ResponseIdVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xDialogAddButtons func(uintptr, string, ...interface{})

// Adds multiple buttons.
//
// This is the same as calling [method@Gtk.Dialog.add_button]
// repeatedly. The variable argument list should be %NULL-terminated
// as with [ctor@Gtk.Dialog.new_with_buttons]. Each button must have both
// text and response ID.
func (x *Dialog) AddButtons(FirstButtonTextVar string, varArgs ...interface{}) {

	xDialogAddButtons(x.GoPointer(), FirstButtonTextVar, varArgs...)

}

var xDialogGetContentArea func(uintptr) uintptr

// Returns the content area of @dialog.
func (x *Dialog) GetContentArea() *Box {
	var cls *Box

	cret := xDialogGetContentArea(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Box{}
	cls.Ptr = cret
	return cls
}

var xDialogGetHeaderBar func(uintptr) uintptr

// Returns the header bar of @dialog.
//
// Note that the headerbar is only used by the dialog if the
// [property@Gtk.Dialog:use-header-bar] property is %TRUE.
func (x *Dialog) GetHeaderBar() *HeaderBar {
	var cls *HeaderBar

	cret := xDialogGetHeaderBar(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &HeaderBar{}
	cls.Ptr = cret
	return cls
}

var xDialogGetResponseForWidget func(uintptr, uintptr) int

// Gets the response id of a widget in the action area
// of a dialog.
func (x *Dialog) GetResponseForWidget(WidgetVar *Widget) int {

	cret := xDialogGetResponseForWidget(x.GoPointer(), WidgetVar.GoPointer())
	return cret
}

var xDialogGetWidgetForResponse func(uintptr, int) uintptr

// Gets the widget button that uses the given response ID in the action area
// of a dialog.
func (x *Dialog) GetWidgetForResponse(ResponseIdVar int) *Widget {
	var cls *Widget

	cret := xDialogGetWidgetForResponse(x.GoPointer(), ResponseIdVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xDialogResponse func(uintptr, int)

// Emits the ::response signal with the given response ID.
//
// Used to indicate that the user has responded to the dialog in some way.
func (x *Dialog) Response(ResponseIdVar int) {

	xDialogResponse(x.GoPointer(), ResponseIdVar)

}

var xDialogSetDefaultResponse func(uintptr, int)

// Sets the default widget for the dialog based on the response ID.
//
// Pressing “Enter” normally activates the default widget.
func (x *Dialog) SetDefaultResponse(ResponseIdVar int) {

	xDialogSetDefaultResponse(x.GoPointer(), ResponseIdVar)

}

var xDialogSetResponseSensitive func(uintptr, int, bool)

// A convenient way to sensitize/desensitize dialog buttons.
//
// Calls `gtk_widget_set_sensitive (widget, @setting)`
// for each widget in the dialog’s action area with the given @response_id.
func (x *Dialog) SetResponseSensitive(ResponseIdVar int, SettingVar bool) {

	xDialogSetResponseSensitive(x.GoPointer(), ResponseIdVar, SettingVar)

}

func (c *Dialog) GoPointer() uintptr {
	return c.Ptr
}

func (c *Dialog) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the user uses a keybinding to close the dialog.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default binding for this signal is the Escape key.
func (x *Dialog) ConnectClose(cb *func(Dialog)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "close", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Dialog{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "close", cbRefPtr)
}

// Emitted when an action widget is clicked.
//
// The signal is also emitted when the dialog receives a
// delete event, and when [method@Gtk.Dialog.response] is called.
// On a delete event, the response ID is %GTK_RESPONSE_DELETE_EVENT.
// Otherwise, it depends on which action widget was clicked.
func (x *Dialog) ConnectResponse(cb *func(Dialog, int)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "response", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ResponseIdVarp int) {
		fa := Dialog{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ResponseIdVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "response", cbRefPtr)
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *Dialog) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *Dialog) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *Dialog) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *Dialog) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Dialog) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Dialog) UpdatePropertyValue(NPropertiesVar int, PropertiesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Dialog) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Dialog) UpdateRelationValue(NRelationsVar int, RelationsVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Dialog) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Dialog) UpdateStateValue(NStatesVar int, StatesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *Dialog) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Returns the renderer that is used for this `GtkNative`.
func (x *Dialog) GetRenderer() *gsk.Renderer {
	var cls *gsk.Renderer

	cret := XGtkNativeGetRenderer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gsk.Renderer{}
	cls.Ptr = cret
	return cls
}

// Returns the surface of this `GtkNative`.
func (x *Dialog) GetSurface() *gdk.Surface {
	var cls *gdk.Surface

	cret := XGtkNativeGetSurface(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Surface{}
	cls.Ptr = cret
	return cls
}

// Retrieves the surface transform of @self.
//
// This is the translation from @self's surface coordinates into
// @self's widget coordinates.
func (x *Dialog) GetSurfaceTransform(XVar float64, YVar float64) {

	XGtkNativeGetSurfaceTransform(x.GoPointer(), XVar, YVar)

}

// Realizes a `GtkNative`.
//
// This should only be used by subclasses.
func (x *Dialog) Realize() {

	XGtkNativeRealize(x.GoPointer())

}

// Unrealizes a `GtkNative`.
//
// This should only be used by subclasses.
func (x *Dialog) Unrealize() {

	XGtkNativeUnrealize(x.GoPointer())

}

// Returns the display that this `GtkRoot` is on.
func (x *Dialog) GetDisplay() *gdk.Display {
	var cls *gdk.Display

	cret := XGtkRootGetDisplay(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Display{}
	cls.Ptr = cret
	return cls
}

// Retrieves the current focused widget within the root.
//
// Note that this is the widget that would have the focus
// if the root is active; if the root is not focused then
// `gtk_widget_has_focus (widget)` will be %FALSE for the
// widget.
func (x *Dialog) GetFocus() *Widget {
	var cls *Widget

	cret := XGtkRootGetFocus(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

// If @focus is not the current focus widget, and is focusable, sets
// it as the focus widget for the root.
//
// If @focus is %NULL, unsets the focus widget for the root.
//
// To set the focus to a particular widget in the root, it is usually
// more convenient to use [method@Gtk.Widget.grab_focus] instead of
// this function.
func (x *Dialog) SetFocus(FocusVar *Widget) {

	XGtkRootSetFocus(x.GoPointer(), FocusVar.GoPointer())

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewDialog, lib, "gtk_dialog_new")
	core.PuregoSafeRegister(&xNewDialogWithButtons, lib, "gtk_dialog_new_with_buttons")

	core.PuregoSafeRegister(&xDialogAddActionWidget, lib, "gtk_dialog_add_action_widget")
	core.PuregoSafeRegister(&xDialogAddButton, lib, "gtk_dialog_add_button")
	core.PuregoSafeRegister(&xDialogAddButtons, lib, "gtk_dialog_add_buttons")
	core.PuregoSafeRegister(&xDialogGetContentArea, lib, "gtk_dialog_get_content_area")
	core.PuregoSafeRegister(&xDialogGetHeaderBar, lib, "gtk_dialog_get_header_bar")
	core.PuregoSafeRegister(&xDialogGetResponseForWidget, lib, "gtk_dialog_get_response_for_widget")
	core.PuregoSafeRegister(&xDialogGetWidgetForResponse, lib, "gtk_dialog_get_widget_for_response")
	core.PuregoSafeRegister(&xDialogResponse, lib, "gtk_dialog_response")
	core.PuregoSafeRegister(&xDialogSetDefaultResponse, lib, "gtk_dialog_set_default_response")
	core.PuregoSafeRegister(&xDialogSetResponseSensitive, lib, "gtk_dialog_set_response_sensitive")

}
