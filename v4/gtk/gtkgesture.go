// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type GestureClass struct {
	_ structs.HostLayout
}

func (x *GestureClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GtkGesture` is the base class for gesture recognition.
//
// Although `GtkGesture` is quite generalized to serve as a base for
// multi-touch gestures, it is suitable to implement single-touch and
// pointer-based gestures (using the special %NULL `GdkEventSequence`
// value for these).
//
// The number of touches that a `GtkGesture` need to be recognized is
// controlled by the [property@Gtk.Gesture:n-points] property, if a
// gesture is keeping track of less or more than that number of sequences,
// it won't check whether the gesture is recognized.
//
// As soon as the gesture has the expected number of touches, it will check
// regularly if it is recognized, the criteria to consider a gesture as
// "recognized" is left to `GtkGesture` subclasses.
//
// A recognized gesture will then emit the following signals:
//
// - [signal@Gtk.Gesture::begin] when the gesture is recognized.
// - [signal@Gtk.Gesture::update], whenever an input event is processed.
// - [signal@Gtk.Gesture::end] when the gesture is no longer recognized.
//
// ## Event propagation
//
// In order to receive events, a gesture needs to set a propagation phase
// through [method@Gtk.EventController.set_propagation_phase].
//
// In the capture phase, events are propagated from the toplevel down
// to the target widget, and gestures that are attached to containers
// above the widget get a chance to interact with the event before it
// reaches the target.
//
// In the bubble phase, events are propagated up from the target widget
// to the toplevel, and gestures that are attached to containers above
// the widget get a chance to interact with events that have not been
// handled yet.
//
// ## States of a sequence
//
// Whenever input interaction happens, a single event may trigger a cascade
// of `GtkGesture`s, both across the parents of the widget receiving the
// event and in parallel within an individual widget. It is a responsibility
// of the widgets using those gestures to set the state of touch sequences
// accordingly in order to enable cooperation of gestures around the
// `GdkEventSequence`s triggering those.
//
// Within a widget, gestures can be grouped through [method@Gtk.Gesture.group].
// Grouped gestures synchronize the state of sequences, so calling
// [method@Gtk.Gesture.set_sequence_state] on one will effectively propagate
// the state throughout the group.
//
// By default, all sequences start out in the %GTK_EVENT_SEQUENCE_NONE state,
// sequences in this state trigger the gesture event handler, but event
// propagation will continue unstopped by gestures.
//
// If a sequence enters into the %GTK_EVENT_SEQUENCE_DENIED state, the gesture
// group will effectively ignore the sequence, letting events go unstopped
// through the gesture, but the "slot" will still remain occupied while
// the touch is active.
//
// If a sequence enters in the %GTK_EVENT_SEQUENCE_CLAIMED state, the gesture
// group will grab all interaction on the sequence, by:
//
//   - Setting the same sequence to %GTK_EVENT_SEQUENCE_DENIED on every other
//     gesture group within the widget, and every gesture on parent widgets
//     in the propagation chain.
//   - Emitting [signal@Gtk.Gesture::cancel] on every gesture in widgets
//     underneath in the propagation chain.
//   - Stopping event propagation after the gesture group handles the event.
//
// Note: if a sequence is set early to %GTK_EVENT_SEQUENCE_CLAIMED on
// %GDK_TOUCH_BEGIN/%GDK_BUTTON_PRESS (so those events are captured before
// reaching the event widget, this implies %GTK_PHASE_CAPTURE), one similar
// event will be emulated if the sequence changes to %GTK_EVENT_SEQUENCE_DENIED.
// This way event coherence is preserved before event propagation is unstopped
// again.
//
// Sequence states can't be changed freely.
// See [method@Gtk.Gesture.set_sequence_state] to know about the possible
// lifetimes of a `GdkEventSequence`.
//
// ## Touchpad gestures
//
// On the platforms that support it, `GtkGesture` will handle transparently
// touchpad gesture events. The only precautions users of `GtkGesture` should
// do to enable this support are:
//
//   - If the gesture has %GTK_PHASE_NONE, ensuring events of type
//     %GDK_TOUCHPAD_SWIPE and %GDK_TOUCHPAD_PINCH are handled by the `GtkGesture`
type Gesture struct {
	EventController
}

var xGestureGLibType func() types.GType

func GestureGLibType() types.GType {
	return xGestureGLibType()
}

func GestureNewFromInternalPtr(ptr uintptr) *Gesture {
	cls := &Gesture{}
	cls.Ptr = ptr
	return cls
}

var xGestureGetBoundingBox func(uintptr, *gdk.Rectangle) bool

// If there are touch sequences being currently handled by @gesture,
// returns %TRUE and fills in @rect with the bounding box containing
// all active touches.
//
// Otherwise, %FALSE will be returned.
//
// Note: This function will yield unexpected results on touchpad
// gestures. Since there is no correlation between physical and
// pixel distances, these will look as if constrained in an
// infinitely small area, @rect width and height will thus be 0
// regardless of the number of touchpoints.
func (x *Gesture) GetBoundingBox(RectVar *gdk.Rectangle) bool {

	cret := xGestureGetBoundingBox(x.GoPointer(), RectVar)
	return cret
}

var xGestureGetBoundingBoxCenter func(uintptr, float64, float64) bool

// If there are touch sequences being currently handled by @gesture,
// returns %TRUE and fills in @x and @y with the center of the bounding
// box containing all active touches.
//
// Otherwise, %FALSE will be returned.
func (x *Gesture) GetBoundingBoxCenter(XVar float64, YVar float64) bool {

	cret := xGestureGetBoundingBoxCenter(x.GoPointer(), XVar, YVar)
	return cret
}

var xGestureGetDevice func(uintptr) uintptr

// Returns the logical `GdkDevice` that is currently operating
// on @gesture.
//
// This returns %NULL if the gesture is not being interacted.
func (x *Gesture) GetDevice() *gdk.Device {
	var cls *gdk.Device

	cret := xGestureGetDevice(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Device{}
	cls.Ptr = cret
	return cls
}

var xGestureGetGroup func(uintptr) *glib.List

// Returns all gestures in the group of @gesture
func (x *Gesture) GetGroup() *glib.List {

	cret := xGestureGetGroup(x.GoPointer())
	return cret
}

var xGestureGetLastEvent func(uintptr, *gdk.EventSequence) uintptr

// Returns the last event that was processed for @sequence.
//
// Note that the returned pointer is only valid as long as the
// @sequence is still interpreted by the @gesture. If in doubt,
// you should make a copy of the event.
func (x *Gesture) GetLastEvent(SequenceVar *gdk.EventSequence) *gdk.Event {
	var cls *gdk.Event

	cret := xGestureGetLastEvent(x.GoPointer(), SequenceVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Event{}
	cls.Ptr = cret
	return cls
}

var xGestureGetLastUpdatedSequence func(uintptr) *gdk.EventSequence

// Returns the `GdkEventSequence` that was last updated on @gesture.
func (x *Gesture) GetLastUpdatedSequence() *gdk.EventSequence {

	cret := xGestureGetLastUpdatedSequence(x.GoPointer())
	return cret
}

var xGestureGetPoint func(uintptr, *gdk.EventSequence, float64, float64) bool

// If @sequence is currently being interpreted by @gesture,
// returns %TRUE and fills in @x and @y with the last coordinates
// stored for that event sequence.
//
// The coordinates are always relative to the widget allocation.
func (x *Gesture) GetPoint(SequenceVar *gdk.EventSequence, XVar float64, YVar float64) bool {

	cret := xGestureGetPoint(x.GoPointer(), SequenceVar, XVar, YVar)
	return cret
}

var xGestureGetSequenceState func(uintptr, *gdk.EventSequence) EventSequenceState

// Returns the @sequence state, as seen by @gesture.
func (x *Gesture) GetSequenceState(SequenceVar *gdk.EventSequence) EventSequenceState {

	cret := xGestureGetSequenceState(x.GoPointer(), SequenceVar)
	return cret
}

var xGestureGetSequences func(uintptr) *glib.List

// Returns the list of `GdkEventSequences` currently being interpreted
// by @gesture.
func (x *Gesture) GetSequences() *glib.List {

	cret := xGestureGetSequences(x.GoPointer())
	return cret
}

var xGestureGroup func(uintptr, uintptr)

// Adds @gesture to the same group than @group_gesture.
//
// Gestures are by default isolated in their own groups.
//
// Both gestures must have been added to the same widget before
// they can be grouped.
//
// When gestures are grouped, the state of `GdkEventSequences`
// is kept in sync for all of those, so calling
// [method@Gtk.Gesture.set_sequence_state], on one will transfer
// the same value to the others.
//
// Groups also perform an "implicit grabbing" of sequences, if a
// `GdkEventSequence` state is set to %GTK_EVENT_SEQUENCE_CLAIMED
// on one group, every other gesture group attached to the same
// `GtkWidget` will switch the state for that sequence to
// %GTK_EVENT_SEQUENCE_DENIED.
func (x *Gesture) Group(GestureVar *Gesture) {

	xGestureGroup(x.GoPointer(), GestureVar.GoPointer())

}

var xGestureHandlesSequence func(uintptr, *gdk.EventSequence) bool

// Returns %TRUE if @gesture is currently handling events
// corresponding to @sequence.
func (x *Gesture) HandlesSequence(SequenceVar *gdk.EventSequence) bool {

	cret := xGestureHandlesSequence(x.GoPointer(), SequenceVar)
	return cret
}

var xGestureIsActive func(uintptr) bool

// Returns %TRUE if the gesture is currently active.
//
// A gesture is active while there are touch sequences
// interacting with it.
func (x *Gesture) IsActive() bool {

	cret := xGestureIsActive(x.GoPointer())
	return cret
}

var xGestureIsGroupedWith func(uintptr, uintptr) bool

// Returns %TRUE if both gestures pertain to the same group.
func (x *Gesture) IsGroupedWith(OtherVar *Gesture) bool {

	cret := xGestureIsGroupedWith(x.GoPointer(), OtherVar.GoPointer())
	return cret
}

var xGestureIsRecognized func(uintptr) bool

// Returns %TRUE if the gesture is currently recognized.
//
// A gesture is recognized if there are as many interacting
// touch sequences as required by @gesture.
func (x *Gesture) IsRecognized() bool {

	cret := xGestureIsRecognized(x.GoPointer())
	return cret
}

var xGestureSetSequenceState func(uintptr, *gdk.EventSequence, EventSequenceState) bool

// Sets the state of @sequence in @gesture.
//
// Sequences start in state %GTK_EVENT_SEQUENCE_NONE, and whenever
// they change state, they can never go back to that state. Likewise,
// sequences in state %GTK_EVENT_SEQUENCE_DENIED cannot turn back to
// a not denied state. With these rules, the lifetime of an event
// sequence is constrained to the next four:
//
// * None
// * None → Denied
// * None → Claimed
// * None → Claimed → Denied
//
// Note: Due to event handling ordering, it may be unsafe to set the
// state on another gesture within a [signal@Gtk.Gesture::begin] signal
// handler, as the callback might be executed before the other gesture
// knows about the sequence. A safe way to perform this could be:
//
// ```c
// static void
// first_gesture_begin_cb (GtkGesture       *first_gesture,
//
//	GdkEventSequence *sequence,
//	gpointer          user_data)
//
//	{
//	  gtk_gesture_set_sequence_state (first_gesture, sequence, GTK_EVENT_SEQUENCE_CLAIMED);
//	  gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
//	}
//
// static void
// second_gesture_begin_cb (GtkGesture       *second_gesture,
//
//	GdkEventSequence *sequence,
//	gpointer          user_data)
//
//	{
//	  if (gtk_gesture_get_sequence_state (first_gesture, sequence) == GTK_EVENT_SEQUENCE_CLAIMED)
//	    gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
//	}
//
// ```
//
// If both gestures are in the same group, just set the state on
// the gesture emitting the event, the sequence will be already
// be initialized to the group's global state when the second
// gesture processes the event.
func (x *Gesture) SetSequenceState(SequenceVar *gdk.EventSequence, StateVar EventSequenceState) bool {

	cret := xGestureSetSequenceState(x.GoPointer(), SequenceVar, StateVar)
	return cret
}

var xGestureSetState func(uintptr, EventSequenceState) bool

// Sets the state of all sequences that @gesture is currently
// interacting with.
//
// See [method@Gtk.Gesture.set_sequence_state] for more details
// on sequence states.
func (x *Gesture) SetState(StateVar EventSequenceState) bool {

	cret := xGestureSetState(x.GoPointer(), StateVar)
	return cret
}

var xGestureUngroup func(uintptr)

// Separates @gesture into an isolated group.
func (x *Gesture) Ungroup() {

	xGestureUngroup(x.GoPointer())

}

func (c *Gesture) GoPointer() uintptr {
	return c.Ptr
}

func (c *Gesture) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the gesture is recognized.
//
// This means the number of touch sequences matches
// [property@Gtk.Gesture:n-points].
//
// Note: These conditions may also happen when an extra touch
// (eg. a third touch on a 2-touches gesture) is lifted, in that
// situation @sequence won't pertain to the current set of active
// touches, so don't rely on this being true.
func (x *Gesture) ConnectBegin(cb *func(Gesture, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "begin", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, SequenceVarp uintptr) {
		fa := Gesture{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, SequenceVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "begin", cbRefPtr)
}

// Emitted whenever a sequence is cancelled.
//
// This usually happens on active touches when
// [method@Gtk.EventController.reset] is called on @gesture
// (manually, due to grabs...), or the individual @sequence
// was claimed by parent widgets' controllers (see
// [method@Gtk.Gesture.set_sequence_state]).
//
// @gesture must forget everything about @sequence as in
// response to this signal.
func (x *Gesture) ConnectCancel(cb *func(Gesture, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "cancel", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, SequenceVarp uintptr) {
		fa := Gesture{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, SequenceVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "cancel", cbRefPtr)
}

// Emitted when @gesture either stopped recognizing the event
// sequences as something to be handled, or the number of touch
// sequences became higher or lower than [property@Gtk.Gesture:n-points].
//
// Note: @sequence might not pertain to the group of sequences that
// were previously triggering recognition on @gesture (ie. a just
// pressed touch sequence that exceeds [property@Gtk.Gesture:n-points]).
// This situation may be detected by checking through
// [method@Gtk.Gesture.handles_sequence].
func (x *Gesture) ConnectEnd(cb *func(Gesture, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "end", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, SequenceVarp uintptr) {
		fa := Gesture{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, SequenceVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "end", cbRefPtr)
}

// Emitted whenever a sequence state changes.
//
// See [method@Gtk.Gesture.set_sequence_state] to know
// more about the expectable sequence lifetimes.
func (x *Gesture) ConnectSequenceStateChanged(cb *func(Gesture, uintptr, EventSequenceState)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "sequence-state-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, SequenceVarp uintptr, StateVarp EventSequenceState) {
		fa := Gesture{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, SequenceVarp, StateVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "sequence-state-changed", cbRefPtr)
}

// Emitted whenever an event is handled while the gesture is recognized.
//
// @sequence is guaranteed to pertain to the set of active touches.
func (x *Gesture) ConnectUpdate(cb *func(Gesture, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "update", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, SequenceVarp uintptr) {
		fa := Gesture{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, SequenceVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "update", cbRefPtr)
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xGestureGLibType, lib, "gtk_gesture_get_type")

	core.PuregoSafeRegister(&xGestureGetBoundingBox, lib, "gtk_gesture_get_bounding_box")
	core.PuregoSafeRegister(&xGestureGetBoundingBoxCenter, lib, "gtk_gesture_get_bounding_box_center")
	core.PuregoSafeRegister(&xGestureGetDevice, lib, "gtk_gesture_get_device")
	core.PuregoSafeRegister(&xGestureGetGroup, lib, "gtk_gesture_get_group")
	core.PuregoSafeRegister(&xGestureGetLastEvent, lib, "gtk_gesture_get_last_event")
	core.PuregoSafeRegister(&xGestureGetLastUpdatedSequence, lib, "gtk_gesture_get_last_updated_sequence")
	core.PuregoSafeRegister(&xGestureGetPoint, lib, "gtk_gesture_get_point")
	core.PuregoSafeRegister(&xGestureGetSequenceState, lib, "gtk_gesture_get_sequence_state")
	core.PuregoSafeRegister(&xGestureGetSequences, lib, "gtk_gesture_get_sequences")
	core.PuregoSafeRegister(&xGestureGroup, lib, "gtk_gesture_group")
	core.PuregoSafeRegister(&xGestureHandlesSequence, lib, "gtk_gesture_handles_sequence")
	core.PuregoSafeRegister(&xGestureIsActive, lib, "gtk_gesture_is_active")
	core.PuregoSafeRegister(&xGestureIsGroupedWith, lib, "gtk_gesture_is_grouped_with")
	core.PuregoSafeRegister(&xGestureIsRecognized, lib, "gtk_gesture_is_recognized")
	core.PuregoSafeRegister(&xGestureSetSequenceState, lib, "gtk_gesture_set_sequence_state")
	core.PuregoSafeRegister(&xGestureSetState, lib, "gtk_gesture_set_state")
	core.PuregoSafeRegister(&xGestureUngroup, lib, "gtk_gesture_ungroup")

}
