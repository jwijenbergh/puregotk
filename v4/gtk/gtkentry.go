// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/pango"
)

// Class structure for `GtkEntry`. All virtual functions have a default
// implementation. Derived classes may set the virtual function pointers for the
// signal handlers to %NULL, but must keep @get_text_area_size and
// @get_frame_size non-%NULL; either use the default implementation, or provide
// a custom one.
type EntryClass struct {
	ParentClass uintptr

	Padding uintptr
}

func (x *EntryClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Specifies the side of the entry at which an icon is placed.
type EntryIconPosition int

const (

	// At the beginning of the entry (depending on the text direction).
	EntryIconPrimaryValue EntryIconPosition = 0
	// At the end of the entry (depending on the text direction).
	EntryIconSecondaryValue EntryIconPosition = 1
)

// `GtkEntry` is a single line text entry widget.
//
// ![An example GtkEntry](entry.png)
//
// A fairly large set of key bindings are supported by default. If the
// entered text is longer than the allocation of the widget, the widget
// will scroll so that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information, it
// can be put into “password mode” using [method@Gtk.Entry.set_visibility].
// In this mode, entered text is displayed using a “invisible” character.
// By default, GTK picks the best invisible character that is available
// in the current font, but it can be changed with
// [method@Gtk.Entry.set_invisible_char].
//
// `GtkEntry` has the ability to display progress or activity
// information behind the text. To make an entry display such information,
// use [method@Gtk.Entry.set_progress_fraction] or
// [method@Gtk.Entry.set_progress_pulse_step].
//
// Additionally, `GtkEntry` can show icons at either side of the entry.
// These icons can be activatable by clicking, can be set up as drag source
// and can have tooltips. To add an icon, use
// [method@Gtk.Entry.set_icon_from_gicon] or one of the various other functions
// that set an icon from an icon name or a paintable. To trigger an action when
// the user clicks an icon, connect to the [signal@Gtk.Entry::icon-press] signal.
// To allow DND operations from an icon, use
// [method@Gtk.Entry.set_icon_drag_source]. To set a tooltip on an icon, use
// [method@Gtk.Entry.set_icon_tooltip_text] or the corresponding function
// for markup.
//
// Note that functionality or information that is only available by clicking
// on an icon in an entry may not be accessible at all to users which are not
// able to use a mouse or other pointing device. It is therefore recommended
// that any such functionality should also be available by other means, e.g.
// via the context menu of the entry.
//
// # CSS nodes
//
// ```
// entry[.flat][.warning][.error]
// ├── text[.readonly]
// ├── image.left
// ├── image.right
// ╰── [progress[.pulse]]
// ```
//
// `GtkEntry` has a main node with the name entry. Depending on the properties
// of the entry, the style classes .read-only and .flat may appear. The style
// classes .warning and .error may also be used with entries.
//
// When the entry shows icons, it adds subnodes with the name image and the
// style class .left or .right, depending on where the icon appears.
//
// When the entry shows progress, it adds a subnode with the name progress.
// The node has the style class .pulse when the shown progress is pulsing.
//
// For all the subnodes added to the text node in various situations,
// see [class@Gtk.Text].
//
// # GtkEntry as GtkBuildable
//
// The `GtkEntry` implementation of the `GtkBuildable` interface supports a
// custom &lt;attributes&gt; element, which supports any number of &lt;attribute&gt;
// elements. The &lt;attribute&gt; element has attributes named “name“, “value“,
// “start“ and “end“ and allows you to specify `PangoAttribute` values for
// this label.
//
// An example of a UI definition fragment specifying Pango attributes:
// ```xml
// &lt;object class="GtkEntry"&gt;
//
//	&lt;attributes&gt;
//	  &lt;attribute name="weight" value="PANGO_WEIGHT_BOLD"/&gt;
//	  &lt;attribute name="background" value="red" start="5" end="10"/&gt;
//	&lt;/attributes&gt;
//
// &lt;/object&gt;
// ```
//
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute
// is applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
//
// # Accessibility
//
// `GtkEntry` uses the %GTK_ACCESSIBLE_ROLE_TEXT_BOX role.
type Entry struct {
	Widget
}

func EntryNewFromInternalPtr(ptr uintptr) *Entry {
	cls := &Entry{}
	cls.Ptr = ptr
	return cls
}

var xNewEntry func() uintptr

// Creates a new entry.
func NewEntry() *Entry {
	var cls *Entry

	cret := xNewEntry()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Entry{}
	cls.Ptr = cret
	return cls
}

var xNewEntryWithBuffer func(uintptr) uintptr

// Creates a new entry with the specified text buffer.
func NewEntryWithBuffer(BufferVar *EntryBuffer) *Entry {
	var cls *Entry

	cret := xNewEntryWithBuffer(BufferVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Entry{}
	cls.Ptr = cret
	return cls
}

var xEntryGetActivatesDefault func(uintptr) bool

// Retrieves the value set by gtk_entry_set_activates_default().
func (x *Entry) GetActivatesDefault() bool {

	cret := xEntryGetActivatesDefault(x.GoPointer())
	return cret
}

var xEntryGetAlignment func(uintptr) float32

// Gets the value set by gtk_entry_set_alignment().
//
// See also: [property@Gtk.Editable:xalign]
func (x *Entry) GetAlignment() float32 {

	cret := xEntryGetAlignment(x.GoPointer())
	return cret
}

var xEntryGetAttributes func(uintptr) *pango.AttrList

// Gets the attribute list of the `GtkEntry`.
//
// See [method@Gtk.Entry.set_attributes].
func (x *Entry) GetAttributes() *pango.AttrList {

	cret := xEntryGetAttributes(x.GoPointer())
	return cret
}

var xEntryGetBuffer func(uintptr) uintptr

// Get the `GtkEntryBuffer` object which holds the text for
// this widget.
func (x *Entry) GetBuffer() *EntryBuffer {
	var cls *EntryBuffer

	cret := xEntryGetBuffer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EntryBuffer{}
	cls.Ptr = cret
	return cls
}

var xEntryGetCompletion func(uintptr) uintptr

// Returns the auxiliary completion object currently
// in use by @entry.
func (x *Entry) GetCompletion() *EntryCompletion {
	var cls *EntryCompletion

	cret := xEntryGetCompletion(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EntryCompletion{}
	cls.Ptr = cret
	return cls
}

var xEntryGetCurrentIconDragSource func(uintptr) int

// Returns the index of the icon which is the source of the
// current  DND operation, or -1.
func (x *Entry) GetCurrentIconDragSource() int {

	cret := xEntryGetCurrentIconDragSource(x.GoPointer())
	return cret
}

var xEntryGetExtraMenu func(uintptr) uintptr

// Gets the menu model set with gtk_entry_set_extra_menu().
func (x *Entry) GetExtraMenu() *gio.MenuModel {
	var cls *gio.MenuModel

	cret := xEntryGetExtraMenu(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.MenuModel{}
	cls.Ptr = cret
	return cls
}

var xEntryGetHasFrame func(uintptr) bool

// Gets the value set by gtk_entry_set_has_frame().
func (x *Entry) GetHasFrame() bool {

	cret := xEntryGetHasFrame(x.GoPointer())
	return cret
}

var xEntryGetIconActivatable func(uintptr, EntryIconPosition) bool

// Returns whether the icon is activatable.
func (x *Entry) GetIconActivatable(IconPosVar EntryIconPosition) bool {

	cret := xEntryGetIconActivatable(x.GoPointer(), IconPosVar)
	return cret
}

var xEntryGetIconArea func(uintptr, EntryIconPosition, *gdk.Rectangle)

// Gets the area where entry’s icon at @icon_pos is drawn.
//
// This function is useful when drawing something to the
// entry in a draw callback.
//
// If the entry is not realized or has no icon at the given
// position, @icon_area is filled with zeros. Otherwise,
// @icon_area will be filled with the icon's allocation,
// relative to @entry's allocation.
func (x *Entry) GetIconArea(IconPosVar EntryIconPosition, IconAreaVar *gdk.Rectangle) {

	xEntryGetIconArea(x.GoPointer(), IconPosVar, IconAreaVar)

}

var xEntryGetIconAtPos func(uintptr, int, int) int

// Finds the icon at the given position and return its index.
//
// The position’s coordinates are relative to the @entry’s
// top left corner. If @x, @y doesn’t lie inside an icon,
// -1 is returned. This function is intended for use in a
//
//	[signal@Gtk.Widget::query-tooltip] signal handler.
func (x *Entry) GetIconAtPos(XVar int, YVar int) int {

	cret := xEntryGetIconAtPos(x.GoPointer(), XVar, YVar)
	return cret
}

var xEntryGetIconGicon func(uintptr, EntryIconPosition) uintptr

// Retrieves the `GIcon` used for the icon.
//
// %NULL will be returned if there is no icon or if the icon was
// set by some other method (e.g., by `GdkPaintable` or icon name).
func (x *Entry) GetIconGicon(IconPosVar EntryIconPosition) *gio.IconBase {
	var cls *gio.IconBase

	cret := xEntryGetIconGicon(x.GoPointer(), IconPosVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.IconBase{}
	cls.Ptr = cret
	return cls
}

var xEntryGetIconName func(uintptr, EntryIconPosition) string

// Retrieves the icon name used for the icon.
//
// %NULL is returned if there is no icon or if the icon was set
// by some other method (e.g., by `GdkPaintable` or gicon).
func (x *Entry) GetIconName(IconPosVar EntryIconPosition) string {

	cret := xEntryGetIconName(x.GoPointer(), IconPosVar)
	return cret
}

var xEntryGetIconPaintable func(uintptr, EntryIconPosition) uintptr

// Retrieves the `GdkPaintable` used for the icon.
//
// If no `GdkPaintable` was used for the icon, %NULL is returned.
func (x *Entry) GetIconPaintable(IconPosVar EntryIconPosition) *gdk.PaintableBase {
	var cls *gdk.PaintableBase

	cret := xEntryGetIconPaintable(x.GoPointer(), IconPosVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.PaintableBase{}
	cls.Ptr = cret
	return cls
}

var xEntryGetIconSensitive func(uintptr, EntryIconPosition) bool

// Returns whether the icon appears sensitive or insensitive.
func (x *Entry) GetIconSensitive(IconPosVar EntryIconPosition) bool {

	cret := xEntryGetIconSensitive(x.GoPointer(), IconPosVar)
	return cret
}

var xEntryGetIconStorageType func(uintptr, EntryIconPosition) ImageType

// Gets the type of representation being used by the icon
// to store image data.
//
// If the icon has no image data, the return value will
// be %GTK_IMAGE_EMPTY.
func (x *Entry) GetIconStorageType(IconPosVar EntryIconPosition) ImageType {

	cret := xEntryGetIconStorageType(x.GoPointer(), IconPosVar)
	return cret
}

var xEntryGetIconTooltipMarkup func(uintptr, EntryIconPosition) string

// Gets the contents of the tooltip on the icon at the specified
// position in @entry.
func (x *Entry) GetIconTooltipMarkup(IconPosVar EntryIconPosition) string {

	cret := xEntryGetIconTooltipMarkup(x.GoPointer(), IconPosVar)
	return cret
}

var xEntryGetIconTooltipText func(uintptr, EntryIconPosition) string

// Gets the contents of the tooltip on the icon at the specified
// position in @entry.
func (x *Entry) GetIconTooltipText(IconPosVar EntryIconPosition) string {

	cret := xEntryGetIconTooltipText(x.GoPointer(), IconPosVar)
	return cret
}

var xEntryGetInputHints func(uintptr) InputHints

// Gets the input hints of this `GtkEntry`.
func (x *Entry) GetInputHints() InputHints {

	cret := xEntryGetInputHints(x.GoPointer())
	return cret
}

var xEntryGetInputPurpose func(uintptr) InputPurpose

// Gets the input purpose of the `GtkEntry`.
func (x *Entry) GetInputPurpose() InputPurpose {

	cret := xEntryGetInputPurpose(x.GoPointer())
	return cret
}

var xEntryGetInvisibleChar func(uintptr) uint32

// Retrieves the character displayed in place of the actual text
// in “password mode”.
func (x *Entry) GetInvisibleChar() uint32 {

	cret := xEntryGetInvisibleChar(x.GoPointer())
	return cret
}

var xEntryGetMaxLength func(uintptr) int

// Retrieves the maximum allowed length of the text in @entry.
//
// See [method@Gtk.Entry.set_max_length].
func (x *Entry) GetMaxLength() int {

	cret := xEntryGetMaxLength(x.GoPointer())
	return cret
}

var xEntryGetOverwriteMode func(uintptr) bool

// Gets whether the `GtkEntry` is in overwrite mode.
func (x *Entry) GetOverwriteMode() bool {

	cret := xEntryGetOverwriteMode(x.GoPointer())
	return cret
}

var xEntryGetPlaceholderText func(uintptr) string

// Retrieves the text that will be displayed when @entry
// is empty and unfocused
func (x *Entry) GetPlaceholderText() string {

	cret := xEntryGetPlaceholderText(x.GoPointer())
	return cret
}

var xEntryGetProgressFraction func(uintptr) float64

// Returns the current fraction of the task that’s been completed.
//
// See [method@Gtk.Entry.set_progress_fraction].
func (x *Entry) GetProgressFraction() float64 {

	cret := xEntryGetProgressFraction(x.GoPointer())
	return cret
}

var xEntryGetProgressPulseStep func(uintptr) float64

// Retrieves the pulse step set with
// gtk_entry_set_progress_pulse_step().
func (x *Entry) GetProgressPulseStep() float64 {

	cret := xEntryGetProgressPulseStep(x.GoPointer())
	return cret
}

var xEntryGetTabs func(uintptr) *pango.TabArray

// Gets the tabstops of the `GtkEntry.
//
// See [method@Gtk.Entry.set_tabs].
func (x *Entry) GetTabs() *pango.TabArray {

	cret := xEntryGetTabs(x.GoPointer())
	return cret
}

var xEntryGetTextLength func(uintptr) uint16

// Retrieves the current length of the text in @entry.
//
// This is equivalent to getting @entry's `GtkEntryBuffer`
// and calling [method@Gtk.EntryBuffer.get_length] on it.
func (x *Entry) GetTextLength() uint16 {

	cret := xEntryGetTextLength(x.GoPointer())
	return cret
}

var xEntryGetVisibility func(uintptr) bool

// Retrieves whether the text in @entry is visible.
//
// See [method@Gtk.Entry.set_visibility].
func (x *Entry) GetVisibility() bool {

	cret := xEntryGetVisibility(x.GoPointer())
	return cret
}

var xEntryGrabFocusWithoutSelecting func(uintptr) bool

// Causes @entry to have keyboard focus.
//
// It behaves like [method@Gtk.Widget.grab_focus], except that it doesn't
// select the contents of the entry. You only want to call this on some
// special entries which the user usually doesn't want to replace all text
// in, such as search-as-you-type entries.
func (x *Entry) GrabFocusWithoutSelecting() bool {

	cret := xEntryGrabFocusWithoutSelecting(x.GoPointer())
	return cret
}

var xEntryProgressPulse func(uintptr)

// Indicates that some progress is made, but you don’t
// know how much.
//
// Causes the entry’s progress indicator to enter “activity
// mode”, where a block bounces back and forth. Each call to
// gtk_entry_progress_pulse() causes the block to move by a
// little bit (the amount of movement per pulse is determined
// by [method@Gtk.Entry.set_progress_pulse_step]).
func (x *Entry) ProgressPulse() {

	xEntryProgressPulse(x.GoPointer())

}

var xEntryResetImContext func(uintptr)

// Reset the input method context of the entry if needed.
//
// This can be necessary in the case where modifying the buffer
// would confuse on-going input method behavior.
func (x *Entry) ResetImContext() {

	xEntryResetImContext(x.GoPointer())

}

var xEntrySetActivatesDefault func(uintptr, bool)

// Sets whether pressing Enter in the @entry will activate the default
// widget for the window containing the entry.
//
// This usually means that the dialog containing the entry will be closed,
// since the default widget is usually one of the dialog buttons.
func (x *Entry) SetActivatesDefault(SettingVar bool) {

	xEntrySetActivatesDefault(x.GoPointer(), SettingVar)

}

var xEntrySetAlignment func(uintptr, float32)

// Sets the alignment for the contents of the entry.
//
// This controls the horizontal positioning of the contents when
// the displayed text is shorter than the width of the entry.
//
// See also: [property@Gtk.Editable:xalign]
func (x *Entry) SetAlignment(XalignVar float32) {

	xEntrySetAlignment(x.GoPointer(), XalignVar)

}

var xEntrySetAttributes func(uintptr, *pango.AttrList)

// Sets a `PangoAttrList`.
//
// The attributes in the list are applied to the entry text.
//
// Since the attributes will be applies to text that changes
// as the user types, it makes most sense to use attributes
// with unlimited extent.
func (x *Entry) SetAttributes(AttrsVar *pango.AttrList) {

	xEntrySetAttributes(x.GoPointer(), AttrsVar)

}

var xEntrySetBuffer func(uintptr, uintptr)

// Set the `GtkEntryBuffer` object which holds the text for
// this widget.
func (x *Entry) SetBuffer(BufferVar *EntryBuffer) {

	xEntrySetBuffer(x.GoPointer(), BufferVar.GoPointer())

}

var xEntrySetCompletion func(uintptr, uintptr)

// Sets @completion to be the auxiliary completion object
// to use with @entry.
//
// All further configuration of the completion mechanism is
// done on @completion using the `GtkEntryCompletion` API.
// Completion is disabled if @completion is set to %NULL.
func (x *Entry) SetCompletion(CompletionVar *EntryCompletion) {

	xEntrySetCompletion(x.GoPointer(), CompletionVar.GoPointer())

}

var xEntrySetExtraMenu func(uintptr, uintptr)

// Sets a menu model to add when constructing
// the context menu for @entry.
func (x *Entry) SetExtraMenu(ModelVar *gio.MenuModel) {

	xEntrySetExtraMenu(x.GoPointer(), ModelVar.GoPointer())

}

var xEntrySetHasFrame func(uintptr, bool)

// Sets whether the entry has a beveled frame around it.
func (x *Entry) SetHasFrame(SettingVar bool) {

	xEntrySetHasFrame(x.GoPointer(), SettingVar)

}

var xEntrySetIconActivatable func(uintptr, EntryIconPosition, bool)

// Sets whether the icon is activatable.
func (x *Entry) SetIconActivatable(IconPosVar EntryIconPosition, ActivatableVar bool) {

	xEntrySetIconActivatable(x.GoPointer(), IconPosVar, ActivatableVar)

}

var xEntrySetIconDragSource func(uintptr, EntryIconPosition, uintptr, gdk.DragAction)

// Sets up the icon at the given position as drag source.
//
// This makes it so that GTK will start a drag
// operation when the user clicks and drags the icon.
func (x *Entry) SetIconDragSource(IconPosVar EntryIconPosition, ProviderVar *gdk.ContentProvider, ActionsVar gdk.DragAction) {

	xEntrySetIconDragSource(x.GoPointer(), IconPosVar, ProviderVar.GoPointer(), ActionsVar)

}

var xEntrySetIconFromGicon func(uintptr, EntryIconPosition, uintptr)

// Sets the icon shown in the entry at the specified position
// from the current icon theme.
//
// If the icon isn’t known, a “broken image” icon will be
// displayed instead.
//
// If @icon is %NULL, no icon will be shown in the
// specified position.
func (x *Entry) SetIconFromGicon(IconPosVar EntryIconPosition, IconVar gio.Icon) {

	xEntrySetIconFromGicon(x.GoPointer(), IconPosVar, IconVar.GoPointer())

}

var xEntrySetIconFromIconName func(uintptr, EntryIconPosition, string)

// Sets the icon shown in the entry at the specified position
// from the current icon theme.
//
// If the icon name isn’t known, a “broken image” icon will be
// displayed instead.
//
// If @icon_name is %NULL, no icon will be shown in the
// specified position.
func (x *Entry) SetIconFromIconName(IconPosVar EntryIconPosition, IconNameVar string) {

	xEntrySetIconFromIconName(x.GoPointer(), IconPosVar, IconNameVar)

}

var xEntrySetIconFromPaintable func(uintptr, EntryIconPosition, uintptr)

// Sets the icon shown in the specified position using a `GdkPaintable`.
//
// If @paintable is %NULL, no icon will be shown in the specified position.
func (x *Entry) SetIconFromPaintable(IconPosVar EntryIconPosition, PaintableVar gdk.Paintable) {

	xEntrySetIconFromPaintable(x.GoPointer(), IconPosVar, PaintableVar.GoPointer())

}

var xEntrySetIconSensitive func(uintptr, EntryIconPosition, bool)

// Sets the sensitivity for the specified icon.
func (x *Entry) SetIconSensitive(IconPosVar EntryIconPosition, SensitiveVar bool) {

	xEntrySetIconSensitive(x.GoPointer(), IconPosVar, SensitiveVar)

}

var xEntrySetIconTooltipMarkup func(uintptr, EntryIconPosition, string)

// Sets @tooltip as the contents of the tooltip for the icon at
// the specified position.
//
// @tooltip is assumed to be marked up with Pango Markup.
//
// Use %NULL for @tooltip to remove an existing tooltip.
//
// See also [method@Gtk.Widget.set_tooltip_markup] and
// [method@Gtk.Entry.set_icon_tooltip_text].
func (x *Entry) SetIconTooltipMarkup(IconPosVar EntryIconPosition, TooltipVar string) {

	xEntrySetIconTooltipMarkup(x.GoPointer(), IconPosVar, TooltipVar)

}

var xEntrySetIconTooltipText func(uintptr, EntryIconPosition, string)

// Sets @tooltip as the contents of the tooltip for the icon
// at the specified position.
//
// Use %NULL for @tooltip to remove an existing tooltip.
//
// See also [method@Gtk.Widget.set_tooltip_text] and
// [method@Gtk.Entry.set_icon_tooltip_markup].
//
// If you unset the widget tooltip via
// [method@Gtk.Widget.set_tooltip_text] or
// [method@Gtk.Widget.set_tooltip_markup], this sets
// [property@Gtk.Widget:has-tooltip] to %FALSE, which suppresses
// icon tooltips too. You can resolve this by then calling
// [method@Gtk.Widget.set_has_tooltip] to set
// [property@Gtk.Widget:has-tooltip] back to %TRUE, or
// setting at least one non-empty tooltip on any icon
// achieves the same result.
func (x *Entry) SetIconTooltipText(IconPosVar EntryIconPosition, TooltipVar string) {

	xEntrySetIconTooltipText(x.GoPointer(), IconPosVar, TooltipVar)

}

var xEntrySetInputHints func(uintptr, InputHints)

// Set additional hints which allow input methods to
// fine-tune their behavior.
func (x *Entry) SetInputHints(HintsVar InputHints) {

	xEntrySetInputHints(x.GoPointer(), HintsVar)

}

var xEntrySetInputPurpose func(uintptr, InputPurpose)

// Sets the input purpose which can be used by input methods
// to adjust their behavior.
func (x *Entry) SetInputPurpose(PurposeVar InputPurpose) {

	xEntrySetInputPurpose(x.GoPointer(), PurposeVar)

}

var xEntrySetInvisibleChar func(uintptr, uint32)

// Sets the character to use in place of the actual text
// in “password mode”.
//
// See [method@Gtk.Entry.set_visibility] for how to enable
// “password mode”.
//
// By default, GTK picks the best invisible char available in
// the current font. If you set the invisible char to 0, then
// the user will get no feedback at all; there will be no text
// on the screen as they type.
func (x *Entry) SetInvisibleChar(ChVar uint32) {

	xEntrySetInvisibleChar(x.GoPointer(), ChVar)

}

var xEntrySetMaxLength func(uintptr, int)

// Sets the maximum allowed length of the contents of the widget.
//
// If the current contents are longer than the given length, then
// they will be truncated to fit. The length is is in characters.
//
// This is equivalent to getting @entry's `GtkEntryBuffer` and
// calling [method@Gtk.EntryBuffer.set_max_length] on it.
func (x *Entry) SetMaxLength(MaxVar int) {

	xEntrySetMaxLength(x.GoPointer(), MaxVar)

}

var xEntrySetOverwriteMode func(uintptr, bool)

// Sets whether the text is overwritten when typing in the `GtkEntry`.
func (x *Entry) SetOverwriteMode(OverwriteVar bool) {

	xEntrySetOverwriteMode(x.GoPointer(), OverwriteVar)

}

var xEntrySetPlaceholderText func(uintptr, string)

// Sets text to be displayed in @entry when it is empty.
//
// This can be used to give a visual hint of the expected
// contents of the `GtkEntry`.
func (x *Entry) SetPlaceholderText(TextVar string) {

	xEntrySetPlaceholderText(x.GoPointer(), TextVar)

}

var xEntrySetProgressFraction func(uintptr, float64)

// Causes the entry’s progress indicator to “fill in” the given
// fraction of the bar.
//
// The fraction should be between 0.0 and 1.0, inclusive.
func (x *Entry) SetProgressFraction(FractionVar float64) {

	xEntrySetProgressFraction(x.GoPointer(), FractionVar)

}

var xEntrySetProgressPulseStep func(uintptr, float64)

// Sets the fraction of total entry width to move the progress
// bouncing block for each pulse.
//
// Use [method@Gtk.Entry.progress_pulse] to pulse
// the progress.
func (x *Entry) SetProgressPulseStep(FractionVar float64) {

	xEntrySetProgressPulseStep(x.GoPointer(), FractionVar)

}

var xEntrySetTabs func(uintptr, *pango.TabArray)

// Sets a `PangoTabArray`.
//
// The tabstops in the array are applied to the entry text.
func (x *Entry) SetTabs(TabsVar *pango.TabArray) {

	xEntrySetTabs(x.GoPointer(), TabsVar)

}

var xEntrySetVisibility func(uintptr, bool)

// Sets whether the contents of the entry are visible or not.
//
// When visibility is set to %FALSE, characters are displayed
// as the invisible char, and will also appear that way when
// the text in the entry widget is copied elsewhere.
//
// By default, GTK picks the best invisible character available
// in the current font, but it can be changed with
// [method@Gtk.Entry.set_invisible_char].
//
// Note that you probably want to set [property@Gtk.Entry:input-purpose]
// to %GTK_INPUT_PURPOSE_PASSWORD or %GTK_INPUT_PURPOSE_PIN to
// inform input methods about the purpose of this entry,
// in addition to setting visibility to %FALSE.
func (x *Entry) SetVisibility(VisibleVar bool) {

	xEntrySetVisibility(x.GoPointer(), VisibleVar)

}

var xEntryUnsetInvisibleChar func(uintptr)

// Unsets the invisible char, so that the default invisible char
// is used again. See [method@Gtk.Entry.set_invisible_char].
func (x *Entry) UnsetInvisibleChar() {

	xEntryUnsetInvisibleChar(x.GoPointer())

}

func (c *Entry) GoPointer() uintptr {
	return c.Ptr
}

func (c *Entry) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the entry is activated.
//
// The keybindings for this signal are all forms of the Enter key.
func (x *Entry) ConnectActivate(cb *func(Entry)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Entry{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
}

// Emitted when an activatable icon is clicked.
func (x *Entry) ConnectIconPress(cb *func(Entry, EntryIconPosition)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "icon-press", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, IconPosVarp EntryIconPosition) {
		fa := Entry{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, IconPosVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "icon-press", cbRefPtr)
}

// Emitted on the button release from a mouse click
// over an activatable icon.
func (x *Entry) ConnectIconRelease(cb *func(Entry, EntryIconPosition)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "icon-release", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, IconPosVarp EntryIconPosition) {
		fa := Entry{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, IconPosVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "icon-release", cbRefPtr)
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *Entry) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *Entry) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *Entry) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *Entry) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Entry) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Entry) UpdatePropertyValue(NPropertiesVar int, PropertiesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Entry) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Entry) UpdateRelationValue(NRelationsVar int, RelationsVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Entry) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Entry) UpdateStateValue(NStatesVar int, StatesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *Entry) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Emits the `GtkCellEditable::editing-done` signal.
func (x *Entry) EditingDone() {

	XGtkCellEditableEditingDone(x.GoPointer())

}

// Emits the `GtkCellEditable::remove-widget` signal.
func (x *Entry) RemoveWidget() {

	XGtkCellEditableRemoveWidget(x.GoPointer())

}

// Begins editing on a @cell_editable.
//
// The `GtkCellRenderer` for the cell creates and returns a `GtkCellEditable` from
// gtk_cell_renderer_start_editing(), configured for the `GtkCellRenderer` type.
//
// gtk_cell_editable_start_editing() can then set up @cell_editable suitably for
// editing a cell, e.g. making the Esc key emit `GtkCellEditable::editing-done`.
//
// Note that the @cell_editable is created on-demand for the current edit; its
// lifetime is temporary and does not persist across other edits and/or cells.
func (x *Entry) StartEditing(EventVar *gdk.Event) {

	XGtkCellEditableStartEditing(x.GoPointer(), EventVar.GoPointer())

}

// Deletes the currently selected text of the editable.
//
// This call doesn’t do anything if there is no selected text.
func (x *Entry) DeleteSelection() {

	XGtkEditableDeleteSelection(x.GoPointer())

}

// Deletes a sequence of characters.
//
// The characters that are deleted are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is
// negative, then the characters deleted are those from @start_pos to
// the end of the text.
//
// Note that the positions are specified in characters, not bytes.
func (x *Entry) DeleteText(StartPosVar int, EndPosVar int) {

	XGtkEditableDeleteText(x.GoPointer(), StartPosVar, EndPosVar)

}

// Undoes the setup done by [method@Gtk.Editable.init_delegate].
//
// This is a helper function that should be called from dispose,
// before removing the delegate object.
func (x *Entry) FinishDelegate() {

	XGtkEditableFinishDelegate(x.GoPointer())

}

// Retrieves a sequence of characters.
//
// The characters that are retrieved are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is negative,
// then the characters retrieved are those characters from @start_pos to
// the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (x *Entry) GetChars(StartPosVar int, EndPosVar int) string {

	cret := XGtkEditableGetChars(x.GoPointer(), StartPosVar, EndPosVar)
	return cret
}

// Gets the `GtkEditable` that @editable is delegating its
// implementation to.
//
// Typically, the delegate is a [class@Gtk.Text] widget.
func (x *Entry) GetDelegate() *EditableBase {
	var cls *EditableBase

	cret := XGtkEditableGetDelegate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EditableBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves whether @editable is editable.
func (x *Entry) GetEditable() bool {

	cret := XGtkEditableGetEditable(x.GoPointer())
	return cret
}

// Gets if undo/redo actions are enabled for @editable
func (x *Entry) GetEnableUndo() bool {

	cret := XGtkEditableGetEnableUndo(x.GoPointer())
	return cret
}

// Retrieves the desired maximum width of @editable, in characters.
func (x *Entry) GetMaxWidthChars() int {

	cret := XGtkEditableGetMaxWidthChars(x.GoPointer())
	return cret
}

// Retrieves the current position of the cursor relative
// to the start of the content of the editable.
//
// Note that this position is in characters, not in bytes.
func (x *Entry) GetPosition() int {

	cret := XGtkEditableGetPosition(x.GoPointer())
	return cret
}

// Retrieves the selection bound of the editable.
//
// @start_pos will be filled with the start of the selection and
// @end_pos with end. If no text was selected both will be identical
// and %FALSE will be returned.
//
// Note that positions are specified in characters, not bytes.
func (x *Entry) GetSelectionBounds(StartPosVar int, EndPosVar int) bool {

	cret := XGtkEditableGetSelectionBounds(x.GoPointer(), StartPosVar, EndPosVar)
	return cret
}

// Retrieves the contents of @editable.
//
// The returned string is owned by GTK and must not be modified or freed.
func (x *Entry) GetText() string {

	cret := XGtkEditableGetText(x.GoPointer())
	return cret
}

// Gets the number of characters of space reserved
// for the contents of the editable.
func (x *Entry) GetWidthChars() int {

	cret := XGtkEditableGetWidthChars(x.GoPointer())
	return cret
}

// Sets up a delegate for `GtkEditable`.
//
// This is assuming that the get_delegate vfunc in the `GtkEditable`
// interface has been set up for the @editable's type.
//
// This is a helper function that should be called in instance init,
// after creating the delegate object.
func (x *Entry) InitDelegate() {

	XGtkEditableInitDelegate(x.GoPointer())

}

// Inserts @length bytes of @text into the contents of the
// widget, at position @position.
//
// Note that the position is in characters, not in bytes.
// The function updates @position to point after the newly
// inserted text.
func (x *Entry) InsertText(TextVar string, LengthVar int, PositionVar int) {

	XGtkEditableInsertText(x.GoPointer(), TextVar, LengthVar, PositionVar)

}

// Selects a region of text.
//
// The characters that are selected are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is
// negative, then the characters selected are those characters from
// @start_pos to  the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (x *Entry) SelectRegion(StartPosVar int, EndPosVar int) {

	XGtkEditableSelectRegion(x.GoPointer(), StartPosVar, EndPosVar)

}

// Determines if the user can edit the text in the editable widget.
func (x *Entry) SetEditable(IsEditableVar bool) {

	XGtkEditableSetEditable(x.GoPointer(), IsEditableVar)

}

// If enabled, changes to @editable will be saved for undo/redo
// actions.
//
// This results in an additional copy of text changes and are not
// stored in secure memory. As such, undo is forcefully disabled
// when [property@Gtk.Text:visibility] is set to %FALSE.
func (x *Entry) SetEnableUndo(EnableUndoVar bool) {

	XGtkEditableSetEnableUndo(x.GoPointer(), EnableUndoVar)

}

// Sets the desired maximum width in characters of @editable.
func (x *Entry) SetMaxWidthChars(NCharsVar int) {

	XGtkEditableSetMaxWidthChars(x.GoPointer(), NCharsVar)

}

// Sets the cursor position in the editable to the given value.
//
// The cursor is displayed before the character with the given (base 0)
// index in the contents of the editable. The value must be less than
// or equal to the number of characters in the editable. A value of -1
// indicates that the position should be set after the last character
// of the editable. Note that @position is in characters, not in bytes.
func (x *Entry) SetPosition(PositionVar int) {

	XGtkEditableSetPosition(x.GoPointer(), PositionVar)

}

// Sets the text in the editable to the given value.
//
// This is replacing the current contents.
func (x *Entry) SetText(TextVar string) {

	XGtkEditableSetText(x.GoPointer(), TextVar)

}

// Changes the size request of the editable to be about the
// right size for @n_chars characters.
//
// Note that it changes the size request, the size can still
// be affected by how you pack the widget into containers.
// If @n_chars is -1, the size reverts to the default size.
func (x *Entry) SetWidthChars(NCharsVar int) {

	XGtkEditableSetWidthChars(x.GoPointer(), NCharsVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewEntry, lib, "gtk_entry_new")
	core.PuregoSafeRegister(&xNewEntryWithBuffer, lib, "gtk_entry_new_with_buffer")

	core.PuregoSafeRegister(&xEntryGetActivatesDefault, lib, "gtk_entry_get_activates_default")
	core.PuregoSafeRegister(&xEntryGetAlignment, lib, "gtk_entry_get_alignment")
	core.PuregoSafeRegister(&xEntryGetAttributes, lib, "gtk_entry_get_attributes")
	core.PuregoSafeRegister(&xEntryGetBuffer, lib, "gtk_entry_get_buffer")
	core.PuregoSafeRegister(&xEntryGetCompletion, lib, "gtk_entry_get_completion")
	core.PuregoSafeRegister(&xEntryGetCurrentIconDragSource, lib, "gtk_entry_get_current_icon_drag_source")
	core.PuregoSafeRegister(&xEntryGetExtraMenu, lib, "gtk_entry_get_extra_menu")
	core.PuregoSafeRegister(&xEntryGetHasFrame, lib, "gtk_entry_get_has_frame")
	core.PuregoSafeRegister(&xEntryGetIconActivatable, lib, "gtk_entry_get_icon_activatable")
	core.PuregoSafeRegister(&xEntryGetIconArea, lib, "gtk_entry_get_icon_area")
	core.PuregoSafeRegister(&xEntryGetIconAtPos, lib, "gtk_entry_get_icon_at_pos")
	core.PuregoSafeRegister(&xEntryGetIconGicon, lib, "gtk_entry_get_icon_gicon")
	core.PuregoSafeRegister(&xEntryGetIconName, lib, "gtk_entry_get_icon_name")
	core.PuregoSafeRegister(&xEntryGetIconPaintable, lib, "gtk_entry_get_icon_paintable")
	core.PuregoSafeRegister(&xEntryGetIconSensitive, lib, "gtk_entry_get_icon_sensitive")
	core.PuregoSafeRegister(&xEntryGetIconStorageType, lib, "gtk_entry_get_icon_storage_type")
	core.PuregoSafeRegister(&xEntryGetIconTooltipMarkup, lib, "gtk_entry_get_icon_tooltip_markup")
	core.PuregoSafeRegister(&xEntryGetIconTooltipText, lib, "gtk_entry_get_icon_tooltip_text")
	core.PuregoSafeRegister(&xEntryGetInputHints, lib, "gtk_entry_get_input_hints")
	core.PuregoSafeRegister(&xEntryGetInputPurpose, lib, "gtk_entry_get_input_purpose")
	core.PuregoSafeRegister(&xEntryGetInvisibleChar, lib, "gtk_entry_get_invisible_char")
	core.PuregoSafeRegister(&xEntryGetMaxLength, lib, "gtk_entry_get_max_length")
	core.PuregoSafeRegister(&xEntryGetOverwriteMode, lib, "gtk_entry_get_overwrite_mode")
	core.PuregoSafeRegister(&xEntryGetPlaceholderText, lib, "gtk_entry_get_placeholder_text")
	core.PuregoSafeRegister(&xEntryGetProgressFraction, lib, "gtk_entry_get_progress_fraction")
	core.PuregoSafeRegister(&xEntryGetProgressPulseStep, lib, "gtk_entry_get_progress_pulse_step")
	core.PuregoSafeRegister(&xEntryGetTabs, lib, "gtk_entry_get_tabs")
	core.PuregoSafeRegister(&xEntryGetTextLength, lib, "gtk_entry_get_text_length")
	core.PuregoSafeRegister(&xEntryGetVisibility, lib, "gtk_entry_get_visibility")
	core.PuregoSafeRegister(&xEntryGrabFocusWithoutSelecting, lib, "gtk_entry_grab_focus_without_selecting")
	core.PuregoSafeRegister(&xEntryProgressPulse, lib, "gtk_entry_progress_pulse")
	core.PuregoSafeRegister(&xEntryResetImContext, lib, "gtk_entry_reset_im_context")
	core.PuregoSafeRegister(&xEntrySetActivatesDefault, lib, "gtk_entry_set_activates_default")
	core.PuregoSafeRegister(&xEntrySetAlignment, lib, "gtk_entry_set_alignment")
	core.PuregoSafeRegister(&xEntrySetAttributes, lib, "gtk_entry_set_attributes")
	core.PuregoSafeRegister(&xEntrySetBuffer, lib, "gtk_entry_set_buffer")
	core.PuregoSafeRegister(&xEntrySetCompletion, lib, "gtk_entry_set_completion")
	core.PuregoSafeRegister(&xEntrySetExtraMenu, lib, "gtk_entry_set_extra_menu")
	core.PuregoSafeRegister(&xEntrySetHasFrame, lib, "gtk_entry_set_has_frame")
	core.PuregoSafeRegister(&xEntrySetIconActivatable, lib, "gtk_entry_set_icon_activatable")
	core.PuregoSafeRegister(&xEntrySetIconDragSource, lib, "gtk_entry_set_icon_drag_source")
	core.PuregoSafeRegister(&xEntrySetIconFromGicon, lib, "gtk_entry_set_icon_from_gicon")
	core.PuregoSafeRegister(&xEntrySetIconFromIconName, lib, "gtk_entry_set_icon_from_icon_name")
	core.PuregoSafeRegister(&xEntrySetIconFromPaintable, lib, "gtk_entry_set_icon_from_paintable")
	core.PuregoSafeRegister(&xEntrySetIconSensitive, lib, "gtk_entry_set_icon_sensitive")
	core.PuregoSafeRegister(&xEntrySetIconTooltipMarkup, lib, "gtk_entry_set_icon_tooltip_markup")
	core.PuregoSafeRegister(&xEntrySetIconTooltipText, lib, "gtk_entry_set_icon_tooltip_text")
	core.PuregoSafeRegister(&xEntrySetInputHints, lib, "gtk_entry_set_input_hints")
	core.PuregoSafeRegister(&xEntrySetInputPurpose, lib, "gtk_entry_set_input_purpose")
	core.PuregoSafeRegister(&xEntrySetInvisibleChar, lib, "gtk_entry_set_invisible_char")
	core.PuregoSafeRegister(&xEntrySetMaxLength, lib, "gtk_entry_set_max_length")
	core.PuregoSafeRegister(&xEntrySetOverwriteMode, lib, "gtk_entry_set_overwrite_mode")
	core.PuregoSafeRegister(&xEntrySetPlaceholderText, lib, "gtk_entry_set_placeholder_text")
	core.PuregoSafeRegister(&xEntrySetProgressFraction, lib, "gtk_entry_set_progress_fraction")
	core.PuregoSafeRegister(&xEntrySetProgressPulseStep, lib, "gtk_entry_set_progress_pulse_step")
	core.PuregoSafeRegister(&xEntrySetTabs, lib, "gtk_entry_set_tabs")
	core.PuregoSafeRegister(&xEntrySetVisibility, lib, "gtk_entry_set_visibility")
	core.PuregoSafeRegister(&xEntryUnsetInvisibleChar, lib, "gtk_entry_unset_invisible_char")

}
