// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/graphene"
	"github.com/jwijenbergh/puregotk/v4/pango"
)

// The `GtkText` widget is a single-line text entry widget.
//
// `GtkText` is the common implementation of single-line text editing
// that is shared between `GtkEntry`, `GtkPasswordEntry`, `GtkSpinButton`
// and other widgets. In all of these, `GtkText` is used as the delegate
// for the [iface@Gtk.Editable] implementation.
//
// A fairly large set of key bindings are supported by default. If the
// entered text is longer than the allocation of the widget, the widget
// will scroll so that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information,
// it can be put into “password mode” using [method@Gtk.Text.set_visibility].
// In this mode, entered text is displayed using a “invisible” character.
// By default, GTK picks the best invisible character that is available
// in the current font, but it can be changed with
// [method@Gtk.Text.set_invisible_char].
//
// If you are looking to add icons or progress display in an entry, look
// at `GtkEntry`. There other alternatives for more specialized use cases,
// such as `GtkSearchEntry`.
//
// If you need multi-line editable text, look at `GtkTextView`.
//
// # CSS nodes
//
// ```
// text[.read-only]
// ├── placeholder
// ├── undershoot.left
// ├── undershoot.right
// ├── [selection]
// ├── [block-cursor]
// ╰── [window.popup]
// ```
//
// `GtkText` has a main node with the name text. Depending on the properties
// of the widget, the .read-only style class may appear.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry is in overwrite mode, it adds a subnode with the name
// block-cursor that determines how the block cursor is drawn.
//
// The CSS node for a context menu is added as a subnode below text as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using
// CSS nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
//
// # Accessibility
//
// `GtkText` uses the %GTK_ACCESSIBLE_ROLE_NONE role, which causes it to be
// skipped for accessibility. This is because `GtkText` is expected to be used
// as a delegate for a `GtkEditable` implementation that will be represented
// to accessibility.
type Text struct {
	Widget
}

func TextNewFromInternalPtr(ptr uintptr) *Text {
	cls := &Text{}
	cls.Ptr = ptr
	return cls
}

var xNewText func() uintptr

// Creates a new `GtkText`.
func NewText() *Text {
	var cls *Text

	cret := xNewText()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Text{}
	cls.Ptr = cret
	return cls
}

var xNewTextWithBuffer func(uintptr) uintptr

// Creates a new `GtkText` with the specified text buffer.
func NewTextWithBuffer(BufferVar *EntryBuffer) *Text {
	var cls *Text

	cret := xNewTextWithBuffer(BufferVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Text{}
	cls.Ptr = cret
	return cls
}

var xTextComputeCursorExtents func(uintptr, uint, *graphene.Rect, *graphene.Rect)

// Determine the positions of the strong and weak cursors if the
// insertion point in the layout is at @position.
//
// The position of each cursor is stored as a zero-width rectangle.
// The strong cursor location is the location where characters of
// the directionality equal to the base direction are inserted.
// The weak cursor location is the location where characters of
// the directionality opposite to the base direction are inserted.
//
// The rectangle positions are in widget coordinates.
func (x *Text) ComputeCursorExtents(PositionVar uint, StrongVar *graphene.Rect, WeakVar *graphene.Rect) {

	xTextComputeCursorExtents(x.GoPointer(), PositionVar, StrongVar, WeakVar)

}

var xTextGetActivatesDefault func(uintptr) bool

// Returns whether pressing Enter will activate
// the default widget for the window containing @self.
//
// See [method@Gtk.Text.set_activates_default].
func (x *Text) GetActivatesDefault() bool {

	cret := xTextGetActivatesDefault(x.GoPointer())
	return cret
}

var xTextGetAttributes func(uintptr) *pango.AttrList

// Gets the attribute list that was set on the `GtkText`.
//
// See [method@Gtk.Text.set_attributes].
func (x *Text) GetAttributes() *pango.AttrList {

	cret := xTextGetAttributes(x.GoPointer())
	return cret
}

var xTextGetBuffer func(uintptr) uintptr

// Get the `GtkEntryBuffer` object which holds the text for
// this widget.
func (x *Text) GetBuffer() *EntryBuffer {
	var cls *EntryBuffer

	cret := xTextGetBuffer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EntryBuffer{}
	cls.Ptr = cret
	return cls
}

var xTextGetEnableEmojiCompletion func(uintptr) bool

// Returns whether Emoji completion is enabled for this
// `GtkText` widget.
func (x *Text) GetEnableEmojiCompletion() bool {

	cret := xTextGetEnableEmojiCompletion(x.GoPointer())
	return cret
}

var xTextGetExtraMenu func(uintptr) uintptr

// Gets the menu model for extra items in the context menu.
//
// See [method@Gtk.Text.set_extra_menu].
func (x *Text) GetExtraMenu() *gio.MenuModel {
	var cls *gio.MenuModel

	cret := xTextGetExtraMenu(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.MenuModel{}
	cls.Ptr = cret
	return cls
}

var xTextGetInputHints func(uintptr) InputHints

// Gets the input hints of the `GtkText`.
func (x *Text) GetInputHints() InputHints {

	cret := xTextGetInputHints(x.GoPointer())
	return cret
}

var xTextGetInputPurpose func(uintptr) InputPurpose

// Gets the input purpose of the `GtkText`.
func (x *Text) GetInputPurpose() InputPurpose {

	cret := xTextGetInputPurpose(x.GoPointer())
	return cret
}

var xTextGetInvisibleChar func(uintptr) uint32

// Retrieves the character displayed when visibility is set to false.
//
// Note that GTK does not compute this value unless it needs it,
// so the value returned by this function is not very useful unless
// it has been explicitly set with [method@Gtk.Text.set_invisible_char].
func (x *Text) GetInvisibleChar() uint32 {

	cret := xTextGetInvisibleChar(x.GoPointer())
	return cret
}

var xTextGetMaxLength func(uintptr) int

// Retrieves the maximum allowed length of the text in @self.
//
// See [method@Gtk.Text.set_max_length].
//
// This is equivalent to getting @self's `GtkEntryBuffer` and
// calling [method@Gtk.EntryBuffer.get_max_length] on it.
func (x *Text) GetMaxLength() int {

	cret := xTextGetMaxLength(x.GoPointer())
	return cret
}

var xTextGetOverwriteMode func(uintptr) bool

// Gets whether text is overwritten when typing in the `GtkText`.
//
// See [method@Gtk.Text.set_overwrite_mode].
func (x *Text) GetOverwriteMode() bool {

	cret := xTextGetOverwriteMode(x.GoPointer())
	return cret
}

var xTextGetPlaceholderText func(uintptr) string

// Retrieves the text that will be displayed when
// @self is empty and unfocused
//
// If no placeholder text has been set, %NULL will be returned.
func (x *Text) GetPlaceholderText() string {

	cret := xTextGetPlaceholderText(x.GoPointer())
	return cret
}

var xTextGetPropagateTextWidth func(uintptr) bool

// Returns whether the `GtkText` will grow and shrink
// with the content.
func (x *Text) GetPropagateTextWidth() bool {

	cret := xTextGetPropagateTextWidth(x.GoPointer())
	return cret
}

var xTextGetTabs func(uintptr) *pango.TabArray

// Gets the tabstops that were set on the `GtkText`.
//
// See [method@Gtk.Text.set_tabs].
func (x *Text) GetTabs() *pango.TabArray {

	cret := xTextGetTabs(x.GoPointer())
	return cret
}

var xTextGetTextLength func(uintptr) uint16

// Retrieves the current length of the text in @self.
//
// This is equivalent to getting @self's `GtkEntryBuffer`
// and calling [method@Gtk.EntryBuffer.get_length] on it.
func (x *Text) GetTextLength() uint16 {

	cret := xTextGetTextLength(x.GoPointer())
	return cret
}

var xTextGetTruncateMultiline func(uintptr) bool

// Returns whether the `GtkText` will truncate multi-line text
// that is pasted into the widget
func (x *Text) GetTruncateMultiline() bool {

	cret := xTextGetTruncateMultiline(x.GoPointer())
	return cret
}

var xTextGetVisibility func(uintptr) bool

// Retrieves whether the text in @self is visible.
func (x *Text) GetVisibility() bool {

	cret := xTextGetVisibility(x.GoPointer())
	return cret
}

var xTextGrabFocusWithoutSelecting func(uintptr) bool

// Causes @self to have keyboard focus.
//
// It behaves like [method@Gtk.Widget.grab_focus],
// except that it doesn't select the contents of @self.
// You only want to call this on some special entries
// which the user usually doesn't want to replace all text in,
// such as search-as-you-type entries.
func (x *Text) GrabFocusWithoutSelecting() bool {

	cret := xTextGrabFocusWithoutSelecting(x.GoPointer())
	return cret
}

var xTextSetActivatesDefault func(uintptr, bool)

// If @activates is %TRUE, pressing Enter will activate
// the default widget for the window containing @self.
//
// This usually means that the dialog containing the `GtkText`
// will be closed, since the default widget is usually one of
// the dialog buttons.
func (x *Text) SetActivatesDefault(ActivatesVar bool) {

	xTextSetActivatesDefault(x.GoPointer(), ActivatesVar)

}

var xTextSetAttributes func(uintptr, *pango.AttrList)

// Sets attributes that are applied to the text.
func (x *Text) SetAttributes(AttrsVar *pango.AttrList) {

	xTextSetAttributes(x.GoPointer(), AttrsVar)

}

var xTextSetBuffer func(uintptr, uintptr)

// Set the `GtkEntryBuffer` object which holds the text for
// this widget.
func (x *Text) SetBuffer(BufferVar *EntryBuffer) {

	xTextSetBuffer(x.GoPointer(), BufferVar.GoPointer())

}

var xTextSetEnableEmojiCompletion func(uintptr, bool)

// Sets whether Emoji completion is enabled.
//
// If it is, typing ':', followed by a recognized keyword,
// will pop up a window with suggested Emojis matching the
// keyword.
func (x *Text) SetEnableEmojiCompletion(EnableEmojiCompletionVar bool) {

	xTextSetEnableEmojiCompletion(x.GoPointer(), EnableEmojiCompletionVar)

}

var xTextSetExtraMenu func(uintptr, uintptr)

// Sets a menu model to add when constructing
// the context menu for @self.
func (x *Text) SetExtraMenu(ModelVar *gio.MenuModel) {

	xTextSetExtraMenu(x.GoPointer(), ModelVar.GoPointer())

}

var xTextSetInputHints func(uintptr, InputHints)

// Sets input hints that allow input methods
// to fine-tune their behaviour.
func (x *Text) SetInputHints(HintsVar InputHints) {

	xTextSetInputHints(x.GoPointer(), HintsVar)

}

var xTextSetInputPurpose func(uintptr, InputPurpose)

// Sets the input purpose of the `GtkText`.
//
// This can be used by on-screen keyboards and other
// input methods to adjust their behaviour.
func (x *Text) SetInputPurpose(PurposeVar InputPurpose) {

	xTextSetInputPurpose(x.GoPointer(), PurposeVar)

}

var xTextSetInvisibleChar func(uintptr, uint32)

// Sets the character to use when in “password mode”.
//
// By default, GTK picks the best invisible char available in the
// current font. If you set the invisible char to 0, then the user
// will get no feedback at all; there will be no text on the screen
// as they type.
func (x *Text) SetInvisibleChar(ChVar uint32) {

	xTextSetInvisibleChar(x.GoPointer(), ChVar)

}

var xTextSetMaxLength func(uintptr, int)

// Sets the maximum allowed length of the contents of the widget.
//
// If the current contents are longer than the given length, then
// they will be truncated to fit.
//
// This is equivalent to getting @self's `GtkEntryBuffer` and
// calling [method@Gtk.EntryBuffer.set_max_length] on it.
func (x *Text) SetMaxLength(LengthVar int) {

	xTextSetMaxLength(x.GoPointer(), LengthVar)

}

var xTextSetOverwriteMode func(uintptr, bool)

// Sets whether the text is overwritten when typing
// in the `GtkText`.
func (x *Text) SetOverwriteMode(OverwriteVar bool) {

	xTextSetOverwriteMode(x.GoPointer(), OverwriteVar)

}

var xTextSetPlaceholderText func(uintptr, string)

// Sets text to be displayed in @self when it is empty.
//
// This can be used to give a visual hint of the expected
// contents of the `GtkText`.
func (x *Text) SetPlaceholderText(TextVar string) {

	xTextSetPlaceholderText(x.GoPointer(), TextVar)

}

var xTextSetPropagateTextWidth func(uintptr, bool)

// Sets whether the `GtkText` should grow and shrink with the content.
func (x *Text) SetPropagateTextWidth(PropagateTextWidthVar bool) {

	xTextSetPropagateTextWidth(x.GoPointer(), PropagateTextWidthVar)

}

var xTextSetTabs func(uintptr, *pango.TabArray)

// Sets tabstops that are applied to the text.
func (x *Text) SetTabs(TabsVar *pango.TabArray) {

	xTextSetTabs(x.GoPointer(), TabsVar)

}

var xTextSetTruncateMultiline func(uintptr, bool)

// Sets whether the `GtkText` should truncate multi-line text
// that is pasted into the widget.
func (x *Text) SetTruncateMultiline(TruncateMultilineVar bool) {

	xTextSetTruncateMultiline(x.GoPointer(), TruncateMultilineVar)

}

var xTextSetVisibility func(uintptr, bool)

// Sets whether the contents of the `GtkText` are visible or not.
//
// When visibility is set to %FALSE, characters are displayed
// as the invisible char, and will also appear that way when
// the text in the widget is copied to the clipboard.
//
// By default, GTK picks the best invisible character available
// in the current font, but it can be changed with
// [method@Gtk.Text.set_invisible_char].
//
// Note that you probably want to set [property@Gtk.Text:input-purpose]
// to %GTK_INPUT_PURPOSE_PASSWORD or %GTK_INPUT_PURPOSE_PIN to
// inform input methods about the purpose of this self,
// in addition to setting visibility to %FALSE.
func (x *Text) SetVisibility(VisibleVar bool) {

	xTextSetVisibility(x.GoPointer(), VisibleVar)

}

var xTextUnsetInvisibleChar func(uintptr)

// Unsets the invisible char.
//
// After calling this, the default invisible
// char is used again.
func (x *Text) UnsetInvisibleChar() {

	xTextUnsetInvisibleChar(x.GoPointer())

}

func (c *Text) GoPointer() uintptr {
	return c.Ptr
}

func (c *Text) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the user hits the Enter key.
//
// The default bindings for this signal are all forms
// of the &lt;kbd&gt;Enter&lt;/kbd&gt; key.
func (x *Text) ConnectActivate(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Backspace&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Backspace&lt;/kbd&gt;.
func (x *Text) ConnectBackspace(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "backspace", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "backspace", cbRefPtr)
}

// Emitted to copy the selection to the clipboard.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;c&lt;/kbd&gt; and
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
func (x *Text) ConnectCopyClipboard(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "copy-clipboard", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "copy-clipboard", cbRefPtr)
}

// Emitted to cut the selection to the clipboard.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;x&lt;/kbd&gt; and
// &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt;.
func (x *Text) ConnectCutClipboard(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "cut-clipboard", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "cut-clipboard", cbRefPtr)
}

// Emitted when the user initiates a text deletion.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// If the @type is %GTK_DELETE_CHARS, GTK deletes the selection
// if there is one, otherwise it deletes the requested number
// of characters.
//
// The default bindings for this signal are &lt;kbd&gt;Delete&lt;/kbd&gt;
// for deleting a character and &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt;
// for deleting a word.
func (x *Text) ConnectDeleteFromCursor(cb *func(Text, DeleteType, int)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "delete-from-cursor", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, TypeVarp DeleteType, CountVarp int) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, TypeVarp, CountVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "delete-from-cursor", cbRefPtr)
}

// Emitted when the user initiates the insertion of a
// fixed string at the cursor.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This signal has no default bindings.
func (x *Text) ConnectInsertAtCursor(cb *func(Text, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "insert-at-cursor", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, StringVarp string) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, StringVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "insert-at-cursor", cbRefPtr)
}

// Emitted to present the Emoji chooser for the widget.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;.&lt;/kbd&gt; and
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;;&lt;/kbd&gt;
func (x *Text) ConnectInsertEmoji(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "insert-emoji", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "insert-emoji", cbRefPtr)
}

// Emitted when the user initiates a cursor movement.
//
// If the cursor is not visible in @self, this signal causes
// the viewport to be moved instead.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor
// programmatically.
//
// The default bindings for this signal come in two variants,
// the variant with the &lt;kbd&gt;Shift&lt;/kbd&gt; modifier extends the
// selection, the variant without it does not.
// There are too many key combinations to list them all here.
//
//   - &lt;kbd&gt;←&lt;/kbd&gt;, &lt;kbd&gt;→&lt;/kbd&gt;, &lt;kbd&gt;↑&lt;/kbd&gt;, &lt;kbd&gt;↓&lt;/kbd&gt;
//     move by individual characters/lines
//   - &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;→&lt;/kbd&gt;, etc. move by words/paragraphs
//   - &lt;kbd&gt;Home&lt;/kbd&gt;, &lt;kbd&gt;End&lt;/kbd&gt; move to the ends of the buffer
func (x *Text) ConnectMoveCursor(cb *func(Text, MovementStep, int, bool)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, StepVarp MovementStep, CountVarp int, ExtendVarp bool) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, StepVarp, CountVarp, ExtendVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
}

// Emitted to paste the contents of the clipboard.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are
// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;v&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
func (x *Text) ConnectPasteClipboard(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "paste-clipboard", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "paste-clipboard", cbRefPtr)
}

// Emitted when the preedit text changes.
//
// If an input method is used, the typed text will not immediately
// be committed to the buffer. So if you are interested in the text,
// connect to this signal.
func (x *Text) ConnectPreeditChanged(cb *func(Text, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "preedit-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PreeditVarp string) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PreeditVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "preedit-changed", cbRefPtr)
}

// Emitted to toggle the overwrite mode of the `GtkText`.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal is &lt;kbd&gt;Insert&lt;/kbd&gt;.
func (x *Text) ConnectToggleOverwrite(cb *func(Text)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "toggle-overwrite", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Text{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "toggle-overwrite", cbRefPtr)
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *Text) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *Text) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *Text) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *Text) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Text) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Text) UpdatePropertyValue(NPropertiesVar int, PropertiesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Text) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Text) UpdateRelationValue(NRelationsVar int, RelationsVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Text) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Text) UpdateStateValue(NStatesVar int, StatesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *Text) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Deletes the currently selected text of the editable.
//
// This call doesn’t do anything if there is no selected text.
func (x *Text) DeleteSelection() {

	XGtkEditableDeleteSelection(x.GoPointer())

}

// Deletes a sequence of characters.
//
// The characters that are deleted are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is
// negative, then the characters deleted are those from @start_pos to
// the end of the text.
//
// Note that the positions are specified in characters, not bytes.
func (x *Text) DeleteText(StartPosVar int, EndPosVar int) {

	XGtkEditableDeleteText(x.GoPointer(), StartPosVar, EndPosVar)

}

// Undoes the setup done by [method@Gtk.Editable.init_delegate].
//
// This is a helper function that should be called from dispose,
// before removing the delegate object.
func (x *Text) FinishDelegate() {

	XGtkEditableFinishDelegate(x.GoPointer())

}

// Gets the alignment of the editable.
func (x *Text) GetAlignment() float32 {

	cret := XGtkEditableGetAlignment(x.GoPointer())
	return cret
}

// Retrieves a sequence of characters.
//
// The characters that are retrieved are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is negative,
// then the characters retrieved are those characters from @start_pos to
// the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (x *Text) GetChars(StartPosVar int, EndPosVar int) string {

	cret := XGtkEditableGetChars(x.GoPointer(), StartPosVar, EndPosVar)
	return cret
}

// Gets the `GtkEditable` that @editable is delegating its
// implementation to.
//
// Typically, the delegate is a [class@Gtk.Text] widget.
func (x *Text) GetDelegate() *EditableBase {
	var cls *EditableBase

	cret := XGtkEditableGetDelegate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EditableBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves whether @editable is editable.
func (x *Text) GetEditable() bool {

	cret := XGtkEditableGetEditable(x.GoPointer())
	return cret
}

// Gets if undo/redo actions are enabled for @editable
func (x *Text) GetEnableUndo() bool {

	cret := XGtkEditableGetEnableUndo(x.GoPointer())
	return cret
}

// Retrieves the desired maximum width of @editable, in characters.
func (x *Text) GetMaxWidthChars() int {

	cret := XGtkEditableGetMaxWidthChars(x.GoPointer())
	return cret
}

// Retrieves the current position of the cursor relative
// to the start of the content of the editable.
//
// Note that this position is in characters, not in bytes.
func (x *Text) GetPosition() int {

	cret := XGtkEditableGetPosition(x.GoPointer())
	return cret
}

// Retrieves the selection bound of the editable.
//
// @start_pos will be filled with the start of the selection and
// @end_pos with end. If no text was selected both will be identical
// and %FALSE will be returned.
//
// Note that positions are specified in characters, not bytes.
func (x *Text) GetSelectionBounds(StartPosVar int, EndPosVar int) bool {

	cret := XGtkEditableGetSelectionBounds(x.GoPointer(), StartPosVar, EndPosVar)
	return cret
}

// Retrieves the contents of @editable.
//
// The returned string is owned by GTK and must not be modified or freed.
func (x *Text) GetText() string {

	cret := XGtkEditableGetText(x.GoPointer())
	return cret
}

// Gets the number of characters of space reserved
// for the contents of the editable.
func (x *Text) GetWidthChars() int {

	cret := XGtkEditableGetWidthChars(x.GoPointer())
	return cret
}

// Sets up a delegate for `GtkEditable`.
//
// This is assuming that the get_delegate vfunc in the `GtkEditable`
// interface has been set up for the @editable's type.
//
// This is a helper function that should be called in instance init,
// after creating the delegate object.
func (x *Text) InitDelegate() {

	XGtkEditableInitDelegate(x.GoPointer())

}

// Inserts @length bytes of @text into the contents of the
// widget, at position @position.
//
// Note that the position is in characters, not in bytes.
// The function updates @position to point after the newly
// inserted text.
func (x *Text) InsertText(TextVar string, LengthVar int, PositionVar int) {

	XGtkEditableInsertText(x.GoPointer(), TextVar, LengthVar, PositionVar)

}

// Selects a region of text.
//
// The characters that are selected are those characters at positions
// from @start_pos up to, but not including @end_pos. If @end_pos is
// negative, then the characters selected are those characters from
// @start_pos to  the end of the text.
//
// Note that positions are specified in characters, not bytes.
func (x *Text) SelectRegion(StartPosVar int, EndPosVar int) {

	XGtkEditableSelectRegion(x.GoPointer(), StartPosVar, EndPosVar)

}

// Sets the alignment for the contents of the editable.
//
// This controls the horizontal positioning of the contents when
// the displayed text is shorter than the width of the editable.
func (x *Text) SetAlignment(XalignVar float32) {

	XGtkEditableSetAlignment(x.GoPointer(), XalignVar)

}

// Determines if the user can edit the text in the editable widget.
func (x *Text) SetEditable(IsEditableVar bool) {

	XGtkEditableSetEditable(x.GoPointer(), IsEditableVar)

}

// If enabled, changes to @editable will be saved for undo/redo
// actions.
//
// This results in an additional copy of text changes and are not
// stored in secure memory. As such, undo is forcefully disabled
// when [property@Gtk.Text:visibility] is set to %FALSE.
func (x *Text) SetEnableUndo(EnableUndoVar bool) {

	XGtkEditableSetEnableUndo(x.GoPointer(), EnableUndoVar)

}

// Sets the desired maximum width in characters of @editable.
func (x *Text) SetMaxWidthChars(NCharsVar int) {

	XGtkEditableSetMaxWidthChars(x.GoPointer(), NCharsVar)

}

// Sets the cursor position in the editable to the given value.
//
// The cursor is displayed before the character with the given (base 0)
// index in the contents of the editable. The value must be less than
// or equal to the number of characters in the editable. A value of -1
// indicates that the position should be set after the last character
// of the editable. Note that @position is in characters, not in bytes.
func (x *Text) SetPosition(PositionVar int) {

	XGtkEditableSetPosition(x.GoPointer(), PositionVar)

}

// Sets the text in the editable to the given value.
//
// This is replacing the current contents.
func (x *Text) SetText(TextVar string) {

	XGtkEditableSetText(x.GoPointer(), TextVar)

}

// Changes the size request of the editable to be about the
// right size for @n_chars characters.
//
// Note that it changes the size request, the size can still
// be affected by how you pack the widget into containers.
// If @n_chars is -1, the size reverts to the default size.
func (x *Text) SetWidthChars(NCharsVar int) {

	XGtkEditableSetWidthChars(x.GoPointer(), NCharsVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewText, lib, "gtk_text_new")
	core.PuregoSafeRegister(&xNewTextWithBuffer, lib, "gtk_text_new_with_buffer")

	core.PuregoSafeRegister(&xTextComputeCursorExtents, lib, "gtk_text_compute_cursor_extents")
	core.PuregoSafeRegister(&xTextGetActivatesDefault, lib, "gtk_text_get_activates_default")
	core.PuregoSafeRegister(&xTextGetAttributes, lib, "gtk_text_get_attributes")
	core.PuregoSafeRegister(&xTextGetBuffer, lib, "gtk_text_get_buffer")
	core.PuregoSafeRegister(&xTextGetEnableEmojiCompletion, lib, "gtk_text_get_enable_emoji_completion")
	core.PuregoSafeRegister(&xTextGetExtraMenu, lib, "gtk_text_get_extra_menu")
	core.PuregoSafeRegister(&xTextGetInputHints, lib, "gtk_text_get_input_hints")
	core.PuregoSafeRegister(&xTextGetInputPurpose, lib, "gtk_text_get_input_purpose")
	core.PuregoSafeRegister(&xTextGetInvisibleChar, lib, "gtk_text_get_invisible_char")
	core.PuregoSafeRegister(&xTextGetMaxLength, lib, "gtk_text_get_max_length")
	core.PuregoSafeRegister(&xTextGetOverwriteMode, lib, "gtk_text_get_overwrite_mode")
	core.PuregoSafeRegister(&xTextGetPlaceholderText, lib, "gtk_text_get_placeholder_text")
	core.PuregoSafeRegister(&xTextGetPropagateTextWidth, lib, "gtk_text_get_propagate_text_width")
	core.PuregoSafeRegister(&xTextGetTabs, lib, "gtk_text_get_tabs")
	core.PuregoSafeRegister(&xTextGetTextLength, lib, "gtk_text_get_text_length")
	core.PuregoSafeRegister(&xTextGetTruncateMultiline, lib, "gtk_text_get_truncate_multiline")
	core.PuregoSafeRegister(&xTextGetVisibility, lib, "gtk_text_get_visibility")
	core.PuregoSafeRegister(&xTextGrabFocusWithoutSelecting, lib, "gtk_text_grab_focus_without_selecting")
	core.PuregoSafeRegister(&xTextSetActivatesDefault, lib, "gtk_text_set_activates_default")
	core.PuregoSafeRegister(&xTextSetAttributes, lib, "gtk_text_set_attributes")
	core.PuregoSafeRegister(&xTextSetBuffer, lib, "gtk_text_set_buffer")
	core.PuregoSafeRegister(&xTextSetEnableEmojiCompletion, lib, "gtk_text_set_enable_emoji_completion")
	core.PuregoSafeRegister(&xTextSetExtraMenu, lib, "gtk_text_set_extra_menu")
	core.PuregoSafeRegister(&xTextSetInputHints, lib, "gtk_text_set_input_hints")
	core.PuregoSafeRegister(&xTextSetInputPurpose, lib, "gtk_text_set_input_purpose")
	core.PuregoSafeRegister(&xTextSetInvisibleChar, lib, "gtk_text_set_invisible_char")
	core.PuregoSafeRegister(&xTextSetMaxLength, lib, "gtk_text_set_max_length")
	core.PuregoSafeRegister(&xTextSetOverwriteMode, lib, "gtk_text_set_overwrite_mode")
	core.PuregoSafeRegister(&xTextSetPlaceholderText, lib, "gtk_text_set_placeholder_text")
	core.PuregoSafeRegister(&xTextSetPropagateTextWidth, lib, "gtk_text_set_propagate_text_width")
	core.PuregoSafeRegister(&xTextSetTabs, lib, "gtk_text_set_tabs")
	core.PuregoSafeRegister(&xTextSetTruncateMultiline, lib, "gtk_text_set_truncate_multiline")
	core.PuregoSafeRegister(&xTextSetVisibility, lib, "gtk_text_set_visibility")
	core.PuregoSafeRegister(&xTextUnsetInvisibleChar, lib, "gtk_text_unset_invisible_char")

}
