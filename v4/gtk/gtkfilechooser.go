// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// `GtkFileChooser` is an interface that can be implemented by file
// selection widgets.
//
// In GTK, the main objects that implement this interface are
// [class@Gtk.FileChooserWidget] and [class@Gtk.FileChooserDialog].
//
// You do not need to write an object that implements the `GtkFileChooser`
// interface unless you are trying to adapt an existing file selector to
// expose a standard programming interface.
//
// `GtkFileChooser` allows for shortcuts to various places in the filesystem.
// In the default implementation these are displayed in the left pane. It
// may be a bit confusing at first that these shortcuts come from various
// sources and in various flavours, so lets explain the terminology here:
//
//   - Bookmarks: are created by the user, by dragging folders from the
//     right pane to the left pane, or by using the “Add”. Bookmarks
//     can be renamed and deleted by the user.
//
//   - Shortcuts: can be provided by the application. For example, a Paint
//     program may want to add a shortcut for a Clipart folder. Shortcuts
//     cannot be modified by the user.
//
//   - Volumes: are provided by the underlying filesystem abstraction. They are
//     the “roots” of the filesystem.
//
// # File Names and Encodings
//
// When the user is finished selecting files in a `GtkFileChooser`, your
// program can get the selected filenames as `GFile`s.
//
// # Adding options
//
// You can add extra widgets to a file chooser to provide options
// that are not present in the default design, by using
// [method@Gtk.FileChooser.add_choice]. Each choice has an identifier and
// a user visible label; additionally, each choice can have multiple
// options. If a choice has no option, it will be rendered as a
// check button with the given label; if a choice has options, it will
// be rendered as a combo box.
type FileChooser interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	AddChoice(IdVar string, LabelVar string, OptionsVar []string, OptionLabelsVar []string)
	AddFilter(FilterVar *FileFilter)
	AddShortcutFolder(FolderVar gio.File) bool
	GetAction() FileChooserAction
	GetChoice(IdVar string) string
	GetCreateFolders() bool
	GetCurrentFolder() *gio.FileBase
	GetCurrentName() string
	GetFile() *gio.FileBase
	GetFiles() *gio.ListModelBase
	GetFilter() *FileFilter
	GetFilters() *gio.ListModelBase
	GetSelectMultiple() bool
	GetShortcutFolders() *gio.ListModelBase
	RemoveChoice(IdVar string)
	RemoveFilter(FilterVar *FileFilter)
	RemoveShortcutFolder(FolderVar gio.File) bool
	SetAction(ActionVar FileChooserAction)
	SetChoice(IdVar string, OptionVar string)
	SetCreateFolders(CreateFoldersVar bool)
	SetCurrentFolder(FileVar gio.File) bool
	SetCurrentName(NameVar string)
	SetFile(FileVar gio.File) bool
	SetFilter(FilterVar *FileFilter)
	SetSelectMultiple(SelectMultipleVar bool)
}

var xFileChooserGLibType func() types.GType

func FileChooserGLibType() types.GType {
	return xFileChooserGLibType()
}

type FileChooserBase struct {
	Ptr uintptr
}

func (x *FileChooserBase) GoPointer() uintptr {
	return x.Ptr
}

func (x *FileChooserBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Adds a 'choice' to the file chooser.
//
// This is typically implemented as a combobox or, for boolean choices,
// as a checkbutton. You can select a value using
// [method@Gtk.FileChooser.set_choice] before the dialog is shown,
// and you can obtain the user-selected value in the
// [signal@Gtk.Dialog::response] signal handler using
// [method@Gtk.FileChooser.get_choice].
func (x *FileChooserBase) AddChoice(IdVar string, LabelVar string, OptionsVar []string, OptionLabelsVar []string) {

	XGtkFileChooserAddChoice(x.GoPointer(), IdVar, LabelVar, OptionsVar, OptionLabelsVar)

}

// Adds @filter to the list of filters that the user can select between.
//
// When a filter is selected, only files that are passed by that
// filter are displayed.
//
// Note that the @chooser takes ownership of the filter if it is floating,
// so you have to ref and sink it if you want to keep a reference.
func (x *FileChooserBase) AddFilter(FilterVar *FileFilter) {

	XGtkFileChooserAddFilter(x.GoPointer(), FilterVar.GoPointer())

}

// Adds a folder to be displayed with the shortcut folders
// in a file chooser.
func (x *FileChooserBase) AddShortcutFolder(FolderVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserAddShortcutFolder(x.GoPointer(), FolderVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Gets the type of operation that the file chooser is performing.
func (x *FileChooserBase) GetAction() FileChooserAction {

	cret := XGtkFileChooserGetAction(x.GoPointer())
	return cret
}

// Gets the currently selected option in the 'choice' with the given ID.
func (x *FileChooserBase) GetChoice(IdVar string) string {

	cret := XGtkFileChooserGetChoice(x.GoPointer(), IdVar)
	return cret
}

// Gets whether file chooser will offer to create new folders.
func (x *FileChooserBase) GetCreateFolders() bool {

	cret := XGtkFileChooserGetCreateFolders(x.GoPointer())
	return cret
}

// Gets the current folder of @chooser as `GFile`.
func (x *FileChooserBase) GetCurrentFolder() *gio.FileBase {
	var cls *gio.FileBase

	cret := XGtkFileChooserGetCurrentFolder(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.FileBase{}
	cls.Ptr = cret
	return cls
}

// Gets the current name in the file selector, as entered by the user.
//
// This is meant to be used in save dialogs, to get the currently typed
// filename when the file itself does not exist yet.
func (x *FileChooserBase) GetCurrentName() string {

	cret := XGtkFileChooserGetCurrentName(x.GoPointer())
	return cret
}

// Gets the `GFile` for the currently selected file in
// the file selector.
//
// If multiple files are selected, one of the files will be
// returned at random.
//
// If the file chooser is in folder mode, this function returns
// the selected folder.
func (x *FileChooserBase) GetFile() *gio.FileBase {
	var cls *gio.FileBase

	cret := XGtkFileChooserGetFile(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.FileBase{}
	cls.Ptr = cret
	return cls
}

// Lists all the selected files and subfolders in the current folder
// of @chooser as `GFile`.
func (x *FileChooserBase) GetFiles() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := XGtkFileChooserGetFiles(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

// Gets the current filter.
func (x *FileChooserBase) GetFilter() *FileFilter {
	var cls *FileFilter

	cret := XGtkFileChooserGetFilter(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FileFilter{}
	cls.Ptr = cret
	return cls
}

// Gets the current set of user-selectable filters, as a list model.
//
// See [method@Gtk.FileChooser.add_filter] and
// [method@Gtk.FileChooser.remove_filter] for changing individual filters.
//
// You should not modify the returned list model. Future changes to
// @chooser may or may not affect the returned model.
func (x *FileChooserBase) GetFilters() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := XGtkFileChooserGetFilters(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

// Gets whether multiple files can be selected in the file
// chooser.
func (x *FileChooserBase) GetSelectMultiple() bool {

	cret := XGtkFileChooserGetSelectMultiple(x.GoPointer())
	return cret
}

// Queries the list of shortcut folders in the file chooser.
//
// You should not modify the returned list model. Future changes to
// @chooser may or may not affect the returned model.
func (x *FileChooserBase) GetShortcutFolders() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := XGtkFileChooserGetShortcutFolders(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

// Removes a 'choice' that has been added with gtk_file_chooser_add_choice().
func (x *FileChooserBase) RemoveChoice(IdVar string) {

	XGtkFileChooserRemoveChoice(x.GoPointer(), IdVar)

}

// Removes @filter from the list of filters that the user can select between.
func (x *FileChooserBase) RemoveFilter(FilterVar *FileFilter) {

	XGtkFileChooserRemoveFilter(x.GoPointer(), FilterVar.GoPointer())

}

// Removes a folder from the shortcut folders in a file chooser.
func (x *FileChooserBase) RemoveShortcutFolder(FolderVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserRemoveShortcutFolder(x.GoPointer(), FolderVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the type of operation that the chooser is performing.
//
// The user interface is adapted to suit the selected action.
//
// For example, an option to create a new folder might be shown
// if the action is %GTK_FILE_CHOOSER_ACTION_SAVE but not if the
// action is %GTK_FILE_CHOOSER_ACTION_OPEN.
func (x *FileChooserBase) SetAction(ActionVar FileChooserAction) {

	XGtkFileChooserSetAction(x.GoPointer(), ActionVar)

}

// Selects an option in a 'choice' that has been added with
// gtk_file_chooser_add_choice().
//
// For a boolean choice, the possible options are "true" and "false".
func (x *FileChooserBase) SetChoice(IdVar string, OptionVar string) {

	XGtkFileChooserSetChoice(x.GoPointer(), IdVar, OptionVar)

}

// Sets whether file chooser will offer to create new folders.
//
// This is only relevant if the action is not set to be
// %GTK_FILE_CHOOSER_ACTION_OPEN.
func (x *FileChooserBase) SetCreateFolders(CreateFoldersVar bool) {

	XGtkFileChooserSetCreateFolders(x.GoPointer(), CreateFoldersVar)

}

// Sets the current folder for @chooser from a `GFile`.
func (x *FileChooserBase) SetCurrentFolder(FileVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserSetCurrentFolder(x.GoPointer(), FileVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the current name in the file selector, as if entered
// by the user.
//
// Note that the name passed in here is a UTF-8 string rather
// than a filename. This function is meant for such uses as a
// suggested name in a “Save As...” dialog.  You can pass
// “Untitled.doc” or a similarly suitable suggestion for the @name.
//
// If you want to preselect a particular existing file, you should
// use [method@Gtk.FileChooser.set_file] instead.
//
// Please see the documentation for those functions for an example
// of using [method@Gtk.FileChooser.set_current_name] as well.
func (x *FileChooserBase) SetCurrentName(NameVar string) {

	XGtkFileChooserSetCurrentName(x.GoPointer(), NameVar)

}

// Sets @file as the current filename for the file chooser.
//
// This includes changing to the file’s parent folder and actually selecting
// the file in list. If the @chooser is in %GTK_FILE_CHOOSER_ACTION_SAVE mode,
// the file’s base name will also appear in the dialog’s file name entry.
//
// If the file name isn’t in the current folder of @chooser, then the current
// folder of @chooser will be changed to the folder containing @file.
//
// Note that the file must exist, or nothing will be done except
// for the directory change.
//
// If you are implementing a save dialog, you should use this function if
// you already have a file name to which the user may save; for example,
// when the user opens an existing file and then does “Save As…”. If you
// don’t have a file name already — for example, if the user just created
// a new file and is saving it for the first time, do not call this function.
//
// Instead, use something similar to this:
//
// ```c
// static void
// prepare_file_chooser (GtkFileChooser *chooser,
//
//	GFile          *existing_file)
//
//	{
//	  gboolean document_is_new = (existing_file == NULL);
//
//	  if (document_is_new)
//	    {
//	      GFile *default_file_for_saving = g_file_new_for_path ("./out.txt");
//	      // the user just created a new document
//	      gtk_file_chooser_set_current_folder (chooser, default_file_for_saving, NULL);
//	      gtk_file_chooser_set_current_name (chooser, "Untitled document");
//	      g_object_unref (default_file_for_saving);
//	    }
//	  else
//	    {
//	      // the user edited an existing document
//	      gtk_file_chooser_set_file (chooser, existing_file, NULL);
//	    }
//	}
//
// ```
func (x *FileChooserBase) SetFile(FileVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserSetFile(x.GoPointer(), FileVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the current filter.
//
// Only the files that pass the filter will be displayed.
// If the user-selectable list of filters is non-empty, then
// the filter should be one of the filters in that list.
//
// Setting the current filter when the list of filters is
// empty is useful if you want to restrict the displayed
// set of files without letting the user change it.
func (x *FileChooserBase) SetFilter(FilterVar *FileFilter) {

	XGtkFileChooserSetFilter(x.GoPointer(), FilterVar.GoPointer())

}

// Sets whether multiple files can be selected in the file chooser.
//
// This is only relevant if the action is set to be
// %GTK_FILE_CHOOSER_ACTION_OPEN or
// %GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
func (x *FileChooserBase) SetSelectMultiple(SelectMultipleVar bool) {

	XGtkFileChooserSetSelectMultiple(x.GoPointer(), SelectMultipleVar)

}

var XGtkFileChooserAddChoice func(uintptr, string, string, []string, []string)
var XGtkFileChooserAddFilter func(uintptr, uintptr)
var XGtkFileChooserAddShortcutFolder func(uintptr, uintptr, **glib.Error) bool
var XGtkFileChooserGetAction func(uintptr) FileChooserAction
var XGtkFileChooserGetChoice func(uintptr, string) string
var XGtkFileChooserGetCreateFolders func(uintptr) bool
var XGtkFileChooserGetCurrentFolder func(uintptr) uintptr
var XGtkFileChooserGetCurrentName func(uintptr) string
var XGtkFileChooserGetFile func(uintptr) uintptr
var XGtkFileChooserGetFiles func(uintptr) uintptr
var XGtkFileChooserGetFilter func(uintptr) uintptr
var XGtkFileChooserGetFilters func(uintptr) uintptr
var XGtkFileChooserGetSelectMultiple func(uintptr) bool
var XGtkFileChooserGetShortcutFolders func(uintptr) uintptr
var XGtkFileChooserRemoveChoice func(uintptr, string)
var XGtkFileChooserRemoveFilter func(uintptr, uintptr)
var XGtkFileChooserRemoveShortcutFolder func(uintptr, uintptr, **glib.Error) bool
var XGtkFileChooserSetAction func(uintptr, FileChooserAction)
var XGtkFileChooserSetChoice func(uintptr, string, string)
var XGtkFileChooserSetCreateFolders func(uintptr, bool)
var XGtkFileChooserSetCurrentFolder func(uintptr, uintptr, **glib.Error) bool
var XGtkFileChooserSetCurrentName func(uintptr, string)
var XGtkFileChooserSetFile func(uintptr, uintptr, **glib.Error) bool
var XGtkFileChooserSetFilter func(uintptr, uintptr)
var XGtkFileChooserSetSelectMultiple func(uintptr, bool)

// Describes whether a `GtkFileChooser` is being used to open existing files
// or to save to a possibly new file.
type FileChooserAction int

var xFileChooserActionGLibType func() types.GType

func FileChooserActionGLibType() types.GType {
	return xFileChooserActionGLibType()
}

const (

	// Indicates open mode.  The file chooser
	//  will only let the user pick an existing file.
	FileChooserActionOpenValue FileChooserAction = 0
	// Indicates save mode.  The file chooser
	//  will let the user pick an existing file, or type in a new
	//  filename.
	FileChooserActionSaveValue FileChooserAction = 1
	// Indicates an Open mode for
	//  selecting folders.  The file chooser will let the user pick an
	//  existing folder.
	FileChooserActionSelectFolderValue FileChooserAction = 2
)

// These identify the various errors that can occur while calling
// `GtkFileChooser` functions.
type FileChooserError int

var xFileChooserErrorGLibType func() types.GType

func FileChooserErrorGLibType() types.GType {
	return xFileChooserErrorGLibType()
}

const (

	// Indicates that a file does not exist.
	FileChooserErrorNonexistentValue FileChooserError = 0
	// Indicates a malformed filename.
	FileChooserErrorBadFilenameValue FileChooserError = 1
	// Indicates a duplicate path (e.g. when
	//  adding a bookmark).
	FileChooserErrorAlreadyExistsValue FileChooserError = 2
	// Indicates an incomplete hostname
	//  (e.g. "http://foo" without a slash after that).
	FileChooserErrorIncompleteHostnameValue FileChooserError = 3
)

var xFileChooserErrorQuark func() glib.Quark

// Registers an error quark for `GtkFileChooser` errors.
func FileChooserErrorQuark() glib.Quark {

	cret := xFileChooserErrorQuark()
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xFileChooserActionGLibType, lib, "gtk_file_chooser_action_get_type")

	core.PuregoSafeRegister(&xFileChooserErrorGLibType, lib, "gtk_file_chooser_error_get_type")

	core.PuregoSafeRegister(&xFileChooserErrorQuark, lib, "gtk_file_chooser_error_quark")

	core.PuregoSafeRegister(&xFileChooserGLibType, lib, "gtk_file_chooser_get_type")

	core.PuregoSafeRegister(&XGtkFileChooserAddChoice, lib, "gtk_file_chooser_add_choice")
	core.PuregoSafeRegister(&XGtkFileChooserAddFilter, lib, "gtk_file_chooser_add_filter")
	core.PuregoSafeRegister(&XGtkFileChooserAddShortcutFolder, lib, "gtk_file_chooser_add_shortcut_folder")
	core.PuregoSafeRegister(&XGtkFileChooserGetAction, lib, "gtk_file_chooser_get_action")
	core.PuregoSafeRegister(&XGtkFileChooserGetChoice, lib, "gtk_file_chooser_get_choice")
	core.PuregoSafeRegister(&XGtkFileChooserGetCreateFolders, lib, "gtk_file_chooser_get_create_folders")
	core.PuregoSafeRegister(&XGtkFileChooserGetCurrentFolder, lib, "gtk_file_chooser_get_current_folder")
	core.PuregoSafeRegister(&XGtkFileChooserGetCurrentName, lib, "gtk_file_chooser_get_current_name")
	core.PuregoSafeRegister(&XGtkFileChooserGetFile, lib, "gtk_file_chooser_get_file")
	core.PuregoSafeRegister(&XGtkFileChooserGetFiles, lib, "gtk_file_chooser_get_files")
	core.PuregoSafeRegister(&XGtkFileChooserGetFilter, lib, "gtk_file_chooser_get_filter")
	core.PuregoSafeRegister(&XGtkFileChooserGetFilters, lib, "gtk_file_chooser_get_filters")
	core.PuregoSafeRegister(&XGtkFileChooserGetSelectMultiple, lib, "gtk_file_chooser_get_select_multiple")
	core.PuregoSafeRegister(&XGtkFileChooserGetShortcutFolders, lib, "gtk_file_chooser_get_shortcut_folders")
	core.PuregoSafeRegister(&XGtkFileChooserRemoveChoice, lib, "gtk_file_chooser_remove_choice")
	core.PuregoSafeRegister(&XGtkFileChooserRemoveFilter, lib, "gtk_file_chooser_remove_filter")
	core.PuregoSafeRegister(&XGtkFileChooserRemoveShortcutFolder, lib, "gtk_file_chooser_remove_shortcut_folder")
	core.PuregoSafeRegister(&XGtkFileChooserSetAction, lib, "gtk_file_chooser_set_action")
	core.PuregoSafeRegister(&XGtkFileChooserSetChoice, lib, "gtk_file_chooser_set_choice")
	core.PuregoSafeRegister(&XGtkFileChooserSetCreateFolders, lib, "gtk_file_chooser_set_create_folders")
	core.PuregoSafeRegister(&XGtkFileChooserSetCurrentFolder, lib, "gtk_file_chooser_set_current_folder")
	core.PuregoSafeRegister(&XGtkFileChooserSetCurrentName, lib, "gtk_file_chooser_set_current_name")
	core.PuregoSafeRegister(&XGtkFileChooserSetFile, lib, "gtk_file_chooser_set_file")
	core.PuregoSafeRegister(&XGtkFileChooserSetFilter, lib, "gtk_file_chooser_set_filter")
	core.PuregoSafeRegister(&XGtkFileChooserSetSelectMultiple, lib, "gtk_file_chooser_set_select_multiple")

}
