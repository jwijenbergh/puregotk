// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/cairo"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/graphene"
	"github.com/jwijenbergh/puregotk/v4/gsk"
	"github.com/jwijenbergh/puregotk/v4/pango"
)

// Callback type for adding a function to update animations. See gtk_widget_add_tick_callback().
type TickCallback func(uintptr, uintptr, uintptr) bool

// The type of the callback functions used for activating
// actions installed with gtk_widget_class_install_action().
//
// The @parameter must match the @parameter_type of the action.
type WidgetActionActivateFunc func(uintptr, string, *glib.Variant)

// A `GtkRequisition` represents the desired size of a widget. See
// [GtkWidget’s geometry management section](class.Widget.html#height-for-width-geometry-management) for
// more information.
type Requisition struct {
	Width int

	Height int
}

func (x *Requisition) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewRequisition func() *Requisition

// Allocates a new `GtkRequisition`.
//
// The struct is initialized to zero.
func NewRequisition() *Requisition {

	cret := xNewRequisition()
	return cret
}

var xRequisitionCopy func(uintptr) *Requisition

// Copies a `GtkRequisition`.
func (x *Requisition) Copy() *Requisition {

	cret := xRequisitionCopy(x.GoPointer())
	return cret
}

var xRequisitionFree func(uintptr)

// Frees a `GtkRequisition`.
func (x *Requisition) Free() {

	xRequisitionFree(x.GoPointer())

}

type WidgetClass struct {
	ParentClass uintptr

	Priv *WidgetClassPrivate

	Padding uintptr
}

func (x *WidgetClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xWidgetClassAddBinding func(uintptr, uint, gdk.ModifierType, uintptr, string, ...interface{})

// Creates a new shortcut for @widget_class that calls the given @callback
// with arguments read according to @format_string.
//
// The arguments and format string must be provided in the same way as
// with g_variant_new().
//
// This function is a convenience wrapper around
// [method@Gtk.WidgetClass.add_shortcut] and must be called during class
// initialization. It does not provide for user_data, if you need that,
// you will have to use [method@GtkWidgetClass.add_shortcut] with a custom
// shortcut.
func (x *WidgetClass) AddBinding(KeyvalVar uint, ModsVar gdk.ModifierType, CallbackVar *ShortcutFunc, FormatStringVar string, varArgs ...interface{}) {

	xWidgetClassAddBinding(x.GoPointer(), KeyvalVar, ModsVar, glib.NewCallback(CallbackVar), FormatStringVar, varArgs...)

}

var xWidgetClassAddBindingAction func(uintptr, uint, gdk.ModifierType, string, string, ...interface{})

// Creates a new shortcut for @widget_class that activates the given
// @action_name with arguments read according to @format_string.
//
// The arguments and format string must be provided in the same way as
// with g_variant_new().
//
// This function is a convenience wrapper around
// [method@Gtk.WidgetClass.add_shortcut] and must be called during class
// initialization.
func (x *WidgetClass) AddBindingAction(KeyvalVar uint, ModsVar gdk.ModifierType, ActionNameVar string, FormatStringVar string, varArgs ...interface{}) {

	xWidgetClassAddBindingAction(x.GoPointer(), KeyvalVar, ModsVar, ActionNameVar, FormatStringVar, varArgs...)

}

var xWidgetClassAddBindingSignal func(uintptr, uint, gdk.ModifierType, string, string, ...interface{})

// Creates a new shortcut for @widget_class that emits the given action
// @signal with arguments read according to @format_string.
//
// The arguments and format string must be provided in the same way as
// with g_variant_new().
//
// This function is a convenience wrapper around
// [method@Gtk.WidgetClass.add_shortcut] and must be called during class
// initialization.
func (x *WidgetClass) AddBindingSignal(KeyvalVar uint, ModsVar gdk.ModifierType, SignalVar string, FormatStringVar string, varArgs ...interface{}) {

	xWidgetClassAddBindingSignal(x.GoPointer(), KeyvalVar, ModsVar, SignalVar, FormatStringVar, varArgs...)

}

var xWidgetClassAddShortcut func(uintptr, uintptr)

// Installs a shortcut in @widget_class.
//
// Every instance created for @widget_class or its subclasses will
// inherit this shortcut and trigger it.
//
// Shortcuts added this way will be triggered in the %GTK_PHASE_BUBBLE
// phase, which means they may also trigger if child widgets have focus.
//
// This function must only be used in class initialization functions
// otherwise it is not guaranteed that the shortcut will be installed.
func (x *WidgetClass) AddShortcut(ShortcutVar *Shortcut) {

	xWidgetClassAddShortcut(x.GoPointer(), ShortcutVar.GoPointer())

}

var xWidgetClassBindTemplateCallbackFull func(uintptr, string, uintptr)

// Declares a @callback_symbol to handle @callback_name from
// the template XML defined for @widget_type.
//
// This function is not supported after [method@Gtk.WidgetClass.set_template_scope]
// has been used on @widget_class. See [method@Gtk.BuilderCScope.add_callback_symbol].
//
// Note that this must be called from a composite widget classes
// class initializer after calling [method@Gtk.WidgetClass.set_template].
func (x *WidgetClass) BindTemplateCallbackFull(CallbackNameVar string, CallbackSymbolVar *gobject.Callback) {

	xWidgetClassBindTemplateCallbackFull(x.GoPointer(), CallbackNameVar, glib.NewCallback(CallbackSymbolVar))

}

var xWidgetClassBindTemplateChildFull func(uintptr, string, bool, int)

// Automatically assign an object declared in the class template XML to
// be set to a location on a freshly built instance’s private data, or
// alternatively accessible via [method@Gtk.Widget.get_template_child].
//
// The struct can point either into the public instance, then you should
// use `G_STRUCT_OFFSET(WidgetType, member)` for @struct_offset, or in the
// private struct, then you should use `G_PRIVATE_OFFSET(WidgetType, member)`.
//
// An explicit strong reference will be held automatically for the duration
// of your instance’s life cycle, it will be released automatically when
// `GObjectClass.dispose()` runs on your instance and if a @struct_offset
// that is `!= 0` is specified, then the automatic location in your instance
// public or private data will be set to %NULL. You can however access an
// automated child pointer the first time your classes `GObjectClass.dispose()`
// runs, or alternatively in [signal@Gtk.Widget::destroy].
//
// If @internal_child is specified, [vfunc@Gtk.Buildable.get_internal_child]
// will be automatically implemented by the `GtkWidget` class so there is no
// need to implement it manually.
//
// The wrapper macros [func@Gtk.widget_class_bind_template_child],
// [func@Gtk.widget_class_bind_template_child_internal],
// [func@Gtk.widget_class_bind_template_child_private] and
// [func@Gtk.widget_class_bind_template_child_internal_private]
// might be more convenient to use.
//
// Note that this must be called from a composite widget classes class
// initializer after calling [method@Gtk.WidgetClass.set_template].
func (x *WidgetClass) BindTemplateChildFull(NameVar string, InternalChildVar bool, StructOffsetVar int) {

	xWidgetClassBindTemplateChildFull(x.GoPointer(), NameVar, InternalChildVar, StructOffsetVar)

}

var xWidgetClassGetAccessibleRole func(uintptr) AccessibleRole

// Retrieves the accessible role used by the given `GtkWidget` class.
//
// Different accessible roles have different states, and are rendered
// differently by assistive technologies.
//
// See also: [method@Gtk.Accessible.get_accessible_role].
func (x *WidgetClass) GetAccessibleRole() AccessibleRole {

	cret := xWidgetClassGetAccessibleRole(x.GoPointer())
	return cret
}

var xWidgetClassGetActivateSignal func(uintptr) uint

// Retrieves the signal id for the activation signal.
//
// the activation signal is set using
// [method@Gtk.WidgetClass.set_activate_signal].
func (x *WidgetClass) GetActivateSignal() uint {

	cret := xWidgetClassGetActivateSignal(x.GoPointer())
	return cret
}

var xWidgetClassGetCssName func(uintptr) string

// Gets the name used by this class for matching in CSS code.
//
// See [method@Gtk.WidgetClass.set_css_name] for details.
func (x *WidgetClass) GetCssName() string {

	cret := xWidgetClassGetCssName(x.GoPointer())
	return cret
}

var xWidgetClassGetLayoutManagerType func(uintptr) []interface{}

// Retrieves the type of the [class@Gtk.LayoutManager]
// used by widgets of class @widget_class.
//
// See also: [method@Gtk.WidgetClass.set_layout_manager_type].
func (x *WidgetClass) GetLayoutManagerType() []interface{} {

	cret := xWidgetClassGetLayoutManagerType(x.GoPointer())
	return cret
}

var xWidgetClassInstallAction func(uintptr, string, string, uintptr)

// This should be called at class initialization time to specify
// actions to be added for all instances of this class.
//
// Actions installed by this function are stateless. The only state
// they have is whether they are enabled or not.
func (x *WidgetClass) InstallAction(ActionNameVar string, ParameterTypeVar string, ActivateVar *WidgetActionActivateFunc) {

	xWidgetClassInstallAction(x.GoPointer(), ActionNameVar, ParameterTypeVar, glib.NewCallback(ActivateVar))

}

var xWidgetClassInstallPropertyAction func(uintptr, string, string)

// Installs an action called @action_name on @widget_class and
// binds its state to the value of the @property_name property.
//
// This function will perform a few santity checks on the property selected
// via @property_name. Namely, the property must exist, must be readable,
// writable and must not be construct-only. There are also restrictions
// on the type of the given property, it must be boolean, int, unsigned int,
// double or string. If any of these conditions are not met, a critical
// warning will be printed and no action will be added.
//
// The state type of the action matches the property type.
//
// If the property is boolean, the action will have no parameter and
// toggle the property value. Otherwise, the action will have a parameter
// of the same type as the property.
func (x *WidgetClass) InstallPropertyAction(ActionNameVar string, PropertyNameVar string) {

	xWidgetClassInstallPropertyAction(x.GoPointer(), ActionNameVar, PropertyNameVar)

}

var xWidgetClassQueryAction func(uintptr, uint, []interface{}, string, **glib.VariantType, string) bool

// Returns details about the @index_-th action that has been
// installed for @widget_class during class initialization.
//
// See [method@Gtk.WidgetClass.install_action] for details on
// how to install actions.
//
// Note that this function will also return actions defined
// by parent classes. You can identify those by looking
// at @owner.
func (x *WidgetClass) QueryAction(IndexVar uint, OwnerVar []interface{}, ActionNameVar string, ParameterTypeVar **glib.VariantType, PropertyNameVar string) bool {

	cret := xWidgetClassQueryAction(x.GoPointer(), IndexVar, OwnerVar, ActionNameVar, ParameterTypeVar, PropertyNameVar)
	return cret
}

var xWidgetClassSetAccessibleRole func(uintptr, AccessibleRole)

// Sets the accessible role used by the given `GtkWidget` class.
//
// Different accessible roles have different states, and are
// rendered differently by assistive technologies.
func (x *WidgetClass) SetAccessibleRole(AccessibleRoleVar AccessibleRole) {

	xWidgetClassSetAccessibleRole(x.GoPointer(), AccessibleRoleVar)

}

var xWidgetClassSetActivateSignal func(uintptr, uint)

// Sets the `GtkWidgetClass.activate_signal` field with the
// given @signal_id.
//
// The signal will be emitted when calling [method@Gtk.Widget.activate].
//
// The @signal_id must have been registered with `g_signal_new()`
// or g_signal_newv() before calling this function.
func (x *WidgetClass) SetActivateSignal(SignalIdVar uint) {

	xWidgetClassSetActivateSignal(x.GoPointer(), SignalIdVar)

}

var xWidgetClassSetActivateSignalFromName func(uintptr, string)

// Sets the `GtkWidgetClass.activate_signal` field with the signal id for
// the given @signal_name.
//
// The signal will be emitted when calling [method@Gtk.Widget.activate].
//
// The @signal_name of @widget_type must have been registered with
// g_signal_new() or g_signal_newv() before calling this function.
func (x *WidgetClass) SetActivateSignalFromName(SignalNameVar string) {

	xWidgetClassSetActivateSignalFromName(x.GoPointer(), SignalNameVar)

}

var xWidgetClassSetCssName func(uintptr, string)

// Sets the name to be used for CSS matching of widgets.
//
// If this function is not called for a given class, the name
// set on the parent class is used. By default, `GtkWidget`
// uses the name "widget".
func (x *WidgetClass) SetCssName(NameVar string) {

	xWidgetClassSetCssName(x.GoPointer(), NameVar)

}

var xWidgetClassSetLayoutManagerType func(uintptr, []interface{})

// Sets the type to be used for creating layout managers for
// widgets of @widget_class.
//
// The given @type must be a subtype of [class@Gtk.LayoutManager].
//
// This function should only be called from class init functions
// of widgets.
func (x *WidgetClass) SetLayoutManagerType(TypeVar []interface{}) {

	xWidgetClassSetLayoutManagerType(x.GoPointer(), TypeVar)

}

var xWidgetClassSetTemplate func(uintptr, *glib.Bytes)

// This should be called at class initialization time to specify
// the `GtkBuilder` XML to be used to extend a widget.
//
// For convenience, [method@Gtk.WidgetClass.set_template_from_resource]
// is also provided.
//
// Note that any class that installs templates must call
// [method@Gtk.Widget.init_template] in the widget’s instance initializer.
func (x *WidgetClass) SetTemplate(TemplateBytesVar *glib.Bytes) {

	xWidgetClassSetTemplate(x.GoPointer(), TemplateBytesVar)

}

var xWidgetClassSetTemplateFromResource func(uintptr, string)

// A convenience function that calls [method@Gtk.WidgetClass.set_template]
// with the contents of a `GResource`.
//
// Note that any class that installs templates must call
// [method@Gtk.Widget.init_template] in the widget’s instance
// initializer.
func (x *WidgetClass) SetTemplateFromResource(ResourceNameVar string) {

	xWidgetClassSetTemplateFromResource(x.GoPointer(), ResourceNameVar)

}

var xWidgetClassSetTemplateScope func(uintptr, uintptr)

// For use in language bindings, this will override the default
// `GtkBuilderScope` to be used when parsing GtkBuilder XML from
// this class’s template data.
//
// Note that this must be called from a composite widget classes class
// initializer after calling [method@GtkWidgetClass.set_template].
func (x *WidgetClass) SetTemplateScope(ScopeVar BuilderScope) {

	xWidgetClassSetTemplateScope(x.GoPointer(), ScopeVar.GoPointer())

}

type WidgetClassPrivate struct {
}

func (x *WidgetClassPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type WidgetPrivate struct {
}

func (x *WidgetPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// The rectangle representing the area allocated for a widget by its parent.
type Allocation = uintptr

// The base class for all widgets.
//
// `GtkWidget` is the base class all widgets in GTK derive from. It manages the
// widget lifecycle, layout, states and style.
//
// ### Height-for-width Geometry Management
//
// GTK uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much
// vertical space it needs, depending on the amount of horizontal space
// that it is given (and similar for width-for-height). The most common
// example is a label that reflows to fill up the available width, wraps
// to fewer lines, and therefore needs less height.
//
// Height-for-width geometry management is implemented in GTK by way
// of two virtual methods:
//
// - [vfunc@Gtk.Widget.get_request_mode]
// - [vfunc@Gtk.Widget.measure]
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in widget implementations.
//
// If you implement a direct `GtkWidget` subclass that supports
// height-for-width or width-for-height geometry management for itself
// or its child widgets, the [vfunc@Gtk.Widget.get_request_mode] virtual
// function must be implemented as well and return the widget's preferred
// request mode. The default implementation of this virtual function
// returns %GTK_SIZE_REQUEST_CONSTANT_SIZE, which means that the widget will
// only ever get -1 passed as the for_size value to its
// [vfunc@Gtk.Widget.measure] implementation.
//
// The geometry management system will query a widget hierarchy in
// only one orientation at a time. When widgets are initially queried
// for their minimum sizes it is generally done in two initial passes
// in the [enum@Gtk.SizeRequestMode] chosen by the toplevel.
//
// For example, when queried in the normal %GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH mode:
//
// First, the default minimum and natural width for each widget
// in the interface will be computed using [id@gtk_widget_measure] with an
// orientation of %GTK_ORIENTATION_HORIZONTAL and a for_size of -1.
// Because the preferred widths for each widget depend on the preferred
// widths of their children, this information propagates up the hierarchy,
// and finally a minimum and natural width is determined for the entire
// toplevel. Next, the toplevel will use the minimum width to query for the
// minimum height contextual to that width using [id@gtk_widget_measure] with an
// orientation of %GTK_ORIENTATION_VERTICAL and a for_size of the just computed
// width. This will also be a highly recursive operation. The minimum height
// for the minimum width is normally used to set the minimum size constraint
// on the toplevel.
//
// After the toplevel window has initially requested its size in both
// dimensions it can go on to allocate itself a reasonable size (or a size
// previously specified with [method@Gtk.Window.set_default_size]). During the
// recursive allocation process it’s important to note that request cycles
// will be recursively executed while widgets allocate their children.
// Each widget, once allocated a size, will go on to first share the
// space in one orientation among its children and then request each child's
// height for its target allocated width or its width for allocated height,
// depending. In this way a `GtkWidget` will typically be requested its size
// a number of times before actually being allocated a size. The size a
// widget is finally allocated can of course differ from the size it has
// requested. For this reason, `GtkWidget` caches a  small number of results
// to avoid re-querying for the same sizes in one allocation cycle.
//
// If a widget does move content around to intelligently use up the
// allocated size then it must support the request in both
// `GtkSizeRequestMode`s even if the widget in question only
// trades sizes in a single orientation.
//
// For instance, a [class@Gtk.Label] that does height-for-width word wrapping
// will not expect to have [vfunc@Gtk.Widget.measure] with an orientation of
// %GTK_ORIENTATION_VERTICAL called because that call is specific to a
// width-for-height request. In this case the label must return the height
// required for its own minimum possible width. By following this rule any
// widget that handles height-for-width or width-for-height requests will
// always be allocated at least enough space to fit its own content.
//
// Here are some examples of how a %GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests:
//
// ```c
// static void
// foo_widget_measure (GtkWidget      *widget,
//
//	GtkOrientation  orientation,
//	int             for_size,
//	int            *minimum_size,
//	int            *natural_size,
//	int            *minimum_baseline,
//	int            *natural_baseline)
//
//	{
//	  if (orientation == GTK_ORIENTATION_HORIZONTAL)
//	    {
//	      // Calculate minimum and natural width
//	    }
//	  else // VERTICAL
//	    {
//	      if (i_am_in_height_for_width_mode)
//	        {
//	          int min_width, dummy;
//
//	          // First, get the minimum width of our widget
//	          GTK_WIDGET_GET_CLASS (widget)-&gt;measure (widget, GTK_ORIENTATION_HORIZONTAL, -1,
//	                                                  &amp;min_width, &amp;dummy, &amp;dummy, &amp;dummy);
//
//	          // Now use the minimum width to retrieve the minimum and natural height to display
//	          // that width.
//	          GTK_WIDGET_GET_CLASS (widget)-&gt;measure (widget, GTK_ORIENTATION_VERTICAL, min_width,
//	                                                  minimum_size, natural_size, &amp;dummy, &amp;dummy);
//	        }
//	      else
//	        {
//	          // ... some widgets do both.
//	        }
//	    }
//	}
//
// ```
//
// Often a widget needs to get its own request during size request or
// allocation. For example, when computing height it may need to also
// compute width. Or when deciding how to use an allocation, the widget
// may need to know its natural size. In these cases, the widget should
// be careful to call its virtual methods directly, like in the code
// example above.
//
// It will not work to use the wrapper function [method@Gtk.Widget.measure]
// inside your own [vfunc@Gtk.Widget.size_allocate] implementation.
// These return a request adjusted by [class@Gtk.SizeGroup], the widget's
// align and expand flags, as well as its CSS style.
//
// If a widget used the wrappers inside its virtual method implementations,
// then the adjustments (such as widget margins) would be applied
// twice. GTK therefore does not allow this and will warn if you try
// to do it.
//
// Of course if you are getting the size request for another widget, such
// as a child widget, you must use [id@gtk_widget_measure]; otherwise, you
// would not properly consider widget margins, [class@Gtk.SizeGroup], and
// so forth.
//
// GTK also supports baseline vertical alignment of widgets. This
// means that widgets are positioned such that the typographical baseline of
// widgets in the same row are aligned. This happens if a widget supports
// baselines, has a vertical alignment of %GTK_ALIGN_BASELINE, and is inside
// a widget that supports baselines and has a natural “row” that it aligns to
// the baseline, or a baseline assigned to it by the grandparent.
//
// Baseline alignment support for a widget is also done by the
// [vfunc@Gtk.Widget.measure] virtual function. It allows you to report
// both a minimum and natural size.
//
// If a widget ends up baseline aligned it will be allocated all the space in
// the parent as if it was %GTK_ALIGN_FILL, but the selected baseline can be
// found via [id@gtk_widget_get_allocated_baseline]. If the baseline has a
// value other than -1 you need to align the widget such that the baseline
// appears at the position.
//
// ### GtkWidget as GtkBuildable
//
// The `GtkWidget` implementation of the `GtkBuildable` interface
// supports various custom elements to specify additional aspects of widgets
// that are not directly expressed as properties.
//
// If the widget uses a [class@Gtk.LayoutManager], `GtkWidget` supports
// a custom `&lt;layout&gt;` element, used to define layout properties:
//
// ```xml
// &lt;object class="GtkGrid" id="my_grid"&gt;
//
//	&lt;child&gt;
//	  &lt;object class="GtkLabel" id="label1"&gt;
//	    &lt;property name="label"&gt;Description&lt;/property&gt;
//	    &lt;layout&gt;
//	      &lt;property name="column"&gt;0&lt;/property&gt;
//	      &lt;property name="row"&gt;0&lt;/property&gt;
//	      &lt;property name="row-span"&gt;1&lt;/property&gt;
//	      &lt;property name="column-span"&gt;1&lt;/property&gt;
//	    &lt;/layout&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//	&lt;child&gt;
//	  &lt;object class="GtkEntry" id="description_entry"&gt;
//	    &lt;layout&gt;
//	      &lt;property name="column"&gt;1&lt;/property&gt;
//	      &lt;property name="row"&gt;0&lt;/property&gt;
//	      &lt;property name="row-span"&gt;1&lt;/property&gt;
//	      &lt;property name="column-span"&gt;1&lt;/property&gt;
//	    &lt;/layout&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//
// &lt;/object&gt;
// ```
//
// `GtkWidget` allows style information such as style classes to
// be associated with widgets, using the custom `&lt;style&gt;` element:
//
// ```xml
// &lt;object class="GtkButton" id="button1"&gt;
//
//	&lt;style&gt;
//	  &lt;class name="my-special-button-class"/&gt;
//	  &lt;class name="dark-button"/&gt;
//	&lt;/style&gt;
//
// &lt;/object&gt;
// ```
//
// `GtkWidget` allows defining accessibility information, such as properties,
// relations, and states, using the custom `&lt;accessibility&gt;` element:
//
// ```xml
// &lt;object class="GtkButton" id="button1"&gt;
//
//	&lt;accessibility&gt;
//	  &lt;property name="label"&gt;Download&lt;/property&gt;
//	  &lt;relation name="labelled-by"&gt;label1&lt;/relation&gt;
//	&lt;/accessibility&gt;
//
// &lt;/object&gt;
// ```
//
// ### Building composite widgets from template XML
//
// `GtkWidget `exposes some facilities to automate the procedure
// of creating composite widgets using "templates".
//
// To create composite widgets with `GtkBuilder` XML, one must associate
// the interface description with the widget class at class initialization
// time using [method@Gtk.WidgetClass.set_template].
//
// The interface description semantics expected in composite template descriptions
// is slightly different from regular [class@Gtk.Builder] XML.
//
// Unlike regular interface descriptions, [method@Gtk.WidgetClass.set_template] will
// expect a `&lt;template&gt;` tag as a direct child of the toplevel `&lt;interface&gt;`
// tag. The `&lt;template&gt;` tag must specify the “class” attribute which must be
// the type name of the widget. Optionally, the “parent” attribute may be
// specified to specify the direct parent type of the widget type, this is
// ignored by `GtkBuilder` but required for UI design tools like
// [Glade](https://glade.gnome.org/) to introspect what kind of properties and
// internal children exist for a given type when the actual type does not exist.
//
// The XML which is contained inside the `&lt;template&gt;` tag behaves as if it were
// added to the `&lt;object&gt;` tag defining the widget itself. You may set properties
// on a widget by inserting `&lt;property&gt;` tags into the `&lt;template&gt;` tag, and also
// add `&lt;child&gt;` tags to add children and extend a widget in the normal way you
// would with `&lt;object&gt;` tags.
//
// Additionally, `&lt;object&gt;` tags can also be added before and after the initial
// `&lt;template&gt;` tag in the normal way, allowing one to define auxiliary objects
// which might be referenced by other widgets declared as children of the
// `&lt;template&gt;` tag.
//
// An example of a template definition:
//
// ```xml
// &lt;interface&gt;
//
//	&lt;template class="FooWidget" parent="GtkBox"&gt;
//	  &lt;property name="orientation"&gt;horizontal&lt;/property&gt;
//	  &lt;property name="spacing"&gt;4&lt;/property&gt;
//	  &lt;child&gt;
//	    &lt;object class="GtkButton" id="hello_button"&gt;
//	      &lt;property name="label"&gt;Hello World&lt;/property&gt;
//	      &lt;signal name="clicked" handler="hello_button_clicked" object="FooWidget" swapped="yes"/&gt;
//	    &lt;/object&gt;
//	  &lt;/child&gt;
//	  &lt;child&gt;
//	    &lt;object class="GtkButton" id="goodbye_button"&gt;
//	      &lt;property name="label"&gt;Goodbye World&lt;/property&gt;
//	    &lt;/object&gt;
//	  &lt;/child&gt;
//	&lt;/template&gt;
//
// &lt;/interface&gt;
// ```
//
// Typically, you'll place the template fragment into a file that is
// bundled with your project, using `GResource`. In order to load the
// template, you need to call [method@Gtk.WidgetClass.set_template_from_resource]
// from the class initialization of your `GtkWidget` type:
//
// ```c
// static void
// foo_widget_class_init (FooWidgetClass *klass)
//
//	{
//	  // ...
//
//	  gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//	                                               "/com/example/ui/foowidget.ui");
//	}
//
// ```
//
// You will also need to call [method@Gtk.Widget.init_template] from the
// instance initialization function:
//
// ```c
// static void
// foo_widget_init (FooWidget *self)
//
//	{
//	  gtk_widget_init_template (GTK_WIDGET (self));
//
//	  // Initialize the rest of the widget...
//	}
//
// ```
//
// as well as calling [method@Gtk.Widget.dispose_template] from the dispose
// function:
//
// ```c
// static void
// foo_widget_dispose (GObject *gobject)
//
//	{
//	  FooWidget *self = FOO_WIDGET (gobject);
//
//	  // Dispose objects for which you have a reference...
//
//	  // Clear the template children for this widget type
//	  gtk_widget_dispose_template (GTK_WIDGET (self), FOO_TYPE_WIDGET);
//
//	  G_OBJECT_CLASS (foo_widget_parent_class)-&gt;dispose (gobject);
//	}
//
// ```
//
// You can access widgets defined in the template using the
// [id@gtk_widget_get_template_child] function, but you will typically declare
// a pointer in the instance private data structure of your type using the same
// name as the widget in the template definition, and call
// [method@Gtk.WidgetClass.bind_template_child_full] (or one of its wrapper macros
// [func@Gtk.widget_class_bind_template_child] and [func@Gtk.widget_class_bind_template_child_private])
// with that name, e.g.
//
// ```c
//
//	typedef struct {
//	  GtkWidget *hello_button;
//	  GtkWidget *goodbye_button;
//	} FooWidgetPrivate;
//
// G_DEFINE_TYPE_WITH_PRIVATE (FooWidget, foo_widget, GTK_TYPE_BOX)
//
// static void
// foo_widget_dispose (GObject *gobject)
//
//	{
//	  gtk_widget_dispose_template (GTK_WIDGET (gobject), FOO_TYPE_WIDGET);
//
//	  G_OBJECT_CLASS (foo_widget_parent_class)-&gt;dispose (gobject);
//	}
//
// static void
// foo_widget_class_init (FooWidgetClass *klass)
//
//	{
//	  // ...
//	  G_OBJECT_CLASS (klass)-&gt;dispose = foo_widget_dispose;
//
//	  gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//	                                               "/com/example/ui/foowidget.ui");
//	  gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
//	                                                FooWidget, hello_button);
//	  gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
//	                                                FooWidget, goodbye_button);
//	}
//
// static void
// foo_widget_init (FooWidget *widget)
//
//	{
//	  gtk_widget_init_template (GTK_WIDGET (widget));
//	}
//
// ```
//
// You can also use [method@Gtk.WidgetClass.bind_template_callback_full] (or
// is wrapper macro [func@Gtk.widget_class_bind_template_callback]) to connect
// a signal callback defined in the template with a function visible in the
// scope of the class, e.g.
//
// ```c
// // the signal handler has the instance and user data swapped
// // because of the swapped="yes" attribute in the template XML
// static void
// hello_button_clicked (FooWidget *self,
//
//	GtkButton *button)
//
//	{
//	  g_print ("Hello, world!\n");
//	}
//
// static void
// foo_widget_class_init (FooWidgetClass *klass)
//
//	{
//	  // ...
//	  gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//	                                               "/com/example/ui/foowidget.ui");
//	  gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//	}
//
// ```
type Widget struct {
	gobject.InitiallyUnowned
}

func WidgetNewFromInternalPtr(ptr uintptr) *Widget {
	cls := &Widget{}
	cls.Ptr = ptr
	return cls
}

var xWidgetActionSetEnabled func(uintptr, string, bool)

// Enable or disable an action installed with
// gtk_widget_class_install_action().
func (x *Widget) ActionSetEnabled(ActionNameVar string, EnabledVar bool) {

	xWidgetActionSetEnabled(x.GoPointer(), ActionNameVar, EnabledVar)

}

var xWidgetActivate func(uintptr) bool

// For widgets that can be “activated” (buttons, menu items, etc.),
// this function activates them.
//
// The activation will emit the signal set using
// [method@Gtk.WidgetClass.set_activate_signal] during class initialization.
//
// Activation is what happens when you press &lt;kbd&gt;Enter&lt;/kbd&gt;
// on a widget during key navigation.
//
// If you wish to handle the activation keybinding yourself, it is
// recommended to use [method@Gtk.WidgetClass.add_shortcut] with an action
// created with [ctor@Gtk.SignalAction.new].
//
// If @widget isn't activatable, the function returns %FALSE.
func (x *Widget) Activate() bool {

	cret := xWidgetActivate(x.GoPointer())
	return cret
}

var xWidgetActivateAction func(uintptr, string, string, ...interface{}) bool

// Looks up the action in the action groups associated
// with @widget and its ancestors, and activates it.
//
// This is a wrapper around [method@Gtk.Widget.activate_action_variant]
// that constructs the @args variant according to @format_string.
func (x *Widget) ActivateAction(NameVar string, FormatStringVar string, varArgs ...interface{}) bool {

	cret := xWidgetActivateAction(x.GoPointer(), NameVar, FormatStringVar, varArgs...)
	return cret
}

var xWidgetActivateActionVariant func(uintptr, string, *glib.Variant) bool

// Looks up the action in the action groups associated with
// @widget and its ancestors, and activates it.
//
// If the action is in an action group added with
// [method@Gtk.Widget.insert_action_group], the @name is expected
// to be prefixed with the prefix that was used when the group was
// inserted.
//
// The arguments must match the actions expected parameter type,
// as returned by `g_action_get_parameter_type()`.
func (x *Widget) ActivateActionVariant(NameVar string, ArgsVar *glib.Variant) bool {

	cret := xWidgetActivateActionVariant(x.GoPointer(), NameVar, ArgsVar)
	return cret
}

var xWidgetActivateDefault func(uintptr)

// Activates the `default.activate` action from @widget.
func (x *Widget) ActivateDefault() {

	xWidgetActivateDefault(x.GoPointer())

}

var xWidgetAddController func(uintptr, uintptr)

// Adds @controller to @widget so that it will receive events.
//
// You will usually want to call this function right after
// creating any kind of [class@Gtk.EventController].
func (x *Widget) AddController(ControllerVar *EventController) {

	xWidgetAddController(x.GoPointer(), ControllerVar.GoPointer())

}

var xWidgetAddCssClass func(uintptr, string)

// Adds a style class to @widget.
//
// After calling this function, the widgets style will match
// for @css_class, according to CSS matching rules.
//
// Use [method@Gtk.Widget.remove_css_class] to remove the
// style again.
func (x *Widget) AddCssClass(CssClassVar string) {

	xWidgetAddCssClass(x.GoPointer(), CssClassVar)

}

var xWidgetAddMnemonicLabel func(uintptr, uintptr)

// Adds a widget to the list of mnemonic labels for this widget.
//
// See [method@Gtk.Widget.list_mnemonic_labels]. Note the
// list of mnemonic labels for the widget is cleared when the
// widget is destroyed, so the caller must make sure to update
// its internal state at this point as well.
func (x *Widget) AddMnemonicLabel(LabelVar *Widget) {

	xWidgetAddMnemonicLabel(x.GoPointer(), LabelVar.GoPointer())

}

var xWidgetAddTickCallback func(uintptr, uintptr, uintptr, uintptr) uint

// Queues an animation frame update and adds a callback to be called
// before each frame.
//
// Until the tick callback is removed, it will be called frequently
// (usually at the frame rate of the output device or as quickly as
// the application can be repainted, whichever is slower). For this
// reason, is most suitable for handling graphics that change every
// frame or every few frames. The tick callback does not automatically
// imply a relayout or repaint. If you want a repaint or relayout, and
// aren’t changing widget properties that would trigger that (for example,
// changing the text of a `GtkLabel`), then you will have to call
// [method@Gtk.Widget.queue_resize] or [method@Gtk.Widget.queue_draw]
// yourself.
//
// [method@Gdk.FrameClock.get_frame_time] should generally be used
// for timing continuous animations and
// [method@Gdk.FrameTimings.get_predicted_presentation_time] if you are
// trying to display isolated frames at particular times.
//
// This is a more convenient alternative to connecting directly to the
// [signal@Gdk.FrameClock::update] signal of `GdkFrameClock`, since you
// don't have to worry about when a `GdkFrameClock` is assigned to a widget.
func (x *Widget) AddTickCallback(CallbackVar *TickCallback, UserDataVar uintptr, NotifyVar *glib.DestroyNotify) uint {

	cret := xWidgetAddTickCallback(x.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallback(NotifyVar))
	return cret
}

var xWidgetAllocate func(uintptr, int, int, int, *gsk.Transform)

// This function is only used by `GtkWidget` subclasses, to
// assign a size, position and (optionally) baseline to their
// child widgets.
//
// In this function, the allocation and baseline may be adjusted.
// The given allocation will be forced to be bigger than the
// widget's minimum size, as well as at least 0×0 in size.
//
// For a version that does not take a transform, see
// [method@Gtk.Widget.size_allocate].
func (x *Widget) Allocate(WidthVar int, HeightVar int, BaselineVar int, TransformVar *gsk.Transform) {

	xWidgetAllocate(x.GoPointer(), WidthVar, HeightVar, BaselineVar, TransformVar)

}

var xWidgetChildFocus func(uintptr, DirectionType) bool

// Called by widgets as the user moves around the window using
// keyboard shortcuts.
//
// The @direction argument indicates what kind of motion is taking place (up,
// down, left, right, tab forward, tab backward).
//
// This function calls the [vfunc@Gtk.Widget.focus] virtual function; widgets
// can override the virtual function in order to implement appropriate focus
// behavior.
//
// The default `focus()` virtual function for a widget should return `TRUE` if
// moving in @direction left the focus on a focusable location inside that
// widget, and `FALSE` if moving in @direction moved the focus outside the
// widget. When returning `TRUE`, widgets normally call [method@Gtk.Widget.grab_focus]
// to place the focus accordingly; when returning `FALSE`, they don’t modify
// the current focus location.
//
// This function is used by custom widget implementations; if you're
// writing an app, you’d use [method@Gtk.Widget.grab_focus] to move
// the focus to a particular widget.
func (x *Widget) ChildFocus(DirectionVar DirectionType) bool {

	cret := xWidgetChildFocus(x.GoPointer(), DirectionVar)
	return cret
}

var xWidgetComputeBounds func(uintptr, uintptr, *graphene.Rect) bool

// Computes the bounds for @widget in the coordinate space of @target.
//
// FIXME: Explain what "bounds" are.
//
// If the operation is successful, %TRUE is returned. If @widget has no
// bounds or the bounds cannot be expressed in @target's coordinate space
// (for example if both widgets are in different windows), %FALSE is
// returned and @bounds is set to the zero rectangle.
//
// It is valid for @widget and @target to be the same widget.
func (x *Widget) ComputeBounds(TargetVar *Widget, OutBoundsVar *graphene.Rect) bool {

	cret := xWidgetComputeBounds(x.GoPointer(), TargetVar.GoPointer(), OutBoundsVar)
	return cret
}

var xWidgetComputeExpand func(uintptr, Orientation) bool

// Computes whether a container should give this widget
// extra space when possible.
//
// Containers should check this, rather than looking at
// [method@Gtk.Widget.get_hexpand] or [method@Gtk.Widget.get_vexpand].
//
// This function already checks whether the widget is visible, so
// visibility does not need to be checked separately. Non-visible
// widgets are not expanded.
//
// The computed expand value uses either the expand setting explicitly
// set on the widget itself, or, if none has been explicitly set,
// the widget may expand if some of its children do.
func (x *Widget) ComputeExpand(OrientationVar Orientation) bool {

	cret := xWidgetComputeExpand(x.GoPointer(), OrientationVar)
	return cret
}

var xWidgetComputePoint func(uintptr, uintptr, *graphene.Point, *graphene.Point) bool

// Translates the given @point in @widget's coordinates to coordinates
// relative to @target’s coordinate system.
//
// In order to perform this operation, both widgets must share a
// common ancestor.
func (x *Widget) ComputePoint(TargetVar *Widget, PointVar *graphene.Point, OutPointVar *graphene.Point) bool {

	cret := xWidgetComputePoint(x.GoPointer(), TargetVar.GoPointer(), PointVar, OutPointVar)
	return cret
}

var xWidgetComputeTransform func(uintptr, uintptr, *graphene.Matrix) bool

// Computes a matrix suitable to describe a transformation from
// @widget's coordinate system into @target's coordinate system.
//
// The transform can not be computed in certain cases, for example
// when @widget and @target do not share a common ancestor. In that
// case @out_transform gets set to the identity matrix.
func (x *Widget) ComputeTransform(TargetVar *Widget, OutTransformVar *graphene.Matrix) bool {

	cret := xWidgetComputeTransform(x.GoPointer(), TargetVar.GoPointer(), OutTransformVar)
	return cret
}

var xWidgetContains func(uintptr, float64, float64) bool

// Tests if the point at (@x, @y) is contained in @widget.
//
// The coordinates for (@x, @y) must be in widget coordinates, so
// (0, 0) is assumed to be the top left of @widget's content area.
func (x *Widget) Contains(XVar float64, YVar float64) bool {

	cret := xWidgetContains(x.GoPointer(), XVar, YVar)
	return cret
}

var xWidgetCreatePangoContext func(uintptr) uintptr

// Creates a new `PangoContext` with the appropriate font map,
// font options, font description, and base direction for drawing
// text for this widget.
//
// See also [method@Gtk.Widget.get_pango_context].
func (x *Widget) CreatePangoContext() *pango.Context {
	var cls *pango.Context

	cret := xWidgetCreatePangoContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &pango.Context{}
	cls.Ptr = cret
	return cls
}

var xWidgetCreatePangoLayout func(uintptr, string) uintptr

// Creates a new `PangoLayout` with the appropriate font map,
// font description, and base direction for drawing text for
// this widget.
//
// If you keep a `PangoLayout` created in this way around,
// you need to re-create it when the widget `PangoContext`
// is replaced. This can be tracked by listening to changes
// of the [property@Gtk.Widget:root] property on the widget.
func (x *Widget) CreatePangoLayout(TextVar string) *pango.Layout {
	var cls *pango.Layout

	cret := xWidgetCreatePangoLayout(x.GoPointer(), TextVar)

	if cret == 0 {
		return nil
	}
	cls = &pango.Layout{}
	cls.Ptr = cret
	return cls
}

var xWidgetDisposeTemplate func(uintptr, []interface{})

// Clears the template children for the given widget.
//
// This function is the opposite of [method@Gtk.Widget.init_template], and
// it is used to clear all the template children from a widget instance.
// If you bound a template child to a field in the instance structure, or
// in the instance private data structure, the field will be set to `NULL`
// after this function returns.
//
// You should call this function inside the `GObjectClass.dispose()`
// implementation of any widget that called `gtk_widget_init_template()`.
// Typically, you will want to call this function last, right before
// chaining up to the parent type's dispose implementation, e.g.
//
// ```c
// static void
// some_widget_dispose (GObject *gobject)
//
//	{
//	  SomeWidget *self = SOME_WIDGET (gobject);
//
//	  // Clear the template data for SomeWidget
//	  gtk_widget_dispose_template (GTK_WIDGET (self), SOME_TYPE_WIDGET);
//
//	  G_OBJECT_CLASS (some_widget_parent_class)-&gt;dispose (gobject);
//	}
//
// ```
func (x *Widget) DisposeTemplate(WidgetTypeVar []interface{}) {

	xWidgetDisposeTemplate(x.GoPointer(), WidgetTypeVar)

}

var xWidgetDragCheckThreshold func(uintptr, int, int, int, int) bool

// Checks to see if a drag movement has passed the GTK drag threshold.
func (x *Widget) DragCheckThreshold(StartXVar int, StartYVar int, CurrentXVar int, CurrentYVar int) bool {

	cret := xWidgetDragCheckThreshold(x.GoPointer(), StartXVar, StartYVar, CurrentXVar, CurrentYVar)
	return cret
}

var xWidgetErrorBell func(uintptr)

// Notifies the user about an input-related error on this widget.
//
// If the [property@Gtk.Settings:gtk-error-bell] setting is %TRUE,
// it calls [method@Gdk.Surface.beep], otherwise it does nothing.
//
// Note that the effect of [method@Gdk.Surface.beep] can be configured
// in many ways, depending on the windowing backend and the desktop
// environment or window manager that is used.
func (x *Widget) ErrorBell() {

	xWidgetErrorBell(x.GoPointer())

}

var xWidgetGetAllocatedBaseline func(uintptr) int

// Returns the baseline that has currently been allocated to @widget.
//
// This function is intended to be used when implementing handlers
// for the `GtkWidget`Class.snapshot() function, and when allocating
// child widgets in `GtkWidget`Class.size_allocate().
func (x *Widget) GetAllocatedBaseline() int {

	cret := xWidgetGetAllocatedBaseline(x.GoPointer())
	return cret
}

var xWidgetGetAllocatedHeight func(uintptr) int

// Returns the height that has currently been allocated to @widget.
func (x *Widget) GetAllocatedHeight() int {

	cret := xWidgetGetAllocatedHeight(x.GoPointer())
	return cret
}

var xWidgetGetAllocatedWidth func(uintptr) int

// Returns the width that has currently been allocated to @widget.
func (x *Widget) GetAllocatedWidth() int {

	cret := xWidgetGetAllocatedWidth(x.GoPointer())
	return cret
}

var xWidgetGetAllocation func(uintptr, *Allocation)

// Retrieves the widget’s allocation.
//
// Note, when implementing a layout container: a widget’s allocation
// will be its “adjusted” allocation, that is, the widget’s parent
// typically calls [method@Gtk.Widget.size_allocate] with an allocation,
// and that allocation is then adjusted (to handle margin
// and alignment for example) before assignment to the widget.
// [method@Gtk.Widget.get_allocation] returns the adjusted allocation that
// was actually assigned to the widget. The adjusted allocation is
// guaranteed to be completely contained within the
// [method@Gtk.Widget.size_allocate] allocation, however.
//
// So a layout container is guaranteed that its children stay inside
// the assigned bounds, but not that they have exactly the bounds the
// container assigned.
func (x *Widget) GetAllocation(AllocationVar *Allocation) {

	xWidgetGetAllocation(x.GoPointer(), AllocationVar)

}

var xWidgetGetAncestor func(uintptr, []interface{}) uintptr

// Gets the first ancestor of @widget with type @widget_type.
//
// For example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)`
// gets the first `GtkBox` that’s an ancestor of @widget. No
// reference will be added to the returned widget; it should
// not be unreferenced.
//
// Note that unlike [method@Gtk.Widget.is_ancestor], this function
// considers @widget to be an ancestor of itself.
func (x *Widget) GetAncestor(WidgetTypeVar []interface{}) *Widget {
	var cls *Widget

	cret := xWidgetGetAncestor(x.GoPointer(), WidgetTypeVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetCanFocus func(uintptr) bool

// Determines whether the input focus can enter @widget or any
// of its children.
//
// See [method@Gtk.Widget.set_focusable].
func (x *Widget) GetCanFocus() bool {

	cret := xWidgetGetCanFocus(x.GoPointer())
	return cret
}

var xWidgetGetCanTarget func(uintptr) bool

// Queries whether @widget can be the target of pointer events.
func (x *Widget) GetCanTarget() bool {

	cret := xWidgetGetCanTarget(x.GoPointer())
	return cret
}

var xWidgetGetChildVisible func(uintptr) bool

// Gets the value set with gtk_widget_set_child_visible().
//
// If you feel a need to use this function, your code probably
// needs reorganization.
//
// This function is only useful for container implementations
// and should never be called by an application.
func (x *Widget) GetChildVisible() bool {

	cret := xWidgetGetChildVisible(x.GoPointer())
	return cret
}

var xWidgetGetClipboard func(uintptr) uintptr

// Gets the clipboard object for @widget.
//
// This is a utility function to get the clipboard object for the
// `GdkDisplay` that @widget is using.
//
// Note that this function always works, even when @widget is not
// realized yet.
func (x *Widget) GetClipboard() *gdk.Clipboard {
	var cls *gdk.Clipboard

	cret := xWidgetGetClipboard(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Clipboard{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetCssClasses func(uintptr) []string

// Returns the list of style classes applied to @widget.
func (x *Widget) GetCssClasses() []string {

	cret := xWidgetGetCssClasses(x.GoPointer())
	return cret
}

var xWidgetGetCssName func(uintptr) string

// Returns the CSS name that is used for @self.
func (x *Widget) GetCssName() string {

	cret := xWidgetGetCssName(x.GoPointer())
	return cret
}

var xWidgetGetCursor func(uintptr) uintptr

// Queries the cursor set on @widget.
//
// See [method@Gtk.Widget.set_cursor] for details.
func (x *Widget) GetCursor() *gdk.Cursor {
	var cls *gdk.Cursor

	cret := xWidgetGetCursor(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Cursor{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetDirection func(uintptr) TextDirection

// Gets the reading direction for a particular widget.
//
// See [method@Gtk.Widget.set_direction].
func (x *Widget) GetDirection() TextDirection {

	cret := xWidgetGetDirection(x.GoPointer())
	return cret
}

var xWidgetGetDisplay func(uintptr) uintptr

// Get the `GdkDisplay` for the toplevel window associated with
// this widget.
//
// This function can only be called after the widget has been
// added to a widget hierarchy with a `GtkWindow` at the top.
//
// In general, you should only create display specific
// resources when a widget has been realized, and you should
// free those resources when the widget is unrealized.
func (x *Widget) GetDisplay() *gdk.Display {
	var cls *gdk.Display

	cret := xWidgetGetDisplay(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Display{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetFirstChild func(uintptr) uintptr

// Returns the widgets first child.
//
// This API is primarily meant for widget implementations.
func (x *Widget) GetFirstChild() *Widget {
	var cls *Widget

	cret := xWidgetGetFirstChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetFocusChild func(uintptr) uintptr

// Returns the current focus child of @widget.
func (x *Widget) GetFocusChild() *Widget {
	var cls *Widget

	cret := xWidgetGetFocusChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetFocusOnClick func(uintptr) bool

// Returns whether the widget should grab focus when it is clicked
// with the mouse.
//
// See [method@Gtk.Widget.set_focus_on_click].
func (x *Widget) GetFocusOnClick() bool {

	cret := xWidgetGetFocusOnClick(x.GoPointer())
	return cret
}

var xWidgetGetFocusable func(uintptr) bool

// Determines whether @widget can own the input focus.
//
// See [method@Gtk.Widget.set_focusable].
func (x *Widget) GetFocusable() bool {

	cret := xWidgetGetFocusable(x.GoPointer())
	return cret
}

var xWidgetGetFontMap func(uintptr) uintptr

// Gets the font map of @widget.
//
// See [method@Gtk.Widget.set_font_map].
func (x *Widget) GetFontMap() *pango.FontMap {
	var cls *pango.FontMap

	cret := xWidgetGetFontMap(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &pango.FontMap{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetFontOptions func(uintptr) *cairo.FontOptions

// Returns the `cairo_font_options_t` of widget.
//
// Seee [method@Gtk.Widget.set_font_options].
func (x *Widget) GetFontOptions() *cairo.FontOptions {

	cret := xWidgetGetFontOptions(x.GoPointer())
	return cret
}

var xWidgetGetFrameClock func(uintptr) uintptr

// Obtains the frame clock for a widget.
//
// The frame clock is a global “ticker” that can be used to drive
// animations and repaints. The most common reason to get the frame
// clock is to call [method@Gdk.FrameClock.get_frame_time], in order
// to get a time to use for animating. For example you might record
// the start of the animation with an initial value from
// [method@Gdk.FrameClock.get_frame_time], and then update the animation
// by calling [method@Gdk.FrameClock.get_frame_time] again during each repaint.
//
// [method@Gdk.FrameClock.request_phase] will result in a new frame on the
// clock, but won’t necessarily repaint any widgets. To repaint a
// widget, you have to use [method@Gtk.Widget.queue_draw] which invalidates
// the widget (thus scheduling it to receive a draw on the next
// frame). gtk_widget_queue_draw() will also end up requesting a frame
// on the appropriate frame clock.
//
// A widget’s frame clock will not change while the widget is
// mapped. Reparenting a widget (which implies a temporary unmap) can
// change the widget’s frame clock.
//
// Unrealized widgets do not have a frame clock.
func (x *Widget) GetFrameClock() *gdk.FrameClock {
	var cls *gdk.FrameClock

	cret := xWidgetGetFrameClock(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.FrameClock{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetHalign func(uintptr) Align

// Gets the horizontal alignment of @widget.
//
// For backwards compatibility reasons this method will never return
// %GTK_ALIGN_BASELINE, but instead it will convert it to
// %GTK_ALIGN_FILL. Baselines are not supported for horizontal
// alignment.
func (x *Widget) GetHalign() Align {

	cret := xWidgetGetHalign(x.GoPointer())
	return cret
}

var xWidgetGetHasTooltip func(uintptr) bool

// Returns the current value of the `has-tooltip` property.
func (x *Widget) GetHasTooltip() bool {

	cret := xWidgetGetHasTooltip(x.GoPointer())
	return cret
}

var xWidgetGetHeight func(uintptr) int

// Returns the content height of the widget.
//
// This function returns the height passed to its
// size-allocate implementation, which is the height you
// should be using in [vfunc@Gtk.Widget.snapshot].
//
// For pointer events, see [method@Gtk.Widget.contains].
func (x *Widget) GetHeight() int {

	cret := xWidgetGetHeight(x.GoPointer())
	return cret
}

var xWidgetGetHexpand func(uintptr) bool

// Gets whether the widget would like any available extra horizontal
// space.
//
// When a user resizes a `GtkWindow`, widgets with expand=TRUE
// generally receive the extra space. For example, a list or
// scrollable area or document in your window would often be set to
// expand.
//
// Containers should use [method@Gtk.Widget.compute_expand] rather
// than this function, to see whether a widget, or any of its children,
// has the expand flag set. If any child of a widget wants to
// expand, the parent may ask to expand also.
//
// This function only looks at the widget’s own hexpand flag, rather
// than computing whether the entire widget tree rooted at this widget
// wants to expand.
func (x *Widget) GetHexpand() bool {

	cret := xWidgetGetHexpand(x.GoPointer())
	return cret
}

var xWidgetGetHexpandSet func(uintptr) bool

// Gets whether gtk_widget_set_hexpand() has been used
// to explicitly set the expand flag on this widget.
//
// If [property@Gtk.Widget:hexpand] property is set, then it
// overrides any computed expand value based on child widgets.
// If `hexpand` is not set, then the expand value depends on
// whether any children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here
// for completeness and consistency.
func (x *Widget) GetHexpandSet() bool {

	cret := xWidgetGetHexpandSet(x.GoPointer())
	return cret
}

var xWidgetGetLastChild func(uintptr) uintptr

// Returns the widgets last child.
//
// This API is primarily meant for widget implementations.
func (x *Widget) GetLastChild() *Widget {
	var cls *Widget

	cret := xWidgetGetLastChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetLayoutManager func(uintptr) uintptr

// Retrieves the layout manager used by @widget.
//
// See [method@Gtk.Widget.set_layout_manager].
func (x *Widget) GetLayoutManager() *LayoutManager {
	var cls *LayoutManager

	cret := xWidgetGetLayoutManager(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &LayoutManager{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetMapped func(uintptr) bool

// Whether the widget is mapped.
func (x *Widget) GetMapped() bool {

	cret := xWidgetGetMapped(x.GoPointer())
	return cret
}

var xWidgetGetMarginBottom func(uintptr) int

// Gets the bottom margin of @widget.
func (x *Widget) GetMarginBottom() int {

	cret := xWidgetGetMarginBottom(x.GoPointer())
	return cret
}

var xWidgetGetMarginEnd func(uintptr) int

// Gets the end margin of @widget.
func (x *Widget) GetMarginEnd() int {

	cret := xWidgetGetMarginEnd(x.GoPointer())
	return cret
}

var xWidgetGetMarginStart func(uintptr) int

// Gets the start margin of @widget.
func (x *Widget) GetMarginStart() int {

	cret := xWidgetGetMarginStart(x.GoPointer())
	return cret
}

var xWidgetGetMarginTop func(uintptr) int

// Gets the top margin of @widget.
func (x *Widget) GetMarginTop() int {

	cret := xWidgetGetMarginTop(x.GoPointer())
	return cret
}

var xWidgetGetName func(uintptr) string

// Retrieves the name of a widget.
//
// See [method@Gtk.Widget.set_name] for the significance of widget names.
func (x *Widget) GetName() string {

	cret := xWidgetGetName(x.GoPointer())
	return cret
}

var xWidgetGetNative func(uintptr) uintptr

// Returns the nearest `GtkNative` ancestor of @widget.
//
// This function will return %NULL if the widget is not
// contained inside a widget tree with a native ancestor.
//
// `GtkNative` widgets will return themselves here.
func (x *Widget) GetNative() *NativeBase {
	var cls *NativeBase

	cret := xWidgetGetNative(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NativeBase{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetNextSibling func(uintptr) uintptr

// Returns the widgets next sibling.
//
// This API is primarily meant for widget implementations.
func (x *Widget) GetNextSibling() *Widget {
	var cls *Widget

	cret := xWidgetGetNextSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetOpacity func(uintptr) float64

// #Fetches the requested opacity for this widget.
//
// See [method@Gtk.Widget.set_opacity].
func (x *Widget) GetOpacity() float64 {

	cret := xWidgetGetOpacity(x.GoPointer())
	return cret
}

var xWidgetGetOverflow func(uintptr) Overflow

// Returns the widgets overflow value.
func (x *Widget) GetOverflow() Overflow {

	cret := xWidgetGetOverflow(x.GoPointer())
	return cret
}

var xWidgetGetPangoContext func(uintptr) uintptr

// Gets a `PangoContext` with the appropriate font map, font description,
// and base direction for this widget.
//
// Unlike the context returned by [method@Gtk.Widget.create_pango_context],
// this context is owned by the widget (it can be used until the screen
// for the widget changes or the widget is removed from its toplevel),
// and will be updated to match any changes to the widget’s attributes.
// This can be tracked by listening to changes of the
// [property@Gtk.Widget:root] property on the widget.
func (x *Widget) GetPangoContext() *pango.Context {
	var cls *pango.Context

	cret := xWidgetGetPangoContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &pango.Context{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetParent func(uintptr) uintptr

// Returns the parent widget of @widget.
func (x *Widget) GetParent() *Widget {
	var cls *Widget

	cret := xWidgetGetParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetPreferredSize func(uintptr, *Requisition, *Requisition)

// Retrieves the minimum and natural size of a widget, taking
// into account the widget’s preference for height-for-width management.
//
// This is used to retrieve a suitable size by container widgets which do
// not impose any restrictions on the child placement. It can be used
// to deduce toplevel window and menu sizes as well as child widgets in
// free-form containers such as `GtkFixed`.
//
// Handle with care. Note that the natural height of a height-for-width
// widget will generally be a smaller size than the minimum height, since
// the required height for the natural width is generally smaller than the
// required height for the minimum width.
//
// Use [id@gtk_widget_measure] if you want to support baseline alignment.
func (x *Widget) GetPreferredSize(MinimumSizeVar *Requisition, NaturalSizeVar *Requisition) {

	xWidgetGetPreferredSize(x.GoPointer(), MinimumSizeVar, NaturalSizeVar)

}

var xWidgetGetPrevSibling func(uintptr) uintptr

// Returns the widgets previous sibling.
//
// This API is primarily meant for widget implementations.
func (x *Widget) GetPrevSibling() *Widget {
	var cls *Widget

	cret := xWidgetGetPrevSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetPrimaryClipboard func(uintptr) uintptr

// Gets the primary clipboard of @widget.
//
// This is a utility function to get the primary clipboard object
// for the `GdkDisplay` that @widget is using.
//
// Note that this function always works, even when @widget is not
// realized yet.
func (x *Widget) GetPrimaryClipboard() *gdk.Clipboard {
	var cls *gdk.Clipboard

	cret := xWidgetGetPrimaryClipboard(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Clipboard{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetRealized func(uintptr) bool

// Determines whether @widget is realized.
func (x *Widget) GetRealized() bool {

	cret := xWidgetGetRealized(x.GoPointer())
	return cret
}

var xWidgetGetReceivesDefault func(uintptr) bool

// Determines whether @widget is always treated as the default widget
// within its toplevel when it has the focus, even if another widget
// is the default.
//
// See [method@Gtk.Widget.set_receives_default].
func (x *Widget) GetReceivesDefault() bool {

	cret := xWidgetGetReceivesDefault(x.GoPointer())
	return cret
}

var xWidgetGetRequestMode func(uintptr) SizeRequestMode

// Gets whether the widget prefers a height-for-width layout
// or a width-for-height layout.
//
// Single-child widgets generally propagate the preference of
// their child, more complex widgets need to request something
// either in context of their children or in context of their
// allocation capabilities.
func (x *Widget) GetRequestMode() SizeRequestMode {

	cret := xWidgetGetRequestMode(x.GoPointer())
	return cret
}

var xWidgetGetRoot func(uintptr) uintptr

// Returns the `GtkRoot` widget of @widget.
//
// This function will return %NULL if the widget is not contained
// inside a widget tree with a root widget.
//
// `GtkRoot` widgets will return themselves here.
func (x *Widget) GetRoot() *RootBase {
	var cls *RootBase

	cret := xWidgetGetRoot(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RootBase{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetScaleFactor func(uintptr) int

// Retrieves the internal scale factor that maps from window
// coordinates to the actual device pixels.
//
// On traditional systems this is 1, on high density outputs,
// it can be a higher value (typically 2).
//
// See [method@Gdk.Surface.get_scale_factor].
func (x *Widget) GetScaleFactor() int {

	cret := xWidgetGetScaleFactor(x.GoPointer())
	return cret
}

var xWidgetGetSensitive func(uintptr) bool

// Returns the widget’s sensitivity.
//
// This function returns the value that has been set using
// [method@Gtk.Widget.set_sensitive]).
//
// The effective sensitivity of a widget is however determined
// by both its own and its parent widget’s sensitivity.
// See [method@Gtk.Widget.is_sensitive].
func (x *Widget) GetSensitive() bool {

	cret := xWidgetGetSensitive(x.GoPointer())
	return cret
}

var xWidgetGetSettings func(uintptr) uintptr

// Gets the settings object holding the settings used for this widget.
//
// Note that this function can only be called when the `GtkWidget`
// is attached to a toplevel, since the settings object is specific
// to a particular `GdkDisplay`. If you want to monitor the widget for
// changes in its settings, connect to the `notify::display` signal.
func (x *Widget) GetSettings() *Settings {
	var cls *Settings

	cret := xWidgetGetSettings(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetSize func(uintptr, Orientation) int

// Returns the content width or height of the widget.
//
// Which dimension is returned depends on @orientation.
//
// This is equivalent to calling [method@Gtk.Widget.get_width]
// for %GTK_ORIENTATION_HORIZONTAL or [method@Gtk.Widget.get_height]
// for %GTK_ORIENTATION_VERTICAL, but can be used when
// writing orientation-independent code, such as when
// implementing [iface@Gtk.Orientable] widgets.
func (x *Widget) GetSize(OrientationVar Orientation) int {

	cret := xWidgetGetSize(x.GoPointer(), OrientationVar)
	return cret
}

var xWidgetGetSizeRequest func(uintptr, int, int)

// Gets the size request that was explicitly set for the widget using
// gtk_widget_set_size_request().
//
// A value of -1 stored in @width or @height indicates that that
// dimension has not been set explicitly and the natural requisition
// of the widget will be used instead. See
// [method@Gtk.Widget.set_size_request]. To get the size a widget will
// actually request, call [method@Gtk.Widget.measure] instead of
// this function.
func (x *Widget) GetSizeRequest(WidthVar int, HeightVar int) {

	xWidgetGetSizeRequest(x.GoPointer(), WidthVar, HeightVar)

}

var xWidgetGetStateFlags func(uintptr) StateFlags

// Returns the widget state as a flag set.
//
// It is worth mentioning that the effective %GTK_STATE_FLAG_INSENSITIVE
// state will be returned, that is, also based on parent insensitivity,
// even if @widget itself is sensitive.
//
// Also note that if you are looking for a way to obtain the
// [flags@Gtk.StateFlags] to pass to a [class@Gtk.StyleContext]
// method, you should look at [method@Gtk.StyleContext.get_state].
func (x *Widget) GetStateFlags() StateFlags {

	cret := xWidgetGetStateFlags(x.GoPointer())
	return cret
}

var xWidgetGetStyleContext func(uintptr) uintptr

// Returns the style context associated to @widget.
//
// The returned object is guaranteed to be the same
// for the lifetime of @widget.
func (x *Widget) GetStyleContext() *StyleContext {
	var cls *StyleContext

	cret := xWidgetGetStyleContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &StyleContext{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetTemplateChild func(uintptr, []interface{}, string) uintptr

// Fetch an object build from the template XML for @widget_type in
// this @widget instance.
//
// This will only report children which were previously declared
// with [method@Gtk.WidgetClass.bind_template_child_full] or one of its
// variants.
//
// This function is only meant to be called for code which is private
// to the @widget_type which declared the child and is meant for language
// bindings which cannot easily make use of the GObject structure offsets.
func (x *Widget) GetTemplateChild(WidgetTypeVar []interface{}, NameVar string) *gobject.Object {
	var cls *gobject.Object

	cret := xWidgetGetTemplateChild(x.GoPointer(), WidgetTypeVar, NameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

var xWidgetGetTooltipMarkup func(uintptr) string

// Gets the contents of the tooltip for @widget.
//
// If the tooltip has not been set using
// [method@Gtk.Widget.set_tooltip_markup], this
// function returns %NULL.
func (x *Widget) GetTooltipMarkup() string {

	cret := xWidgetGetTooltipMarkup(x.GoPointer())
	return cret
}

var xWidgetGetTooltipText func(uintptr) string

// Gets the contents of the tooltip for @widget.
//
// If the @widget's tooltip was set using
// [method@Gtk.Widget.set_tooltip_markup],
// this function will return the escaped text.
func (x *Widget) GetTooltipText() string {

	cret := xWidgetGetTooltipText(x.GoPointer())
	return cret
}

var xWidgetGetValign func(uintptr) Align

// Gets the vertical alignment of @widget.
func (x *Widget) GetValign() Align {

	cret := xWidgetGetValign(x.GoPointer())
	return cret
}

var xWidgetGetVexpand func(uintptr) bool

// Gets whether the widget would like any available extra vertical
// space.
//
// See [method@Gtk.Widget.get_hexpand] for more detail.
func (x *Widget) GetVexpand() bool {

	cret := xWidgetGetVexpand(x.GoPointer())
	return cret
}

var xWidgetGetVexpandSet func(uintptr) bool

// Gets whether gtk_widget_set_vexpand() has been used to
// explicitly set the expand flag on this widget.
//
// See [method@Gtk.Widget.get_hexpand_set] for more detail.
func (x *Widget) GetVexpandSet() bool {

	cret := xWidgetGetVexpandSet(x.GoPointer())
	return cret
}

var xWidgetGetVisible func(uintptr) bool

// Determines whether the widget is visible.
//
// If you want to take into account whether the widget’s
// parent is also marked as visible, use
// [method@Gtk.Widget.is_visible] instead.
//
// This function does not check if the widget is
// obscured in any way.
//
// See [method@Gtk.Widget.set_visible].
func (x *Widget) GetVisible() bool {

	cret := xWidgetGetVisible(x.GoPointer())
	return cret
}

var xWidgetGetWidth func(uintptr) int

// Returns the content width of the widget.
//
// This function returns the width passed to its
// size-allocate implementation, which is the width you
// should be using in [vfunc@Gtk.Widget.snapshot].
//
// For pointer events, see [method@Gtk.Widget.contains].
func (x *Widget) GetWidth() int {

	cret := xWidgetGetWidth(x.GoPointer())
	return cret
}

var xWidgetGrabFocus func(uintptr) bool

// Causes @widget to have the keyboard focus for the `GtkWindow` it's inside.
//
// If @widget is not focusable, or its [vfunc@Gtk.Widget.grab_focus]
// implementation cannot transfer the focus to a descendant of @widget
// that is focusable, it will not take focus and %FALSE will be returned.
//
// Calling [method@Gtk.Widget.grab_focus] on an already focused widget
// is allowed, should not have an effect, and return %TRUE.
func (x *Widget) GrabFocus() bool {

	cret := xWidgetGrabFocus(x.GoPointer())
	return cret
}

var xWidgetHasCssClass func(uintptr, string) bool

// Returns whether @css_class is currently applied to @widget.
func (x *Widget) HasCssClass(CssClassVar string) bool {

	cret := xWidgetHasCssClass(x.GoPointer(), CssClassVar)
	return cret
}

var xWidgetHasDefault func(uintptr) bool

// Determines whether @widget is the current default widget
// within its toplevel.
func (x *Widget) HasDefault() bool {

	cret := xWidgetHasDefault(x.GoPointer())
	return cret
}

var xWidgetHasFocus func(uintptr) bool

// Determines if the widget has the global input focus.
//
// See [method@Gtk.Widget.is_focus] for the difference between
// having the global input focus, and only having the focus
// within a toplevel.
func (x *Widget) HasFocus() bool {

	cret := xWidgetHasFocus(x.GoPointer())
	return cret
}

var xWidgetHasVisibleFocus func(uintptr) bool

// Determines if the widget should show a visible indication that
// it has the global input focus.
//
// This is a convenience function that takes into account whether
// focus indication should currently be shown in the toplevel window
// of @widget. See [method@Gtk.Window.get_focus_visible] for more
// information about focus indication.
//
// To find out if the widget has the global input focus, use
// [method@Gtk.Widget.has_focus].
func (x *Widget) HasVisibleFocus() bool {

	cret := xWidgetHasVisibleFocus(x.GoPointer())
	return cret
}

var xWidgetHide func(uintptr)

// Reverses the effects of gtk_widget_show().
//
// This is causing the widget to be hidden (invisible to the user).
func (x *Widget) Hide() {

	xWidgetHide(x.GoPointer())

}

var xWidgetInDestruction func(uintptr) bool

// Returns whether the widget is currently being destroyed.
//
// This information can sometimes be used to avoid doing
// unnecessary work.
func (x *Widget) InDestruction() bool {

	cret := xWidgetInDestruction(x.GoPointer())
	return cret
}

var xWidgetInitTemplate func(uintptr)

// Creates and initializes child widgets defined in templates.
//
// This function must be called in the instance initializer
// for any class which assigned itself a template using
// [method@Gtk.WidgetClass.set_template].
//
// It is important to call this function in the instance initializer
// of a `GtkWidget` subclass and not in `GObject.constructed()` or
// `GObject.constructor()` for two reasons:
//
//   - derived widgets will assume that the composite widgets
//     defined by its parent classes have been created in their
//     relative instance initializers
//   - when calling `g_object_new()` on a widget with composite templates,
//     it’s important to build the composite widgets before the construct
//     properties are set. Properties passed to `g_object_new()` should
//     take precedence over properties set in the private template XML
//
// A good rule of thumb is to call this function as the first thing in
// an instance initialization function.
func (x *Widget) InitTemplate() {

	xWidgetInitTemplate(x.GoPointer())

}

var xWidgetInsertActionGroup func(uintptr, string, uintptr)

// Inserts @group into @widget.
//
// Children of @widget that implement [iface@Gtk.Actionable] can
// then be associated with actions in @group by setting their
// “action-name” to @prefix.`action-name`.
//
// Note that inheritance is defined for individual actions. I.e.
// even if you insert a group with prefix @prefix, actions with
// the same prefix will still be inherited from the parent, unless
// the group contains an action with the same name.
//
// If @group is %NULL, a previously inserted group for @name is
// removed from @widget.
func (x *Widget) InsertActionGroup(NameVar string, GroupVar gio.ActionGroup) {

	xWidgetInsertActionGroup(x.GoPointer(), NameVar, GroupVar.GoPointer())

}

var xWidgetInsertAfter func(uintptr, uintptr, uintptr)

// Inserts @widget into the child widget list of @parent.
//
// It will be placed after @previous_sibling, or at the beginning if
// @previous_sibling is %NULL.
//
// After calling this function, `gtk_widget_get_prev_sibling(widget)`
// will return @previous_sibling.
//
// If @parent is already set as the parent widget of @widget, this
// function can also be used to reorder @widget in the child widget
// list of @parent.
//
// This API is primarily meant for widget implementations; if you are
// just using a widget, you *must* use its own API for adding children.
func (x *Widget) InsertAfter(ParentVar *Widget, PreviousSiblingVar *Widget) {

	xWidgetInsertAfter(x.GoPointer(), ParentVar.GoPointer(), PreviousSiblingVar.GoPointer())

}

var xWidgetInsertBefore func(uintptr, uintptr, uintptr)

// Inserts @widget into the child widget list of @parent.
//
// It will be placed before @next_sibling, or at the end if
// @next_sibling is %NULL.
//
// After calling this function, `gtk_widget_get_next_sibling(widget)`
// will return @next_sibling.
//
// If @parent is already set as the parent widget of @widget, this function
// can also be used to reorder @widget in the child widget list of @parent.
//
// This API is primarily meant for widget implementations; if you are
// just using a widget, you *must* use its own API for adding children.
func (x *Widget) InsertBefore(ParentVar *Widget, NextSiblingVar *Widget) {

	xWidgetInsertBefore(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

var xWidgetIsAncestor func(uintptr, uintptr) bool

// Determines whether @widget is somewhere inside @ancestor,
// possibly with intermediate containers.
func (x *Widget) IsAncestor(AncestorVar *Widget) bool {

	cret := xWidgetIsAncestor(x.GoPointer(), AncestorVar.GoPointer())
	return cret
}

var xWidgetIsDrawable func(uintptr) bool

// Determines whether @widget can be drawn to.
//
// A widget can be drawn if it is mapped and visible.
func (x *Widget) IsDrawable() bool {

	cret := xWidgetIsDrawable(x.GoPointer())
	return cret
}

var xWidgetIsFocus func(uintptr) bool

// Determines if the widget is the focus widget within its
// toplevel.
//
// This does not mean that the [property@Gtk.Widget:has-focus]
// property is necessarily set; [property@Gtk.Widget:has-focus]
// will only be set if the toplevel widget additionally has the
// global input focus.
func (x *Widget) IsFocus() bool {

	cret := xWidgetIsFocus(x.GoPointer())
	return cret
}

var xWidgetIsSensitive func(uintptr) bool

// Returns the widget’s effective sensitivity.
//
// This means it is sensitive itself and also its
// parent widget is sensitive.
func (x *Widget) IsSensitive() bool {

	cret := xWidgetIsSensitive(x.GoPointer())
	return cret
}

var xWidgetIsVisible func(uintptr) bool

// Determines whether the widget and all its parents are marked as
// visible.
//
// This function does not check if the widget is obscured in any way.
//
// See also [method@Gtk.Widget.get_visible] and
// [method@Gtk.Widget.set_visible].
func (x *Widget) IsVisible() bool {

	cret := xWidgetIsVisible(x.GoPointer())
	return cret
}

var xWidgetKeynavFailed func(uintptr, DirectionType) bool

// Emits the `::keynav-failed` signal on the widget.
//
// This function should be called whenever keyboard navigation
// within a single widget hits a boundary.
//
// The return value of this function should be interpreted
// in a way similar to the return value of
// [method@Gtk.Widget.child_focus]. When %TRUE is returned,
// stay in the widget, the failed keyboard  navigation is OK
// and/or there is nowhere we can/should move the focus to.
// When %FALSE is returned, the caller should continue with
// keyboard navigation outside the widget, e.g. by calling
// [method@Gtk.Widget.child_focus] on the widget’s toplevel.
//
// The default [signal@Gtk.Widget::keynav-failed] handler returns
// %FALSE for %GTK_DIR_TAB_FORWARD and %GTK_DIR_TAB_BACKWARD.
// For the other values of `GtkDirectionType` it returns %TRUE.
//
// Whenever the default handler returns %TRUE, it also calls
// [method@Gtk.Widget.error_bell] to notify the user of the
// failed keyboard navigation.
//
// A use case for providing an own implementation of ::keynav-failed
// (either by connecting to it or by overriding it) would be a row of
// [class@Gtk.Entry] widgets where the user should be able to navigate
// the entire row with the cursor keys, as e.g. known from user
// interfaces that require entering license keys.
func (x *Widget) KeynavFailed(DirectionVar DirectionType) bool {

	cret := xWidgetKeynavFailed(x.GoPointer(), DirectionVar)
	return cret
}

var xWidgetListMnemonicLabels func(uintptr) *glib.List

// Returns the widgets for which this widget is the target of a
// mnemonic.
//
// Typically, these widgets will be labels. See, for example,
// [method@Gtk.Label.set_mnemonic_widget].
//
// The widgets in the list are not individually referenced.
// If you want to iterate through the list and perform actions
// involving callbacks that might destroy the widgets, you
// must call `g_list_foreach (result, (GFunc)g_object_ref, NULL)`
// first, and then unref all the widgets afterwards.
func (x *Widget) ListMnemonicLabels() *glib.List {

	cret := xWidgetListMnemonicLabels(x.GoPointer())
	return cret
}

var xWidgetMap func(uintptr)

// Causes a widget to be mapped if it isn’t already.
//
// This function is only for use in widget implementations.
func (x *Widget) Map() {

	xWidgetMap(x.GoPointer())

}

var xWidgetMeasure func(uintptr, Orientation, int, int, int, int, int)

// Measures @widget in the orientation @orientation and for the given @for_size.
//
// As an example, if @orientation is %GTK_ORIENTATION_HORIZONTAL and @for_size
// is 300, this functions will compute the minimum and natural width of @widget
// if it is allocated at a height of 300 pixels.
//
// See [GtkWidget’s geometry management section](class.Widget.html#height-for-width-geometry-management) for
// a more details on implementing `GtkWidgetClass.measure()`.
func (x *Widget) Measure(OrientationVar Orientation, ForSizeVar int, MinimumVar int, NaturalVar int, MinimumBaselineVar int, NaturalBaselineVar int) {

	xWidgetMeasure(x.GoPointer(), OrientationVar, ForSizeVar, MinimumVar, NaturalVar, MinimumBaselineVar, NaturalBaselineVar)

}

var xWidgetMnemonicActivate func(uintptr, bool) bool

// Emits the ::mnemonic-activate signal.
//
// See [signal@Gtk.Widget::mnemonic-activate].
func (x *Widget) MnemonicActivate(GroupCyclingVar bool) bool {

	cret := xWidgetMnemonicActivate(x.GoPointer(), GroupCyclingVar)
	return cret
}

var xWidgetObserveChildren func(uintptr) uintptr

// Returns a `GListModel` to track the children of @widget.
//
// Calling this function will enable extra internal bookkeeping
// to track children and emit signals on the returned listmodel.
// It may slow down operations a lot.
//
// Applications should try hard to avoid calling this function
// because of the slowdowns.
func (x *Widget) ObserveChildren() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xWidgetObserveChildren(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xWidgetObserveControllers func(uintptr) uintptr

// Returns a `GListModel` to track the [class@Gtk.EventController]s
// of @widget.
//
// Calling this function will enable extra internal bookkeeping
// to track controllers and emit signals on the returned listmodel.
// It may slow down operations a lot.
//
// Applications should try hard to avoid calling this function
// because of the slowdowns.
func (x *Widget) ObserveControllers() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xWidgetObserveControllers(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xWidgetPick func(uintptr, float64, float64, PickFlags) uintptr

// Finds the descendant of @widget closest to the point (@x, @y).
//
// The point must be given in widget coordinates, so (0, 0) is assumed
// to be the top left of @widget's content area.
//
// Usually widgets will return %NULL if the given coordinate is not
// contained in @widget checked via [method@Gtk.Widget.contains].
// Otherwise they will recursively try to find a child that does
// not return %NULL. Widgets are however free to customize their
// picking algorithm.
//
// This function is used on the toplevel to determine the widget
// below the mouse cursor for purposes of hover highlighting and
// delivering events.
func (x *Widget) Pick(XVar float64, YVar float64, FlagsVar PickFlags) *Widget {
	var cls *Widget

	cret := xWidgetPick(x.GoPointer(), XVar, YVar, FlagsVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWidgetQueueAllocate func(uintptr)

// Flags the widget for a rerun of the [vfunc@Gtk.Widget.size_allocate]
// function.
//
// Use this function instead of [method@Gtk.Widget.queue_resize]
// when the @widget's size request didn't change but it wants to
// reposition its contents.
//
// An example user of this function is [method@Gtk.Widget.set_halign].
//
// This function is only for use in widget implementations.
func (x *Widget) QueueAllocate() {

	xWidgetQueueAllocate(x.GoPointer())

}

var xWidgetQueueDraw func(uintptr)

// Schedules this widget to be redrawn in the paint phase
// of the current or the next frame.
//
// This means @widget's [vfunc@Gtk.Widget.snapshot]
// implementation will be called.
func (x *Widget) QueueDraw() {

	xWidgetQueueDraw(x.GoPointer())

}

var xWidgetQueueResize func(uintptr)

// Flags a widget to have its size renegotiated.
//
// This should be called when a widget for some reason has a new
// size request. For example, when you change the text in a
// [class@Gtk.Label], the label queues a resize to ensure there’s
// enough space for the new text.
//
// Note that you cannot call gtk_widget_queue_resize() on a widget
// from inside its implementation of the [vfunc@Gtk.Widget.size_allocate]
// virtual method. Calls to gtk_widget_queue_resize() from inside
// [vfunc@Gtk.Widget.size_allocate] will be silently ignored.
//
// This function is only for use in widget implementations.
func (x *Widget) QueueResize() {

	xWidgetQueueResize(x.GoPointer())

}

var xWidgetRealize func(uintptr)

// Creates the GDK resources associated with a widget.
//
// Normally realization happens implicitly; if you show a widget
// and all its parent containers, then the widget will be realized
// and mapped automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be
// realized; calling this function realizes the widget’s parents
// in addition to @widget itself. If a widget is not yet inside a
// toplevel window when you realize it, bad things will happen.
//
// This function is primarily used in widget implementations, and
// isn’t very useful otherwise. Many times when you think you might
// need it, a better approach is to connect to a signal that will be
// called after the widget is realized automatically, such as
// [signal@Gtk.Widget::realize].
func (x *Widget) Realize() {

	xWidgetRealize(x.GoPointer())

}

var xWidgetRemoveController func(uintptr, uintptr)

// Removes @controller from @widget, so that it doesn't process
// events anymore.
//
// It should not be used again.
//
// Widgets will remove all event controllers automatically when they
// are destroyed, there is normally no need to call this function.
func (x *Widget) RemoveController(ControllerVar *EventController) {

	xWidgetRemoveController(x.GoPointer(), ControllerVar.GoPointer())

}

var xWidgetRemoveCssClass func(uintptr, string)

// Removes a style from @widget.
//
// After this, the style of @widget will stop matching for @css_class.
func (x *Widget) RemoveCssClass(CssClassVar string) {

	xWidgetRemoveCssClass(x.GoPointer(), CssClassVar)

}

var xWidgetRemoveMnemonicLabel func(uintptr, uintptr)

// Removes a widget from the list of mnemonic labels for this widget.
//
// See [method@Gtk.Widget.list_mnemonic_labels]. The widget must
// have previously been added to the list with
// [method@Gtk.Widget.add_mnemonic_label].
func (x *Widget) RemoveMnemonicLabel(LabelVar *Widget) {

	xWidgetRemoveMnemonicLabel(x.GoPointer(), LabelVar.GoPointer())

}

var xWidgetRemoveTickCallback func(uintptr, uint)

// Removes a tick callback previously registered with
// gtk_widget_add_tick_callback().
func (x *Widget) RemoveTickCallback(IdVar uint) {

	xWidgetRemoveTickCallback(x.GoPointer(), IdVar)

}

var xWidgetSetCanFocus func(uintptr, bool)

// Specifies whether the input focus can enter the widget
// or any of its children.
//
// Applications should set @can_focus to %FALSE to mark a
// widget as for pointer/touch use only.
//
// Note that having @can_focus be %TRUE is only one of the
// necessary conditions for being focusable. A widget must
// also be sensitive and focusable and not have an ancestor
// that is marked as not can-focus in order to receive input
// focus.
//
// See [method@Gtk.Widget.grab_focus] for actually setting
// the input focus on a widget.
func (x *Widget) SetCanFocus(CanFocusVar bool) {

	xWidgetSetCanFocus(x.GoPointer(), CanFocusVar)

}

var xWidgetSetCanTarget func(uintptr, bool)

// Sets whether @widget can be the target of pointer events.
func (x *Widget) SetCanTarget(CanTargetVar bool) {

	xWidgetSetCanTarget(x.GoPointer(), CanTargetVar)

}

var xWidgetSetChildVisible func(uintptr, bool)

// Sets whether @widget should be mapped along with its parent.
//
// The child visibility can be set for widget before it is added
// to a container with [method@Gtk.Widget.set_parent], to avoid
// mapping children unnecessary before immediately unmapping them.
// However it will be reset to its default state of %TRUE when the
// widget is removed from a container.
//
// Note that changing the child visibility of a widget does not
// queue a resize on the widget. Most of the time, the size of
// a widget is computed from all visible children, whether or
// not they are mapped. If this is not the case, the container
// can queue a resize itself.
//
// This function is only useful for container implementations
// and should never be called by an application.
func (x *Widget) SetChildVisible(ChildVisibleVar bool) {

	xWidgetSetChildVisible(x.GoPointer(), ChildVisibleVar)

}

var xWidgetSetCssClasses func(uintptr, []string)

// Clear all style classes applied to @widget
// and replace them with @classes.
func (x *Widget) SetCssClasses(ClassesVar []string) {

	xWidgetSetCssClasses(x.GoPointer(), ClassesVar)

}

var xWidgetSetCursor func(uintptr, uintptr)

// Sets the cursor to be shown when pointer devices point
// towards @widget.
//
// If the @cursor is NULL, @widget will use the cursor
// inherited from the parent widget.
func (x *Widget) SetCursor(CursorVar *gdk.Cursor) {

	xWidgetSetCursor(x.GoPointer(), CursorVar.GoPointer())

}

var xWidgetSetCursorFromName func(uintptr, string)

// Sets a named cursor to be shown when pointer devices point
// towards @widget.
//
// This is a utility function that creates a cursor via
// [ctor@Gdk.Cursor.new_from_name] and then sets it on @widget
// with [method@Gtk.Widget.set_cursor]. See those functions for
// details.
//
// On top of that, this function allows @name to be %NULL, which
// will do the same as calling [method@Gtk.Widget.set_cursor]
// with a %NULL cursor.
func (x *Widget) SetCursorFromName(NameVar string) {

	xWidgetSetCursorFromName(x.GoPointer(), NameVar)

}

var xWidgetSetDirection func(uintptr, TextDirection)

// Sets the reading direction on a particular widget.
//
// This direction controls the primary direction for widgets
// containing text, and also the direction in which the children
// of a container are packed. The ability to set the direction is
// present in order so that correct localization into languages with
// right-to-left reading directions can be done. Generally, applications
// will let the default reading direction present, except for containers
// where the containers are arranged in an order that is explicitly
// visual rather than logical (such as buttons for text justification).
//
// If the direction is set to %GTK_TEXT_DIR_NONE, then the value
// set by [func@Gtk.Widget.set_default_direction] will be used.
func (x *Widget) SetDirection(DirVar TextDirection) {

	xWidgetSetDirection(x.GoPointer(), DirVar)

}

var xWidgetSetFocusChild func(uintptr, uintptr)

// Set @child as the current focus child of @widget.
//
// This function is only suitable for widget implementations.
// If you want a certain widget to get the input focus, call
// [method@Gtk.Widget.grab_focus] on it.
func (x *Widget) SetFocusChild(ChildVar *Widget) {

	xWidgetSetFocusChild(x.GoPointer(), ChildVar.GoPointer())

}

var xWidgetSetFocusOnClick func(uintptr, bool)

// Sets whether the widget should grab focus when it is clicked
// with the mouse.
//
// Making mouse clicks not grab focus is useful in places like
// toolbars where you don’t want the keyboard focus removed from
// the main area of the application.
func (x *Widget) SetFocusOnClick(FocusOnClickVar bool) {

	xWidgetSetFocusOnClick(x.GoPointer(), FocusOnClickVar)

}

var xWidgetSetFocusable func(uintptr, bool)

// Specifies whether @widget can own the input focus.
//
// Widget implementations should set @focusable to %TRUE in
// their init() function if they want to receive keyboard input.
//
// Note that having @focusable be %TRUE is only one of the
// necessary conditions for being focusable. A widget must
// also be sensitive and can-focus and not have an ancestor
// that is marked as not can-focus in order to receive input
// focus.
//
// See [method@Gtk.Widget.grab_focus] for actually setting
// the input focus on a widget.
func (x *Widget) SetFocusable(FocusableVar bool) {

	xWidgetSetFocusable(x.GoPointer(), FocusableVar)

}

var xWidgetSetFontMap func(uintptr, uintptr)

// Sets the font map to use for Pango rendering.
//
// The font map is the object that is used to look up fonts.
// Setting a custom font map can be useful in special situations,
// e.g. when you need to add application-specific fonts to the set
// of available fonts.
//
// When not set, the widget will inherit the font map from its parent.
func (x *Widget) SetFontMap(FontMapVar *pango.FontMap) {

	xWidgetSetFontMap(x.GoPointer(), FontMapVar.GoPointer())

}

var xWidgetSetFontOptions func(uintptr, *cairo.FontOptions)

// Sets the `cairo_font_options_t` used for Pango rendering
// in this widget.
//
// When not set, the default font options for the `GdkDisplay`
// will be used.
func (x *Widget) SetFontOptions(OptionsVar *cairo.FontOptions) {

	xWidgetSetFontOptions(x.GoPointer(), OptionsVar)

}

var xWidgetSetHalign func(uintptr, Align)

// Sets the horizontal alignment of @widget.
func (x *Widget) SetHalign(AlignVar Align) {

	xWidgetSetHalign(x.GoPointer(), AlignVar)

}

var xWidgetSetHasTooltip func(uintptr, bool)

// Sets the `has-tooltip` property on @widget to @has_tooltip.
func (x *Widget) SetHasTooltip(HasTooltipVar bool) {

	xWidgetSetHasTooltip(x.GoPointer(), HasTooltipVar)

}

var xWidgetSetHexpand func(uintptr, bool)

// Sets whether the widget would like any available extra horizontal
// space.
//
// When a user resizes a `GtkWindow`, widgets with expand=TRUE
// generally receive the extra space. For example, a list or
// scrollable area or document in your window would often be set to
// expand.
//
// Call this function to set the expand flag if you would like your
// widget to become larger horizontally when the window has extra
// room.
//
// By default, widgets automatically expand if any of their children
// want to expand. (To see if a widget will automatically expand given
// its current children and state, call [method@Gtk.Widget.compute_expand].
// A container can decide how the expandability of children affects the
// expansion of the container by overriding the compute_expand virtual
// method on `GtkWidget`.).
//
// Setting hexpand explicitly with this function will override the
// automatic expand behavior.
//
// This function forces the widget to expand or not to expand,
// regardless of children.  The override occurs because
// [method@Gtk.Widget.set_hexpand] sets the hexpand-set property (see
// [method@Gtk.Widget.set_hexpand_set]) which causes the widget’s hexpand
// value to be used, rather than looking at children and widget state.
func (x *Widget) SetHexpand(ExpandVar bool) {

	xWidgetSetHexpand(x.GoPointer(), ExpandVar)

}

var xWidgetSetHexpandSet func(uintptr, bool)

// Sets whether the hexpand flag will be used.
//
// The [property@Gtk.Widget:hexpand-set] property will be set
// automatically when you call [method@Gtk.Widget.set_hexpand]
// to set hexpand, so the most likely reason to use this function
// would be to unset an explicit expand flag.
//
// If hexpand is set, then it overrides any computed
// expand value based on child widgets. If hexpand is not
// set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here
// for completeness and consistency.
func (x *Widget) SetHexpandSet(SetVar bool) {

	xWidgetSetHexpandSet(x.GoPointer(), SetVar)

}

var xWidgetSetLayoutManager func(uintptr, uintptr)

// Sets the layout manager delegate instance that provides an
// implementation for measuring and allocating the children of @widget.
func (x *Widget) SetLayoutManager(LayoutManagerVar *LayoutManager) {

	xWidgetSetLayoutManager(x.GoPointer(), LayoutManagerVar.GoPointer())

}

var xWidgetSetMarginBottom func(uintptr, int)

// Sets the bottom margin of @widget.
func (x *Widget) SetMarginBottom(MarginVar int) {

	xWidgetSetMarginBottom(x.GoPointer(), MarginVar)

}

var xWidgetSetMarginEnd func(uintptr, int)

// Sets the end margin of @widget.
func (x *Widget) SetMarginEnd(MarginVar int) {

	xWidgetSetMarginEnd(x.GoPointer(), MarginVar)

}

var xWidgetSetMarginStart func(uintptr, int)

// Sets the start margin of @widget.
func (x *Widget) SetMarginStart(MarginVar int) {

	xWidgetSetMarginStart(x.GoPointer(), MarginVar)

}

var xWidgetSetMarginTop func(uintptr, int)

// Sets the top margin of @widget.
func (x *Widget) SetMarginTop(MarginVar int) {

	xWidgetSetMarginTop(x.GoPointer(), MarginVar)

}

var xWidgetSetName func(uintptr, string)

// Sets a widgets name.
//
// Setting a name allows you to refer to the widget from a
// CSS file. You can apply a style to widgets with a particular name
// in the CSS file. See the documentation for the CSS syntax (on the
// same page as the docs for [class@Gtk.StyleContext].
//
// Note that the CSS syntax has certain special characters to delimit
// and represent elements in a selector (period, #, &gt;, *...), so using
// these will make your widget impossible to match by name. Any combination
// of alphanumeric symbols, dashes and underscores will suffice.
func (x *Widget) SetName(NameVar string) {

	xWidgetSetName(x.GoPointer(), NameVar)

}

var xWidgetSetOpacity func(uintptr, float64)

// Request the @widget to be rendered partially transparent.
//
// An opacity of 0 is fully transparent and an opacity of 1
// is fully opaque.
//
// Opacity works on both toplevel widgets and child widgets, although
// there are some limitations: For toplevel widgets, applying opacity
// depends on the capabilities of the windowing system. On X11, this
// has any effect only on X displays with a compositing manager,
// see gdk_display_is_composited(). On Windows and Wayland it should
// always work, although setting a window’s opacity after the window
// has been shown may cause some flicker.
//
// Note that the opacity is inherited through inclusion — if you set
// a toplevel to be partially translucent, all of its content will
// appear translucent, since it is ultimatively rendered on that
// toplevel. The opacity value itself is not inherited by child
// widgets (since that would make widgets deeper in the hierarchy
// progressively more translucent). As a consequence, [class@Gtk.Popover]s
// and other [iface@Gtk.Native] widgets with their own surface will use their
// own opacity value, and thus by default appear non-translucent,
// even if they are attached to a toplevel that is translucent.
func (x *Widget) SetOpacity(OpacityVar float64) {

	xWidgetSetOpacity(x.GoPointer(), OpacityVar)

}

var xWidgetSetOverflow func(uintptr, Overflow)

// Sets how @widget treats content that is drawn outside the
// widget's content area.
//
// See the definition of [enum@Gtk.Overflow] for details.
//
// This setting is provided for widget implementations and
// should not be used by application code.
//
// The default value is %GTK_OVERFLOW_VISIBLE.
func (x *Widget) SetOverflow(OverflowVar Overflow) {

	xWidgetSetOverflow(x.GoPointer(), OverflowVar)

}

var xWidgetSetParent func(uintptr, uintptr)

// Sets @parent as the parent widget of @widget.
//
// This takes care of details such as updating the state and style
// of the child to reflect its new location and resizing the parent.
// The opposite function is [method@Gtk.Widget.unparent].
//
// This function is useful only when implementing subclasses of
// `GtkWidget`.
func (x *Widget) SetParent(ParentVar *Widget) {

	xWidgetSetParent(x.GoPointer(), ParentVar.GoPointer())

}

var xWidgetSetReceivesDefault func(uintptr, bool)

// Specifies whether @widget will be treated as the default
// widget within its toplevel when it has the focus, even if
// another widget is the default.
func (x *Widget) SetReceivesDefault(ReceivesDefaultVar bool) {

	xWidgetSetReceivesDefault(x.GoPointer(), ReceivesDefaultVar)

}

var xWidgetSetSensitive func(uintptr, bool)

// Sets the sensitivity of a widget.
//
// A widget is sensitive if the user can interact with it.
// Insensitive widgets are “grayed out” and the user can’t
// interact with them. Insensitive widgets are known as
// “inactive”, “disabled”, or “ghosted” in some other toolkits.
func (x *Widget) SetSensitive(SensitiveVar bool) {

	xWidgetSetSensitive(x.GoPointer(), SensitiveVar)

}

var xWidgetSetSizeRequest func(uintptr, int, int)

// Sets the minimum size of a widget.
//
// That is, the widget’s size request will be at least @width
// by @height. You can use this function to force a widget to
// be larger than it normally would be.
//
// In most cases, [method@Gtk.Window.set_default_size] is a better
// choice for toplevel windows than this function; setting the default
// size will still allow users to shrink the window. Setting the size
// request will force them to leave the window at least as large as
// the size request.
//
// Note the inherent danger of setting any fixed size - themes,
// translations into other languages, different fonts, and user action
// can all change the appropriate size for a given widget. So, it's
// basically impossible to hardcode a size that will always be
// correct.
//
// The size request of a widget is the smallest size a widget can
// accept while still functioning well and drawing itself correctly.
// However in some strange cases a widget may be allocated less than
// its requested size, and in many cases a widget may be allocated more
// space than it requested.
//
// If the size request in a given direction is -1 (unset), then
// the “natural” size request of the widget will be used instead.
//
// The size request set here does not include any margin from the
// properties
// [property@Gtk.Widget:margin-start],
// [property@Gtk.Widget:margin-end],
// [property@Gtk.Widget:margin-top], and
// [property@Gtk.Widget:margin-bottom], but it does include pretty
// much all other padding or border properties set by any subclass
// of `GtkWidget`.
func (x *Widget) SetSizeRequest(WidthVar int, HeightVar int) {

	xWidgetSetSizeRequest(x.GoPointer(), WidthVar, HeightVar)

}

var xWidgetSetStateFlags func(uintptr, StateFlags, bool)

// Turns on flag values in the current widget state.
//
// Typical widget states are insensitive, prelighted, etc.
//
// This function accepts the values %GTK_STATE_FLAG_DIR_LTR and
// %GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set
// the widget's direction, use [method@Gtk.Widget.set_direction].
//
// This function is for use in widget implementations.
func (x *Widget) SetStateFlags(FlagsVar StateFlags, ClearVar bool) {

	xWidgetSetStateFlags(x.GoPointer(), FlagsVar, ClearVar)

}

var xWidgetSetTooltipMarkup func(uintptr, string)

// Sets @markup as the contents of the tooltip, which is marked
// up with Pango markup.
//
// This function will take care of setting the
// [property@Gtk.Widget:has-tooltip] as a side effect, and of the
// default handler for the [signal@Gtk.Widget::query-tooltip] signal.
//
// See also [method@Gtk.Tooltip.set_markup].
func (x *Widget) SetTooltipMarkup(MarkupVar string) {

	xWidgetSetTooltipMarkup(x.GoPointer(), MarkupVar)

}

var xWidgetSetTooltipText func(uintptr, string)

// Sets @text as the contents of the tooltip.
//
// If @text contains any markup, it will be escaped.
//
// This function will take care of setting
// [property@Gtk.Widget:has-tooltip] as a side effect,
// and of the default handler for the
// [signal@Gtk.Widget::query-tooltip] signal.
//
// See also [method@Gtk.Tooltip.set_text].
func (x *Widget) SetTooltipText(TextVar string) {

	xWidgetSetTooltipText(x.GoPointer(), TextVar)

}

var xWidgetSetValign func(uintptr, Align)

// Sets the vertical alignment of @widget.
func (x *Widget) SetValign(AlignVar Align) {

	xWidgetSetValign(x.GoPointer(), AlignVar)

}

var xWidgetSetVexpand func(uintptr, bool)

// Sets whether the widget would like any available extra vertical
// space.
//
// See [method@Gtk.Widget.set_hexpand] for more detail.
func (x *Widget) SetVexpand(ExpandVar bool) {

	xWidgetSetVexpand(x.GoPointer(), ExpandVar)

}

var xWidgetSetVexpandSet func(uintptr, bool)

// Sets whether the vexpand flag will be used.
//
// See [method@Gtk.Widget.set_hexpand_set] for more detail.
func (x *Widget) SetVexpandSet(SetVar bool) {

	xWidgetSetVexpandSet(x.GoPointer(), SetVar)

}

var xWidgetSetVisible func(uintptr, bool)

// Sets the visibility state of @widget.
//
// Note that setting this to %TRUE doesn’t mean the widget is
// actually viewable, see [method@Gtk.Widget.get_visible].
//
// This function simply calls [method@Gtk.Widget.show] or
// [method@Gtk.Widget.hide] but is nicer to use when the
// visibility of the widget depends on some condition.
func (x *Widget) SetVisible(VisibleVar bool) {

	xWidgetSetVisible(x.GoPointer(), VisibleVar)

}

var xWidgetShouldLayout func(uintptr) bool

// Returns whether @widget should contribute to
// the measuring and allocation of its parent.
//
// This is %FALSE for invisible children, but also
// for children that have their own surface.
func (x *Widget) ShouldLayout() bool {

	cret := xWidgetShouldLayout(x.GoPointer())
	return cret
}

var xWidgetShow func(uintptr)

// Flags a widget to be displayed.
//
// Any widget that isn’t shown will not appear on the screen.
//
// Remember that you have to show the containers containing a widget,
// in addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and
// mapped; other shown widgets are realized and mapped when their
// toplevel container is realized and mapped.
func (x *Widget) Show() {

	xWidgetShow(x.GoPointer())

}

var xWidgetSizeAllocate func(uintptr, *Allocation, int)

// Allocates widget with a transformation that translates
// the origin to the position in @allocation.
//
// This is a simple form of [method@Gtk.Widget.allocate].
func (x *Widget) SizeAllocate(AllocationVar *Allocation, BaselineVar int) {

	xWidgetSizeAllocate(x.GoPointer(), AllocationVar, BaselineVar)

}

var xWidgetSnapshotChild func(uintptr, uintptr, uintptr)

// Snapshot the a child of @widget.
//
// When a widget receives a call to the snapshot function,
// it must send synthetic [vfunc@Gtk.Widget.snapshot] calls
// to all children. This function provides a convenient way
// of doing this. A widget, when it receives a call to its
// [vfunc@Gtk.Widget.snapshot] function, calls
// gtk_widget_snapshot_child() once for each child, passing in
// the @snapshot the widget received.
//
// gtk_widget_snapshot_child() takes care of translating the origin of
// @snapshot, and deciding whether the child needs to be snapshot.
//
// This function does nothing for children that implement `GtkNative`.
func (x *Widget) SnapshotChild(ChildVar *Widget, SnapshotVar *Snapshot) {

	xWidgetSnapshotChild(x.GoPointer(), ChildVar.GoPointer(), SnapshotVar.GoPointer())

}

var xWidgetTranslateCoordinates func(uintptr, uintptr, float64, float64, float64, float64) bool

// Translate coordinates relative to @src_widget’s allocation
// to coordinates relative to @dest_widget’s allocations.
//
// In order to perform this operation, both widget must share
// a common ancestor.
func (x *Widget) TranslateCoordinates(DestWidgetVar *Widget, SrcXVar float64, SrcYVar float64, DestXVar float64, DestYVar float64) bool {

	cret := xWidgetTranslateCoordinates(x.GoPointer(), DestWidgetVar.GoPointer(), SrcXVar, SrcYVar, DestXVar, DestYVar)
	return cret
}

var xWidgetTriggerTooltipQuery func(uintptr)

// Triggers a tooltip query on the display where the toplevel
// of @widget is located.
func (x *Widget) TriggerTooltipQuery() {

	xWidgetTriggerTooltipQuery(x.GoPointer())

}

var xWidgetUnmap func(uintptr)

// Causes a widget to be unmapped if it’s currently mapped.
//
// This function is only for use in widget implementations.
func (x *Widget) Unmap() {

	xWidgetUnmap(x.GoPointer())

}

var xWidgetUnparent func(uintptr)

// Dissociate @widget from its parent.
//
// This function is only for use in widget implementations,
// typically in dispose.
func (x *Widget) Unparent() {

	xWidgetUnparent(x.GoPointer())

}

var xWidgetUnrealize func(uintptr)

// Causes a widget to be unrealized (frees all GDK resources
// associated with the widget).
//
// This function is only useful in widget implementations.
func (x *Widget) Unrealize() {

	xWidgetUnrealize(x.GoPointer())

}

var xWidgetUnsetStateFlags func(uintptr, StateFlags)

// Turns off flag values for the current widget state.
//
// See [method@Gtk.Widget.set_state_flags].
//
// This function is for use in widget implementations.
func (x *Widget) UnsetStateFlags(FlagsVar StateFlags) {

	xWidgetUnsetStateFlags(x.GoPointer(), FlagsVar)

}

func (c *Widget) GoPointer() uintptr {
	return c.Ptr
}

func (c *Widget) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Signals that all holders of a reference to the widget should release
// the reference that they hold.
//
// May result in finalization of the widget if all references are released.
//
// This signal is not suitable for saving widget state.
func (x *Widget) ConnectDestroy(cb *func(Widget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "destroy", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "destroy", cbRefPtr)
}

// Emitted when the text direction of a widget changes.
func (x *Widget) ConnectDirectionChanged(cb *func(Widget, TextDirection)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "direction-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PreviousDirectionVarp TextDirection) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PreviousDirectionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "direction-changed", cbRefPtr)
}

// Emitted when @widget is hidden.
func (x *Widget) ConnectHide(cb *func(Widget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "hide", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "hide", cbRefPtr)
}

// Emitted if keyboard navigation fails.
//
// See [method@Gtk.Widget.keynav_failed] for details.
func (x *Widget) ConnectKeynavFailed(cb *func(Widget, DirectionType) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "keynav-failed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, DirectionVarp DirectionType) bool {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, DirectionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "keynav-failed", cbRefPtr)
}

// Emitted when @widget is going to be mapped.
//
// A widget is mapped when the widget is visible (which is controlled with
// [property@Gtk.Widget:visible]) and all its parents up to the toplevel widget
// are also visible.
//
// The ::map signal can be used to determine whether a widget will be drawn,
// for instance it can resume an animation that was stopped during the
// emission of [signal@Gtk.Widget::unmap].
func (x *Widget) ConnectMap(cb *func(Widget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "map", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "map", cbRefPtr)
}

// Emitted when a widget is activated via a mnemonic.
//
// The default handler for this signal activates @widget if @group_cycling
// is %FALSE, or just makes @widget grab focus if @group_cycling is %TRUE.
func (x *Widget) ConnectMnemonicActivate(cb *func(Widget, bool) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "mnemonic-activate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, GroupCyclingVarp bool) bool {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, GroupCyclingVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "mnemonic-activate", cbRefPtr)
}

// Emitted when the focus is moved.
func (x *Widget) ConnectMoveFocus(cb *func(Widget, DirectionType)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "move-focus", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, DirectionVarp DirectionType) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, DirectionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "move-focus", cbRefPtr)
}

// Emitted when the widgets tooltip is about to be shown.
//
// This happens when the [property@Gtk.Widget:has-tooltip] property
// is %TRUE and the hover timeout has expired with the cursor hovering
// "above" @widget; or emitted when @widget got focus in keyboard mode.
//
// Using the given coordinates, the signal handler should determine
// whether a tooltip should be shown for @widget. If this is the case
// %TRUE should be returned, %FALSE otherwise.  Note that if
// @keyboard_mode is %TRUE, the values of @x and @y are undefined and
// should not be used.
//
// The signal handler is free to manipulate @tooltip with the therefore
// destined function calls.
func (x *Widget) ConnectQueryTooltip(cb *func(Widget, int, int, bool, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "query-tooltip", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, XVarp int, YVarp int, KeyboardModeVarp bool, TooltipVarp uintptr) bool {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, XVarp, YVarp, KeyboardModeVarp, TooltipVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "query-tooltip", cbRefPtr)
}

// Emitted when @widget is associated with a `GdkSurface`.
//
// This means that [method@Gtk.Widget.realize] has been called
// or the widget has been mapped (that is, it is going to be drawn).
func (x *Widget) ConnectRealize(cb *func(Widget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "realize", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "realize", cbRefPtr)
}

// Emitted when @widget is shown.
func (x *Widget) ConnectShow(cb *func(Widget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "show", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "show", cbRefPtr)
}

// Emitted when the widget state changes.
//
// See [method@Gtk.Widget.get_state_flags].
func (x *Widget) ConnectStateFlagsChanged(cb *func(Widget, StateFlags)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "state-flags-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, FlagsVarp StateFlags) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, FlagsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "state-flags-changed", cbRefPtr)
}

// Emitted when @widget is going to be unmapped.
//
// A widget is unmapped when either it or any of its parents up to the
// toplevel widget have been set as hidden.
//
// As ::unmap indicates that a widget will not be shown any longer,
// it can be used to, for example, stop an animation on the widget.
func (x *Widget) ConnectUnmap(cb *func(Widget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "unmap", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "unmap", cbRefPtr)
}

// Emitted when the `GdkSurface` associated with @widget is destroyed.
//
// This means that [method@Gtk.Widget.unrealize] has been called
// or the widget has been unmapped (that is, it is going to be hidden).
func (x *Widget) ConnectUnrealize(cb *func(Widget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "unrealize", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Widget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "unrealize", cbRefPtr)
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *Widget) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *Widget) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *Widget) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *Widget) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Widget) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Widget) UpdatePropertyValue(NPropertiesVar int, PropertiesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Widget) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Widget) UpdateRelationValue(NRelationsVar int, RelationsVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Widget) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Widget) UpdateStateValue(NStatesVar int, StatesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *Widget) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

var xWidgetGetDefaultDirection func() TextDirection

// Obtains the current default reading direction.
//
// See [func@Gtk.Widget.set_default_direction].
func WidgetGetDefaultDirection() TextDirection {

	cret := xWidgetGetDefaultDirection()
	return cret
}

var xWidgetSetDefaultDirection func(TextDirection)

// Sets the default reading direction for widgets.
//
// See [method@Gtk.Widget.set_direction].
func WidgetSetDefaultDirection(DirVar TextDirection) {

	xWidgetSetDefaultDirection(DirVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewRequisition, lib, "gtk_requisition_new")

	core.PuregoSafeRegister(&xRequisitionCopy, lib, "gtk_requisition_copy")
	core.PuregoSafeRegister(&xRequisitionFree, lib, "gtk_requisition_free")

	core.PuregoSafeRegister(&xWidgetClassAddBinding, lib, "gtk_widget_class_add_binding")
	core.PuregoSafeRegister(&xWidgetClassAddBindingAction, lib, "gtk_widget_class_add_binding_action")
	core.PuregoSafeRegister(&xWidgetClassAddBindingSignal, lib, "gtk_widget_class_add_binding_signal")
	core.PuregoSafeRegister(&xWidgetClassAddShortcut, lib, "gtk_widget_class_add_shortcut")
	core.PuregoSafeRegister(&xWidgetClassBindTemplateCallbackFull, lib, "gtk_widget_class_bind_template_callback_full")
	core.PuregoSafeRegister(&xWidgetClassBindTemplateChildFull, lib, "gtk_widget_class_bind_template_child_full")
	core.PuregoSafeRegister(&xWidgetClassGetAccessibleRole, lib, "gtk_widget_class_get_accessible_role")
	core.PuregoSafeRegister(&xWidgetClassGetActivateSignal, lib, "gtk_widget_class_get_activate_signal")
	core.PuregoSafeRegister(&xWidgetClassGetCssName, lib, "gtk_widget_class_get_css_name")
	core.PuregoSafeRegister(&xWidgetClassGetLayoutManagerType, lib, "gtk_widget_class_get_layout_manager_type")
	core.PuregoSafeRegister(&xWidgetClassInstallAction, lib, "gtk_widget_class_install_action")
	core.PuregoSafeRegister(&xWidgetClassInstallPropertyAction, lib, "gtk_widget_class_install_property_action")
	core.PuregoSafeRegister(&xWidgetClassQueryAction, lib, "gtk_widget_class_query_action")
	core.PuregoSafeRegister(&xWidgetClassSetAccessibleRole, lib, "gtk_widget_class_set_accessible_role")
	core.PuregoSafeRegister(&xWidgetClassSetActivateSignal, lib, "gtk_widget_class_set_activate_signal")
	core.PuregoSafeRegister(&xWidgetClassSetActivateSignalFromName, lib, "gtk_widget_class_set_activate_signal_from_name")
	core.PuregoSafeRegister(&xWidgetClassSetCssName, lib, "gtk_widget_class_set_css_name")
	core.PuregoSafeRegister(&xWidgetClassSetLayoutManagerType, lib, "gtk_widget_class_set_layout_manager_type")
	core.PuregoSafeRegister(&xWidgetClassSetTemplate, lib, "gtk_widget_class_set_template")
	core.PuregoSafeRegister(&xWidgetClassSetTemplateFromResource, lib, "gtk_widget_class_set_template_from_resource")
	core.PuregoSafeRegister(&xWidgetClassSetTemplateScope, lib, "gtk_widget_class_set_template_scope")

	core.PuregoSafeRegister(&xWidgetActionSetEnabled, lib, "gtk_widget_action_set_enabled")
	core.PuregoSafeRegister(&xWidgetActivate, lib, "gtk_widget_activate")
	core.PuregoSafeRegister(&xWidgetActivateAction, lib, "gtk_widget_activate_action")
	core.PuregoSafeRegister(&xWidgetActivateActionVariant, lib, "gtk_widget_activate_action_variant")
	core.PuregoSafeRegister(&xWidgetActivateDefault, lib, "gtk_widget_activate_default")
	core.PuregoSafeRegister(&xWidgetAddController, lib, "gtk_widget_add_controller")
	core.PuregoSafeRegister(&xWidgetAddCssClass, lib, "gtk_widget_add_css_class")
	core.PuregoSafeRegister(&xWidgetAddMnemonicLabel, lib, "gtk_widget_add_mnemonic_label")
	core.PuregoSafeRegister(&xWidgetAddTickCallback, lib, "gtk_widget_add_tick_callback")
	core.PuregoSafeRegister(&xWidgetAllocate, lib, "gtk_widget_allocate")
	core.PuregoSafeRegister(&xWidgetChildFocus, lib, "gtk_widget_child_focus")
	core.PuregoSafeRegister(&xWidgetComputeBounds, lib, "gtk_widget_compute_bounds")
	core.PuregoSafeRegister(&xWidgetComputeExpand, lib, "gtk_widget_compute_expand")
	core.PuregoSafeRegister(&xWidgetComputePoint, lib, "gtk_widget_compute_point")
	core.PuregoSafeRegister(&xWidgetComputeTransform, lib, "gtk_widget_compute_transform")
	core.PuregoSafeRegister(&xWidgetContains, lib, "gtk_widget_contains")
	core.PuregoSafeRegister(&xWidgetCreatePangoContext, lib, "gtk_widget_create_pango_context")
	core.PuregoSafeRegister(&xWidgetCreatePangoLayout, lib, "gtk_widget_create_pango_layout")
	core.PuregoSafeRegister(&xWidgetDisposeTemplate, lib, "gtk_widget_dispose_template")
	core.PuregoSafeRegister(&xWidgetDragCheckThreshold, lib, "gtk_drag_check_threshold")
	core.PuregoSafeRegister(&xWidgetErrorBell, lib, "gtk_widget_error_bell")
	core.PuregoSafeRegister(&xWidgetGetAllocatedBaseline, lib, "gtk_widget_get_allocated_baseline")
	core.PuregoSafeRegister(&xWidgetGetAllocatedHeight, lib, "gtk_widget_get_allocated_height")
	core.PuregoSafeRegister(&xWidgetGetAllocatedWidth, lib, "gtk_widget_get_allocated_width")
	core.PuregoSafeRegister(&xWidgetGetAllocation, lib, "gtk_widget_get_allocation")
	core.PuregoSafeRegister(&xWidgetGetAncestor, lib, "gtk_widget_get_ancestor")
	core.PuregoSafeRegister(&xWidgetGetCanFocus, lib, "gtk_widget_get_can_focus")
	core.PuregoSafeRegister(&xWidgetGetCanTarget, lib, "gtk_widget_get_can_target")
	core.PuregoSafeRegister(&xWidgetGetChildVisible, lib, "gtk_widget_get_child_visible")
	core.PuregoSafeRegister(&xWidgetGetClipboard, lib, "gtk_widget_get_clipboard")
	core.PuregoSafeRegister(&xWidgetGetCssClasses, lib, "gtk_widget_get_css_classes")
	core.PuregoSafeRegister(&xWidgetGetCssName, lib, "gtk_widget_get_css_name")
	core.PuregoSafeRegister(&xWidgetGetCursor, lib, "gtk_widget_get_cursor")
	core.PuregoSafeRegister(&xWidgetGetDirection, lib, "gtk_widget_get_direction")
	core.PuregoSafeRegister(&xWidgetGetDisplay, lib, "gtk_widget_get_display")
	core.PuregoSafeRegister(&xWidgetGetFirstChild, lib, "gtk_widget_get_first_child")
	core.PuregoSafeRegister(&xWidgetGetFocusChild, lib, "gtk_widget_get_focus_child")
	core.PuregoSafeRegister(&xWidgetGetFocusOnClick, lib, "gtk_widget_get_focus_on_click")
	core.PuregoSafeRegister(&xWidgetGetFocusable, lib, "gtk_widget_get_focusable")
	core.PuregoSafeRegister(&xWidgetGetFontMap, lib, "gtk_widget_get_font_map")
	core.PuregoSafeRegister(&xWidgetGetFontOptions, lib, "gtk_widget_get_font_options")
	core.PuregoSafeRegister(&xWidgetGetFrameClock, lib, "gtk_widget_get_frame_clock")
	core.PuregoSafeRegister(&xWidgetGetHalign, lib, "gtk_widget_get_halign")
	core.PuregoSafeRegister(&xWidgetGetHasTooltip, lib, "gtk_widget_get_has_tooltip")
	core.PuregoSafeRegister(&xWidgetGetHeight, lib, "gtk_widget_get_height")
	core.PuregoSafeRegister(&xWidgetGetHexpand, lib, "gtk_widget_get_hexpand")
	core.PuregoSafeRegister(&xWidgetGetHexpandSet, lib, "gtk_widget_get_hexpand_set")
	core.PuregoSafeRegister(&xWidgetGetLastChild, lib, "gtk_widget_get_last_child")
	core.PuregoSafeRegister(&xWidgetGetLayoutManager, lib, "gtk_widget_get_layout_manager")
	core.PuregoSafeRegister(&xWidgetGetMapped, lib, "gtk_widget_get_mapped")
	core.PuregoSafeRegister(&xWidgetGetMarginBottom, lib, "gtk_widget_get_margin_bottom")
	core.PuregoSafeRegister(&xWidgetGetMarginEnd, lib, "gtk_widget_get_margin_end")
	core.PuregoSafeRegister(&xWidgetGetMarginStart, lib, "gtk_widget_get_margin_start")
	core.PuregoSafeRegister(&xWidgetGetMarginTop, lib, "gtk_widget_get_margin_top")
	core.PuregoSafeRegister(&xWidgetGetName, lib, "gtk_widget_get_name")
	core.PuregoSafeRegister(&xWidgetGetNative, lib, "gtk_widget_get_native")
	core.PuregoSafeRegister(&xWidgetGetNextSibling, lib, "gtk_widget_get_next_sibling")
	core.PuregoSafeRegister(&xWidgetGetOpacity, lib, "gtk_widget_get_opacity")
	core.PuregoSafeRegister(&xWidgetGetOverflow, lib, "gtk_widget_get_overflow")
	core.PuregoSafeRegister(&xWidgetGetPangoContext, lib, "gtk_widget_get_pango_context")
	core.PuregoSafeRegister(&xWidgetGetParent, lib, "gtk_widget_get_parent")
	core.PuregoSafeRegister(&xWidgetGetPreferredSize, lib, "gtk_widget_get_preferred_size")
	core.PuregoSafeRegister(&xWidgetGetPrevSibling, lib, "gtk_widget_get_prev_sibling")
	core.PuregoSafeRegister(&xWidgetGetPrimaryClipboard, lib, "gtk_widget_get_primary_clipboard")
	core.PuregoSafeRegister(&xWidgetGetRealized, lib, "gtk_widget_get_realized")
	core.PuregoSafeRegister(&xWidgetGetReceivesDefault, lib, "gtk_widget_get_receives_default")
	core.PuregoSafeRegister(&xWidgetGetRequestMode, lib, "gtk_widget_get_request_mode")
	core.PuregoSafeRegister(&xWidgetGetRoot, lib, "gtk_widget_get_root")
	core.PuregoSafeRegister(&xWidgetGetScaleFactor, lib, "gtk_widget_get_scale_factor")
	core.PuregoSafeRegister(&xWidgetGetSensitive, lib, "gtk_widget_get_sensitive")
	core.PuregoSafeRegister(&xWidgetGetSettings, lib, "gtk_widget_get_settings")
	core.PuregoSafeRegister(&xWidgetGetSize, lib, "gtk_widget_get_size")
	core.PuregoSafeRegister(&xWidgetGetSizeRequest, lib, "gtk_widget_get_size_request")
	core.PuregoSafeRegister(&xWidgetGetStateFlags, lib, "gtk_widget_get_state_flags")
	core.PuregoSafeRegister(&xWidgetGetStyleContext, lib, "gtk_widget_get_style_context")
	core.PuregoSafeRegister(&xWidgetGetTemplateChild, lib, "gtk_widget_get_template_child")
	core.PuregoSafeRegister(&xWidgetGetTooltipMarkup, lib, "gtk_widget_get_tooltip_markup")
	core.PuregoSafeRegister(&xWidgetGetTooltipText, lib, "gtk_widget_get_tooltip_text")
	core.PuregoSafeRegister(&xWidgetGetValign, lib, "gtk_widget_get_valign")
	core.PuregoSafeRegister(&xWidgetGetVexpand, lib, "gtk_widget_get_vexpand")
	core.PuregoSafeRegister(&xWidgetGetVexpandSet, lib, "gtk_widget_get_vexpand_set")
	core.PuregoSafeRegister(&xWidgetGetVisible, lib, "gtk_widget_get_visible")
	core.PuregoSafeRegister(&xWidgetGetWidth, lib, "gtk_widget_get_width")
	core.PuregoSafeRegister(&xWidgetGrabFocus, lib, "gtk_widget_grab_focus")
	core.PuregoSafeRegister(&xWidgetHasCssClass, lib, "gtk_widget_has_css_class")
	core.PuregoSafeRegister(&xWidgetHasDefault, lib, "gtk_widget_has_default")
	core.PuregoSafeRegister(&xWidgetHasFocus, lib, "gtk_widget_has_focus")
	core.PuregoSafeRegister(&xWidgetHasVisibleFocus, lib, "gtk_widget_has_visible_focus")
	core.PuregoSafeRegister(&xWidgetHide, lib, "gtk_widget_hide")
	core.PuregoSafeRegister(&xWidgetInDestruction, lib, "gtk_widget_in_destruction")
	core.PuregoSafeRegister(&xWidgetInitTemplate, lib, "gtk_widget_init_template")
	core.PuregoSafeRegister(&xWidgetInsertActionGroup, lib, "gtk_widget_insert_action_group")
	core.PuregoSafeRegister(&xWidgetInsertAfter, lib, "gtk_widget_insert_after")
	core.PuregoSafeRegister(&xWidgetInsertBefore, lib, "gtk_widget_insert_before")
	core.PuregoSafeRegister(&xWidgetIsAncestor, lib, "gtk_widget_is_ancestor")
	core.PuregoSafeRegister(&xWidgetIsDrawable, lib, "gtk_widget_is_drawable")
	core.PuregoSafeRegister(&xWidgetIsFocus, lib, "gtk_widget_is_focus")
	core.PuregoSafeRegister(&xWidgetIsSensitive, lib, "gtk_widget_is_sensitive")
	core.PuregoSafeRegister(&xWidgetIsVisible, lib, "gtk_widget_is_visible")
	core.PuregoSafeRegister(&xWidgetKeynavFailed, lib, "gtk_widget_keynav_failed")
	core.PuregoSafeRegister(&xWidgetListMnemonicLabels, lib, "gtk_widget_list_mnemonic_labels")
	core.PuregoSafeRegister(&xWidgetMap, lib, "gtk_widget_map")
	core.PuregoSafeRegister(&xWidgetMeasure, lib, "gtk_widget_measure")
	core.PuregoSafeRegister(&xWidgetMnemonicActivate, lib, "gtk_widget_mnemonic_activate")
	core.PuregoSafeRegister(&xWidgetObserveChildren, lib, "gtk_widget_observe_children")
	core.PuregoSafeRegister(&xWidgetObserveControllers, lib, "gtk_widget_observe_controllers")
	core.PuregoSafeRegister(&xWidgetPick, lib, "gtk_widget_pick")
	core.PuregoSafeRegister(&xWidgetQueueAllocate, lib, "gtk_widget_queue_allocate")
	core.PuregoSafeRegister(&xWidgetQueueDraw, lib, "gtk_widget_queue_draw")
	core.PuregoSafeRegister(&xWidgetQueueResize, lib, "gtk_widget_queue_resize")
	core.PuregoSafeRegister(&xWidgetRealize, lib, "gtk_widget_realize")
	core.PuregoSafeRegister(&xWidgetRemoveController, lib, "gtk_widget_remove_controller")
	core.PuregoSafeRegister(&xWidgetRemoveCssClass, lib, "gtk_widget_remove_css_class")
	core.PuregoSafeRegister(&xWidgetRemoveMnemonicLabel, lib, "gtk_widget_remove_mnemonic_label")
	core.PuregoSafeRegister(&xWidgetRemoveTickCallback, lib, "gtk_widget_remove_tick_callback")
	core.PuregoSafeRegister(&xWidgetSetCanFocus, lib, "gtk_widget_set_can_focus")
	core.PuregoSafeRegister(&xWidgetSetCanTarget, lib, "gtk_widget_set_can_target")
	core.PuregoSafeRegister(&xWidgetSetChildVisible, lib, "gtk_widget_set_child_visible")
	core.PuregoSafeRegister(&xWidgetSetCssClasses, lib, "gtk_widget_set_css_classes")
	core.PuregoSafeRegister(&xWidgetSetCursor, lib, "gtk_widget_set_cursor")
	core.PuregoSafeRegister(&xWidgetSetCursorFromName, lib, "gtk_widget_set_cursor_from_name")
	core.PuregoSafeRegister(&xWidgetSetDirection, lib, "gtk_widget_set_direction")
	core.PuregoSafeRegister(&xWidgetSetFocusChild, lib, "gtk_widget_set_focus_child")
	core.PuregoSafeRegister(&xWidgetSetFocusOnClick, lib, "gtk_widget_set_focus_on_click")
	core.PuregoSafeRegister(&xWidgetSetFocusable, lib, "gtk_widget_set_focusable")
	core.PuregoSafeRegister(&xWidgetSetFontMap, lib, "gtk_widget_set_font_map")
	core.PuregoSafeRegister(&xWidgetSetFontOptions, lib, "gtk_widget_set_font_options")
	core.PuregoSafeRegister(&xWidgetSetHalign, lib, "gtk_widget_set_halign")
	core.PuregoSafeRegister(&xWidgetSetHasTooltip, lib, "gtk_widget_set_has_tooltip")
	core.PuregoSafeRegister(&xWidgetSetHexpand, lib, "gtk_widget_set_hexpand")
	core.PuregoSafeRegister(&xWidgetSetHexpandSet, lib, "gtk_widget_set_hexpand_set")
	core.PuregoSafeRegister(&xWidgetSetLayoutManager, lib, "gtk_widget_set_layout_manager")
	core.PuregoSafeRegister(&xWidgetSetMarginBottom, lib, "gtk_widget_set_margin_bottom")
	core.PuregoSafeRegister(&xWidgetSetMarginEnd, lib, "gtk_widget_set_margin_end")
	core.PuregoSafeRegister(&xWidgetSetMarginStart, lib, "gtk_widget_set_margin_start")
	core.PuregoSafeRegister(&xWidgetSetMarginTop, lib, "gtk_widget_set_margin_top")
	core.PuregoSafeRegister(&xWidgetSetName, lib, "gtk_widget_set_name")
	core.PuregoSafeRegister(&xWidgetSetOpacity, lib, "gtk_widget_set_opacity")
	core.PuregoSafeRegister(&xWidgetSetOverflow, lib, "gtk_widget_set_overflow")
	core.PuregoSafeRegister(&xWidgetSetParent, lib, "gtk_widget_set_parent")
	core.PuregoSafeRegister(&xWidgetSetReceivesDefault, lib, "gtk_widget_set_receives_default")
	core.PuregoSafeRegister(&xWidgetSetSensitive, lib, "gtk_widget_set_sensitive")
	core.PuregoSafeRegister(&xWidgetSetSizeRequest, lib, "gtk_widget_set_size_request")
	core.PuregoSafeRegister(&xWidgetSetStateFlags, lib, "gtk_widget_set_state_flags")
	core.PuregoSafeRegister(&xWidgetSetTooltipMarkup, lib, "gtk_widget_set_tooltip_markup")
	core.PuregoSafeRegister(&xWidgetSetTooltipText, lib, "gtk_widget_set_tooltip_text")
	core.PuregoSafeRegister(&xWidgetSetValign, lib, "gtk_widget_set_valign")
	core.PuregoSafeRegister(&xWidgetSetVexpand, lib, "gtk_widget_set_vexpand")
	core.PuregoSafeRegister(&xWidgetSetVexpandSet, lib, "gtk_widget_set_vexpand_set")
	core.PuregoSafeRegister(&xWidgetSetVisible, lib, "gtk_widget_set_visible")
	core.PuregoSafeRegister(&xWidgetShouldLayout, lib, "gtk_widget_should_layout")
	core.PuregoSafeRegister(&xWidgetShow, lib, "gtk_widget_show")
	core.PuregoSafeRegister(&xWidgetSizeAllocate, lib, "gtk_widget_size_allocate")
	core.PuregoSafeRegister(&xWidgetSnapshotChild, lib, "gtk_widget_snapshot_child")
	core.PuregoSafeRegister(&xWidgetTranslateCoordinates, lib, "gtk_widget_translate_coordinates")
	core.PuregoSafeRegister(&xWidgetTriggerTooltipQuery, lib, "gtk_widget_trigger_tooltip_query")
	core.PuregoSafeRegister(&xWidgetUnmap, lib, "gtk_widget_unmap")
	core.PuregoSafeRegister(&xWidgetUnparent, lib, "gtk_widget_unparent")
	core.PuregoSafeRegister(&xWidgetUnrealize, lib, "gtk_widget_unrealize")
	core.PuregoSafeRegister(&xWidgetUnsetStateFlags, lib, "gtk_widget_unset_state_flags")

	core.PuregoSafeRegister(&xWidgetGetDefaultDirection, lib, "gtk_widget_get_default_direction")
	core.PuregoSafeRegister(&xWidgetSetDefaultDirection, lib, "gtk_widget_set_default_direction")

}
