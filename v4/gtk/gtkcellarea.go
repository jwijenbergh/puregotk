// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// The type of the callback functions used for iterating over the
// cell renderers and their allocated areas inside a `GtkCellArea`,
// see gtk_cell_area_foreach_alloc().
type CellAllocCallback func(uintptr, *gdk.Rectangle, *gdk.Rectangle, uintptr) bool

// The type of the callback functions used for iterating over
// the cell renderers of a `GtkCellArea`, see gtk_cell_area_foreach().
type CellCallback func(uintptr, uintptr) bool

type CellAreaClass struct {
	ParentClass uintptr

	Padding uintptr
}

func (x *CellAreaClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xCellAreaClassFindCellProperty func(uintptr, string) uintptr

// Finds a cell property of a cell area class by name.
func (x *CellAreaClass) FindCellProperty(PropertyNameVar string) *gobject.ParamSpec {
	var cls *gobject.ParamSpec

	cret := xCellAreaClassFindCellProperty(x.GoPointer(), PropertyNameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gobject.ParamSpec{}
	cls.Ptr = cret
	return cls
}

var xCellAreaClassInstallCellProperty func(uintptr, uint, uintptr)

// Installs a cell property on a cell area class.
func (x *CellAreaClass) InstallCellProperty(PropertyIdVar uint, PspecVar *gobject.ParamSpec) {

	xCellAreaClassInstallCellProperty(x.GoPointer(), PropertyIdVar, PspecVar.GoPointer())

}

var xCellAreaClassListCellProperties func(uintptr, uint) uintptr

// Returns all cell properties of a cell area class.
func (x *CellAreaClass) ListCellProperties(NPropertiesVar uint) uintptr {

	cret := xCellAreaClassListCellProperties(x.GoPointer(), NPropertiesVar)
	return cret
}

// An abstract class for laying out `GtkCellRenderer`s
//
// The `GtkCellArea` is an abstract class for [iface@Gtk.CellLayout]
// widgets (also referred to as "layouting widgets") to interface with
// an arbitrary number of [class@Gtk.CellRenderer]s and interact with the user
// for a given [iface@Gtk.TreeModel] row.
//
// The cell area handles events, focus navigation, drawing and
// size requests and allocations for a given row of data.
//
// Usually users dont have to interact with the `GtkCellArea` directly
// unless they are implementing a cell-layouting widget themselves.
//
// # Requesting area sizes
//
// As outlined in
// [GtkWidget’s geometry management section](class.Widget.html#height-for-width-geometry-management),
// GTK uses a height-for-width
// geometry management system to compute the sizes of widgets and user
// interfaces. `GtkCellArea` uses the same semantics to calculate the
// size of an area for an arbitrary number of `GtkTreeModel` rows.
//
// When requesting the size of a cell area one needs to calculate
// the size for a handful of rows, and this will be done differently by
// different layouting widgets. For instance a [class@Gtk.TreeViewColumn]
// always lines up the areas from top to bottom while a [class@Gtk.IconView]
// on the other hand might enforce that all areas received the same
// width and wrap the areas around, requesting height for more cell
// areas when allocated less width.
//
// It’s also important for areas to maintain some cell
// alignments with areas rendered for adjacent rows (cells can
// appear “columnized” inside an area even when the size of
// cells are different in each row). For this reason the `GtkCellArea`
// uses a [class@Gtk.CellAreaContext] object to store the alignments
// and sizes along the way (as well as the overall largest minimum
// and natural size for all the rows which have been calculated
// with the said context).
//
// The [class@Gtk.CellAreaContext] is an opaque object specific to the
// `GtkCellArea` which created it (see [method@Gtk.CellArea.create_context]).
//
// The owning cell-layouting widget can create as many contexts as
// it wishes to calculate sizes of rows which should receive the
// same size in at least one orientation (horizontally or vertically),
// However, it’s important that the same [class@Gtk.CellAreaContext] which
// was used to request the sizes for a given `GtkTreeModel` row be
// used when rendering or processing events for that row.
//
// In order to request the width of all the rows at the root level
// of a `GtkTreeModel` one would do the following:
//
// ```c
// GtkTreeIter iter;
// int minimum_width;
// int natural_width;
//
// valid = gtk_tree_model_get_iter_first (model, &amp;iter);
// while (valid)
//
//	{
//	  gtk_cell_area_apply_attributes (area, model, &amp;iter, FALSE, FALSE);
//	  gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
//
//	  valid = gtk_tree_model_iter_next (model, &amp;iter);
//	}
//
// gtk_cell_area_context_get_preferred_width (context, &amp;minimum_width, &amp;natural_width);
// ```
//
// Note that in this example it’s not important to observe the
// returned minimum and natural width of the area for each row
// unless the cell-layouting object is actually interested in the
// widths of individual rows. The overall width is however stored
// in the accompanying `GtkCellAreaContext` object and can be consulted
// at any time.
//
// This can be useful since `GtkCellLayout` widgets usually have to
// support requesting and rendering rows in treemodels with an
// exceedingly large amount of rows. The `GtkCellLayout` widget in
// that case would calculate the required width of the rows in an
// idle or timeout source (see [func@GLib.timeout_add]) and when the widget
// is requested its actual width in [vfunc@Gtk.Widget.measure]
// it can simply consult the width accumulated so far in the
// `GtkCellAreaContext` object.
//
// A simple example where rows are rendered from top to bottom and
// take up the full width of the layouting widget would look like:
//
// ```c
// static void
// foo_get_preferred_width (GtkWidget *widget,
//
//	int       *minimum_size,
//	int       *natural_size)
//
//	{
//	  Foo *self = FOO (widget);
//	  FooPrivate *priv = foo_get_instance_private (self);
//
//	  foo_ensure_at_least_one_handfull_of_rows_have_been_requested (self);
//
//	  gtk_cell_area_context_get_preferred_width (priv-&gt;context, minimum_size, natural_size);
//	}
//
// ```
//
// In the above example the `Foo` widget has to make sure that some
// row sizes have been calculated (the amount of rows that `Foo` judged
// was appropriate to request space for in a single timeout iteration)
// before simply returning the amount of space required by the area via
// the `GtkCellAreaContext`.
//
// Requesting the height for width (or width for height) of an area is
// a similar task except in this case the `GtkCellAreaContext` does not
// store the data (actually, it does not know how much space the layouting
// widget plans to allocate it for every row. It’s up to the layouting
// widget to render each row of data with the appropriate height and
// width which was requested by the `GtkCellArea`).
//
// In order to request the height for width of all the rows at the
// root level of a `GtkTreeModel` one would do the following:
//
// ```c
// GtkTreeIter iter;
// int minimum_height;
// int natural_height;
// int full_minimum_height = 0;
// int full_natural_height = 0;
//
// valid = gtk_tree_model_get_iter_first (model, &amp;iter);
// while (valid)
//
//	{
//	  gtk_cell_area_apply_attributes (area, model, &amp;iter, FALSE, FALSE);
//	  gtk_cell_area_get_preferred_height_for_width (area, context, widget,
//	                                                width, &amp;minimum_height, &amp;natural_height);
//
//	  if (width_is_for_allocation)
//	     cache_row_height (&amp;iter, minimum_height, natural_height);
//
//	  full_minimum_height += minimum_height;
//	  full_natural_height += natural_height;
//
//	  valid = gtk_tree_model_iter_next (model, &amp;iter);
//	}
//
// ```
//
// Note that in the above example we would need to cache the heights
// returned for each row so that we would know what sizes to render the
// areas for each row. However we would only want to really cache the
// heights if the request is intended for the layouting widgets real
// allocation.
//
// In some cases the layouting widget is requested the height for an
// arbitrary for_width, this is a special case for layouting widgets
// who need to request size for tens of thousands  of rows. For this
// case it’s only important that the layouting widget calculate
// one reasonably sized chunk of rows and return that height
// synchronously. The reasoning here is that any layouting widget is
// at least capable of synchronously calculating enough height to fill
// the screen height (or scrolled window height) in response to a single
// call to [vfunc@Gtk.Widget.measure]. Returning
// a perfect height for width that is larger than the screen area is
// inconsequential since after the layouting receives an allocation
// from a scrolled window it simply continues to drive the scrollbar
// values while more and more height is required for the row heights
// that are calculated in the background.
//
// # Rendering Areas
//
// Once area sizes have been acquired at least for the rows in the
// visible area of the layouting widget they can be rendered at
// [vfunc@Gtk.Widget.snapshot] time.
//
// A crude example of how to render all the rows at the root level
// runs as follows:
//
// ```c
// GtkAllocation allocation;
// GdkRectangle cell_area = { 0, };
// GtkTreeIter iter;
// int minimum_width;
// int natural_width;
//
// gtk_widget_get_allocation (widget, &amp;allocation);
// cell_area.width = allocation.width;
//
// valid = gtk_tree_model_get_iter_first (model, &amp;iter);
// while (valid)
//
//	{
//	  cell_area.height = get_cached_height_for_row (&amp;iter);
//
//	  gtk_cell_area_apply_attributes (area, model, &amp;iter, FALSE, FALSE);
//	  gtk_cell_area_render (area, context, widget, cr,
//	                        &amp;cell_area, &amp;cell_area, state_flags, FALSE);
//
//	  cell_area.y += cell_area.height;
//
//	  valid = gtk_tree_model_iter_next (model, &amp;iter);
//	}
//
// ```
//
// Note that the cached height in this example really depends on how
// the layouting widget works. The layouting widget might decide to
// give every row its minimum or natural height or, if the model content
// is expected to fit inside the layouting widget without scrolling, it
// would make sense to calculate the allocation for each row at
// the time the widget is allocated using [func@Gtk.distribute_natural_allocation].
//
// # Handling Events and Driving Keyboard Focus
//
// Passing events to the area is as simple as handling events on any
// normal widget and then passing them to the [method@Gtk.CellArea.event]
// API as they come in. Usually `GtkCellArea` is only interested in
// button events, however some customized derived areas can be implemented
// who are interested in handling other events. Handling an event can
// trigger the [`signal@Gtk.CellArea::focus-changed`] signal to fire; as well
// as [`signal@GtkCellArea::add-editable`] in the case that an editable cell
// was clicked and needs to start editing. You can call
// [method@Gtk.CellArea.stop_editing] at any time to cancel any cell editing
// that is currently in progress.
//
// The `GtkCellArea` drives keyboard focus from cell to cell in a way
// similar to `GtkWidget`. For layouting widgets that support giving
// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
// to the area functions for the row that has focus and to tell the
// area to paint the focus at render time.
//
// Layouting widgets that accept focus on cells should implement the
// [vfunc@Gtk.Widget.focus] virtual method. The layouting widget is always
// responsible for knowing where `GtkTreeModel` rows are rendered inside
// the widget, so at [vfunc@Gtk.Widget.focus] time the layouting widget
// should use the `GtkCellArea` methods to navigate focus inside the area
// and then observe the [enum@Gtk.DirectionType] to pass the focus to adjacent
// rows and areas.
//
// A basic example of how the [vfunc@Gtk.Widget.focus] virtual method
// should be implemented:
//
// ```
// static gboolean
// foo_focus (GtkWidget       *widget,
//
//	GtkDirectionType direction)
//
//	{
//	  Foo *self = FOO (widget);
//	  FooPrivate *priv = foo_get_instance_private (self);
//	  int focus_row = priv-&gt;focus_row;
//	  gboolean have_focus = FALSE;
//
//	  if (!gtk_widget_has_focus (widget))
//	    gtk_widget_grab_focus (widget);
//
//	  valid = gtk_tree_model_iter_nth_child (priv-&gt;model, &amp;iter, NULL, priv-&gt;focus_row);
//	  while (valid)
//	    {
//	      gtk_cell_area_apply_attributes (priv-&gt;area, priv-&gt;model, &amp;iter, FALSE, FALSE);
//
//	      if (gtk_cell_area_focus (priv-&gt;area, direction))
//	        {
//	           priv-&gt;focus_row = focus_row;
//	           have_focus = TRUE;
//	           break;
//	        }
//	      else
//	        {
//	          if (direction == GTK_DIR_RIGHT ||
//	              direction == GTK_DIR_LEFT)
//	            break;
//	          else if (direction == GTK_DIR_UP ||
//	                   direction == GTK_DIR_TAB_BACKWARD)
//	           {
//	              if (focus_row == 0)
//	                break;
//	              else
//	               {
//	                  focus_row--;
//	                  valid = gtk_tree_model_iter_nth_child (priv-&gt;model, &amp;iter, NULL, focus_row);
//	               }
//	            }
//	          else
//	            {
//	              if (focus_row == last_row)
//	                break;
//	              else
//	                {
//	                  focus_row++;
//	                  valid = gtk_tree_model_iter_next (priv-&gt;model, &amp;iter);
//	                }
//	            }
//	        }
//	    }
//	    return have_focus;
//	}
//
// ```
//
// Note that the layouting widget is responsible for matching the
// `GtkDirectionType` values to the way it lays out its cells.
//
// # Cell Properties
//
// The `GtkCellArea` introduces cell properties for `GtkCellRenderer`s.
// This provides some general interfaces for defining the relationship
// cell areas have with their cells. For instance in a [class@Gtk.CellAreaBox]
// a cell might “expand” and receive extra space when the area is allocated
// more than its full natural request, or a cell might be configured to “align”
// with adjacent rows which were requested and rendered with the same
// `GtkCellAreaContext`.
//
// Use [method@Gtk.CellAreaClass.install_cell_property] to install cell
// properties for a cell area class and [method@Gtk.CellAreaClass.find_cell_property]
// or [method@Gtk.CellAreaClass.list_cell_properties] to get information about
// existing cell properties.
//
// To set the value of a cell property, use [method@Gtk.CellArea.cell_set_property],
// [method@Gtk.CellArea.cell_set] or [method@Gtk.CellArea.cell_set_valist]. To obtain
// the value of a cell property, use [method@Gtk.CellArea.cell_get_property]
// [method@Gtk.CellArea.cell_get] or [method@Gtk.CellArea.cell_get_valist].
type CellArea struct {
	gobject.InitiallyUnowned
}

func CellAreaNewFromInternalPtr(ptr uintptr) *CellArea {
	cls := &CellArea{}
	cls.Ptr = ptr
	return cls
}

var xCellAreaActivate func(uintptr, uintptr, uintptr, *gdk.Rectangle, CellRendererState, bool) bool

// Activates @area, usually by activating the currently focused
// cell, however some subclasses which embed widgets in the area
// can also activate a widget if it currently has the focus.
func (x *CellArea) Activate(ContextVar *CellAreaContext, WidgetVar *Widget, CellAreaVar *gdk.Rectangle, FlagsVar CellRendererState, EditOnlyVar bool) bool {

	cret := xCellAreaActivate(x.GoPointer(), ContextVar.GoPointer(), WidgetVar.GoPointer(), CellAreaVar, FlagsVar, EditOnlyVar)
	return cret
}

var xCellAreaActivateCell func(uintptr, uintptr, uintptr, uintptr, *gdk.Rectangle, CellRendererState) bool

// This is used by `GtkCellArea` subclasses when handling events
// to activate cells, the base `GtkCellArea` class activates cells
// for keyboard events for free in its own GtkCellArea-&gt;activate()
// implementation.
func (x *CellArea) ActivateCell(WidgetVar *Widget, RendererVar *CellRenderer, EventVar *gdk.Event, CellAreaVar *gdk.Rectangle, FlagsVar CellRendererState) bool {

	cret := xCellAreaActivateCell(x.GoPointer(), WidgetVar.GoPointer(), RendererVar.GoPointer(), EventVar.GoPointer(), CellAreaVar, FlagsVar)
	return cret
}

var xCellAreaAdd func(uintptr, uintptr)

// Adds @renderer to @area with the default child cell properties.
func (x *CellArea) Add(RendererVar *CellRenderer) {

	xCellAreaAdd(x.GoPointer(), RendererVar.GoPointer())

}

var xCellAreaAddFocusSibling func(uintptr, uintptr, uintptr)

// Adds @sibling to @renderer’s focusable area, focus will be drawn
// around @renderer and all of its siblings if @renderer can
// focus for a given row.
//
// Events handled by focus siblings can also activate the given
// focusable @renderer.
func (x *CellArea) AddFocusSibling(RendererVar *CellRenderer, SiblingVar *CellRenderer) {

	xCellAreaAddFocusSibling(x.GoPointer(), RendererVar.GoPointer(), SiblingVar.GoPointer())

}

var xCellAreaAddWithProperties func(uintptr, uintptr, string, ...interface{})

// Adds @renderer to @area, setting cell properties at the same time.
// See gtk_cell_area_add() and gtk_cell_area_cell_set() for more details.
func (x *CellArea) AddWithProperties(RendererVar *CellRenderer, FirstPropNameVar string, varArgs ...interface{}) {

	xCellAreaAddWithProperties(x.GoPointer(), RendererVar.GoPointer(), FirstPropNameVar, varArgs...)

}

var xCellAreaApplyAttributes func(uintptr, uintptr, *TreeIter, bool, bool)

// Applies any connected attributes to the renderers in
// @area by pulling the values from @tree_model.
func (x *CellArea) ApplyAttributes(TreeModelVar TreeModel, IterVar *TreeIter, IsExpanderVar bool, IsExpandedVar bool) {

	xCellAreaApplyAttributes(x.GoPointer(), TreeModelVar.GoPointer(), IterVar, IsExpanderVar, IsExpandedVar)

}

var xCellAreaAttributeConnect func(uintptr, uintptr, string, int)

// Connects an @attribute to apply values from @column for the
// `GtkTreeModel` in use.
func (x *CellArea) AttributeConnect(RendererVar *CellRenderer, AttributeVar string, ColumnVar int) {

	xCellAreaAttributeConnect(x.GoPointer(), RendererVar.GoPointer(), AttributeVar, ColumnVar)

}

var xCellAreaAttributeDisconnect func(uintptr, uintptr, string)

// Disconnects @attribute for the @renderer in @area so that
// attribute will no longer be updated with values from the
// model.
func (x *CellArea) AttributeDisconnect(RendererVar *CellRenderer, AttributeVar string) {

	xCellAreaAttributeDisconnect(x.GoPointer(), RendererVar.GoPointer(), AttributeVar)

}

var xCellAreaAttributeGetColumn func(uintptr, uintptr, string) int

// Returns the model column that an attribute has been mapped to,
// or -1 if the attribute is not mapped.
func (x *CellArea) AttributeGetColumn(RendererVar *CellRenderer, AttributeVar string) int {

	cret := xCellAreaAttributeGetColumn(x.GoPointer(), RendererVar.GoPointer(), AttributeVar)
	return cret
}

var xCellAreaCellGet func(uintptr, uintptr, string, ...interface{})

// Gets the values of one or more cell properties for @renderer in @area.
func (x *CellArea) CellGet(RendererVar *CellRenderer, FirstPropNameVar string, varArgs ...interface{}) {

	xCellAreaCellGet(x.GoPointer(), RendererVar.GoPointer(), FirstPropNameVar, varArgs...)

}

var xCellAreaCellGetProperty func(uintptr, uintptr, string, *gobject.Value)

// Gets the value of a cell property for @renderer in @area.
func (x *CellArea) CellGetProperty(RendererVar *CellRenderer, PropertyNameVar string, ValueVar *gobject.Value) {

	xCellAreaCellGetProperty(x.GoPointer(), RendererVar.GoPointer(), PropertyNameVar, ValueVar)

}

var xCellAreaCellGetValist func(uintptr, uintptr, string, []interface{})

// Gets the values of one or more cell properties for @renderer in @area.
func (x *CellArea) CellGetValist(RendererVar *CellRenderer, FirstPropertyNameVar string, VarArgsVar []interface{}) {

	xCellAreaCellGetValist(x.GoPointer(), RendererVar.GoPointer(), FirstPropertyNameVar, VarArgsVar)

}

var xCellAreaCellSet func(uintptr, uintptr, string, ...interface{})

// Sets one or more cell properties for @cell in @area.
func (x *CellArea) CellSet(RendererVar *CellRenderer, FirstPropNameVar string, varArgs ...interface{}) {

	xCellAreaCellSet(x.GoPointer(), RendererVar.GoPointer(), FirstPropNameVar, varArgs...)

}

var xCellAreaCellSetProperty func(uintptr, uintptr, string, *gobject.Value)

// Sets a cell property for @renderer in @area.
func (x *CellArea) CellSetProperty(RendererVar *CellRenderer, PropertyNameVar string, ValueVar *gobject.Value) {

	xCellAreaCellSetProperty(x.GoPointer(), RendererVar.GoPointer(), PropertyNameVar, ValueVar)

}

var xCellAreaCellSetValist func(uintptr, uintptr, string, []interface{})

// Sets one or more cell properties for @renderer in @area.
func (x *CellArea) CellSetValist(RendererVar *CellRenderer, FirstPropertyNameVar string, VarArgsVar []interface{}) {

	xCellAreaCellSetValist(x.GoPointer(), RendererVar.GoPointer(), FirstPropertyNameVar, VarArgsVar)

}

var xCellAreaCopyContext func(uintptr, uintptr) uintptr

// This is sometimes needed for cases where rows need to share
// alignments in one orientation but may be separately grouped
// in the opposing orientation.
//
// For instance, `GtkIconView` creates all icons (rows) to have
// the same width and the cells theirin to have the same
// horizontal alignments. However each row of icons may have
// a separate collective height. `GtkIconView` uses this to
// request the heights of each row based on a context which
// was already used to request all the row widths that are
// to be displayed.
func (x *CellArea) CopyContext(ContextVar *CellAreaContext) *CellAreaContext {
	var cls *CellAreaContext

	cret := xCellAreaCopyContext(x.GoPointer(), ContextVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &CellAreaContext{}
	cls.Ptr = cret
	return cls
}

var xCellAreaCreateContext func(uintptr) uintptr

// Creates a `GtkCellArea`Context to be used with @area for
// all purposes. `GtkCellArea`Context stores geometry information
// for rows for which it was operated on, it is important to use
// the same context for the same row of data at all times (i.e.
// one should render and handle events with the same `GtkCellArea`Context
// which was used to request the size of those rows of data).
func (x *CellArea) CreateContext() *CellAreaContext {
	var cls *CellAreaContext

	cret := xCellAreaCreateContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &CellAreaContext{}
	cls.Ptr = cret
	return cls
}

var xCellAreaEvent func(uintptr, uintptr, uintptr, uintptr, *gdk.Rectangle, CellRendererState) int

// Delegates event handling to a `GtkCellArea`.
func (x *CellArea) Event(ContextVar *CellAreaContext, WidgetVar *Widget, EventVar *gdk.Event, CellAreaVar *gdk.Rectangle, FlagsVar CellRendererState) int {

	cret := xCellAreaEvent(x.GoPointer(), ContextVar.GoPointer(), WidgetVar.GoPointer(), EventVar.GoPointer(), CellAreaVar, FlagsVar)
	return cret
}

var xCellAreaFocus func(uintptr, DirectionType) bool

// This should be called by the @area’s owning layout widget
// when focus is to be passed to @area, or moved within @area
// for a given @direction and row data.
//
// Implementing `GtkCellArea` classes should implement this
// method to receive and navigate focus in its own way particular
// to how it lays out cells.
func (x *CellArea) Focus(DirectionVar DirectionType) bool {

	cret := xCellAreaFocus(x.GoPointer(), DirectionVar)
	return cret
}

var xCellAreaForeach func(uintptr, uintptr, uintptr)

// Calls @callback for every `GtkCellRenderer` in @area.
func (x *CellArea) Foreach(CallbackVar *CellCallback, CallbackDataVar uintptr) {

	xCellAreaForeach(x.GoPointer(), glib.NewCallback(CallbackVar), CallbackDataVar)

}

var xCellAreaForeachAlloc func(uintptr, uintptr, uintptr, *gdk.Rectangle, *gdk.Rectangle, uintptr, uintptr)

// Calls @callback for every `GtkCellRenderer` in @area with the
// allocated rectangle inside @cell_area.
func (x *CellArea) ForeachAlloc(ContextVar *CellAreaContext, WidgetVar *Widget, CellAreaVar *gdk.Rectangle, BackgroundAreaVar *gdk.Rectangle, CallbackVar *CellAllocCallback, CallbackDataVar uintptr) {

	xCellAreaForeachAlloc(x.GoPointer(), ContextVar.GoPointer(), WidgetVar.GoPointer(), CellAreaVar, BackgroundAreaVar, glib.NewCallback(CallbackVar), CallbackDataVar)

}

var xCellAreaGetCellAllocation func(uintptr, uintptr, uintptr, uintptr, *gdk.Rectangle, *gdk.Rectangle)

// Derives the allocation of @renderer inside @area if @area
// were to be renderered in @cell_area.
func (x *CellArea) GetCellAllocation(ContextVar *CellAreaContext, WidgetVar *Widget, RendererVar *CellRenderer, CellAreaVar *gdk.Rectangle, AllocationVar *gdk.Rectangle) {

	xCellAreaGetCellAllocation(x.GoPointer(), ContextVar.GoPointer(), WidgetVar.GoPointer(), RendererVar.GoPointer(), CellAreaVar, AllocationVar)

}

var xCellAreaGetCellAtPosition func(uintptr, uintptr, uintptr, *gdk.Rectangle, int, int, *gdk.Rectangle) uintptr

// Gets the `GtkCellRenderer` at @x and @y coordinates inside @area and optionally
// returns the full cell allocation for it inside @cell_area.
func (x *CellArea) GetCellAtPosition(ContextVar *CellAreaContext, WidgetVar *Widget, CellAreaVar *gdk.Rectangle, XVar int, YVar int, AllocAreaVar *gdk.Rectangle) *CellRenderer {
	var cls *CellRenderer

	cret := xCellAreaGetCellAtPosition(x.GoPointer(), ContextVar.GoPointer(), WidgetVar.GoPointer(), CellAreaVar, XVar, YVar, AllocAreaVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &CellRenderer{}
	cls.Ptr = cret
	return cls
}

var xCellAreaGetCurrentPathString func(uintptr) string

// Gets the current `GtkTreePath` string for the currently
// applied `GtkTreeIter`, this is implicitly updated when
// gtk_cell_area_apply_attributes() is called and can be
// used to interact with renderers from `GtkCellArea`
// subclasses.
func (x *CellArea) GetCurrentPathString() string {

	cret := xCellAreaGetCurrentPathString(x.GoPointer())
	return cret
}

var xCellAreaGetEditWidget func(uintptr) uintptr

// Gets the `GtkCellEditable` widget currently used
// to edit the currently edited cell.
func (x *CellArea) GetEditWidget() *CellEditableBase {
	var cls *CellEditableBase

	cret := xCellAreaGetEditWidget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &CellEditableBase{}
	cls.Ptr = cret
	return cls
}

var xCellAreaGetEditedCell func(uintptr) uintptr

// Gets the `GtkCellRenderer` in @area that is currently
// being edited.
func (x *CellArea) GetEditedCell() *CellRenderer {
	var cls *CellRenderer

	cret := xCellAreaGetEditedCell(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &CellRenderer{}
	cls.Ptr = cret
	return cls
}

var xCellAreaGetFocusCell func(uintptr) uintptr

// Retrieves the currently focused cell for @area
func (x *CellArea) GetFocusCell() *CellRenderer {
	var cls *CellRenderer

	cret := xCellAreaGetFocusCell(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &CellRenderer{}
	cls.Ptr = cret
	return cls
}

var xCellAreaGetFocusFromSibling func(uintptr, uintptr) uintptr

// Gets the `GtkCellRenderer` which is expected to be focusable
// for which @renderer is, or may be a sibling.
//
// This is handy for `GtkCellArea` subclasses when handling events,
// after determining the renderer at the event location it can
// then chose to activate the focus cell for which the event
// cell may have been a sibling.
func (x *CellArea) GetFocusFromSibling(RendererVar *CellRenderer) *CellRenderer {
	var cls *CellRenderer

	cret := xCellAreaGetFocusFromSibling(x.GoPointer(), RendererVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &CellRenderer{}
	cls.Ptr = cret
	return cls
}

var xCellAreaGetFocusSiblings func(uintptr, uintptr) *glib.List

// Gets the focus sibling cell renderers for @renderer.
func (x *CellArea) GetFocusSiblings(RendererVar *CellRenderer) *glib.List {

	cret := xCellAreaGetFocusSiblings(x.GoPointer(), RendererVar.GoPointer())
	return cret
}

var xCellAreaGetPreferredHeight func(uintptr, uintptr, uintptr, int, int)

// Retrieves a cell area’s initial minimum and natural height.
//
// @area will store some geometrical information in @context along the way;
// when requesting sizes over an arbitrary number of rows, it’s not important
// to check the @minimum_height and @natural_height of this call but rather to
// consult gtk_cell_area_context_get_preferred_height() after a series of
// requests.
func (x *CellArea) GetPreferredHeight(ContextVar *CellAreaContext, WidgetVar *Widget, MinimumHeightVar int, NaturalHeightVar int) {

	xCellAreaGetPreferredHeight(x.GoPointer(), ContextVar.GoPointer(), WidgetVar.GoPointer(), MinimumHeightVar, NaturalHeightVar)

}

var xCellAreaGetPreferredHeightForWidth func(uintptr, uintptr, uintptr, int, int, int)

// Retrieves a cell area’s minimum and natural height if it would be given
// the specified @width.
//
// @area stores some geometrical information in @context along the way
// while calling gtk_cell_area_get_preferred_width(). It’s important to
// perform a series of gtk_cell_area_get_preferred_width() requests with
// @context first and then call gtk_cell_area_get_preferred_height_for_width()
// on each cell area individually to get the height for width of each
// fully requested row.
//
// If at some point, the width of a single row changes, it should be
// requested with gtk_cell_area_get_preferred_width() again and then
// the full width of the requested rows checked again with
// gtk_cell_area_context_get_preferred_width().
func (x *CellArea) GetPreferredHeightForWidth(ContextVar *CellAreaContext, WidgetVar *Widget, WidthVar int, MinimumHeightVar int, NaturalHeightVar int) {

	xCellAreaGetPreferredHeightForWidth(x.GoPointer(), ContextVar.GoPointer(), WidgetVar.GoPointer(), WidthVar, MinimumHeightVar, NaturalHeightVar)

}

var xCellAreaGetPreferredWidth func(uintptr, uintptr, uintptr, int, int)

// Retrieves a cell area’s initial minimum and natural width.
//
// @area will store some geometrical information in @context along the way;
// when requesting sizes over an arbitrary number of rows, it’s not important
// to check the @minimum_width and @natural_width of this call but rather to
// consult gtk_cell_area_context_get_preferred_width() after a series of
// requests.
func (x *CellArea) GetPreferredWidth(ContextVar *CellAreaContext, WidgetVar *Widget, MinimumWidthVar int, NaturalWidthVar int) {

	xCellAreaGetPreferredWidth(x.GoPointer(), ContextVar.GoPointer(), WidgetVar.GoPointer(), MinimumWidthVar, NaturalWidthVar)

}

var xCellAreaGetPreferredWidthForHeight func(uintptr, uintptr, uintptr, int, int, int)

// Retrieves a cell area’s minimum and natural width if it would be given
// the specified @height.
//
// @area stores some geometrical information in @context along the way
// while calling gtk_cell_area_get_preferred_height(). It’s important to
// perform a series of gtk_cell_area_get_preferred_height() requests with
// @context first and then call gtk_cell_area_get_preferred_width_for_height()
// on each cell area individually to get the height for width of each
// fully requested row.
//
// If at some point, the height of a single row changes, it should be
// requested with gtk_cell_area_get_preferred_height() again and then
// the full height of the requested rows checked again with
// gtk_cell_area_context_get_preferred_height().
func (x *CellArea) GetPreferredWidthForHeight(ContextVar *CellAreaContext, WidgetVar *Widget, HeightVar int, MinimumWidthVar int, NaturalWidthVar int) {

	xCellAreaGetPreferredWidthForHeight(x.GoPointer(), ContextVar.GoPointer(), WidgetVar.GoPointer(), HeightVar, MinimumWidthVar, NaturalWidthVar)

}

var xCellAreaGetRequestMode func(uintptr) SizeRequestMode

// Gets whether the area prefers a height-for-width layout
// or a width-for-height layout.
func (x *CellArea) GetRequestMode() SizeRequestMode {

	cret := xCellAreaGetRequestMode(x.GoPointer())
	return cret
}

var xCellAreaHasRenderer func(uintptr, uintptr) bool

// Checks if @area contains @renderer.
func (x *CellArea) HasRenderer(RendererVar *CellRenderer) bool {

	cret := xCellAreaHasRenderer(x.GoPointer(), RendererVar.GoPointer())
	return cret
}

var xCellAreaInnerCellArea func(uintptr, uintptr, *gdk.Rectangle, *gdk.Rectangle)

// This is a convenience function for `GtkCellArea` implementations
// to get the inner area where a given `GtkCellRenderer` will be
// rendered. It removes any padding previously added by gtk_cell_area_request_renderer().
func (x *CellArea) InnerCellArea(WidgetVar *Widget, CellAreaVar *gdk.Rectangle, InnerAreaVar *gdk.Rectangle) {

	xCellAreaInnerCellArea(x.GoPointer(), WidgetVar.GoPointer(), CellAreaVar, InnerAreaVar)

}

var xCellAreaIsActivatable func(uintptr) bool

// Returns whether the area can do anything when activated,
// after applying new attributes to @area.
func (x *CellArea) IsActivatable() bool {

	cret := xCellAreaIsActivatable(x.GoPointer())
	return cret
}

var xCellAreaIsFocusSibling func(uintptr, uintptr, uintptr) bool

// Returns whether @sibling is one of @renderer’s focus siblings
// (see gtk_cell_area_add_focus_sibling()).
func (x *CellArea) IsFocusSibling(RendererVar *CellRenderer, SiblingVar *CellRenderer) bool {

	cret := xCellAreaIsFocusSibling(x.GoPointer(), RendererVar.GoPointer(), SiblingVar.GoPointer())
	return cret
}

var xCellAreaRemove func(uintptr, uintptr)

// Removes @renderer from @area.
func (x *CellArea) Remove(RendererVar *CellRenderer) {

	xCellAreaRemove(x.GoPointer(), RendererVar.GoPointer())

}

var xCellAreaRemoveFocusSibling func(uintptr, uintptr, uintptr)

// Removes @sibling from @renderer’s focus sibling list
// (see gtk_cell_area_add_focus_sibling()).
func (x *CellArea) RemoveFocusSibling(RendererVar *CellRenderer, SiblingVar *CellRenderer) {

	xCellAreaRemoveFocusSibling(x.GoPointer(), RendererVar.GoPointer(), SiblingVar.GoPointer())

}

var xCellAreaRequestRenderer func(uintptr, uintptr, Orientation, uintptr, int, int, int)

// This is a convenience function for `GtkCellArea` implementations
// to request size for cell renderers. It’s important to use this
// function to request size and then use gtk_cell_area_inner_cell_area()
// at render and event time since this function will add padding
// around the cell for focus painting.
func (x *CellArea) RequestRenderer(RendererVar *CellRenderer, OrientationVar Orientation, WidgetVar *Widget, ForSizeVar int, MinimumSizeVar int, NaturalSizeVar int) {

	xCellAreaRequestRenderer(x.GoPointer(), RendererVar.GoPointer(), OrientationVar, WidgetVar.GoPointer(), ForSizeVar, MinimumSizeVar, NaturalSizeVar)

}

var xCellAreaSetFocusCell func(uintptr, uintptr)

// Explicitly sets the currently focused cell to @renderer.
//
// This is generally called by implementations of
// `GtkCellAreaClass.focus()` or `GtkCellAreaClass.event()`,
// however it can also be used to implement functions such
// as gtk_tree_view_set_cursor_on_cell().
func (x *CellArea) SetFocusCell(RendererVar *CellRenderer) {

	xCellAreaSetFocusCell(x.GoPointer(), RendererVar.GoPointer())

}

var xCellAreaSnapshot func(uintptr, uintptr, uintptr, uintptr, *gdk.Rectangle, *gdk.Rectangle, CellRendererState, bool)

// Snapshots @area’s cells according to @area’s layout onto at
// the given coordinates.
func (x *CellArea) Snapshot(ContextVar *CellAreaContext, WidgetVar *Widget, SnapshotVar *Snapshot, BackgroundAreaVar *gdk.Rectangle, CellAreaVar *gdk.Rectangle, FlagsVar CellRendererState, PaintFocusVar bool) {

	xCellAreaSnapshot(x.GoPointer(), ContextVar.GoPointer(), WidgetVar.GoPointer(), SnapshotVar.GoPointer(), BackgroundAreaVar, CellAreaVar, FlagsVar, PaintFocusVar)

}

var xCellAreaStopEditing func(uintptr, bool)

// Explicitly stops the editing of the currently edited cell.
//
// If @canceled is %TRUE, the currently edited cell renderer
// will emit the ::editing-canceled signal, otherwise the
// the ::editing-done signal will be emitted on the current
// edit widget.
//
// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
func (x *CellArea) StopEditing(CanceledVar bool) {

	xCellAreaStopEditing(x.GoPointer(), CanceledVar)

}

func (c *CellArea) GoPointer() uintptr {
	return c.Ptr
}

func (c *CellArea) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Indicates that editing has started on @renderer and that @editable
// should be added to the owning cell-layouting widget at @cell_area.
func (x *CellArea) ConnectAddEditable(cb *func(CellArea, uintptr, uintptr, uintptr, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "add-editable", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, RendererVarp uintptr, EditableVarp uintptr, CellAreaVarp uintptr, PathVarp string) {
		fa := CellArea{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, RendererVarp, EditableVarp, CellAreaVarp, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "add-editable", cbRefPtr)
}

// This signal is emitted whenever applying attributes to @area from @model
func (x *CellArea) ConnectApplyAttributes(cb *func(CellArea, uintptr, uintptr, bool, bool)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "apply-attributes", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ModelVarp uintptr, IterVarp uintptr, IsExpanderVarp bool, IsExpandedVarp bool) {
		fa := CellArea{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ModelVarp, IterVarp, IsExpanderVarp, IsExpandedVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "apply-attributes", cbRefPtr)
}

// Indicates that focus changed on this @area. This signal
// is emitted either as a result of focus handling or event
// handling.
//
// It's possible that the signal is emitted even if the
// currently focused renderer did not change, this is
// because focus may change to the same renderer in the
// same cell area for a different row of data.
func (x *CellArea) ConnectFocusChanged(cb *func(CellArea, uintptr, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "focus-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, RendererVarp uintptr, PathVarp string) {
		fa := CellArea{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, RendererVarp, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "focus-changed", cbRefPtr)
}

// Indicates that editing finished on @renderer and that @editable
// should be removed from the owning cell-layouting widget.
func (x *CellArea) ConnectRemoveEditable(cb *func(CellArea, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "remove-editable", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, RendererVarp uintptr, EditableVarp uintptr) {
		fa := CellArea{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, RendererVarp, EditableVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "remove-editable", cbRefPtr)
}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *CellArea) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Adds an attribute mapping to the list in @cell_layout.
//
// The @column is the column of the model to get a value from, and the
// @attribute is the property on @cell to be set from that value. So for
// example if column 2 of the model contains strings, you could have the
// “text” attribute of a `GtkCellRendererText` get its values from column 2.
// In this context "attribute" and "property" are used interchangeably.
func (x *CellArea) AddAttribute(CellVar *CellRenderer, AttributeVar string, ColumnVar int) {

	XGtkCellLayoutAddAttribute(x.GoPointer(), CellVar.GoPointer(), AttributeVar, ColumnVar)

}

// Unsets all the mappings on all renderers on @cell_layout and
// removes all renderers from @cell_layout.
func (x *CellArea) Clear() {

	XGtkCellLayoutClear(x.GoPointer())

}

// Clears all existing attributes previously set with
// gtk_cell_layout_set_attributes().
func (x *CellArea) ClearAttributes(CellVar *CellRenderer) {

	XGtkCellLayoutClearAttributes(x.GoPointer(), CellVar.GoPointer())

}

// Returns the underlying `GtkCellArea` which might be @cell_layout
// if called on a `GtkCellArea` or might be %NULL if no `GtkCellArea`
// is used by @cell_layout.
func (x *CellArea) GetArea() *CellArea {
	var cls *CellArea

	cret := XGtkCellLayoutGetArea(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &CellArea{}
	cls.Ptr = cret
	return cls
}

// Returns the cell renderers which have been added to @cell_layout.
func (x *CellArea) GetCells() *glib.List {

	cret := XGtkCellLayoutGetCells(x.GoPointer())
	return cret
}

// Adds the @cell to the end of @cell_layout. If @expand is %FALSE, then the
// @cell is allocated no more space than it needs. Any unused space is
// divided evenly between cells for which @expand is %TRUE.
//
// Note that reusing the same cell renderer is not supported.
func (x *CellArea) PackEnd(CellVar *CellRenderer, ExpandVar bool) {

	XGtkCellLayoutPackEnd(x.GoPointer(), CellVar.GoPointer(), ExpandVar)

}

// Packs the @cell into the beginning of @cell_layout. If @expand is %FALSE,
// then the @cell is allocated no more space than it needs. Any unused space
// is divided evenly between cells for which @expand is %TRUE.
//
// Note that reusing the same cell renderer is not supported.
func (x *CellArea) PackStart(CellVar *CellRenderer, ExpandVar bool) {

	XGtkCellLayoutPackStart(x.GoPointer(), CellVar.GoPointer(), ExpandVar)

}

// Re-inserts @cell at @position.
//
// Note that @cell has already to be packed into @cell_layout
// for this to function properly.
func (x *CellArea) Reorder(CellVar *CellRenderer, PositionVar int) {

	XGtkCellLayoutReorder(x.GoPointer(), CellVar.GoPointer(), PositionVar)

}

// Sets the attributes in the parameter list as the attributes
// of @cell_layout.
//
// See [method@Gtk.CellLayout.add_attribute] for more details.
//
// The attributes should be in attribute/column order, as in
// gtk_cell_layout_add_attribute(). All existing attributes are
// removed, and replaced with the new attributes.
func (x *CellArea) SetAttributes(CellVar *CellRenderer, varArgs ...interface{}) {

	XGtkCellLayoutSetAttributes(x.GoPointer(), CellVar.GoPointer(), varArgs...)

}

// Sets the `GtkCellLayout`DataFunc to use for @cell_layout.
//
// This function is used instead of the standard attributes mapping
// for setting the column value, and should set the value of @cell_layout’s
// cell renderer(s) as appropriate.
//
// @func may be %NULL to remove a previously set function.
func (x *CellArea) SetCellDataFunc(CellVar *CellRenderer, FuncVar *CellLayoutDataFunc, FuncDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	XGtkCellLayoutSetCellDataFunc(x.GoPointer(), CellVar.GoPointer(), glib.NewCallback(FuncVar), FuncDataVar, glib.NewCallback(DestroyVar))

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xCellAreaClassFindCellProperty, lib, "gtk_cell_area_class_find_cell_property")
	core.PuregoSafeRegister(&xCellAreaClassInstallCellProperty, lib, "gtk_cell_area_class_install_cell_property")
	core.PuregoSafeRegister(&xCellAreaClassListCellProperties, lib, "gtk_cell_area_class_list_cell_properties")

	core.PuregoSafeRegister(&xCellAreaActivate, lib, "gtk_cell_area_activate")
	core.PuregoSafeRegister(&xCellAreaActivateCell, lib, "gtk_cell_area_activate_cell")
	core.PuregoSafeRegister(&xCellAreaAdd, lib, "gtk_cell_area_add")
	core.PuregoSafeRegister(&xCellAreaAddFocusSibling, lib, "gtk_cell_area_add_focus_sibling")
	core.PuregoSafeRegister(&xCellAreaAddWithProperties, lib, "gtk_cell_area_add_with_properties")
	core.PuregoSafeRegister(&xCellAreaApplyAttributes, lib, "gtk_cell_area_apply_attributes")
	core.PuregoSafeRegister(&xCellAreaAttributeConnect, lib, "gtk_cell_area_attribute_connect")
	core.PuregoSafeRegister(&xCellAreaAttributeDisconnect, lib, "gtk_cell_area_attribute_disconnect")
	core.PuregoSafeRegister(&xCellAreaAttributeGetColumn, lib, "gtk_cell_area_attribute_get_column")
	core.PuregoSafeRegister(&xCellAreaCellGet, lib, "gtk_cell_area_cell_get")
	core.PuregoSafeRegister(&xCellAreaCellGetProperty, lib, "gtk_cell_area_cell_get_property")
	core.PuregoSafeRegister(&xCellAreaCellGetValist, lib, "gtk_cell_area_cell_get_valist")
	core.PuregoSafeRegister(&xCellAreaCellSet, lib, "gtk_cell_area_cell_set")
	core.PuregoSafeRegister(&xCellAreaCellSetProperty, lib, "gtk_cell_area_cell_set_property")
	core.PuregoSafeRegister(&xCellAreaCellSetValist, lib, "gtk_cell_area_cell_set_valist")
	core.PuregoSafeRegister(&xCellAreaCopyContext, lib, "gtk_cell_area_copy_context")
	core.PuregoSafeRegister(&xCellAreaCreateContext, lib, "gtk_cell_area_create_context")
	core.PuregoSafeRegister(&xCellAreaEvent, lib, "gtk_cell_area_event")
	core.PuregoSafeRegister(&xCellAreaFocus, lib, "gtk_cell_area_focus")
	core.PuregoSafeRegister(&xCellAreaForeach, lib, "gtk_cell_area_foreach")
	core.PuregoSafeRegister(&xCellAreaForeachAlloc, lib, "gtk_cell_area_foreach_alloc")
	core.PuregoSafeRegister(&xCellAreaGetCellAllocation, lib, "gtk_cell_area_get_cell_allocation")
	core.PuregoSafeRegister(&xCellAreaGetCellAtPosition, lib, "gtk_cell_area_get_cell_at_position")
	core.PuregoSafeRegister(&xCellAreaGetCurrentPathString, lib, "gtk_cell_area_get_current_path_string")
	core.PuregoSafeRegister(&xCellAreaGetEditWidget, lib, "gtk_cell_area_get_edit_widget")
	core.PuregoSafeRegister(&xCellAreaGetEditedCell, lib, "gtk_cell_area_get_edited_cell")
	core.PuregoSafeRegister(&xCellAreaGetFocusCell, lib, "gtk_cell_area_get_focus_cell")
	core.PuregoSafeRegister(&xCellAreaGetFocusFromSibling, lib, "gtk_cell_area_get_focus_from_sibling")
	core.PuregoSafeRegister(&xCellAreaGetFocusSiblings, lib, "gtk_cell_area_get_focus_siblings")
	core.PuregoSafeRegister(&xCellAreaGetPreferredHeight, lib, "gtk_cell_area_get_preferred_height")
	core.PuregoSafeRegister(&xCellAreaGetPreferredHeightForWidth, lib, "gtk_cell_area_get_preferred_height_for_width")
	core.PuregoSafeRegister(&xCellAreaGetPreferredWidth, lib, "gtk_cell_area_get_preferred_width")
	core.PuregoSafeRegister(&xCellAreaGetPreferredWidthForHeight, lib, "gtk_cell_area_get_preferred_width_for_height")
	core.PuregoSafeRegister(&xCellAreaGetRequestMode, lib, "gtk_cell_area_get_request_mode")
	core.PuregoSafeRegister(&xCellAreaHasRenderer, lib, "gtk_cell_area_has_renderer")
	core.PuregoSafeRegister(&xCellAreaInnerCellArea, lib, "gtk_cell_area_inner_cell_area")
	core.PuregoSafeRegister(&xCellAreaIsActivatable, lib, "gtk_cell_area_is_activatable")
	core.PuregoSafeRegister(&xCellAreaIsFocusSibling, lib, "gtk_cell_area_is_focus_sibling")
	core.PuregoSafeRegister(&xCellAreaRemove, lib, "gtk_cell_area_remove")
	core.PuregoSafeRegister(&xCellAreaRemoveFocusSibling, lib, "gtk_cell_area_remove_focus_sibling")
	core.PuregoSafeRegister(&xCellAreaRequestRenderer, lib, "gtk_cell_area_request_renderer")
	core.PuregoSafeRegister(&xCellAreaSetFocusCell, lib, "gtk_cell_area_set_focus_cell")
	core.PuregoSafeRegister(&xCellAreaSnapshot, lib, "gtk_cell_area_snapshot")
	core.PuregoSafeRegister(&xCellAreaStopEditing, lib, "gtk_cell_area_stop_editing")

}
