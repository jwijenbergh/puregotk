// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The list of virtual functions for the `GtkSelectionModel` interface.
// No function must be implemented, but unless `GtkSelectionModel::is_selected()`
// is implemented, it will not be possible to select items in the set.
//
// The model does not need to implement any functions to support either
// selecting or unselecting items. Of course, if the model does not do that,
// it means that users cannot select or unselect items in a list widget
// using the model.
//
// All selection functions fall back to `GtkSelectionModel::set_selection()`
// so it is sufficient to implement just that function for full selection
// support.
type SelectionModelInterface struct {
	GIface uintptr
}

func (x *SelectionModelInterface) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GtkSelectionModel` is an interface that add support for selection to list models.
//
// This support is then used by widgets using list models to add the ability
// to select and unselect various items.
//
// GTK provides default implementations of the most common selection modes such
// as [class@Gtk.SingleSelection], so you will only need to implement this
// interface if you want detailed control about how selections should be handled.
//
// A `GtkSelectionModel` supports a single boolean per item indicating if an item is
// selected or not. This can be queried via [method@Gtk.SelectionModel.is_selected].
// When the selected state of one or more items changes, the model will emit the
// [signal@Gtk.SelectionModel::selection-changed] signal by calling the
// [method@Gtk.SelectionModel.selection_changed] function. The positions given
// in that signal may have their selection state changed, though that is not a
// requirement. If new items added to the model via the
// [signal@Gio.ListModel::items-changed] signal are selected or not is up to the
// implementation.
//
// Note that items added via [signal@Gio.ListModel::items-changed] may already
// be selected and no [signal@Gtk.SelectionModel::selection-changed] will be
// emitted for them. So to track which items are selected, it is necessary to
// listen to both signals.
//
// Additionally, the interface can expose functionality to select and unselect
// items. If these functions are implemented, GTK's list widgets will allow users
// to select and unselect items. However, `GtkSelectionModel`s are free to only
// implement them partially or not at all. In that case the widgets will not
// support the unimplemented operations.
//
// When selecting or unselecting is supported by a model, the return values of
// the selection functions do *not* indicate if selection or unselection happened.
// They are only meant to indicate complete failure, like when this mode of
// selecting is not supported by the model.
//
// Selections may happen asynchronously, so the only reliable way to find out
// when an item was selected is to listen to the signals that indicate selection.
type SelectionModel interface {
	GoPointer() uintptr
	SetGoPointer(uintptr)
	GetSelection() *Bitset
	GetSelectionInRange(PositionVar uint, NItemsVar uint) *Bitset
	IsSelected(PositionVar uint) bool
	SelectAll() bool
	SelectItem(PositionVar uint, UnselectRestVar bool) bool
	SelectRange(PositionVar uint, NItemsVar uint, UnselectRestVar bool) bool
	SelectionChanged(PositionVar uint, NItemsVar uint)
	SetSelection(SelectedVar *Bitset, MaskVar *Bitset) bool
	UnselectAll() bool
	UnselectItem(PositionVar uint) bool
	UnselectRange(PositionVar uint, NItemsVar uint) bool
}

var xSelectionModelGLibType func() types.GType

func SelectionModelGLibType() types.GType {
	return xSelectionModelGLibType()
}

type SelectionModelBase struct {
	Ptr uintptr
}

func (x *SelectionModelBase) GoPointer() uintptr {
	return x.Ptr
}

func (x *SelectionModelBase) SetGoPointer(ptr uintptr) {
	x.Ptr = ptr
}

// Gets the set containing all currently selected items in the model.
//
// This function may be slow, so if you are only interested in single item,
// consider using [method@Gtk.SelectionModel.is_selected] or if you are only
// interested in a few, consider [method@Gtk.SelectionModel.get_selection_in_range].
func (x *SelectionModelBase) GetSelection() *Bitset {

	cret := XGtkSelectionModelGetSelection(x.GoPointer())
	return cret
}

// Gets the set of selected items in a range.
//
// This function is an optimization for
// [method@Gtk.SelectionModel.get_selection] when you are only
// interested in part of the model's selected state. A common use
// case is in response to the [signal@Gtk.SelectionModel::selection-changed]
// signal.
func (x *SelectionModelBase) GetSelectionInRange(PositionVar uint, NItemsVar uint) *Bitset {

	cret := XGtkSelectionModelGetSelectionInRange(x.GoPointer(), PositionVar, NItemsVar)
	return cret
}

// Checks if the given item is selected.
func (x *SelectionModelBase) IsSelected(PositionVar uint) bool {

	cret := XGtkSelectionModelIsSelected(x.GoPointer(), PositionVar)
	return cret
}

// Requests to select all items in the model.
func (x *SelectionModelBase) SelectAll() bool {

	cret := XGtkSelectionModelSelectAll(x.GoPointer())
	return cret
}

// Requests to select an item in the model.
func (x *SelectionModelBase) SelectItem(PositionVar uint, UnselectRestVar bool) bool {

	cret := XGtkSelectionModelSelectItem(x.GoPointer(), PositionVar, UnselectRestVar)
	return cret
}

// Requests to select a range of items in the model.
func (x *SelectionModelBase) SelectRange(PositionVar uint, NItemsVar uint, UnselectRestVar bool) bool {

	cret := XGtkSelectionModelSelectRange(x.GoPointer(), PositionVar, NItemsVar, UnselectRestVar)
	return cret
}

// Helper function for implementations of `GtkSelectionModel`.
//
// Call this when a the selection changes to emit the
// [signal@Gtk.SelectionModel::selection-changed] signal.
func (x *SelectionModelBase) SelectionChanged(PositionVar uint, NItemsVar uint) {

	XGtkSelectionModelSelectionChanged(x.GoPointer(), PositionVar, NItemsVar)

}

// Make selection changes.
//
// This is the most advanced selection updating method that allows
// the most fine-grained control over selection changes. If you can,
// you should try the simpler versions, as implementations are more
// likely to implement support for those.
//
// Requests that the selection state of all positions set in @mask
// be updated to the respective value in the @selected bitmask.
//
// In pseudocode, it would look something like this:
//
// ```c
// for (i = 0; i &lt; n_items; i++)
//
//	{
//	  // don't change values not in the mask
//	  if (!gtk_bitset_contains (mask, i))
//	    continue;
//
//	  if (gtk_bitset_contains (selected, i))
//	    select_item (i);
//	  else
//	    unselect_item (i);
//	}
//
// gtk_selection_model_selection_changed (model,
//
//	first_changed_item,
//	n_changed_items);
//
// ```
//
// @mask and @selected must not be modified. They may refer to the
// same bitset, which would mean that every item in the set should
// be selected.
func (x *SelectionModelBase) SetSelection(SelectedVar *Bitset, MaskVar *Bitset) bool {

	cret := XGtkSelectionModelSetSelection(x.GoPointer(), SelectedVar, MaskVar)
	return cret
}

// Requests to unselect all items in the model.
func (x *SelectionModelBase) UnselectAll() bool {

	cret := XGtkSelectionModelUnselectAll(x.GoPointer())
	return cret
}

// Requests to unselect an item in the model.
func (x *SelectionModelBase) UnselectItem(PositionVar uint) bool {

	cret := XGtkSelectionModelUnselectItem(x.GoPointer(), PositionVar)
	return cret
}

// Requests to unselect a range of items in the model.
func (x *SelectionModelBase) UnselectRange(PositionVar uint, NItemsVar uint) bool {

	cret := XGtkSelectionModelUnselectRange(x.GoPointer(), PositionVar, NItemsVar)
	return cret
}

var XGtkSelectionModelGetSelection func(uintptr) *Bitset
var XGtkSelectionModelGetSelectionInRange func(uintptr, uint, uint) *Bitset
var XGtkSelectionModelIsSelected func(uintptr, uint) bool
var XGtkSelectionModelSelectAll func(uintptr) bool
var XGtkSelectionModelSelectItem func(uintptr, uint, bool) bool
var XGtkSelectionModelSelectRange func(uintptr, uint, uint, bool) bool
var XGtkSelectionModelSelectionChanged func(uintptr, uint, uint)
var XGtkSelectionModelSetSelection func(uintptr, *Bitset, *Bitset) bool
var XGtkSelectionModelUnselectAll func(uintptr) bool
var XGtkSelectionModelUnselectItem func(uintptr, uint) bool
var XGtkSelectionModelUnselectRange func(uintptr, uint, uint) bool

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xSelectionModelGLibType, lib, "gtk_selection_model_get_type")

	core.PuregoSafeRegister(&XGtkSelectionModelGetSelection, lib, "gtk_selection_model_get_selection")
	core.PuregoSafeRegister(&XGtkSelectionModelGetSelectionInRange, lib, "gtk_selection_model_get_selection_in_range")
	core.PuregoSafeRegister(&XGtkSelectionModelIsSelected, lib, "gtk_selection_model_is_selected")
	core.PuregoSafeRegister(&XGtkSelectionModelSelectAll, lib, "gtk_selection_model_select_all")
	core.PuregoSafeRegister(&XGtkSelectionModelSelectItem, lib, "gtk_selection_model_select_item")
	core.PuregoSafeRegister(&XGtkSelectionModelSelectRange, lib, "gtk_selection_model_select_range")
	core.PuregoSafeRegister(&XGtkSelectionModelSelectionChanged, lib, "gtk_selection_model_selection_changed")
	core.PuregoSafeRegister(&XGtkSelectionModelSetSelection, lib, "gtk_selection_model_set_selection")
	core.PuregoSafeRegister(&XGtkSelectionModelUnselectAll, lib, "gtk_selection_model_unselect_all")
	core.PuregoSafeRegister(&XGtkSelectionModelUnselectItem, lib, "gtk_selection_model_unselect_item")
	core.PuregoSafeRegister(&XGtkSelectionModelUnselectRange, lib, "gtk_selection_model_unselect_range")

}
