// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gsk"
)

type WindowClass struct {
	ParentClass uintptr

	Padding uintptr
}

func (x *WindowClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type WindowGroupPrivate struct {
}

func (x *WindowGroupPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A `GtkWindow` is a toplevel window which can contain other widgets.
//
// ![An example GtkWindow](window.png)
//
// Windows normally have decorations that are under the control
// of the windowing system and allow the user to manipulate the window
// (resize it, move it, close it,...).
//
// # GtkWindow as GtkBuildable
//
// The `GtkWindow` implementation of the [iface@Gtk.Buildable] interface supports
// setting a child as the titlebar by specifying “titlebar” as the “type”
// attribute of a &lt;child&gt; element.
//
// # CSS nodes
//
// ```
// window.background [.csd / .solid-csd / .ssd] [.maximized / .fullscreen / .tiled]
// ├── &lt;child&gt;
// ╰── &lt;titlebar child&gt;.titlebar [.default-decoration]
// ```
//
// `GtkWindow` has a main CSS node with name window and style class .background.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .maximized, .fullscreen, .tiled (when supported,
// also .tiled-top, .tiled-left, .tiled-right, .tiled-bottom).
//
// `GtkWindow` subclasses often add their own discriminating style classes,
// such as .dialog, .popup or .tooltip.
//
// Generally, some CSS properties don't make sense on the toplevel window node,
// such as margins or padding. When client-side decorations without invisible
// borders are in use (i.e. the .solid-csd style class is added to the
// main window node), the CSS border of the toplevel window is used for
// resize drags. In the .csd case, the shadow area outside of the window
// can be used to resize it.
//
// `GtkWindow` adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
//
// # Accessibility
//
// `GtkWindow` uses the %GTK_ACCESSIBLE_ROLE_WINDOW role.
//
// # Actions
//
// `GtkWindow` defines a set of built-in actions:
// - `default.activate`: Activate the default widget.
// - `window.minimize`: Minimize the window.
// - `window.toggle-maximized`: Maximize or restore the window.
// - `window.close`: Close the window.
type Window struct {
	Widget
}

func WindowNewFromInternalPtr(ptr uintptr) *Window {
	cls := &Window{}
	cls.Ptr = ptr
	return cls
}

var xNewWindow func() uintptr

// Creates a new `GtkWindow`.
//
// To get an undecorated window (no window borders), use
// [method@Gtk.Window.set_decorated].
//
// All top-level windows created by gtk_window_new() are stored
// in an internal top-level window list. This list can be obtained
// from [func@Gtk.Window.list_toplevels]. Due to GTK keeping a
// reference to the window internally, gtk_window_new() does not
// return a reference to the caller.
//
// To delete a `GtkWindow`, call [method@Gtk.Window.destroy].
func NewWindow() *Window {
	var cls *Window

	cret := xNewWindow()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Window{}
	cls.Ptr = cret
	return cls
}

var xWindowClose func(uintptr)

// Requests that the window is closed.
//
// This is similar to what happens when a window manager
// close button is clicked.
//
// This function can be used with close buttons in custom
// titlebars.
func (x *Window) Close() {

	xWindowClose(x.GoPointer())

}

var xWindowDestroy func(uintptr)

// Drop the internal reference GTK holds on toplevel windows.
func (x *Window) Destroy() {

	xWindowDestroy(x.GoPointer())

}

var xWindowFullscreen func(uintptr)

// Asks to place @window in the fullscreen state.
//
// Note that you shouldn’t assume the window is definitely fullscreen
// afterward, because other entities (e.g. the user or window manager
// unfullscreen it again, and not all window managers honor requests
// to fullscreen windows.
//
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to
// notifications of the [property@Gtk.Window:fullscreened] property.
func (x *Window) Fullscreen() {

	xWindowFullscreen(x.GoPointer())

}

var xWindowFullscreenOnMonitor func(uintptr, uintptr)

// Asks to place @window in the fullscreen state on the given @monitor.
//
// Note that you shouldn't assume the window is definitely fullscreen
// afterward, or that the windowing system allows fullscreen windows on
// any given monitor.
//
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to
// notifications of the [property@Gtk.Window:fullscreened] property.
func (x *Window) FullscreenOnMonitor(MonitorVar *gdk.Monitor) {

	xWindowFullscreenOnMonitor(x.GoPointer(), MonitorVar.GoPointer())

}

var xWindowGetApplication func(uintptr) uintptr

// Gets the `GtkApplication` associated with the window.
func (x *Window) GetApplication() *Application {
	var cls *Application

	cret := xWindowGetApplication(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Application{}
	cls.Ptr = cret
	return cls
}

var xWindowGetChild func(uintptr) uintptr

// Gets the child widget of @window.
func (x *Window) GetChild() *Widget {
	var cls *Widget

	cret := xWindowGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWindowGetDecorated func(uintptr) bool

// Returns whether the window has been set to have decorations.
func (x *Window) GetDecorated() bool {

	cret := xWindowGetDecorated(x.GoPointer())
	return cret
}

var xWindowGetDefaultSize func(uintptr, int, int)

// Gets the default size of the window.
//
// A value of 0 for the width or height indicates that a default
// size has not been explicitly set for that dimension, so the
// “natural” size of the window will be used.
func (x *Window) GetDefaultSize(WidthVar int, HeightVar int) {

	xWindowGetDefaultSize(x.GoPointer(), WidthVar, HeightVar)

}

var xWindowGetDefaultWidget func(uintptr) uintptr

// Returns the default widget for @window.
func (x *Window) GetDefaultWidget() *Widget {
	var cls *Widget

	cret := xWindowGetDefaultWidget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWindowGetDeletable func(uintptr) bool

// Returns whether the window has been set to have a close button.
func (x *Window) GetDeletable() bool {

	cret := xWindowGetDeletable(x.GoPointer())
	return cret
}

var xWindowGetDestroyWithParent func(uintptr) bool

// Returns whether the window will be destroyed with its transient parent.
func (x *Window) GetDestroyWithParent() bool {

	cret := xWindowGetDestroyWithParent(x.GoPointer())
	return cret
}

var xWindowGetFocus func(uintptr) uintptr

// Retrieves the current focused widget within the window.
//
// Note that this is the widget that would have the focus
// if the toplevel window focused; if the toplevel window
// is not focused then `gtk_widget_has_focus (widget)` will
// not be %TRUE for the widget.
func (x *Window) GetFocus() *Widget {
	var cls *Widget

	cret := xWindowGetFocus(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWindowGetFocusVisible func(uintptr) bool

// Gets whether “focus rectangles” are supposed to be visible.
func (x *Window) GetFocusVisible() bool {

	cret := xWindowGetFocusVisible(x.GoPointer())
	return cret
}

var xWindowGetGroup func(uintptr) uintptr

// Returns the group for @window.
//
// If the window has no group, then the default group is returned.
func (x *Window) GetGroup() *WindowGroup {
	var cls *WindowGroup

	cret := xWindowGetGroup(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WindowGroup{}
	cls.Ptr = cret
	return cls
}

var xWindowGetHandleMenubarAccel func(uintptr) bool

// Returns whether this window reacts to F10 key presses by
// activating a menubar it contains.
func (x *Window) GetHandleMenubarAccel() bool {

	cret := xWindowGetHandleMenubarAccel(x.GoPointer())
	return cret
}

var xWindowGetHideOnClose func(uintptr) bool

// Returns whether the window will be hidden when the close button is clicked.
func (x *Window) GetHideOnClose() bool {

	cret := xWindowGetHideOnClose(x.GoPointer())
	return cret
}

var xWindowGetIconName func(uintptr) string

// Returns the name of the themed icon for the window.
func (x *Window) GetIconName() string {

	cret := xWindowGetIconName(x.GoPointer())
	return cret
}

var xWindowGetMnemonicsVisible func(uintptr) bool

// Gets whether mnemonics are supposed to be visible.
func (x *Window) GetMnemonicsVisible() bool {

	cret := xWindowGetMnemonicsVisible(x.GoPointer())
	return cret
}

var xWindowGetModal func(uintptr) bool

// Returns whether the window is modal.
func (x *Window) GetModal() bool {

	cret := xWindowGetModal(x.GoPointer())
	return cret
}

var xWindowGetResizable func(uintptr) bool

// Gets the value set by gtk_window_set_resizable().
func (x *Window) GetResizable() bool {

	cret := xWindowGetResizable(x.GoPointer())
	return cret
}

var xWindowGetTitle func(uintptr) string

// Retrieves the title of the window.
func (x *Window) GetTitle() string {

	cret := xWindowGetTitle(x.GoPointer())
	return cret
}

var xWindowGetTitlebar func(uintptr) uintptr

// Returns the custom titlebar that has been set with
// gtk_window_set_titlebar().
func (x *Window) GetTitlebar() *Widget {
	var cls *Widget

	cret := xWindowGetTitlebar(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xWindowGetTransientFor func(uintptr) uintptr

// Fetches the transient parent for this window.
func (x *Window) GetTransientFor() *Window {
	var cls *Window

	cret := xWindowGetTransientFor(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Window{}
	cls.Ptr = cret
	return cls
}

var xWindowHasGroup func(uintptr) bool

// Returns whether @window has an explicit window group.
func (x *Window) HasGroup() bool {

	cret := xWindowHasGroup(x.GoPointer())
	return cret
}

var xWindowIsActive func(uintptr) bool

// Returns whether the window is part of the current active toplevel.
//
// The active toplevel is the window receiving keystrokes.
//
// The return value is %TRUE if the window is active toplevel itself.
// You might use this function if you wanted to draw a widget
// differently in an active window from a widget in an inactive window.
func (x *Window) IsActive() bool {

	cret := xWindowIsActive(x.GoPointer())
	return cret
}

var xWindowIsFullscreen func(uintptr) bool

// Retrieves the current fullscreen state of @window.
//
// Note that since fullscreening is ultimately handled by the window
// manager and happens asynchronously to an application request, you
// shouldn’t assume the return value of this function changing
// immediately (or at all), as an effect of calling
// [method@Gtk.Window.fullscreen] or [method@Gtk.Window.unfullscreen].
//
// If the window isn't yet mapped, the value returned will whether the
// initial requested state is fullscreen.
func (x *Window) IsFullscreen() bool {

	cret := xWindowIsFullscreen(x.GoPointer())
	return cret
}

var xWindowIsMaximized func(uintptr) bool

// Retrieves the current maximized state of @window.
//
// Note that since maximization is ultimately handled by the window
// manager and happens asynchronously to an application request, you
// shouldn’t assume the return value of this function changing
// immediately (or at all), as an effect of calling
// [method@Gtk.Window.maximize] or [method@Gtk.Window.unmaximize].
//
// If the window isn't yet mapped, the value returned will whether the
// initial requested state is maximized.
func (x *Window) IsMaximized() bool {

	cret := xWindowIsMaximized(x.GoPointer())
	return cret
}

var xWindowMaximize func(uintptr)

// Asks to maximize @window, so that it fills the screen.
//
// Note that you shouldn’t assume the window is definitely maximized
// afterward, because other entities (e.g. the user or window manager
// could unmaximize it again, and not all window managers support
// maximization.
//
// It’s permitted to call this function before showing a window,
// in which case the window will be maximized when it appears onscreen
// initially.
//
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to
// notifications on the [property@Gtk.Window:maximized]
// property.
func (x *Window) Maximize() {

	xWindowMaximize(x.GoPointer())

}

var xWindowMinimize func(uintptr)

// Asks to minimize the specified @window.
//
// Note that you shouldn’t assume the window is definitely minimized
// afterward, because the windowing system might not support this
// functionality; other entities (e.g. the user or the window manager
// could unminimize it again, or there may not be a window manager in
// which case minimization isn’t possible, etc.
//
// It’s permitted to call this function before showing a window,
// in which case the window will be minimized before it ever appears
// onscreen.
//
// You can track result of this operation via the
// [property@Gdk.Toplevel:state] property.
func (x *Window) Minimize() {

	xWindowMinimize(x.GoPointer())

}

var xWindowPresent func(uintptr)

// Presents a window to the user.
//
// This function should not be used as when it is called,
// it is too late to gather a valid timestamp to allow focus
// stealing prevention to work correctly.
func (x *Window) Present() {

	xWindowPresent(x.GoPointer())

}

var xWindowPresentWithTime func(uintptr, uint32)

// Presents a window to the user.
//
// This may mean raising the window in the stacking order,
// unminimizing it, moving it to the current desktop, and/or
// giving it the keyboard focus, possibly dependent on the user’s
// platform, window manager, and preferences.
//
// If @window is hidden, this function calls [method@Gtk.Widget.show]
// as well.
//
// This function should be used when the user tries to open a window
// that’s already open. Say for example the preferences dialog is
// currently open, and the user chooses Preferences from the menu
// a second time; use [method@Gtk.Window.present] to move the
// already-open dialog where the user can see it.
//
// Presents a window to the user in response to a user interaction.
// The timestamp should be gathered when the window was requested
// to be shown (when clicking a link for example), rather than once
// the window is ready to be shown.
func (x *Window) PresentWithTime(TimestampVar uint32) {

	xWindowPresentWithTime(x.GoPointer(), TimestampVar)

}

var xWindowSetApplication func(uintptr, uintptr)

// Sets or unsets the `GtkApplication` associated with the window.
//
// The application will be kept alive for at least as long as it has
// any windows associated with it (see g_application_hold() for a way
// to keep it alive without windows).
//
// Normally, the connection between the application and the window will
// remain until the window is destroyed, but you can explicitly remove
// it by setting the @application to %NULL.
//
// This is equivalent to calling [method@Gtk.Application.remove_window]
// and/or [method@Gtk.Application.add_window] on the old/new applications
// as relevant.
func (x *Window) SetApplication(ApplicationVar *Application) {

	xWindowSetApplication(x.GoPointer(), ApplicationVar.GoPointer())

}

var xWindowSetChild func(uintptr, uintptr)

// Sets the child widget of @window.
func (x *Window) SetChild(ChildVar *Widget) {

	xWindowSetChild(x.GoPointer(), ChildVar.GoPointer())

}

var xWindowSetDecorated func(uintptr, bool)

// Sets whether the window should be decorated.
//
// By default, windows are decorated with a title bar, resize
// controls, etc. Some window managers allow GTK to disable these
// decorations, creating a borderless window. If you set the decorated
// property to %FALSE using this function, GTK will do its best to
// convince the window manager not to decorate the window. Depending on
// the system, this function may not have any effect when called on a
// window that is already visible, so you should call it before calling
// [method@Gtk.Widget.show].
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
func (x *Window) SetDecorated(SettingVar bool) {

	xWindowSetDecorated(x.GoPointer(), SettingVar)

}

var xWindowSetDefaultSize func(uintptr, int, int)

// Sets the default size of a window.
//
// If the window’s “natural” size (its size request) is larger than
// the default, the default will be ignored.
//
// Unlike [method@Gtk.Widget.set_size_request], which sets a size
// request for a widget and thus would keep users from shrinking
// the window, this function only sets the initial size, just as
// if the user had resized the window themselves. Users can still
// shrink the window again as they normally would. Setting a default
// size of -1 means to use the “natural” default size (the size request
// of the window).
//
// The default size of a window only affects the first time a window is
// shown; if a window is hidden and re-shown, it will remember the size
// it had prior to hiding, rather than using the default size.
//
// Windows can’t actually be 0x0 in size, they must be at least 1x1, but
// passing 0 for @width and @height is OK, resulting in a 1x1 default size.
//
// If you use this function to reestablish a previously saved window size,
// note that the appropriate size to save is the one returned by
// [method@Gtk.Window.get_default_size]. Using the window allocation
// directly will not work in all circumstances and can lead to growing
// or shrinking windows.
func (x *Window) SetDefaultSize(WidthVar int, HeightVar int) {

	xWindowSetDefaultSize(x.GoPointer(), WidthVar, HeightVar)

}

var xWindowSetDefaultWidget func(uintptr, uintptr)

// Sets the default widget.
//
// The default widget is the widget that is activated when the user
// presses Enter in a dialog (for example).
func (x *Window) SetDefaultWidget(DefaultWidgetVar *Widget) {

	xWindowSetDefaultWidget(x.GoPointer(), DefaultWidgetVar.GoPointer())

}

var xWindowSetDeletable func(uintptr, bool)

// Sets whether the window should be deletable.
//
// By default, windows have a close button in the window frame.
// Some  window managers allow GTK to disable this button. If you
// set the deletable property to %FALSE using this function, GTK
// will do its best to convince the window manager not to show a
// close button. Depending on the system, this function may not
// have any effect when called on a window that is already visible,
// so you should call it before calling [method@Gtk.Widget.show].
//
// On Windows, this function always works, since there’s no window
// manager policy involved.
func (x *Window) SetDeletable(SettingVar bool) {

	xWindowSetDeletable(x.GoPointer(), SettingVar)

}

var xWindowSetDestroyWithParent func(uintptr, bool)

// If @setting is %TRUE, then destroying the transient parent of @window
// will also destroy @window itself.
//
// This is useful for dialogs that shouldn’t persist beyond the lifetime
// of the main window they are associated with, for example.
func (x *Window) SetDestroyWithParent(SettingVar bool) {

	xWindowSetDestroyWithParent(x.GoPointer(), SettingVar)

}

var xWindowSetDisplay func(uintptr, uintptr)

// Sets the `GdkDisplay` where the @window is displayed.
//
// If the window is already mapped, it will be unmapped,
// and then remapped on the new display.
func (x *Window) SetDisplay(DisplayVar *gdk.Display) {

	xWindowSetDisplay(x.GoPointer(), DisplayVar.GoPointer())

}

var xWindowSetFocus func(uintptr, uintptr)

// Sets the focus widget.
//
// If @focus is not the current focus widget, and is focusable,
// sets it as the focus widget for the window. If @focus is %NULL,
// unsets the focus widget for this window. To set the focus to a
// particular widget in the toplevel, it is usually more convenient
// to use [method@Gtk.Widget.grab_focus] instead of this function.
func (x *Window) SetFocus(FocusVar *Widget) {

	xWindowSetFocus(x.GoPointer(), FocusVar.GoPointer())

}

var xWindowSetFocusVisible func(uintptr, bool)

// Sets whether “focus rectangles” are supposed to be visible.
func (x *Window) SetFocusVisible(SettingVar bool) {

	xWindowSetFocusVisible(x.GoPointer(), SettingVar)

}

var xWindowSetHandleMenubarAccel func(uintptr, bool)

// Sets whether this window should react to F10 key presses
// by activating a menubar it contains.
func (x *Window) SetHandleMenubarAccel(HandleMenubarAccelVar bool) {

	xWindowSetHandleMenubarAccel(x.GoPointer(), HandleMenubarAccelVar)

}

var xWindowSetHideOnClose func(uintptr, bool)

// If @setting is %TRUE, then clicking the close button on the window
// will not destroy it, but only hide it.
func (x *Window) SetHideOnClose(SettingVar bool) {

	xWindowSetHideOnClose(x.GoPointer(), SettingVar)

}

var xWindowSetIconName func(uintptr, string)

// Sets the icon for the window from a named themed icon.
//
// See the docs for [class@Gtk.IconTheme] for more details.
// On some platforms, the window icon is not used at all.
//
// Note that this has nothing to do with the WM_ICON_NAME
// property which is mentioned in the ICCCM.
func (x *Window) SetIconName(NameVar string) {

	xWindowSetIconName(x.GoPointer(), NameVar)

}

var xWindowSetMnemonicsVisible func(uintptr, bool)

// Sets whether mnemonics are supposed to be visible.
func (x *Window) SetMnemonicsVisible(SettingVar bool) {

	xWindowSetMnemonicsVisible(x.GoPointer(), SettingVar)

}

var xWindowSetModal func(uintptr, bool)

// Sets a window modal or non-modal.
//
// Modal windows prevent interaction with other windows in the same
// application. To keep modal dialogs on top of main application windows,
// use [method@Gtk.Window.set_transient_for] to make the dialog transient
// for the parent; most window managers will then disallow lowering the
// dialog below the parent.
func (x *Window) SetModal(ModalVar bool) {

	xWindowSetModal(x.GoPointer(), ModalVar)

}

var xWindowSetResizable func(uintptr, bool)

// Sets whether the user can resize a window.
//
// Windows are user resizable by default.
func (x *Window) SetResizable(ResizableVar bool) {

	xWindowSetResizable(x.GoPointer(), ResizableVar)

}

var xWindowSetStartupId func(uintptr, string)

// Sets the startup notification ID.
//
// Startup notification identifiers are used by desktop environment
// to track application startup, to provide user feedback and other
// features. This function changes the corresponding property on the
// underlying `GdkSurface`.
//
// Normally, startup identifier is managed automatically and you should
// only use this function in special cases like transferring focus from
// other processes. You should use this function before calling
// [method@Gtk.Window.present] or any equivalent function generating
// a window map event.
//
// This function is only useful on X11, not with other GTK targets.
func (x *Window) SetStartupId(StartupIdVar string) {

	xWindowSetStartupId(x.GoPointer(), StartupIdVar)

}

var xWindowSetTitle func(uintptr, string)

// Sets the title of the `GtkWindow`.
//
// The title of a window will be displayed in its title bar; on the
// X Window System, the title bar is rendered by the window manager
// so exactly how the title appears to users may vary according to a
// user’s exact configuration. The title should help a user distinguish
// this window from other windows they may have open. A good title might
// include the application name and current document filename, for example.
//
// Passing %NULL does the same as setting the title to an empty string.
func (x *Window) SetTitle(TitleVar string) {

	xWindowSetTitle(x.GoPointer(), TitleVar)

}

var xWindowSetTitlebar func(uintptr, uintptr)

// Sets a custom titlebar for @window.
//
// A typical widget used here is [class@Gtk.HeaderBar], as it
// provides various features expected of a titlebar while allowing
// the addition of child widgets to it.
//
// If you set a custom titlebar, GTK will do its best to convince
// the window manager not to put its own titlebar on the window.
// Depending on the system, this function may not work for a window
// that is already visible, so you set the titlebar before calling
// [method@Gtk.Widget.show].
func (x *Window) SetTitlebar(TitlebarVar *Widget) {

	xWindowSetTitlebar(x.GoPointer(), TitlebarVar.GoPointer())

}

var xWindowSetTransientFor func(uintptr, uintptr)

// Dialog windows should be set transient for the main application
// window they were spawned from. This allows window managers to e.g.
// keep the dialog on top of the main window, or center the dialog
// over the main window. [ctor@Gtk.Dialog.new_with_buttons] and other
// convenience functions in GTK will sometimes call
// gtk_window_set_transient_for() on your behalf.
//
// Passing %NULL for @parent unsets the current transient window.
//
// On Windows, this function puts the child window on top of the parent,
// much as the window manager would have done on X.
func (x *Window) SetTransientFor(ParentVar *Window) {

	xWindowSetTransientFor(x.GoPointer(), ParentVar.GoPointer())

}

var xWindowUnfullscreen func(uintptr)

// Asks to remove the fullscreen state for @window, and return to
// its previous state.
//
// Note that you shouldn’t assume the window is definitely not
// fullscreen afterward, because other entities (e.g. the user or
// window manager could fullscreen it again, and not all window
// managers honor requests to unfullscreen windows; normally the
// window will end up restored to its normal state. Just don’t
// write code that crashes if not.
//
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to
// notifications of the [property@Gtk.Window:fullscreened] property.
func (x *Window) Unfullscreen() {

	xWindowUnfullscreen(x.GoPointer())

}

var xWindowUnmaximize func(uintptr)

// Asks to unmaximize @window.
//
// Note that you shouldn’t assume the window is definitely unmaximized
// afterward, because other entities (e.g. the user or window manager
// maximize it again, and not all window managers honor requests to
// unmaximize.
//
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to
// notifications on the [property@Gtk.Window:maximized] property.
func (x *Window) Unmaximize() {

	xWindowUnmaximize(x.GoPointer())

}

var xWindowUnminimize func(uintptr)

// Asks to unminimize the specified @window.
//
// Note that you shouldn’t assume the window is definitely unminimized
// afterward, because the windowing system might not support this
// functionality; other entities (e.g. the user or the window manager
// could minimize it again, or there may not be a window manager in
// which case minimization isn’t possible, etc.
//
// You can track result of this operation via the
// [property@Gdk.Toplevel:state] property.
func (x *Window) Unminimize() {

	xWindowUnminimize(x.GoPointer())

}

func (c *Window) GoPointer() uintptr {
	return c.Ptr
}

func (c *Window) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the user activates the default widget
// of @window.
//
// This is a [keybinding signal](class.SignalAction.html).
func (x *Window) ConnectActivateDefault(cb *func(Window)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate-default", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Window{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate-default", cbRefPtr)
}

// Emitted when the user activates the currently focused
// widget of @window.
//
// This is a [keybinding signal](class.SignalAction.html).
func (x *Window) ConnectActivateFocus(cb *func(Window)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate-focus", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Window{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate-focus", cbRefPtr)
}

// Emitted when the user clicks on the close button of the window.
func (x *Window) ConnectCloseRequest(cb *func(Window) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "close-request", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := Window{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "close-request", cbRefPtr)
}

// Emitted when the user enables or disables interactive debugging.
//
// When @toggle is %TRUE, interactive debugging is toggled on or off,
// when it is %FALSE, the debugger will be pointed at the widget
// under the pointer.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// The default bindings for this signal are Ctrl-Shift-I
// and Ctrl-Shift-D.
func (x *Window) ConnectEnableDebugging(cb *func(Window, bool) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "enable-debugging", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ToggleVarp bool) bool {
		fa := Window{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ToggleVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "enable-debugging", cbRefPtr)
}

// emitted when the set of accelerators or mnemonics that
// are associated with @window changes.
func (x *Window) ConnectKeysChanged(cb *func(Window)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "keys-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Window{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "keys-changed", cbRefPtr)
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *Window) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *Window) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *Window) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *Window) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Window) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Window) UpdatePropertyValue(NPropertiesVar int, PropertiesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Window) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Window) UpdateRelationValue(NRelationsVar int, RelationsVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Window) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Window) UpdateStateValue(NStatesVar int, StatesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *Window) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Returns the renderer that is used for this `GtkNative`.
func (x *Window) GetRenderer() *gsk.Renderer {
	var cls *gsk.Renderer

	cret := XGtkNativeGetRenderer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gsk.Renderer{}
	cls.Ptr = cret
	return cls
}

// Returns the surface of this `GtkNative`.
func (x *Window) GetSurface() *gdk.Surface {
	var cls *gdk.Surface

	cret := XGtkNativeGetSurface(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Surface{}
	cls.Ptr = cret
	return cls
}

// Retrieves the surface transform of @self.
//
// This is the translation from @self's surface coordinates into
// @self's widget coordinates.
func (x *Window) GetSurfaceTransform(XVar float64, YVar float64) {

	XGtkNativeGetSurfaceTransform(x.GoPointer(), XVar, YVar)

}

// Realizes a `GtkNative`.
//
// This should only be used by subclasses.
func (x *Window) Realize() {

	XGtkNativeRealize(x.GoPointer())

}

// Unrealizes a `GtkNative`.
//
// This should only be used by subclasses.
func (x *Window) Unrealize() {

	XGtkNativeUnrealize(x.GoPointer())

}

// Returns the display that this `GtkRoot` is on.
func (x *Window) GetDisplay() *gdk.Display {
	var cls *gdk.Display

	cret := XGtkRootGetDisplay(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Display{}
	cls.Ptr = cret
	return cls
}

var xWindowGetDefaultIconName func() string

// Returns the fallback icon name for windows.
//
// The returned string is owned by GTK and should not
// be modified. It is only valid until the next call to
// [func@Gtk.Window.set_default_icon_name].
func WindowGetDefaultIconName() string {

	cret := xWindowGetDefaultIconName()
	return cret
}

var xWindowGetToplevels func() uintptr

// Returns a list of all existing toplevel windows.
//
// If you want to iterate through the list and perform actions involving
// callbacks that might destroy the widgets or add new ones, be aware that
// the list of toplevels will change and emit the "items-changed" signal.
func WindowGetToplevels() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xWindowGetToplevels()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xWindowListToplevels func() *glib.List

// Returns a list of all existing toplevel windows.
//
// The widgets in the list are not individually referenced.
// If you want to iterate through the list and perform actions
// involving callbacks that might destroy the widgets, you must
// call `g_list_foreach (result, (GFunc)g_object_ref, NULL)` first,
// and then unref all the widgets afterwards.
func WindowListToplevels() *glib.List {

	cret := xWindowListToplevels()
	return cret
}

var xWindowSetAutoStartupNotification func(bool)

// Sets whether the window should request startup notification.
//
// By default, after showing the first `GtkWindow`, GTK calls
// [method@Gdk.Display.notify_startup_complete]. Call this function
// to disable the automatic startup notification. You might do this
// if your first window is a splash screen, and you want to delay
// notification until after your real main window has been shown,
// for example.
//
// In that example, you would disable startup notification
// temporarily, show your splash screen, then re-enable it so that
// showing the main window would automatically result in notification.
func WindowSetAutoStartupNotification(SettingVar bool) {

	xWindowSetAutoStartupNotification(SettingVar)

}

var xWindowSetDefaultIconName func(string)

// Sets an icon to be used as fallback.
//
// The fallback icon is used for windows that
// haven't had [method@Gtk.Window.set_icon_name]
// called on them.
func WindowSetDefaultIconName(NameVar string) {

	xWindowSetDefaultIconName(NameVar)

}

var xWindowSetInteractiveDebugging func(bool)

// Opens or closes the [interactive debugger](running.html#interactive-debugging).
//
// The debugger offers access to the widget hierarchy of the application
// and to useful debugging tools.
func WindowSetInteractiveDebugging(EnableVar bool) {

	xWindowSetInteractiveDebugging(EnableVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewWindow, lib, "gtk_window_new")

	core.PuregoSafeRegister(&xWindowClose, lib, "gtk_window_close")
	core.PuregoSafeRegister(&xWindowDestroy, lib, "gtk_window_destroy")
	core.PuregoSafeRegister(&xWindowFullscreen, lib, "gtk_window_fullscreen")
	core.PuregoSafeRegister(&xWindowFullscreenOnMonitor, lib, "gtk_window_fullscreen_on_monitor")
	core.PuregoSafeRegister(&xWindowGetApplication, lib, "gtk_window_get_application")
	core.PuregoSafeRegister(&xWindowGetChild, lib, "gtk_window_get_child")
	core.PuregoSafeRegister(&xWindowGetDecorated, lib, "gtk_window_get_decorated")
	core.PuregoSafeRegister(&xWindowGetDefaultSize, lib, "gtk_window_get_default_size")
	core.PuregoSafeRegister(&xWindowGetDefaultWidget, lib, "gtk_window_get_default_widget")
	core.PuregoSafeRegister(&xWindowGetDeletable, lib, "gtk_window_get_deletable")
	core.PuregoSafeRegister(&xWindowGetDestroyWithParent, lib, "gtk_window_get_destroy_with_parent")
	core.PuregoSafeRegister(&xWindowGetFocus, lib, "gtk_window_get_focus")
	core.PuregoSafeRegister(&xWindowGetFocusVisible, lib, "gtk_window_get_focus_visible")
	core.PuregoSafeRegister(&xWindowGetGroup, lib, "gtk_window_get_group")
	core.PuregoSafeRegister(&xWindowGetHandleMenubarAccel, lib, "gtk_window_get_handle_menubar_accel")
	core.PuregoSafeRegister(&xWindowGetHideOnClose, lib, "gtk_window_get_hide_on_close")
	core.PuregoSafeRegister(&xWindowGetIconName, lib, "gtk_window_get_icon_name")
	core.PuregoSafeRegister(&xWindowGetMnemonicsVisible, lib, "gtk_window_get_mnemonics_visible")
	core.PuregoSafeRegister(&xWindowGetModal, lib, "gtk_window_get_modal")
	core.PuregoSafeRegister(&xWindowGetResizable, lib, "gtk_window_get_resizable")
	core.PuregoSafeRegister(&xWindowGetTitle, lib, "gtk_window_get_title")
	core.PuregoSafeRegister(&xWindowGetTitlebar, lib, "gtk_window_get_titlebar")
	core.PuregoSafeRegister(&xWindowGetTransientFor, lib, "gtk_window_get_transient_for")
	core.PuregoSafeRegister(&xWindowHasGroup, lib, "gtk_window_has_group")
	core.PuregoSafeRegister(&xWindowIsActive, lib, "gtk_window_is_active")
	core.PuregoSafeRegister(&xWindowIsFullscreen, lib, "gtk_window_is_fullscreen")
	core.PuregoSafeRegister(&xWindowIsMaximized, lib, "gtk_window_is_maximized")
	core.PuregoSafeRegister(&xWindowMaximize, lib, "gtk_window_maximize")
	core.PuregoSafeRegister(&xWindowMinimize, lib, "gtk_window_minimize")
	core.PuregoSafeRegister(&xWindowPresent, lib, "gtk_window_present")
	core.PuregoSafeRegister(&xWindowPresentWithTime, lib, "gtk_window_present_with_time")
	core.PuregoSafeRegister(&xWindowSetApplication, lib, "gtk_window_set_application")
	core.PuregoSafeRegister(&xWindowSetChild, lib, "gtk_window_set_child")
	core.PuregoSafeRegister(&xWindowSetDecorated, lib, "gtk_window_set_decorated")
	core.PuregoSafeRegister(&xWindowSetDefaultSize, lib, "gtk_window_set_default_size")
	core.PuregoSafeRegister(&xWindowSetDefaultWidget, lib, "gtk_window_set_default_widget")
	core.PuregoSafeRegister(&xWindowSetDeletable, lib, "gtk_window_set_deletable")
	core.PuregoSafeRegister(&xWindowSetDestroyWithParent, lib, "gtk_window_set_destroy_with_parent")
	core.PuregoSafeRegister(&xWindowSetDisplay, lib, "gtk_window_set_display")
	core.PuregoSafeRegister(&xWindowSetFocus, lib, "gtk_window_set_focus")
	core.PuregoSafeRegister(&xWindowSetFocusVisible, lib, "gtk_window_set_focus_visible")
	core.PuregoSafeRegister(&xWindowSetHandleMenubarAccel, lib, "gtk_window_set_handle_menubar_accel")
	core.PuregoSafeRegister(&xWindowSetHideOnClose, lib, "gtk_window_set_hide_on_close")
	core.PuregoSafeRegister(&xWindowSetIconName, lib, "gtk_window_set_icon_name")
	core.PuregoSafeRegister(&xWindowSetMnemonicsVisible, lib, "gtk_window_set_mnemonics_visible")
	core.PuregoSafeRegister(&xWindowSetModal, lib, "gtk_window_set_modal")
	core.PuregoSafeRegister(&xWindowSetResizable, lib, "gtk_window_set_resizable")
	core.PuregoSafeRegister(&xWindowSetStartupId, lib, "gtk_window_set_startup_id")
	core.PuregoSafeRegister(&xWindowSetTitle, lib, "gtk_window_set_title")
	core.PuregoSafeRegister(&xWindowSetTitlebar, lib, "gtk_window_set_titlebar")
	core.PuregoSafeRegister(&xWindowSetTransientFor, lib, "gtk_window_set_transient_for")
	core.PuregoSafeRegister(&xWindowUnfullscreen, lib, "gtk_window_unfullscreen")
	core.PuregoSafeRegister(&xWindowUnmaximize, lib, "gtk_window_unmaximize")
	core.PuregoSafeRegister(&xWindowUnminimize, lib, "gtk_window_unminimize")

	core.PuregoSafeRegister(&xWindowGetDefaultIconName, lib, "gtk_window_get_default_icon_name")
	core.PuregoSafeRegister(&xWindowGetToplevels, lib, "gtk_window_get_toplevels")
	core.PuregoSafeRegister(&xWindowListToplevels, lib, "gtk_window_list_toplevels")
	core.PuregoSafeRegister(&xWindowSetAutoStartupNotification, lib, "gtk_window_set_auto_startup_notification")
	core.PuregoSafeRegister(&xWindowSetDefaultIconName, lib, "gtk_window_set_default_icon_name")
	core.PuregoSafeRegister(&xWindowSetInteractiveDebugging, lib, "gtk_window_set_interactive_debugging")

}
