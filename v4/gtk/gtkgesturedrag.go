// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type GestureDragClass struct {
}

func (x *GestureDragClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GtkGestureDrag` is a `GtkGesture` implementation for drags.
//
// The drag operation itself can be tracked throughout the
// [signal@Gtk.GestureDrag::drag-begin],
// [signal@Gtk.GestureDrag::drag-update] and
// [signal@Gtk.GestureDrag::drag-end] signals, and the relevant
// coordinates can be extracted through
// [method@Gtk.GestureDrag.get_offset] and
// [method@Gtk.GestureDrag.get_start_point].
type GestureDrag struct {
	GestureSingle
}

func GestureDragNewFromInternalPtr(ptr uintptr) *GestureDrag {
	cls := &GestureDrag{}
	cls.Ptr = ptr
	return cls
}

var xNewGestureDrag func() uintptr

// Returns a newly created `GtkGesture` that recognizes drags.
func NewGestureDrag() *GestureDrag {
	var cls *GestureDrag

	cret := xNewGestureDrag()

	if cret == 0 {
		return nil
	}
	cls = &GestureDrag{}
	cls.Ptr = cret
	return cls
}

var xGestureDragGetOffset func(uintptr, float64, float64) bool

// Gets the offset from the start point.
//
// If the @gesture is active, this function returns %TRUE and
// fills in @x and @y with the coordinates of the current point,
// as an offset to the starting drag point.
func (x *GestureDrag) GetOffset(XVar float64, YVar float64) bool {

	cret := xGestureDragGetOffset(x.GoPointer(), XVar, YVar)
	return cret
}

var xGestureDragGetStartPoint func(uintptr, float64, float64) bool

// Gets the point where the drag started.
//
// If the @gesture is active, this function returns %TRUE
// and fills in @x and @y with the drag start coordinates,
// in widget-relative coordinates.
func (x *GestureDrag) GetStartPoint(XVar float64, YVar float64) bool {

	cret := xGestureDragGetStartPoint(x.GoPointer(), XVar, YVar)
	return cret
}

func (c *GestureDrag) GoPointer() uintptr {
	return c.Ptr
}

func (c *GestureDrag) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted whenever dragging starts.
func (x *GestureDrag) ConnectDragBegin(cb *func(GestureDrag, float64, float64)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "drag-begin", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, StartXVarp float64, StartYVarp float64) {
		fa := GestureDrag{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, StartXVarp, StartYVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "drag-begin", cbRefPtr)
}

// Emitted whenever the dragging is finished.
func (x *GestureDrag) ConnectDragEnd(cb *func(GestureDrag, float64, float64)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "drag-end", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, OffsetXVarp float64, OffsetYVarp float64) {
		fa := GestureDrag{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, OffsetXVarp, OffsetYVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "drag-end", cbRefPtr)
}

// Emitted whenever the dragging point moves.
func (x *GestureDrag) ConnectDragUpdate(cb *func(GestureDrag, float64, float64)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "drag-update", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, OffsetXVarp float64, OffsetYVarp float64) {
		fa := GestureDrag{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, OffsetXVarp, OffsetYVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "drag-update", cbRefPtr)
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewGestureDrag, lib, "gtk_gesture_drag_new")

	core.PuregoSafeRegister(&xGestureDragGetOffset, lib, "gtk_gesture_drag_get_offset")
	core.PuregoSafeRegister(&xGestureDragGetStartPoint, lib, "gtk_gesture_drag_get_start_point")

}
