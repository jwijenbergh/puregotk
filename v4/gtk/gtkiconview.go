// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// A function used by gtk_icon_view_selected_foreach() to map all
// selected rows.
//
// It will be called on every selected row in the view.
type IconViewForeachFunc func(uintptr, *TreePath, uintptr)

// An enum for determining where a dropped item goes.
type IconViewDropPosition int

const (

	// no drop possible
	IconViewNoDropValue IconViewDropPosition = 0
	// dropped item replaces the item
	IconViewDropIntoValue IconViewDropPosition = 1
	// dropped item is inserted to the left
	IconViewDropLeftValue IconViewDropPosition = 2
	// dropped item is inserted to the right
	IconViewDropRightValue IconViewDropPosition = 3
	// dropped item is inserted above
	IconViewDropAboveValue IconViewDropPosition = 4
	// dropped item is inserted below
	IconViewDropBelowValue IconViewDropPosition = 5
)

// `GtkIconView` is a widget which displays data in a grid of icons.
//
// `GtkIconView` provides an alternative view on a `GtkTreeModel`.
// It displays the model as a grid of icons with labels. Like
// [class@Gtk.TreeView], it allows to select one or multiple items
// (depending on the selection mode, see [method@Gtk.IconView.set_selection_mode]).
// In addition to selection with the arrow keys, `GtkIconView` supports
// rubberband selection, which is controlled by dragging the pointer.
//
// Note that if the tree model is backed by an actual tree store (as
// opposed to a flat list where the mapping to icons is obvious),
// `GtkIconView` will only display the first level of the tree and
// ignore the tree’s branches.
//
// # CSS nodes
//
// ```
// iconview.view
// ╰── [rubberband]
// ```
//
// `GtkIconView` has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
type IconView struct {
	Widget
}

func IconViewNewFromInternalPtr(ptr uintptr) *IconView {
	cls := &IconView{}
	cls.Ptr = ptr
	return cls
}

var xNewIconView func() uintptr

// Creates a new `GtkIconView` widget
func NewIconView() *IconView {
	var cls *IconView

	cret := xNewIconView()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &IconView{}
	cls.Ptr = cret
	return cls
}

var xNewIconViewWithArea func(uintptr) uintptr

// Creates a new `GtkIconView` widget using the
// specified @area to layout cells inside the icons.
func NewIconViewWithArea(AreaVar *CellArea) *IconView {
	var cls *IconView

	cret := xNewIconViewWithArea(AreaVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &IconView{}
	cls.Ptr = cret
	return cls
}

var xNewIconViewWithModel func(uintptr) uintptr

// Creates a new `GtkIconView` widget with the model @model.
func NewIconViewWithModel(ModelVar TreeModel) *IconView {
	var cls *IconView

	cret := xNewIconViewWithModel(ModelVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &IconView{}
	cls.Ptr = cret
	return cls
}

var xIconViewCreateDragIcon func(uintptr, *TreePath) uintptr

// Creates a `GdkPaintable` representation of the item at @path.
// This image is used for a drag icon.
func (x *IconView) CreateDragIcon(PathVar *TreePath) *gdk.PaintableBase {
	var cls *gdk.PaintableBase

	cret := xIconViewCreateDragIcon(x.GoPointer(), PathVar)

	if cret == 0 {
		return nil
	}
	cls = &gdk.PaintableBase{}
	cls.Ptr = cret
	return cls
}

var xIconViewEnableModelDragDest func(uintptr, *gdk.ContentFormats, gdk.DragAction)

// Turns @icon_view into a drop destination for automatic DND. Calling this
// method sets `GtkIconView`:reorderable to %FALSE.
func (x *IconView) EnableModelDragDest(FormatsVar *gdk.ContentFormats, ActionsVar gdk.DragAction) {

	xIconViewEnableModelDragDest(x.GoPointer(), FormatsVar, ActionsVar)

}

var xIconViewEnableModelDragSource func(uintptr, gdk.ModifierType, *gdk.ContentFormats, gdk.DragAction)

// Turns @icon_view into a drag source for automatic DND. Calling this
// method sets `GtkIconView`:reorderable to %FALSE.
func (x *IconView) EnableModelDragSource(StartButtonMaskVar gdk.ModifierType, FormatsVar *gdk.ContentFormats, ActionsVar gdk.DragAction) {

	xIconViewEnableModelDragSource(x.GoPointer(), StartButtonMaskVar, FormatsVar, ActionsVar)

}

var xIconViewGetActivateOnSingleClick func(uintptr) bool

// Gets the setting set by gtk_icon_view_set_activate_on_single_click().
func (x *IconView) GetActivateOnSingleClick() bool {

	cret := xIconViewGetActivateOnSingleClick(x.GoPointer())
	return cret
}

var xIconViewGetCellRect func(uintptr, *TreePath, uintptr, *gdk.Rectangle) bool

// Fills the bounding rectangle in widget coordinates for the cell specified by
// @path and @cell. If @cell is %NULL the main cell area is used.
//
// This function is only valid if @icon_view is realized.
func (x *IconView) GetCellRect(PathVar *TreePath, CellVar *CellRenderer, RectVar *gdk.Rectangle) bool {

	cret := xIconViewGetCellRect(x.GoPointer(), PathVar, CellVar.GoPointer(), RectVar)
	return cret
}

var xIconViewGetColumnSpacing func(uintptr) int

// Returns the value of the ::column-spacing property.
func (x *IconView) GetColumnSpacing() int {

	cret := xIconViewGetColumnSpacing(x.GoPointer())
	return cret
}

var xIconViewGetColumns func(uintptr) int

// Returns the value of the ::columns property.
func (x *IconView) GetColumns() int {

	cret := xIconViewGetColumns(x.GoPointer())
	return cret
}

var xIconViewGetCursor func(uintptr, **TreePath, *uintptr) bool

// Fills in @path and @cell with the current cursor path and cell.
// If the cursor isn’t currently set, then *@path will be %NULL.
// If no cell currently has focus, then *@cell will be %NULL.
//
// The returned `GtkTreePath` must be freed with gtk_tree_path_free().
func (x *IconView) GetCursor(PathVar **TreePath, CellVar **CellRenderer) bool {

	cret := xIconViewGetCursor(x.GoPointer(), PathVar, gobject.ConvertPtr(CellVar))
	return cret
}

var xIconViewGetDestItemAtPos func(uintptr, int, int, **TreePath, *IconViewDropPosition) bool

// Determines the destination item for a given position.
func (x *IconView) GetDestItemAtPos(DragXVar int, DragYVar int, PathVar **TreePath, PosVar *IconViewDropPosition) bool {

	cret := xIconViewGetDestItemAtPos(x.GoPointer(), DragXVar, DragYVar, PathVar, PosVar)
	return cret
}

var xIconViewGetDragDestItem func(uintptr, **TreePath, *IconViewDropPosition)

// Gets information about the item that is highlighted for feedback.
func (x *IconView) GetDragDestItem(PathVar **TreePath, PosVar *IconViewDropPosition) {

	xIconViewGetDragDestItem(x.GoPointer(), PathVar, PosVar)

}

var xIconViewGetItemAtPos func(uintptr, int, int, **TreePath, *uintptr) bool

// Gets the path and cell for the icon at the given position.
func (x *IconView) GetItemAtPos(XVar int, YVar int, PathVar **TreePath, CellVar **CellRenderer) bool {

	cret := xIconViewGetItemAtPos(x.GoPointer(), XVar, YVar, PathVar, gobject.ConvertPtr(CellVar))
	return cret
}

var xIconViewGetItemColumn func(uintptr, *TreePath) int

// Gets the column in which the item @path is currently
// displayed. Column numbers start at 0.
func (x *IconView) GetItemColumn(PathVar *TreePath) int {

	cret := xIconViewGetItemColumn(x.GoPointer(), PathVar)
	return cret
}

var xIconViewGetItemOrientation func(uintptr) Orientation

// Returns the value of the ::item-orientation property which determines
// whether the labels are drawn beside the icons instead of below.
func (x *IconView) GetItemOrientation() Orientation {

	cret := xIconViewGetItemOrientation(x.GoPointer())
	return cret
}

var xIconViewGetItemPadding func(uintptr) int

// Returns the value of the ::item-padding property.
func (x *IconView) GetItemPadding() int {

	cret := xIconViewGetItemPadding(x.GoPointer())
	return cret
}

var xIconViewGetItemRow func(uintptr, *TreePath) int

// Gets the row in which the item @path is currently
// displayed. Row numbers start at 0.
func (x *IconView) GetItemRow(PathVar *TreePath) int {

	cret := xIconViewGetItemRow(x.GoPointer(), PathVar)
	return cret
}

var xIconViewGetItemWidth func(uintptr) int

// Returns the value of the ::item-width property.
func (x *IconView) GetItemWidth() int {

	cret := xIconViewGetItemWidth(x.GoPointer())
	return cret
}

var xIconViewGetMargin func(uintptr) int

// Returns the value of the ::margin property.
func (x *IconView) GetMargin() int {

	cret := xIconViewGetMargin(x.GoPointer())
	return cret
}

var xIconViewGetMarkupColumn func(uintptr) int

// Returns the column with markup text for @icon_view.
func (x *IconView) GetMarkupColumn() int {

	cret := xIconViewGetMarkupColumn(x.GoPointer())
	return cret
}

var xIconViewGetModel func(uintptr) uintptr

// Returns the model the `GtkIconView` is based on.  Returns %NULL if the
// model is unset.
func (x *IconView) GetModel() *TreeModelBase {
	var cls *TreeModelBase

	cret := xIconViewGetModel(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TreeModelBase{}
	cls.Ptr = cret
	return cls
}

var xIconViewGetPathAtPos func(uintptr, int, int) *TreePath

// Gets the path for the icon at the given position.
func (x *IconView) GetPathAtPos(XVar int, YVar int) *TreePath {

	cret := xIconViewGetPathAtPos(x.GoPointer(), XVar, YVar)
	return cret
}

var xIconViewGetPixbufColumn func(uintptr) int

// Returns the column with pixbufs for @icon_view.
func (x *IconView) GetPixbufColumn() int {

	cret := xIconViewGetPixbufColumn(x.GoPointer())
	return cret
}

var xIconViewGetReorderable func(uintptr) bool

// Retrieves whether the user can reorder the list via drag-and-drop.
// See gtk_icon_view_set_reorderable().
func (x *IconView) GetReorderable() bool {

	cret := xIconViewGetReorderable(x.GoPointer())
	return cret
}

var xIconViewGetRowSpacing func(uintptr) int

// Returns the value of the ::row-spacing property.
func (x *IconView) GetRowSpacing() int {

	cret := xIconViewGetRowSpacing(x.GoPointer())
	return cret
}

var xIconViewGetSelectedItems func(uintptr) *glib.List

// Creates a list of paths of all selected items. Additionally, if you are
// planning on modifying the model after calling this function, you may
// want to convert the returned list into a list of `GtkTreeRowReferences`.
// To do this, you can use gtk_tree_row_reference_new().
//
// To free the return value, use `g_list_free_full`:
// |[&lt;!-- language="C" --&gt;
// GtkWidget *icon_view = gtk_icon_view_new ();
// // Use icon_view
//
// GList *list = gtk_icon_view_get_selected_items (GTK_ICON_VIEW (icon_view));
//
// // use list
//
// g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
// ]|
func (x *IconView) GetSelectedItems() *glib.List {

	cret := xIconViewGetSelectedItems(x.GoPointer())
	return cret
}

var xIconViewGetSelectionMode func(uintptr) SelectionMode

// Gets the selection mode of the @icon_view.
func (x *IconView) GetSelectionMode() SelectionMode {

	cret := xIconViewGetSelectionMode(x.GoPointer())
	return cret
}

var xIconViewGetSpacing func(uintptr) int

// Returns the value of the ::spacing property.
func (x *IconView) GetSpacing() int {

	cret := xIconViewGetSpacing(x.GoPointer())
	return cret
}

var xIconViewGetTextColumn func(uintptr) int

// Returns the column with text for @icon_view.
func (x *IconView) GetTextColumn() int {

	cret := xIconViewGetTextColumn(x.GoPointer())
	return cret
}

var xIconViewGetTooltipColumn func(uintptr) int

// Returns the column of @icon_view’s model which is being used for
// displaying tooltips on @icon_view’s rows.
func (x *IconView) GetTooltipColumn() int {

	cret := xIconViewGetTooltipColumn(x.GoPointer())
	return cret
}

var xIconViewGetTooltipContext func(uintptr, int, int, bool, *uintptr, **TreePath, *TreeIter) bool

// This function is supposed to be used in a `GtkWidget::query-tooltip`
// signal handler for `GtkIconView`. The @x, @y and @keyboard_tip values
// which are received in the signal handler, should be passed to this
// function without modification.
//
// The return value indicates whether there is an icon view item at the given
// coordinates (%TRUE) or not (%FALSE) for mouse tooltips. For keyboard
// tooltips the item returned will be the cursor item. When %TRUE, then any of
// @model, @path and @iter which have been provided will be set to point to
// that row and the corresponding model.
func (x *IconView) GetTooltipContext(XVar int, YVar int, KeyboardTipVar bool, ModelVar *TreeModel, PathVar **TreePath, IterVar *TreeIter) bool {

	cret := xIconViewGetTooltipContext(x.GoPointer(), XVar, YVar, KeyboardTipVar, gobject.ConvertPtr(ModelVar), PathVar, IterVar)
	return cret
}

var xIconViewGetVisibleRange func(uintptr, **TreePath, **TreePath) bool

// Sets @start_path and @end_path to be the first and last visible path.
// Note that there may be invisible paths in between.
//
// Both paths should be freed with gtk_tree_path_free() after use.
func (x *IconView) GetVisibleRange(StartPathVar **TreePath, EndPathVar **TreePath) bool {

	cret := xIconViewGetVisibleRange(x.GoPointer(), StartPathVar, EndPathVar)
	return cret
}

var xIconViewItemActivated func(uintptr, *TreePath)

// Activates the item determined by @path.
func (x *IconView) ItemActivated(PathVar *TreePath) {

	xIconViewItemActivated(x.GoPointer(), PathVar)

}

var xIconViewPathIsSelected func(uintptr, *TreePath) bool

// Returns %TRUE if the icon pointed to by @path is currently
// selected. If @path does not point to a valid location, %FALSE is returned.
func (x *IconView) PathIsSelected(PathVar *TreePath) bool {

	cret := xIconViewPathIsSelected(x.GoPointer(), PathVar)
	return cret
}

var xIconViewScrollToPath func(uintptr, *TreePath, bool, float32, float32)

// Moves the alignments of @icon_view to the position specified by @path.
// @row_align determines where the row is placed, and @col_align determines
// where @column is placed.  Both are expected to be between 0.0 and 1.0.
// 0.0 means left/top alignment, 1.0 means right/bottom alignment, 0.5 means
// center.
//
// If @use_align is %FALSE, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the item onto the screen.
// This means that the item will be scrolled to the edge closest to its current
// position.  If the item is currently visible on the screen, nothing is done.
//
// This function only works if the model is set, and @path is a valid row on
// the model. If the model changes before the @icon_view is realized, the
// centered path will be modified to reflect this change.
func (x *IconView) ScrollToPath(PathVar *TreePath, UseAlignVar bool, RowAlignVar float32, ColAlignVar float32) {

	xIconViewScrollToPath(x.GoPointer(), PathVar, UseAlignVar, RowAlignVar, ColAlignVar)

}

var xIconViewSelectAll func(uintptr)

// Selects all the icons. @icon_view must has its selection mode set
// to %GTK_SELECTION_MULTIPLE.
func (x *IconView) SelectAll() {

	xIconViewSelectAll(x.GoPointer())

}

var xIconViewSelectPath func(uintptr, *TreePath)

// Selects the row at @path.
func (x *IconView) SelectPath(PathVar *TreePath) {

	xIconViewSelectPath(x.GoPointer(), PathVar)

}

var xIconViewSelectedForeach func(uintptr, uintptr, uintptr)

// Calls a function for each selected icon. Note that the model or
// selection cannot be modified from within this function.
func (x *IconView) SelectedForeach(FuncVar *IconViewForeachFunc, DataVar uintptr) {

	xIconViewSelectedForeach(x.GoPointer(), glib.NewCallback(FuncVar), DataVar)

}

var xIconViewSetActivateOnSingleClick func(uintptr, bool)

// Causes the `GtkIconView`::item-activated signal to be emitted on
// a single click instead of a double click.
func (x *IconView) SetActivateOnSingleClick(SingleVar bool) {

	xIconViewSetActivateOnSingleClick(x.GoPointer(), SingleVar)

}

var xIconViewSetColumnSpacing func(uintptr, int)

// Sets the ::column-spacing property which specifies the space
// which is inserted between the columns of the icon view.
func (x *IconView) SetColumnSpacing(ColumnSpacingVar int) {

	xIconViewSetColumnSpacing(x.GoPointer(), ColumnSpacingVar)

}

var xIconViewSetColumns func(uintptr, int)

// Sets the ::columns property which determines in how
// many columns the icons are arranged. If @columns is
// -1, the number of columns will be chosen automatically
// to fill the available area.
func (x *IconView) SetColumns(ColumnsVar int) {

	xIconViewSetColumns(x.GoPointer(), ColumnsVar)

}

var xIconViewSetCursor func(uintptr, *TreePath, uintptr, bool)

// Sets the current keyboard focus to be at @path, and selects it.  This is
// useful when you want to focus the user’s attention on a particular item.
// If @cell is not %NULL, then focus is given to the cell specified by
// it. Additionally, if @start_editing is %TRUE, then editing should be
// started in the specified cell.
//
// This function is often followed by `gtk_widget_grab_focus
// (icon_view)` in order to give keyboard focus to the widget.
// Please note that editing can only happen when the widget is realized.
func (x *IconView) SetCursor(PathVar *TreePath, CellVar *CellRenderer, StartEditingVar bool) {

	xIconViewSetCursor(x.GoPointer(), PathVar, CellVar.GoPointer(), StartEditingVar)

}

var xIconViewSetDragDestItem func(uintptr, *TreePath, IconViewDropPosition)

// Sets the item that is highlighted for feedback.
func (x *IconView) SetDragDestItem(PathVar *TreePath, PosVar IconViewDropPosition) {

	xIconViewSetDragDestItem(x.GoPointer(), PathVar, PosVar)

}

var xIconViewSetItemOrientation func(uintptr, Orientation)

// Sets the ::item-orientation property which determines whether the labels
// are drawn beside the icons instead of below.
func (x *IconView) SetItemOrientation(OrientationVar Orientation) {

	xIconViewSetItemOrientation(x.GoPointer(), OrientationVar)

}

var xIconViewSetItemPadding func(uintptr, int)

// Sets the `GtkIconView`:item-padding property which specifies the padding
// around each of the icon view’s items.
func (x *IconView) SetItemPadding(ItemPaddingVar int) {

	xIconViewSetItemPadding(x.GoPointer(), ItemPaddingVar)

}

var xIconViewSetItemWidth func(uintptr, int)

// Sets the ::item-width property which specifies the width
// to use for each item. If it is set to -1, the icon view will
// automatically determine a suitable item size.
func (x *IconView) SetItemWidth(ItemWidthVar int) {

	xIconViewSetItemWidth(x.GoPointer(), ItemWidthVar)

}

var xIconViewSetMargin func(uintptr, int)

// Sets the ::margin property which specifies the space
// which is inserted at the top, bottom, left and right
// of the icon view.
func (x *IconView) SetMargin(MarginVar int) {

	xIconViewSetMargin(x.GoPointer(), MarginVar)

}

var xIconViewSetMarkupColumn func(uintptr, int)

// Sets the column with markup information for @icon_view to be
// @column. The markup column must be of type `G_TYPE_STRING`.
// If the markup column is set to something, it overrides
// the text column set by gtk_icon_view_set_text_column().
func (x *IconView) SetMarkupColumn(ColumnVar int) {

	xIconViewSetMarkupColumn(x.GoPointer(), ColumnVar)

}

var xIconViewSetModel func(uintptr, uintptr)

// Sets the model for a `GtkIconView`.
// If the @icon_view already has a model set, it will remove
// it before setting the new model.  If @model is %NULL, then
// it will unset the old model.
func (x *IconView) SetModel(ModelVar TreeModel) {

	xIconViewSetModel(x.GoPointer(), ModelVar.GoPointer())

}

var xIconViewSetPixbufColumn func(uintptr, int)

// Sets the column with pixbufs for @icon_view to be @column. The pixbuf
// column must be of type `GDK_TYPE_PIXBUF`
func (x *IconView) SetPixbufColumn(ColumnVar int) {

	xIconViewSetPixbufColumn(x.GoPointer(), ColumnVar)

}

var xIconViewSetReorderable func(uintptr, bool)

// This function is a convenience function to allow you to reorder models that
// support the `GtkTreeDragSourceIface` and the `GtkTreeDragDestIface`. Both
// `GtkTreeStore` and `GtkListStore` support these. If @reorderable is %TRUE, then
// the user can reorder the model by dragging and dropping rows.  The
// developer can listen to these changes by connecting to the model's
// row_inserted and row_deleted signals. The reordering is implemented by setting up
// the icon view as a drag source and destination. Therefore, drag and
// drop can not be used in a reorderable view for any other purpose.
//
// This function does not give you any degree of control over the order -- any
// reordering is allowed.  If more control is needed, you should probably
// handle drag and drop manually.
func (x *IconView) SetReorderable(ReorderableVar bool) {

	xIconViewSetReorderable(x.GoPointer(), ReorderableVar)

}

var xIconViewSetRowSpacing func(uintptr, int)

// Sets the ::row-spacing property which specifies the space
// which is inserted between the rows of the icon view.
func (x *IconView) SetRowSpacing(RowSpacingVar int) {

	xIconViewSetRowSpacing(x.GoPointer(), RowSpacingVar)

}

var xIconViewSetSelectionMode func(uintptr, SelectionMode)

// Sets the selection mode of the @icon_view.
func (x *IconView) SetSelectionMode(ModeVar SelectionMode) {

	xIconViewSetSelectionMode(x.GoPointer(), ModeVar)

}

var xIconViewSetSpacing func(uintptr, int)

// Sets the ::spacing property which specifies the space
// which is inserted between the cells (i.e. the icon and
// the text) of an item.
func (x *IconView) SetSpacing(SpacingVar int) {

	xIconViewSetSpacing(x.GoPointer(), SpacingVar)

}

var xIconViewSetTextColumn func(uintptr, int)

// Sets the column with text for @icon_view to be @column. The text
// column must be of type `G_TYPE_STRING`.
func (x *IconView) SetTextColumn(ColumnVar int) {

	xIconViewSetTextColumn(x.GoPointer(), ColumnVar)

}

var xIconViewSetTooltipCell func(uintptr, uintptr, *TreePath, uintptr)

// Sets the tip area of @tooltip to the area which @cell occupies in
// the item pointed to by @path. See also gtk_tooltip_set_tip_area().
//
// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
func (x *IconView) SetTooltipCell(TooltipVar *Tooltip, PathVar *TreePath, CellVar *CellRenderer) {

	xIconViewSetTooltipCell(x.GoPointer(), TooltipVar.GoPointer(), PathVar, CellVar.GoPointer())

}

var xIconViewSetTooltipColumn func(uintptr, int)

// If you only plan to have simple (text-only) tooltips on full items, you
// can use this function to have `GtkIconView` handle these automatically
// for you. @column should be set to the column in @icon_view’s model
// containing the tooltip texts, or -1 to disable this feature.
//
// When enabled, `GtkWidget:has-tooltip` will be set to %TRUE and
// @icon_view will connect a `GtkWidget::query-tooltip` signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
// so &amp;, &lt;, etc have to be escaped in the text.
func (x *IconView) SetTooltipColumn(ColumnVar int) {

	xIconViewSetTooltipColumn(x.GoPointer(), ColumnVar)

}

var xIconViewSetTooltipItem func(uintptr, uintptr, *TreePath)

// Sets the tip area of @tooltip to be the area covered by the item at @path.
// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
// See also gtk_tooltip_set_tip_area().
func (x *IconView) SetTooltipItem(TooltipVar *Tooltip, PathVar *TreePath) {

	xIconViewSetTooltipItem(x.GoPointer(), TooltipVar.GoPointer(), PathVar)

}

var xIconViewUnselectAll func(uintptr)

// Unselects all the icons.
func (x *IconView) UnselectAll() {

	xIconViewUnselectAll(x.GoPointer())

}

var xIconViewUnselectPath func(uintptr, *TreePath)

// Unselects the row at @path.
func (x *IconView) UnselectPath(PathVar *TreePath) {

	xIconViewUnselectPath(x.GoPointer(), PathVar)

}

var xIconViewUnsetModelDragDest func(uintptr)

// Undoes the effect of gtk_icon_view_enable_model_drag_dest(). Calling this
// method sets `GtkIconView`:reorderable to %FALSE.
func (x *IconView) UnsetModelDragDest() {

	xIconViewUnsetModelDragDest(x.GoPointer())

}

var xIconViewUnsetModelDragSource func(uintptr)

// Undoes the effect of gtk_icon_view_enable_model_drag_source(). Calling this
// method sets `GtkIconView`:reorderable to %FALSE.
func (x *IconView) UnsetModelDragSource() {

	xIconViewUnsetModelDragSource(x.GoPointer())

}

func (c *IconView) GoPointer() uintptr {
	return c.Ptr
}

func (c *IconView) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A [keybinding signal][class@Gtk.SignalAction]
// which gets emitted when the user activates the currently
// focused item.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control activation
// programmatically.
//
// The default bindings for this signal are Space, Return and Enter.
func (x *IconView) ConnectActivateCursorItem(cb *func(IconView) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate-cursor-item", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := IconView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate-cursor-item", cbRefPtr)
}

// The ::item-activated signal is emitted when the method
// gtk_icon_view_item_activated() is called, when the user double
// clicks an item with the "activate-on-single-click" property set
// to %FALSE, or when the user single clicks an item when the
// "activate-on-single-click" property set to %TRUE. It is also
// emitted when a non-editable item is selected and one of the keys:
// Space, Return or Enter is pressed.
func (x *IconView) ConnectItemActivated(cb *func(IconView, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "item-activated", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PathVarp uintptr) {
		fa := IconView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "item-activated", cbRefPtr)
}

// The ::move-cursor signal is a
// [keybinding signal][class@Gtk.SignalAction]
// which gets emitted when the user initiates a cursor movement.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor
// programmatically.
//
// The default bindings for this signal include
// - Arrow keys which move by individual steps
// - Home/End keys which move to the first/last item
// - PageUp/PageDown which move by "pages"
// All of these will extend the selection when combined with
// the Shift modifier.
func (x *IconView) ConnectMoveCursor(cb *func(IconView, MovementStep, int, bool, bool) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, StepVarp MovementStep, CountVarp int, ExtendVarp bool, ModifyVarp bool) bool {
		fa := IconView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, StepVarp, CountVarp, ExtendVarp, ModifyVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "move-cursor", cbRefPtr)
}

// A [keybinding signal][class@Gtk.SignalAction]
// which gets emitted when the user selects all items.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection
// programmatically.
//
// The default binding for this signal is Ctrl-a.
func (x *IconView) ConnectSelectAll(cb *func(IconView)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "select-all", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := IconView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "select-all", cbRefPtr)
}

// A [keybinding signal][class@Gtk.SignalAction]
// which gets emitted when the user selects the item that is currently
// focused.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection
// programmatically.
//
// There is no default binding for this signal.
func (x *IconView) ConnectSelectCursorItem(cb *func(IconView)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "select-cursor-item", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := IconView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "select-cursor-item", cbRefPtr)
}

// The ::selection-changed signal is emitted when the selection
// (i.e. the set of selected items) changes.
func (x *IconView) ConnectSelectionChanged(cb *func(IconView)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "selection-changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := IconView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "selection-changed", cbRefPtr)
}

// A [keybinding signal][class@Gtk.SignalAction]
// which gets emitted when the user toggles whether the currently
// focused item is selected or not. The exact effect of this
// depend on the selection mode.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection
// programmatically.
//
// There is no default binding for this signal is Ctrl-Space.
func (x *IconView) ConnectToggleCursorItem(cb *func(IconView)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "toggle-cursor-item", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := IconView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "toggle-cursor-item", cbRefPtr)
}

// A [keybinding signal][class@Gtk.SignalAction]
// which gets emitted when the user unselects all items.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection
// programmatically.
//
// The default binding for this signal is Ctrl-Shift-a.
func (x *IconView) ConnectUnselectAll(cb *func(IconView)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "unselect-all", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := IconView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "unselect-all", cbRefPtr)
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *IconView) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *IconView) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *IconView) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *IconView) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *IconView) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *IconView) UpdatePropertyValue(NPropertiesVar int, PropertiesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *IconView) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *IconView) UpdateRelationValue(NRelationsVar int, RelationsVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *IconView) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *IconView) UpdateStateValue(NStatesVar int, StatesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *IconView) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Adds an attribute mapping to the list in @cell_layout.
//
// The @column is the column of the model to get a value from, and the
// @attribute is the property on @cell to be set from that value. So for
// example if column 2 of the model contains strings, you could have the
// “text” attribute of a `GtkCellRendererText` get its values from column 2.
// In this context "attribute" and "property" are used interchangeably.
func (x *IconView) AddAttribute(CellVar *CellRenderer, AttributeVar string, ColumnVar int) {

	XGtkCellLayoutAddAttribute(x.GoPointer(), CellVar.GoPointer(), AttributeVar, ColumnVar)

}

// Unsets all the mappings on all renderers on @cell_layout and
// removes all renderers from @cell_layout.
func (x *IconView) Clear() {

	XGtkCellLayoutClear(x.GoPointer())

}

// Clears all existing attributes previously set with
// gtk_cell_layout_set_attributes().
func (x *IconView) ClearAttributes(CellVar *CellRenderer) {

	XGtkCellLayoutClearAttributes(x.GoPointer(), CellVar.GoPointer())

}

// Returns the underlying `GtkCellArea` which might be @cell_layout
// if called on a `GtkCellArea` or might be %NULL if no `GtkCellArea`
// is used by @cell_layout.
func (x *IconView) GetArea() *CellArea {
	var cls *CellArea

	cret := XGtkCellLayoutGetArea(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &CellArea{}
	cls.Ptr = cret
	return cls
}

// Returns the cell renderers which have been added to @cell_layout.
func (x *IconView) GetCells() *glib.List {

	cret := XGtkCellLayoutGetCells(x.GoPointer())
	return cret
}

// Adds the @cell to the end of @cell_layout. If @expand is %FALSE, then the
// @cell is allocated no more space than it needs. Any unused space is
// divided evenly between cells for which @expand is %TRUE.
//
// Note that reusing the same cell renderer is not supported.
func (x *IconView) PackEnd(CellVar *CellRenderer, ExpandVar bool) {

	XGtkCellLayoutPackEnd(x.GoPointer(), CellVar.GoPointer(), ExpandVar)

}

// Packs the @cell into the beginning of @cell_layout. If @expand is %FALSE,
// then the @cell is allocated no more space than it needs. Any unused space
// is divided evenly between cells for which @expand is %TRUE.
//
// Note that reusing the same cell renderer is not supported.
func (x *IconView) PackStart(CellVar *CellRenderer, ExpandVar bool) {

	XGtkCellLayoutPackStart(x.GoPointer(), CellVar.GoPointer(), ExpandVar)

}

// Re-inserts @cell at @position.
//
// Note that @cell has already to be packed into @cell_layout
// for this to function properly.
func (x *IconView) Reorder(CellVar *CellRenderer, PositionVar int) {

	XGtkCellLayoutReorder(x.GoPointer(), CellVar.GoPointer(), PositionVar)

}

// Sets the attributes in the parameter list as the attributes
// of @cell_layout.
//
// See [method@Gtk.CellLayout.add_attribute] for more details.
//
// The attributes should be in attribute/column order, as in
// gtk_cell_layout_add_attribute(). All existing attributes are
// removed, and replaced with the new attributes.
func (x *IconView) SetAttributes(CellVar *CellRenderer, varArgs ...interface{}) {

	XGtkCellLayoutSetAttributes(x.GoPointer(), CellVar.GoPointer(), varArgs...)

}

// Sets the `GtkCellLayout`DataFunc to use for @cell_layout.
//
// This function is used instead of the standard attributes mapping
// for setting the column value, and should set the value of @cell_layout’s
// cell renderer(s) as appropriate.
//
// @func may be %NULL to remove a previously set function.
func (x *IconView) SetCellDataFunc(CellVar *CellRenderer, FuncVar *CellLayoutDataFunc, FuncDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	XGtkCellLayoutSetCellDataFunc(x.GoPointer(), CellVar.GoPointer(), glib.NewCallback(FuncVar), FuncDataVar, glib.NewCallback(DestroyVar))

}

// Returns the size of a non-scrolling border around the
// outside of the scrollable.
//
// An example for this would be treeview headers. GTK can use
// this information to display overlaid graphics, like the
// overshoot indication, at the right position.
func (x *IconView) GetBorder(BorderVar *Border) bool {

	cret := XGtkScrollableGetBorder(x.GoPointer(), BorderVar)
	return cret
}

// Retrieves the `GtkAdjustment` used for horizontal scrolling.
func (x *IconView) GetHadjustment() *Adjustment {
	var cls *Adjustment

	cret := XGtkScrollableGetHadjustment(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Adjustment{}
	cls.Ptr = cret
	return cls
}

// Gets the horizontal `GtkScrollablePolicy`.
func (x *IconView) GetHscrollPolicy() ScrollablePolicy {

	cret := XGtkScrollableGetHscrollPolicy(x.GoPointer())
	return cret
}

// Retrieves the `GtkAdjustment` used for vertical scrolling.
func (x *IconView) GetVadjustment() *Adjustment {
	var cls *Adjustment

	cret := XGtkScrollableGetVadjustment(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Adjustment{}
	cls.Ptr = cret
	return cls
}

// Gets the vertical `GtkScrollablePolicy`.
func (x *IconView) GetVscrollPolicy() ScrollablePolicy {

	cret := XGtkScrollableGetVscrollPolicy(x.GoPointer())
	return cret
}

// Sets the horizontal adjustment of the `GtkScrollable`.
func (x *IconView) SetHadjustment(HadjustmentVar *Adjustment) {

	XGtkScrollableSetHadjustment(x.GoPointer(), HadjustmentVar.GoPointer())

}

// Sets the `GtkScrollablePolicy`.
//
// The policy determines whether horizontal scrolling should start
// below the minimum width or below the natural width.
func (x *IconView) SetHscrollPolicy(PolicyVar ScrollablePolicy) {

	XGtkScrollableSetHscrollPolicy(x.GoPointer(), PolicyVar)

}

// Sets the vertical adjustment of the `GtkScrollable`.
func (x *IconView) SetVadjustment(VadjustmentVar *Adjustment) {

	XGtkScrollableSetVadjustment(x.GoPointer(), VadjustmentVar.GoPointer())

}

// Sets the `GtkScrollablePolicy`.
//
// The policy determines whether vertical scrolling should start
// below the minimum height or below the natural height.
func (x *IconView) SetVscrollPolicy(PolicyVar ScrollablePolicy) {

	XGtkScrollableSetVscrollPolicy(x.GoPointer(), PolicyVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewIconView, lib, "gtk_icon_view_new")
	core.PuregoSafeRegister(&xNewIconViewWithArea, lib, "gtk_icon_view_new_with_area")
	core.PuregoSafeRegister(&xNewIconViewWithModel, lib, "gtk_icon_view_new_with_model")

	core.PuregoSafeRegister(&xIconViewCreateDragIcon, lib, "gtk_icon_view_create_drag_icon")
	core.PuregoSafeRegister(&xIconViewEnableModelDragDest, lib, "gtk_icon_view_enable_model_drag_dest")
	core.PuregoSafeRegister(&xIconViewEnableModelDragSource, lib, "gtk_icon_view_enable_model_drag_source")
	core.PuregoSafeRegister(&xIconViewGetActivateOnSingleClick, lib, "gtk_icon_view_get_activate_on_single_click")
	core.PuregoSafeRegister(&xIconViewGetCellRect, lib, "gtk_icon_view_get_cell_rect")
	core.PuregoSafeRegister(&xIconViewGetColumnSpacing, lib, "gtk_icon_view_get_column_spacing")
	core.PuregoSafeRegister(&xIconViewGetColumns, lib, "gtk_icon_view_get_columns")
	core.PuregoSafeRegister(&xIconViewGetCursor, lib, "gtk_icon_view_get_cursor")
	core.PuregoSafeRegister(&xIconViewGetDestItemAtPos, lib, "gtk_icon_view_get_dest_item_at_pos")
	core.PuregoSafeRegister(&xIconViewGetDragDestItem, lib, "gtk_icon_view_get_drag_dest_item")
	core.PuregoSafeRegister(&xIconViewGetItemAtPos, lib, "gtk_icon_view_get_item_at_pos")
	core.PuregoSafeRegister(&xIconViewGetItemColumn, lib, "gtk_icon_view_get_item_column")
	core.PuregoSafeRegister(&xIconViewGetItemOrientation, lib, "gtk_icon_view_get_item_orientation")
	core.PuregoSafeRegister(&xIconViewGetItemPadding, lib, "gtk_icon_view_get_item_padding")
	core.PuregoSafeRegister(&xIconViewGetItemRow, lib, "gtk_icon_view_get_item_row")
	core.PuregoSafeRegister(&xIconViewGetItemWidth, lib, "gtk_icon_view_get_item_width")
	core.PuregoSafeRegister(&xIconViewGetMargin, lib, "gtk_icon_view_get_margin")
	core.PuregoSafeRegister(&xIconViewGetMarkupColumn, lib, "gtk_icon_view_get_markup_column")
	core.PuregoSafeRegister(&xIconViewGetModel, lib, "gtk_icon_view_get_model")
	core.PuregoSafeRegister(&xIconViewGetPathAtPos, lib, "gtk_icon_view_get_path_at_pos")
	core.PuregoSafeRegister(&xIconViewGetPixbufColumn, lib, "gtk_icon_view_get_pixbuf_column")
	core.PuregoSafeRegister(&xIconViewGetReorderable, lib, "gtk_icon_view_get_reorderable")
	core.PuregoSafeRegister(&xIconViewGetRowSpacing, lib, "gtk_icon_view_get_row_spacing")
	core.PuregoSafeRegister(&xIconViewGetSelectedItems, lib, "gtk_icon_view_get_selected_items")
	core.PuregoSafeRegister(&xIconViewGetSelectionMode, lib, "gtk_icon_view_get_selection_mode")
	core.PuregoSafeRegister(&xIconViewGetSpacing, lib, "gtk_icon_view_get_spacing")
	core.PuregoSafeRegister(&xIconViewGetTextColumn, lib, "gtk_icon_view_get_text_column")
	core.PuregoSafeRegister(&xIconViewGetTooltipColumn, lib, "gtk_icon_view_get_tooltip_column")
	core.PuregoSafeRegister(&xIconViewGetTooltipContext, lib, "gtk_icon_view_get_tooltip_context")
	core.PuregoSafeRegister(&xIconViewGetVisibleRange, lib, "gtk_icon_view_get_visible_range")
	core.PuregoSafeRegister(&xIconViewItemActivated, lib, "gtk_icon_view_item_activated")
	core.PuregoSafeRegister(&xIconViewPathIsSelected, lib, "gtk_icon_view_path_is_selected")
	core.PuregoSafeRegister(&xIconViewScrollToPath, lib, "gtk_icon_view_scroll_to_path")
	core.PuregoSafeRegister(&xIconViewSelectAll, lib, "gtk_icon_view_select_all")
	core.PuregoSafeRegister(&xIconViewSelectPath, lib, "gtk_icon_view_select_path")
	core.PuregoSafeRegister(&xIconViewSelectedForeach, lib, "gtk_icon_view_selected_foreach")
	core.PuregoSafeRegister(&xIconViewSetActivateOnSingleClick, lib, "gtk_icon_view_set_activate_on_single_click")
	core.PuregoSafeRegister(&xIconViewSetColumnSpacing, lib, "gtk_icon_view_set_column_spacing")
	core.PuregoSafeRegister(&xIconViewSetColumns, lib, "gtk_icon_view_set_columns")
	core.PuregoSafeRegister(&xIconViewSetCursor, lib, "gtk_icon_view_set_cursor")
	core.PuregoSafeRegister(&xIconViewSetDragDestItem, lib, "gtk_icon_view_set_drag_dest_item")
	core.PuregoSafeRegister(&xIconViewSetItemOrientation, lib, "gtk_icon_view_set_item_orientation")
	core.PuregoSafeRegister(&xIconViewSetItemPadding, lib, "gtk_icon_view_set_item_padding")
	core.PuregoSafeRegister(&xIconViewSetItemWidth, lib, "gtk_icon_view_set_item_width")
	core.PuregoSafeRegister(&xIconViewSetMargin, lib, "gtk_icon_view_set_margin")
	core.PuregoSafeRegister(&xIconViewSetMarkupColumn, lib, "gtk_icon_view_set_markup_column")
	core.PuregoSafeRegister(&xIconViewSetModel, lib, "gtk_icon_view_set_model")
	core.PuregoSafeRegister(&xIconViewSetPixbufColumn, lib, "gtk_icon_view_set_pixbuf_column")
	core.PuregoSafeRegister(&xIconViewSetReorderable, lib, "gtk_icon_view_set_reorderable")
	core.PuregoSafeRegister(&xIconViewSetRowSpacing, lib, "gtk_icon_view_set_row_spacing")
	core.PuregoSafeRegister(&xIconViewSetSelectionMode, lib, "gtk_icon_view_set_selection_mode")
	core.PuregoSafeRegister(&xIconViewSetSpacing, lib, "gtk_icon_view_set_spacing")
	core.PuregoSafeRegister(&xIconViewSetTextColumn, lib, "gtk_icon_view_set_text_column")
	core.PuregoSafeRegister(&xIconViewSetTooltipCell, lib, "gtk_icon_view_set_tooltip_cell")
	core.PuregoSafeRegister(&xIconViewSetTooltipColumn, lib, "gtk_icon_view_set_tooltip_column")
	core.PuregoSafeRegister(&xIconViewSetTooltipItem, lib, "gtk_icon_view_set_tooltip_item")
	core.PuregoSafeRegister(&xIconViewUnselectAll, lib, "gtk_icon_view_unselect_all")
	core.PuregoSafeRegister(&xIconViewUnselectPath, lib, "gtk_icon_view_unselect_path")
	core.PuregoSafeRegister(&xIconViewUnsetModelDragDest, lib, "gtk_icon_view_unset_model_drag_dest")
	core.PuregoSafeRegister(&xIconViewUnsetModelDragSource, lib, "gtk_icon_view_unset_model_drag_source")

}
