// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// The parameter used in the action signals of `GtkNotebook`.
type NotebookTab int

const (

	// the first tab in the notebook
	NotebookTabFirstValue NotebookTab = 0
	// the last tab in the notebook
	NotebookTabLastValue NotebookTab = 1
)

// `GtkNotebook` is a container whose children are pages switched
// between using tabs.
//
// ![An example GtkNotebook](notebook.png)
//
// There are many configuration options for `GtkNotebook`. Among
// other things, you can choose on which edge the tabs appear
// (see [method@Gtk.Notebook.set_tab_pos]), whether, if there are
// too many tabs to fit the notebook should be made bigger or scrolling
// arrows added (see [method@Gtk.Notebook.set_scrollable]), and whether
// there will be a popup menu allowing the users to switch pages.
// (see [method@Gtk.Notebook.popup_enable]).
//
// # GtkNotebook as GtkBuildable
//
// The `GtkNotebook` implementation of the `GtkBuildable` interface
// supports placing children into tabs by specifying “tab” as the
// “type” attribute of a &lt;child&gt; element. Note that the content
// of the tab must be created before the tab can be filled.
// A tab child can be specified without specifying a &lt;child&gt;
// type attribute.
//
// To add a child widget in the notebooks action area, specify
// "action-start" or “action-end” as the “type” attribute of the
// &lt;child&gt; element.
//
// An example of a UI definition fragment with `GtkNotebook`:
//
// ```xml
// &lt;object class="GtkNotebook"&gt;
//
//	&lt;child&gt;
//	  &lt;object class="GtkLabel" id="notebook-content"&gt;
//	    &lt;property name="label"&gt;Content&lt;/property&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//	&lt;child type="tab"&gt;
//	  &lt;object class="GtkLabel" id="notebook-tab"&gt;
//	    &lt;property name="label"&gt;Tab&lt;/property&gt;
//	  &lt;/object&gt;
//	&lt;/child&gt;
//
// &lt;/object&gt;
// ```
//
// # CSS nodes
//
// ```
// notebook
// ├── header.top
// │   ├── [&lt;action widget&gt;]
// │   ├── tabs
// │   │   ├── [arrow]
// │   │   ├── tab
// │   │   │   ╰── &lt;tab label&gt;
// ┊   ┊   ┊
// │   │   ├── tab[.reorderable-page]
// │   │   │   ╰── &lt;tab label&gt;
// │   │   ╰── [arrow]
// │   ╰── [&lt;action widget&gt;]
// │
// ╰── stack
//
//	├── &lt;child&gt;
//	┊
//	╰── &lt;child&gt;
//
// ```
//
// `GtkNotebook` has a main CSS node with name `notebook`, a subnode
// with name `header` and below that a subnode with name `tabs` which
// contains one subnode per tab with name `tab`.
//
// If action widgets are present, their CSS nodes are placed next
// to the `tabs` node. If the notebook is scrollable, CSS nodes with
// name `arrow` are placed as first and last child of the `tabs` node.
//
// The main node gets the `.frame` style class when the notebook
// has a border (see [method@Gtk.Notebook.set_show_border]).
//
// The header node gets one of the style class `.top`, `.bottom`,
// `.left` or `.right`, depending on where the tabs are placed. For
// reorderable pages, the tab node gets the `.reorderable-page` class.
//
// A `tab` node gets the `.dnd` style class while it is moved with drag-and-drop.
//
// The nodes are always arranged from left-to-right, regardless of text direction.
//
// # Accessibility
//
// `GtkNotebook` uses the following roles:
//
//   - %GTK_ACCESSIBLE_ROLE_GROUP for the notebook widget
//   - %GTK_ACCESSIBLE_ROLE_TAB_LIST for the list of tabs
//   - %GTK_ACCESSIBLE_ROLE_TAB role for each tab
//   - %GTK_ACCESSIBLE_ROLE_TAB_PANEL for each page
type Notebook struct {
	Widget
}

func NotebookNewFromInternalPtr(ptr uintptr) *Notebook {
	cls := &Notebook{}
	cls.Ptr = ptr
	return cls
}

var xNewNotebook func() uintptr

// Creates a new `GtkNotebook` widget with no pages.
func NewNotebook() *Notebook {
	var cls *Notebook

	cret := xNewNotebook()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Notebook{}
	cls.Ptr = cret
	return cls
}

var xNotebookAppendPage func(uintptr, uintptr, uintptr) int

// Appends a page to @notebook.
func (x *Notebook) AppendPage(ChildVar *Widget, TabLabelVar *Widget) int {

	cret := xNotebookAppendPage(x.GoPointer(), ChildVar.GoPointer(), TabLabelVar.GoPointer())
	return cret
}

var xNotebookAppendPageMenu func(uintptr, uintptr, uintptr, uintptr) int

// Appends a page to @notebook, specifying the widget to use as the
// label in the popup menu.
func (x *Notebook) AppendPageMenu(ChildVar *Widget, TabLabelVar *Widget, MenuLabelVar *Widget) int {

	cret := xNotebookAppendPageMenu(x.GoPointer(), ChildVar.GoPointer(), TabLabelVar.GoPointer(), MenuLabelVar.GoPointer())
	return cret
}

var xNotebookDetachTab func(uintptr, uintptr)

// Removes the child from the notebook.
//
// This function is very similar to [method@Gtk.Notebook.remove_page],
// but additionally informs the notebook that the removal
// is happening as part of a tab DND operation, which should
// not be cancelled.
func (x *Notebook) DetachTab(ChildVar *Widget) {

	xNotebookDetachTab(x.GoPointer(), ChildVar.GoPointer())

}

var xNotebookGetActionWidget func(uintptr, PackType) uintptr

// Gets one of the action widgets.
//
// See [method@Gtk.Notebook.set_action_widget].
func (x *Notebook) GetActionWidget(PackTypeVar PackType) *Widget {
	var cls *Widget

	cret := xNotebookGetActionWidget(x.GoPointer(), PackTypeVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xNotebookGetCurrentPage func(uintptr) int

// Returns the page number of the current page.
func (x *Notebook) GetCurrentPage() int {

	cret := xNotebookGetCurrentPage(x.GoPointer())
	return cret
}

var xNotebookGetGroupName func(uintptr) string

// Gets the current group name for @notebook.
func (x *Notebook) GetGroupName() string {

	cret := xNotebookGetGroupName(x.GoPointer())
	return cret
}

var xNotebookGetMenuLabel func(uintptr, uintptr) uintptr

// Retrieves the menu label widget of the page containing @child.
func (x *Notebook) GetMenuLabel(ChildVar *Widget) *Widget {
	var cls *Widget

	cret := xNotebookGetMenuLabel(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xNotebookGetMenuLabelText func(uintptr, uintptr) string

// Retrieves the text of the menu label for the page containing
// @child.
func (x *Notebook) GetMenuLabelText(ChildVar *Widget) string {

	cret := xNotebookGetMenuLabelText(x.GoPointer(), ChildVar.GoPointer())
	return cret
}

var xNotebookGetNPages func(uintptr) int

// Gets the number of pages in a notebook.
func (x *Notebook) GetNPages() int {

	cret := xNotebookGetNPages(x.GoPointer())
	return cret
}

var xNotebookGetNthPage func(uintptr, int) uintptr

// Returns the child widget contained in page number @page_num.
func (x *Notebook) GetNthPage(PageNumVar int) *Widget {
	var cls *Widget

	cret := xNotebookGetNthPage(x.GoPointer(), PageNumVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xNotebookGetPage func(uintptr, uintptr) uintptr

// Returns the `GtkNotebookPage` for @child.
func (x *Notebook) GetPage(ChildVar *Widget) *NotebookPage {
	var cls *NotebookPage

	cret := xNotebookGetPage(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NotebookPage{}
	cls.Ptr = cret
	return cls
}

var xNotebookGetPages func(uintptr) uintptr

// Returns a `GListModel` that contains the pages of the notebook.
//
// This can be used to keep an up-to-date view. The model also
// implements [iface@Gtk.SelectionModel] and can be used to track
// and modify the visible page.
func (x *Notebook) GetPages() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xNotebookGetPages(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xNotebookGetScrollable func(uintptr) bool

// Returns whether the tab label area has arrows for scrolling.
func (x *Notebook) GetScrollable() bool {

	cret := xNotebookGetScrollable(x.GoPointer())
	return cret
}

var xNotebookGetShowBorder func(uintptr) bool

// Returns whether a bevel will be drawn around the notebook pages.
func (x *Notebook) GetShowBorder() bool {

	cret := xNotebookGetShowBorder(x.GoPointer())
	return cret
}

var xNotebookGetShowTabs func(uintptr) bool

// Returns whether the tabs of the notebook are shown.
func (x *Notebook) GetShowTabs() bool {

	cret := xNotebookGetShowTabs(x.GoPointer())
	return cret
}

var xNotebookGetTabDetachable func(uintptr, uintptr) bool

// Returns whether the tab contents can be detached from @notebook.
func (x *Notebook) GetTabDetachable(ChildVar *Widget) bool {

	cret := xNotebookGetTabDetachable(x.GoPointer(), ChildVar.GoPointer())
	return cret
}

var xNotebookGetTabLabel func(uintptr, uintptr) uintptr

// Returns the tab label widget for the page @child.
//
// %NULL is returned if @child is not in @notebook or
// if no tab label has specifically been set for @child.
func (x *Notebook) GetTabLabel(ChildVar *Widget) *Widget {
	var cls *Widget

	cret := xNotebookGetTabLabel(x.GoPointer(), ChildVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xNotebookGetTabLabelText func(uintptr, uintptr) string

// Retrieves the text of the tab label for the page containing
// @child.
func (x *Notebook) GetTabLabelText(ChildVar *Widget) string {

	cret := xNotebookGetTabLabelText(x.GoPointer(), ChildVar.GoPointer())
	return cret
}

var xNotebookGetTabPos func(uintptr) PositionType

// Gets the edge at which the tabs are drawn.
func (x *Notebook) GetTabPos() PositionType {

	cret := xNotebookGetTabPos(x.GoPointer())
	return cret
}

var xNotebookGetTabReorderable func(uintptr, uintptr) bool

// Gets whether the tab can be reordered via drag and drop or not.
func (x *Notebook) GetTabReorderable(ChildVar *Widget) bool {

	cret := xNotebookGetTabReorderable(x.GoPointer(), ChildVar.GoPointer())
	return cret
}

var xNotebookInsertPage func(uintptr, uintptr, uintptr, int) int

// Insert a page into @notebook at the given position.
func (x *Notebook) InsertPage(ChildVar *Widget, TabLabelVar *Widget, PositionVar int) int {

	cret := xNotebookInsertPage(x.GoPointer(), ChildVar.GoPointer(), TabLabelVar.GoPointer(), PositionVar)
	return cret
}

var xNotebookInsertPageMenu func(uintptr, uintptr, uintptr, uintptr, int) int

// Insert a page into @notebook at the given position, specifying
// the widget to use as the label in the popup menu.
func (x *Notebook) InsertPageMenu(ChildVar *Widget, TabLabelVar *Widget, MenuLabelVar *Widget, PositionVar int) int {

	cret := xNotebookInsertPageMenu(x.GoPointer(), ChildVar.GoPointer(), TabLabelVar.GoPointer(), MenuLabelVar.GoPointer(), PositionVar)
	return cret
}

var xNotebookNextPage func(uintptr)

// Switches to the next page.
//
// Nothing happens if the current page is the last page.
func (x *Notebook) NextPage() {

	xNotebookNextPage(x.GoPointer())

}

var xNotebookPageNum func(uintptr, uintptr) int

// Finds the index of the page which contains the given child
// widget.
func (x *Notebook) PageNum(ChildVar *Widget) int {

	cret := xNotebookPageNum(x.GoPointer(), ChildVar.GoPointer())
	return cret
}

var xNotebookPopupDisable func(uintptr)

// Disables the popup menu.
func (x *Notebook) PopupDisable() {

	xNotebookPopupDisable(x.GoPointer())

}

var xNotebookPopupEnable func(uintptr)

// Enables the popup menu.
//
// If the user clicks with the right mouse button on the tab labels,
// a menu with all the pages will be popped up.
func (x *Notebook) PopupEnable() {

	xNotebookPopupEnable(x.GoPointer())

}

var xNotebookPrependPage func(uintptr, uintptr, uintptr) int

// Prepends a page to @notebook.
func (x *Notebook) PrependPage(ChildVar *Widget, TabLabelVar *Widget) int {

	cret := xNotebookPrependPage(x.GoPointer(), ChildVar.GoPointer(), TabLabelVar.GoPointer())
	return cret
}

var xNotebookPrependPageMenu func(uintptr, uintptr, uintptr, uintptr) int

// Prepends a page to @notebook, specifying the widget to use as the
// label in the popup menu.
func (x *Notebook) PrependPageMenu(ChildVar *Widget, TabLabelVar *Widget, MenuLabelVar *Widget) int {

	cret := xNotebookPrependPageMenu(x.GoPointer(), ChildVar.GoPointer(), TabLabelVar.GoPointer(), MenuLabelVar.GoPointer())
	return cret
}

var xNotebookPrevPage func(uintptr)

// Switches to the previous page.
//
// Nothing happens if the current page is the first page.
func (x *Notebook) PrevPage() {

	xNotebookPrevPage(x.GoPointer())

}

var xNotebookRemovePage func(uintptr, int)

// Removes a page from the notebook given its index
// in the notebook.
func (x *Notebook) RemovePage(PageNumVar int) {

	xNotebookRemovePage(x.GoPointer(), PageNumVar)

}

var xNotebookReorderChild func(uintptr, uintptr, int)

// Reorders the page containing @child, so that it appears in position
// @position.
//
// If @position is greater than or equal to the number of children in
// the list or negative, @child will be moved to the end of the list.
func (x *Notebook) ReorderChild(ChildVar *Widget, PositionVar int) {

	xNotebookReorderChild(x.GoPointer(), ChildVar.GoPointer(), PositionVar)

}

var xNotebookSetActionWidget func(uintptr, uintptr, PackType)

// Sets @widget as one of the action widgets.
//
// Depending on the pack type the widget will be placed before
// or after the tabs. You can use a `GtkBox` if you need to pack
// more than one widget on the same side.
func (x *Notebook) SetActionWidget(WidgetVar *Widget, PackTypeVar PackType) {

	xNotebookSetActionWidget(x.GoPointer(), WidgetVar.GoPointer(), PackTypeVar)

}

var xNotebookSetCurrentPage func(uintptr, int)

// Switches to the page number @page_num.
//
// Note that due to historical reasons, GtkNotebook refuses
// to switch to a page unless the child widget is visible.
// Therefore, it is recommended to show child widgets before
// adding them to a notebook.
func (x *Notebook) SetCurrentPage(PageNumVar int) {

	xNotebookSetCurrentPage(x.GoPointer(), PageNumVar)

}

var xNotebookSetGroupName func(uintptr, string)

// Sets a group name for @notebook.
//
// Notebooks with the same name will be able to exchange tabs
// via drag and drop. A notebook with a %NULL group name will
// not be able to exchange tabs with any other notebook.
func (x *Notebook) SetGroupName(GroupNameVar string) {

	xNotebookSetGroupName(x.GoPointer(), GroupNameVar)

}

var xNotebookSetMenuLabel func(uintptr, uintptr, uintptr)

// Changes the menu label for the page containing @child.
func (x *Notebook) SetMenuLabel(ChildVar *Widget, MenuLabelVar *Widget) {

	xNotebookSetMenuLabel(x.GoPointer(), ChildVar.GoPointer(), MenuLabelVar.GoPointer())

}

var xNotebookSetMenuLabelText func(uintptr, uintptr, string)

// Creates a new label and sets it as the menu label of @child.
func (x *Notebook) SetMenuLabelText(ChildVar *Widget, MenuTextVar string) {

	xNotebookSetMenuLabelText(x.GoPointer(), ChildVar.GoPointer(), MenuTextVar)

}

var xNotebookSetScrollable func(uintptr, bool)

// Sets whether the tab label area will have arrows for
// scrolling if there are too many tabs to fit in the area.
func (x *Notebook) SetScrollable(ScrollableVar bool) {

	xNotebookSetScrollable(x.GoPointer(), ScrollableVar)

}

var xNotebookSetShowBorder func(uintptr, bool)

// Sets whether a bevel will be drawn around the notebook pages.
//
// This only has a visual effect when the tabs are not shown.
func (x *Notebook) SetShowBorder(ShowBorderVar bool) {

	xNotebookSetShowBorder(x.GoPointer(), ShowBorderVar)

}

var xNotebookSetShowTabs func(uintptr, bool)

// Sets whether to show the tabs for the notebook or not.
func (x *Notebook) SetShowTabs(ShowTabsVar bool) {

	xNotebookSetShowTabs(x.GoPointer(), ShowTabsVar)

}

var xNotebookSetTabDetachable func(uintptr, uintptr, bool)

// Sets whether the tab can be detached from @notebook to another
// notebook or widget.
//
// Note that two notebooks must share a common group identificator
// (see [method@Gtk.Notebook.set_group_name]) to allow automatic tabs
// interchange between them.
//
// If you want a widget to interact with a notebook through DnD
// (i.e.: accept dragged tabs from it) it must be set as a drop
// destination and accept the target “GTK_NOTEBOOK_TAB”. The notebook
// will fill the selection with a GtkWidget** pointing to the child
// widget that corresponds to the dropped tab.
//
// Note that you should use [method@Gtk.Notebook.detach_tab] instead
// of [method@Gtk.Notebook.remove_page] if you want to remove the tab
// from the source notebook as part of accepting a drop. Otherwise,
// the source notebook will think that the dragged tab was removed
// from underneath the ongoing drag operation, and will initiate a
// drag cancel animation.
//
// ```c
// static void
// on_drag_data_received (GtkWidget        *widget,
//
//	GdkDrop          *drop,
//	GtkSelectionData *data,
//	guint             time,
//	gpointer          user_data)
//
//	{
//	  GtkDrag *drag;
//	  GtkWidget *notebook;
//	  GtkWidget **child;
//
//	  drag = gtk_drop_get_drag (drop);
//	  notebook = g_object_get_data (drag, "gtk-notebook-drag-origin");
//	  child = (void*) gtk_selection_data_get_data (data);
//
//	  // process_widget (*child);
//
//	  gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
//	}
//
// ```
//
// If you want a notebook to accept drags from other widgets,
// you will have to set your own DnD code to do it.
func (x *Notebook) SetTabDetachable(ChildVar *Widget, DetachableVar bool) {

	xNotebookSetTabDetachable(x.GoPointer(), ChildVar.GoPointer(), DetachableVar)

}

var xNotebookSetTabLabel func(uintptr, uintptr, uintptr)

// Changes the tab label for @child.
//
// If %NULL is specified for @tab_label, then the page will
// have the label “page N”.
func (x *Notebook) SetTabLabel(ChildVar *Widget, TabLabelVar *Widget) {

	xNotebookSetTabLabel(x.GoPointer(), ChildVar.GoPointer(), TabLabelVar.GoPointer())

}

var xNotebookSetTabLabelText func(uintptr, uintptr, string)

// Creates a new label and sets it as the tab label for the page
// containing @child.
func (x *Notebook) SetTabLabelText(ChildVar *Widget, TabTextVar string) {

	xNotebookSetTabLabelText(x.GoPointer(), ChildVar.GoPointer(), TabTextVar)

}

var xNotebookSetTabPos func(uintptr, PositionType)

// Sets the edge at which the tabs are drawn.
func (x *Notebook) SetTabPos(PosVar PositionType) {

	xNotebookSetTabPos(x.GoPointer(), PosVar)

}

var xNotebookSetTabReorderable func(uintptr, uintptr, bool)

// Sets whether the notebook tab can be reordered
// via drag and drop or not.
func (x *Notebook) SetTabReorderable(ChildVar *Widget, ReorderableVar bool) {

	xNotebookSetTabReorderable(x.GoPointer(), ChildVar.GoPointer(), ReorderableVar)

}

func (c *Notebook) GoPointer() uintptr {
	return c.Ptr
}

func (c *Notebook) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func (x *Notebook) ConnectChangeCurrentPage(cb *func(Notebook, int) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "change-current-page", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ObjectVarp int) bool {
		fa := Notebook{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ObjectVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "change-current-page", cbRefPtr)
}

// The ::create-window signal is emitted when a detachable
// tab is dropped on the root window.
//
// A handler for this signal can create a window containing
// a notebook where the tab will be attached. It is also
// responsible for moving/resizing the window and adding the
// necessary properties to the notebook (e.g. the
// `GtkNotebook`:group-name ).
func (x *Notebook) ConnectCreateWindow(cb *func(Notebook, uintptr) Notebook) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "create-window", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PageVarp uintptr) uintptr {
		fa := Notebook{}
		fa.Ptr = clsPtr
		cbFn := *cb

		CreateWindowCls := cbFn(fa, PageVarp)
		return CreateWindowCls.Ptr

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "create-window", cbRefPtr)
}

func (x *Notebook) ConnectFocusTab(cb *func(Notebook, NotebookTab) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "focus-tab", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ObjectVarp NotebookTab) bool {
		fa := Notebook{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ObjectVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "focus-tab", cbRefPtr)
}

func (x *Notebook) ConnectMoveFocusOut(cb *func(Notebook, DirectionType)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "move-focus-out", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ObjectVarp DirectionType) {
		fa := Notebook{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ObjectVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "move-focus-out", cbRefPtr)
}

// the ::page-added signal is emitted in the notebook
// right after a page is added to the notebook.
func (x *Notebook) ConnectPageAdded(cb *func(Notebook, uintptr, uint)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "page-added", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ChildVarp uintptr, PageNumVarp uint) {
		fa := Notebook{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ChildVarp, PageNumVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "page-added", cbRefPtr)
}

// the ::page-removed signal is emitted in the notebook
// right after a page is removed from the notebook.
func (x *Notebook) ConnectPageRemoved(cb *func(Notebook, uintptr, uint)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "page-removed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ChildVarp uintptr, PageNumVarp uint) {
		fa := Notebook{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ChildVarp, PageNumVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "page-removed", cbRefPtr)
}

// the ::page-reordered signal is emitted in the notebook
// right after a page has been reordered.
func (x *Notebook) ConnectPageReordered(cb *func(Notebook, uintptr, uint)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "page-reordered", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ChildVarp uintptr, PageNumVarp uint) {
		fa := Notebook{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ChildVarp, PageNumVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "page-reordered", cbRefPtr)
}

func (x *Notebook) ConnectReorderTab(cb *func(Notebook, DirectionType, bool) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "reorder-tab", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ObjectVarp DirectionType, P0Varp bool) bool {
		fa := Notebook{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ObjectVarp, P0Varp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "reorder-tab", cbRefPtr)
}

func (x *Notebook) ConnectSelectPage(cb *func(Notebook, bool) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "select-page", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ObjectVarp bool) bool {
		fa := Notebook{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ObjectVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "select-page", cbRefPtr)
}

// Emitted when the user or a function changes the current page.
func (x *Notebook) ConnectSwitchPage(cb *func(Notebook, uintptr, uint)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "switch-page", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PageVarp uintptr, PageNumVarp uint) {
		fa := Notebook{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PageVarp, PageNumVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "switch-page", cbRefPtr)
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *Notebook) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *Notebook) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *Notebook) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *Notebook) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Notebook) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Notebook) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Notebook) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Notebook) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Notebook) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Notebook) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *Notebook) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// `GtkNotebookPage` is an auxiliary object used by `GtkNotebook`.
type NotebookPage struct {
	gobject.Object
}

func NotebookPageNewFromInternalPtr(ptr uintptr) *NotebookPage {
	cls := &NotebookPage{}
	cls.Ptr = ptr
	return cls
}

var xNotebookPageGetChild func(uintptr) uintptr

// Returns the notebook child to which @page belongs.
func (x *NotebookPage) GetChild() *Widget {
	var cls *Widget

	cret := xNotebookPageGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

func (c *NotebookPage) GoPointer() uintptr {
	return c.Ptr
}

func (c *NotebookPage) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewNotebook, lib, "gtk_notebook_new")

	core.PuregoSafeRegister(&xNotebookAppendPage, lib, "gtk_notebook_append_page")
	core.PuregoSafeRegister(&xNotebookAppendPageMenu, lib, "gtk_notebook_append_page_menu")
	core.PuregoSafeRegister(&xNotebookDetachTab, lib, "gtk_notebook_detach_tab")
	core.PuregoSafeRegister(&xNotebookGetActionWidget, lib, "gtk_notebook_get_action_widget")
	core.PuregoSafeRegister(&xNotebookGetCurrentPage, lib, "gtk_notebook_get_current_page")
	core.PuregoSafeRegister(&xNotebookGetGroupName, lib, "gtk_notebook_get_group_name")
	core.PuregoSafeRegister(&xNotebookGetMenuLabel, lib, "gtk_notebook_get_menu_label")
	core.PuregoSafeRegister(&xNotebookGetMenuLabelText, lib, "gtk_notebook_get_menu_label_text")
	core.PuregoSafeRegister(&xNotebookGetNPages, lib, "gtk_notebook_get_n_pages")
	core.PuregoSafeRegister(&xNotebookGetNthPage, lib, "gtk_notebook_get_nth_page")
	core.PuregoSafeRegister(&xNotebookGetPage, lib, "gtk_notebook_get_page")
	core.PuregoSafeRegister(&xNotebookGetPages, lib, "gtk_notebook_get_pages")
	core.PuregoSafeRegister(&xNotebookGetScrollable, lib, "gtk_notebook_get_scrollable")
	core.PuregoSafeRegister(&xNotebookGetShowBorder, lib, "gtk_notebook_get_show_border")
	core.PuregoSafeRegister(&xNotebookGetShowTabs, lib, "gtk_notebook_get_show_tabs")
	core.PuregoSafeRegister(&xNotebookGetTabDetachable, lib, "gtk_notebook_get_tab_detachable")
	core.PuregoSafeRegister(&xNotebookGetTabLabel, lib, "gtk_notebook_get_tab_label")
	core.PuregoSafeRegister(&xNotebookGetTabLabelText, lib, "gtk_notebook_get_tab_label_text")
	core.PuregoSafeRegister(&xNotebookGetTabPos, lib, "gtk_notebook_get_tab_pos")
	core.PuregoSafeRegister(&xNotebookGetTabReorderable, lib, "gtk_notebook_get_tab_reorderable")
	core.PuregoSafeRegister(&xNotebookInsertPage, lib, "gtk_notebook_insert_page")
	core.PuregoSafeRegister(&xNotebookInsertPageMenu, lib, "gtk_notebook_insert_page_menu")
	core.PuregoSafeRegister(&xNotebookNextPage, lib, "gtk_notebook_next_page")
	core.PuregoSafeRegister(&xNotebookPageNum, lib, "gtk_notebook_page_num")
	core.PuregoSafeRegister(&xNotebookPopupDisable, lib, "gtk_notebook_popup_disable")
	core.PuregoSafeRegister(&xNotebookPopupEnable, lib, "gtk_notebook_popup_enable")
	core.PuregoSafeRegister(&xNotebookPrependPage, lib, "gtk_notebook_prepend_page")
	core.PuregoSafeRegister(&xNotebookPrependPageMenu, lib, "gtk_notebook_prepend_page_menu")
	core.PuregoSafeRegister(&xNotebookPrevPage, lib, "gtk_notebook_prev_page")
	core.PuregoSafeRegister(&xNotebookRemovePage, lib, "gtk_notebook_remove_page")
	core.PuregoSafeRegister(&xNotebookReorderChild, lib, "gtk_notebook_reorder_child")
	core.PuregoSafeRegister(&xNotebookSetActionWidget, lib, "gtk_notebook_set_action_widget")
	core.PuregoSafeRegister(&xNotebookSetCurrentPage, lib, "gtk_notebook_set_current_page")
	core.PuregoSafeRegister(&xNotebookSetGroupName, lib, "gtk_notebook_set_group_name")
	core.PuregoSafeRegister(&xNotebookSetMenuLabel, lib, "gtk_notebook_set_menu_label")
	core.PuregoSafeRegister(&xNotebookSetMenuLabelText, lib, "gtk_notebook_set_menu_label_text")
	core.PuregoSafeRegister(&xNotebookSetScrollable, lib, "gtk_notebook_set_scrollable")
	core.PuregoSafeRegister(&xNotebookSetShowBorder, lib, "gtk_notebook_set_show_border")
	core.PuregoSafeRegister(&xNotebookSetShowTabs, lib, "gtk_notebook_set_show_tabs")
	core.PuregoSafeRegister(&xNotebookSetTabDetachable, lib, "gtk_notebook_set_tab_detachable")
	core.PuregoSafeRegister(&xNotebookSetTabLabel, lib, "gtk_notebook_set_tab_label")
	core.PuregoSafeRegister(&xNotebookSetTabLabelText, lib, "gtk_notebook_set_tab_label_text")
	core.PuregoSafeRegister(&xNotebookSetTabPos, lib, "gtk_notebook_set_tab_pos")
	core.PuregoSafeRegister(&xNotebookSetTabReorderable, lib, "gtk_notebook_set_tab_reorderable")

	core.PuregoSafeRegister(&xNotebookPageGetChild, lib, "gtk_notebook_page_get_child")

}
