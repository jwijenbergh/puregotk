// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type SortListModelClass struct {
	ParentClass uintptr
}

func (x *SortListModelClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A `GListModel` that sorts the elements of an underlying model
// according to a `GtkSorter`.
//
// The model is a stable sort. If two items compare equal according
// to the sorter, the one that appears first in the original model will
// also appear first after sorting.
// Note that if you change the sorter, the previous order will have no
// influence on the new order. If you want that, consider using a
// `GtkMultiSorter` and appending the previous sorter to it.
//
// The model can be set up to do incremental sorting, so that
// sorting long lists doesn't block the UI. See
// [method@Gtk.SortListModel.set_incremental] for details.
//
// `GtkSortListModel` is a generic model and because of that it
// cannot take advantage of any external knowledge when sorting.
// If you run into performance issues with `GtkSortListModel`,
// it is strongly recommended that you write your own sorting list
// model.
type SortListModel struct {
	gobject.Object
}

func SortListModelNewFromInternalPtr(ptr uintptr) *SortListModel {
	cls := &SortListModel{}
	cls.Ptr = ptr
	return cls
}

var xNewSortListModel func(uintptr, uintptr) uintptr

// Creates a new sort list model that uses the @sorter to sort @model.
func NewSortListModel(ModelVar gio.ListModel, SorterVar *Sorter) *SortListModel {
	var cls *SortListModel

	cret := xNewSortListModel(ModelVar.GoPointer(), SorterVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &SortListModel{}
	cls.Ptr = cret
	return cls
}

var xSortListModelGetIncremental func(uintptr) bool

// Returns whether incremental sorting is enabled.
//
// See [method@Gtk.SortListModel.set_incremental].
func (x *SortListModel) GetIncremental() bool {

	cret := xSortListModelGetIncremental(x.GoPointer())
	return cret
}

var xSortListModelGetModel func(uintptr) uintptr

// Gets the model currently sorted or %NULL if none.
func (x *SortListModel) GetModel() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xSortListModelGetModel(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xSortListModelGetPending func(uintptr) uint

// Estimates progress of an ongoing sorting operation.
//
// The estimate is the number of items that would still need to be
// sorted to finish the sorting operation if this was a linear
// algorithm. So this number is not related to how many items are
// already correctly sorted.
//
// If you want to estimate the progress, you can use code like this:
// ```c
// pending = gtk_sort_list_model_get_pending (self);
// model = gtk_sort_list_model_get_model (self);
// progress = 1.0 - pending / (double) MAX (1, g_list_model_get_n_items (model));
// ```
//
// If no sort operation is ongoing - in particular when
// [property@Gtk.SortListModel:incremental] is %FALSE - this
// function returns 0.
func (x *SortListModel) GetPending() uint {

	cret := xSortListModelGetPending(x.GoPointer())
	return cret
}

var xSortListModelGetSorter func(uintptr) uintptr

// Gets the sorter that is used to sort @self.
func (x *SortListModel) GetSorter() *Sorter {
	var cls *Sorter

	cret := xSortListModelGetSorter(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Sorter{}
	cls.Ptr = cret
	return cls
}

var xSortListModelSetIncremental func(uintptr, bool)

// Sets the sort model to do an incremental sort.
//
// When incremental sorting is enabled, the `GtkSortListModel` will not do
// a complete sort immediately, but will instead queue an idle handler that
// incrementally sorts the items towards their correct position. This of
// course means that items do not instantly appear in the right place. It
// also means that the total sorting time is a lot slower.
//
// When your filter blocks the UI while sorting, you might consider
// turning this on. Depending on your model and sorters, this may become
// interesting around 10,000 to 100,000 items.
//
// By default, incremental sorting is disabled.
//
// See [method@Gtk.SortListModel.get_pending] for progress information
// about an ongoing incremental sorting operation.
func (x *SortListModel) SetIncremental(IncrementalVar bool) {

	xSortListModelSetIncremental(x.GoPointer(), IncrementalVar)

}

var xSortListModelSetModel func(uintptr, uintptr)

// Sets the model to be sorted.
//
// The @model's item type must conform to the item type of @self.
func (x *SortListModel) SetModel(ModelVar gio.ListModel) {

	xSortListModelSetModel(x.GoPointer(), ModelVar.GoPointer())

}

var xSortListModelSetSorter func(uintptr, uintptr)

// Sets a new sorter on @self.
func (x *SortListModel) SetSorter(SorterVar *Sorter) {

	xSortListModelSetSorter(x.GoPointer(), SorterVar.GoPointer())

}

func (c *SortListModel) GoPointer() uintptr {
	return c.Ptr
}

func (c *SortListModel) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// See also: g_list_model_get_n_items()
func (x *SortListModel) GetItem(PositionVar uint) uintptr {

	cret := gio.XGListModelGetItem(x.GoPointer(), PositionVar)
	return cret
}

// Gets the type of the items in @list.
//
// All items returned from g_list_model_get_item() are of the type
// returned by this function, or a subtype, or if the type is an
// interface, they are an implementation of that interface.
//
// The item type of a #GListModel can not change during the life of the
// model.
func (x *SortListModel) GetItemType() []interface{} {

	cret := gio.XGListModelGetItemType(x.GoPointer())
	return cret
}

// Gets the number of items in @list.
//
// Depending on the model implementation, calling this function may be
// less efficient than iterating the list with increasing values for
// @position until g_list_model_get_item() returns %NULL.
func (x *SortListModel) GetNItems() uint {

	cret := gio.XGListModelGetNItems(x.GoPointer())
	return cret
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// This function is meant to be used by language bindings in place
// of g_list_model_get_item().
//
// See also: g_list_model_get_n_items()
func (x *SortListModel) GetObject(PositionVar uint) *gobject.Object {
	var cls *gobject.Object

	cret := gio.XGListModelGetObject(x.GoPointer(), PositionVar)

	if cret == 0 {
		return nil
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

// Emits the #GListModel::items-changed signal on @list.
//
// This function should only be called by classes implementing
// #GListModel. It has to be called after the internal representation
// of @list has been updated, because handlers connected to this signal
// might query the new state of the list.
//
// Implementations must only make changes to the model (as visible to
// its consumer) in places that will not cause problems for that
// consumer.  For models that are driven directly by a write API (such
// as #GListStore), changes can be reported in response to uses of that
// API.  For models that represent remote data, changes should only be
// made from a fresh mainloop dispatch.  It is particularly not
// permitted to make changes in response to a call to the #GListModel
// consumer API.
//
// Stated another way: in general, it is assumed that code making a
// series of accesses to the model via the API, without returning to the
// mainloop, and without calling other code, will continue to view the
// same contents of the model.
func (x *SortListModel) ItemsChanged(PositionVar uint, RemovedVar uint, AddedVar uint) {

	gio.XGListModelItemsChanged(x.GoPointer(), PositionVar, RemovedVar, AddedVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewSortListModel, lib, "gtk_sort_list_model_new")

	core.PuregoSafeRegister(&xSortListModelGetIncremental, lib, "gtk_sort_list_model_get_incremental")
	core.PuregoSafeRegister(&xSortListModelGetModel, lib, "gtk_sort_list_model_get_model")
	core.PuregoSafeRegister(&xSortListModelGetPending, lib, "gtk_sort_list_model_get_pending")
	core.PuregoSafeRegister(&xSortListModelGetSorter, lib, "gtk_sort_list_model_get_sorter")
	core.PuregoSafeRegister(&xSortListModelSetIncremental, lib, "gtk_sort_list_model_set_incremental")
	core.PuregoSafeRegister(&xSortListModelSetModel, lib, "gtk_sort_list_model_set_model")
	core.PuregoSafeRegister(&xSortListModelSetSorter, lib, "gtk_sort_list_model_set_sorter")

}
