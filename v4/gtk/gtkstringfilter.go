// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type StringFilterClass struct {
	_ structs.HostLayout

	ParentClass uintptr
}

func (x *StringFilterClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Specifies how search strings are matched inside text.
type StringFilterMatchMode int

var xStringFilterMatchModeGLibType func() types.GType

func StringFilterMatchModeGLibType() types.GType {
	return xStringFilterMatchModeGLibType()
}

const (

	// The search string and
	//   text must match exactly.
	StringFilterMatchModeExactValue StringFilterMatchMode = 0
	// The search string
	//   must be contained as a substring inside the text.
	StringFilterMatchModeSubstringValue StringFilterMatchMode = 1
	// The text must begin
	//   with the search string.
	StringFilterMatchModePrefixValue StringFilterMatchMode = 2
)

// `GtkStringFilter` determines whether to include items by comparing
// strings to a fixed search term.
//
// The strings are obtained from the items by evaluating a `GtkExpression`
// set with [method@Gtk.StringFilter.set_expression], and they are
// compared against a search term set with [method@Gtk.StringFilter.set_search].
//
// `GtkStringFilter` has several different modes of comparison - it
// can match the whole string, just a prefix, or any substring. Use
// [method@Gtk.StringFilter.set_match_mode] choose a mode.
//
// It is also possible to make case-insensitive comparisons, with
// [method@Gtk.StringFilter.set_ignore_case].
type StringFilter struct {
	Filter
}

var xStringFilterGLibType func() types.GType

func StringFilterGLibType() types.GType {
	return xStringFilterGLibType()
}

func StringFilterNewFromInternalPtr(ptr uintptr) *StringFilter {
	cls := &StringFilter{}
	cls.Ptr = ptr
	return cls
}

var xNewStringFilter func(uintptr) uintptr

// Creates a new string filter.
//
// You will want to set up the filter by providing a string to search for
// and by providing a property to look up on the item.
func NewStringFilter(ExpressionVar *Expression) *StringFilter {
	var cls *StringFilter

	cret := xNewStringFilter(ExpressionVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &StringFilter{}
	cls.Ptr = cret
	return cls
}

var xStringFilterGetExpression func(uintptr) uintptr

// Gets the expression that the string filter uses to
// obtain strings from items.
func (x *StringFilter) GetExpression() *Expression {
	var cls *Expression

	cret := xStringFilterGetExpression(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Expression{}
	cls.Ptr = cret
	return cls
}

var xStringFilterGetIgnoreCase func(uintptr) bool

// Returns whether the filter ignores case differences.
func (x *StringFilter) GetIgnoreCase() bool {

	cret := xStringFilterGetIgnoreCase(x.GoPointer())
	return cret
}

var xStringFilterGetMatchMode func(uintptr) StringFilterMatchMode

// Returns the match mode that the filter is using.
func (x *StringFilter) GetMatchMode() StringFilterMatchMode {

	cret := xStringFilterGetMatchMode(x.GoPointer())
	return cret
}

var xStringFilterGetSearch func(uintptr) string

// Gets the search term.
func (x *StringFilter) GetSearch() string {

	cret := xStringFilterGetSearch(x.GoPointer())
	return cret
}

var xStringFilterSetExpression func(uintptr, uintptr)

// Sets the expression that the string filter uses to
// obtain strings from items.
//
// The expression must have a value type of %G_TYPE_STRING.
func (x *StringFilter) SetExpression(ExpressionVar *Expression) {

	xStringFilterSetExpression(x.GoPointer(), ExpressionVar.GoPointer())

}

var xStringFilterSetIgnoreCase func(uintptr, bool)

// Sets whether the filter ignores case differences.
func (x *StringFilter) SetIgnoreCase(IgnoreCaseVar bool) {

	xStringFilterSetIgnoreCase(x.GoPointer(), IgnoreCaseVar)

}

var xStringFilterSetMatchMode func(uintptr, StringFilterMatchMode)

// Sets the match mode for the filter.
func (x *StringFilter) SetMatchMode(ModeVar StringFilterMatchMode) {

	xStringFilterSetMatchMode(x.GoPointer(), ModeVar)

}

var xStringFilterSetSearch func(uintptr, string)

// Sets the string to search for.
func (x *StringFilter) SetSearch(SearchVar string) {

	xStringFilterSetSearch(x.GoPointer(), SearchVar)

}

func (c *StringFilter) GoPointer() uintptr {
	return c.Ptr
}

func (c *StringFilter) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xStringFilterMatchModeGLibType, lib, "gtk_string_filter_match_mode_get_type")

	core.PuregoSafeRegister(&xStringFilterGLibType, lib, "gtk_string_filter_get_type")

	core.PuregoSafeRegister(&xNewStringFilter, lib, "gtk_string_filter_new")

	core.PuregoSafeRegister(&xStringFilterGetExpression, lib, "gtk_string_filter_get_expression")
	core.PuregoSafeRegister(&xStringFilterGetIgnoreCase, lib, "gtk_string_filter_get_ignore_case")
	core.PuregoSafeRegister(&xStringFilterGetMatchMode, lib, "gtk_string_filter_get_match_mode")
	core.PuregoSafeRegister(&xStringFilterGetSearch, lib, "gtk_string_filter_get_search")
	core.PuregoSafeRegister(&xStringFilterSetExpression, lib, "gtk_string_filter_set_expression")
	core.PuregoSafeRegister(&xStringFilterSetIgnoreCase, lib, "gtk_string_filter_set_ignore_case")
	core.PuregoSafeRegister(&xStringFilterSetMatchMode, lib, "gtk_string_filter_set_match_mode")
	core.PuregoSafeRegister(&xStringFilterSetSearch, lib, "gtk_string_filter_set_search")

}
