// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// Renders a toggle button in a cell
//
// `GtkCellRendererToggle` renders a toggle button in a cell. The
// button is drawn as a radio or a checkbutton, depending on the
// `GtkCellRendererToggle:radio` property.
// When activated, it emits the `GtkCellRendererToggle::toggled` signal.
type CellRendererToggle struct {
	CellRenderer
}

func CellRendererToggleNewFromInternalPtr(ptr uintptr) *CellRendererToggle {
	cls := &CellRendererToggle{}
	cls.Ptr = ptr
	return cls
}

var xNewCellRendererToggle func() uintptr

// Creates a new `GtkCellRendererToggle`. Adjust rendering
// parameters using object properties. Object properties can be set
// globally (with g_object_set()). Also, with `GtkTreeViewColumn`, you
// can bind a property to a value in a `GtkTreeModel`. For example, you
// can bind the “active” property on the cell renderer to a boolean value
// in the model, thus causing the check button to reflect the state of
// the model.
func NewCellRendererToggle() *CellRendererToggle {
	var cls *CellRendererToggle

	cret := xNewCellRendererToggle()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &CellRendererToggle{}
	cls.Ptr = cret
	return cls
}

var xCellRendererToggleGetActivatable func(uintptr) bool

// Returns whether the cell renderer is activatable. See
// gtk_cell_renderer_toggle_set_activatable().
func (x *CellRendererToggle) GetActivatable() bool {

	cret := xCellRendererToggleGetActivatable(x.GoPointer())
	return cret
}

var xCellRendererToggleGetActive func(uintptr) bool

// Returns whether the cell renderer is active. See
// gtk_cell_renderer_toggle_set_active().
func (x *CellRendererToggle) GetActive() bool {

	cret := xCellRendererToggleGetActive(x.GoPointer())
	return cret
}

var xCellRendererToggleGetRadio func(uintptr) bool

// Returns whether we’re rendering radio toggles rather than checkboxes.
func (x *CellRendererToggle) GetRadio() bool {

	cret := xCellRendererToggleGetRadio(x.GoPointer())
	return cret
}

var xCellRendererToggleSetActivatable func(uintptr, bool)

// Makes the cell renderer activatable.
func (x *CellRendererToggle) SetActivatable(SettingVar bool) {

	xCellRendererToggleSetActivatable(x.GoPointer(), SettingVar)

}

var xCellRendererToggleSetActive func(uintptr, bool)

// Activates or deactivates a cell renderer.
func (x *CellRendererToggle) SetActive(SettingVar bool) {

	xCellRendererToggleSetActive(x.GoPointer(), SettingVar)

}

var xCellRendererToggleSetRadio func(uintptr, bool)

// If @radio is %TRUE, the cell renderer renders a radio toggle
// (i.e. a toggle in a group of mutually-exclusive toggles).
// If %FALSE, it renders a check toggle (a standalone boolean option).
// This can be set globally for the cell renderer, or changed just
// before rendering each cell in the model (for `GtkTreeView`, you set
// up a per-row setting using `GtkTreeViewColumn` to associate model
// columns with cell renderer properties).
func (x *CellRendererToggle) SetRadio(RadioVar bool) {

	xCellRendererToggleSetRadio(x.GoPointer(), RadioVar)

}

func (c *CellRendererToggle) GoPointer() uintptr {
	return c.Ptr
}

func (c *CellRendererToggle) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// The ::toggled signal is emitted when the cell is toggled.
//
// It is the responsibility of the application to update the model
// with the correct value to store at @path.  Often this is simply the
// opposite of the value currently stored at @path.
func (x *CellRendererToggle) ConnectToggled(cb *func(CellRendererToggle, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "toggled", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PathVarp string) {
		fa := CellRendererToggle{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "toggled", cbRefPtr)
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewCellRendererToggle, lib, "gtk_cell_renderer_toggle_new")

	core.PuregoSafeRegister(&xCellRendererToggleGetActivatable, lib, "gtk_cell_renderer_toggle_get_activatable")
	core.PuregoSafeRegister(&xCellRendererToggleGetActive, lib, "gtk_cell_renderer_toggle_get_active")
	core.PuregoSafeRegister(&xCellRendererToggleGetRadio, lib, "gtk_cell_renderer_toggle_get_radio")
	core.PuregoSafeRegister(&xCellRendererToggleSetActivatable, lib, "gtk_cell_renderer_toggle_set_activatable")
	core.PuregoSafeRegister(&xCellRendererToggleSetActive, lib, "gtk_cell_renderer_toggle_set_active")
	core.PuregoSafeRegister(&xCellRendererToggleSetRadio, lib, "gtk_cell_renderer_toggle_set_radio")

}
