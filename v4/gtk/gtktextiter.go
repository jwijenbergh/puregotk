// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/pango"
)

// The predicate function used by gtk_text_iter_forward_find_char() and
// gtk_text_iter_backward_find_char().
type TextCharPredicate func(uint32, uintptr) bool

// An iterator for the contents of a `GtkTextBuffer`.
//
// You may wish to begin by reading the
// [text widget conceptual overview](section-text-widget.html),
// which gives an overview of all the objects and data types
// related to the text widget and how they work together.
type TextIter struct {
	Dummy1 uintptr

	Dummy2 uintptr

	Dummy3 int

	Dummy4 int

	Dummy5 int

	Dummy6 int

	Dummy7 int

	Dummy8 int

	Dummy9 uintptr

	Dummy10 uintptr

	Dummy11 int

	Dummy12 int

	Dummy13 int

	Dummy14 uintptr
}

func (x *TextIter) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTextIterAssign func(uintptr, *TextIter)

// Assigns the value of @other to @iter.
//
// This function is not useful in applications, because
// iterators can be assigned with `GtkTextIter i = j;`.
//
// The function is used by language bindings.
func (x *TextIter) Assign(OtherVar *TextIter) {

	xTextIterAssign(x.GoPointer(), OtherVar)

}

var xTextIterBackwardChar func(uintptr) bool

// Moves backward by one character offset.
//
// Returns %TRUE if movement was possible; if @iter was the first
// in the buffer (character offset 0), this function returns %FALSE
// for convenience when writing loops.
func (x *TextIter) BackwardChar() bool {

	cret := xTextIterBackwardChar(x.GoPointer())
	return cret
}

var xTextIterBackwardChars func(uintptr, int) bool

// Moves @count characters backward, if possible.
//
// If @count would move past the start or end of the buffer, moves
// to the start or end of the buffer.
//
// The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or
// moved onto the end iterator, then %FALSE is returned. If @count is 0,
// the function does nothing and returns %FALSE.
func (x *TextIter) BackwardChars(CountVar int) bool {

	cret := xTextIterBackwardChars(x.GoPointer(), CountVar)
	return cret
}

var xTextIterBackwardCursorPosition func(uintptr) bool

// Like gtk_text_iter_forward_cursor_position(), but moves backward.
func (x *TextIter) BackwardCursorPosition() bool {

	cret := xTextIterBackwardCursorPosition(x.GoPointer())
	return cret
}

var xTextIterBackwardCursorPositions func(uintptr, int) bool

// Moves up to @count cursor positions.
//
// See [method@Gtk.TextIter.forward_cursor_position] for details.
func (x *TextIter) BackwardCursorPositions(CountVar int) bool {

	cret := xTextIterBackwardCursorPositions(x.GoPointer(), CountVar)
	return cret
}

var xTextIterBackwardFindChar func(uintptr, uintptr, uintptr, *TextIter) bool

// Same as gtk_text_iter_forward_find_char(),
// but goes backward from @iter.
func (x *TextIter) BackwardFindChar(PredVar *TextCharPredicate, UserDataVar uintptr, LimitVar *TextIter) bool {

	cret := xTextIterBackwardFindChar(x.GoPointer(), glib.NewCallback(PredVar), UserDataVar, LimitVar)
	return cret
}

var xTextIterBackwardLine func(uintptr) bool

// Moves @iter to the start of the previous line.
//
// Returns %TRUE if @iter could be moved; i.e. if @iter was at
// character offset 0, this function returns %FALSE. Therefore,
// if @iter was already on line 0, but not at the start of the line,
// @iter is snapped to the start of the line and the function returns
// %TRUE. (Note that this implies that
// in a loop calling this function, the line number may not change on
// every iteration, if your first iteration is on line 0.)
func (x *TextIter) BackwardLine() bool {

	cret := xTextIterBackwardLine(x.GoPointer())
	return cret
}

var xTextIterBackwardLines func(uintptr, int) bool

// Moves @count lines backward, if possible.
//
// If @count would move past the start or end of the buffer, moves to
// the start or end of the buffer.
//
// The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or
// moved onto the end iterator, then %FALSE is returned. If @count is 0,
// the function does nothing and returns %FALSE. If @count is negative,
// moves forward by 0 - @count lines.
func (x *TextIter) BackwardLines(CountVar int) bool {

	cret := xTextIterBackwardLines(x.GoPointer(), CountVar)
	return cret
}

var xTextIterBackwardSearch func(uintptr, string, TextSearchFlags, *TextIter, *TextIter, *TextIter) bool

// Same as gtk_text_iter_forward_search(), but moves backward.
//
// @match_end will never be set to a `GtkTextIter` located after @iter,
// even if there is a possible @match_start before or at @iter.
func (x *TextIter) BackwardSearch(StrVar string, FlagsVar TextSearchFlags, MatchStartVar *TextIter, MatchEndVar *TextIter, LimitVar *TextIter) bool {

	cret := xTextIterBackwardSearch(x.GoPointer(), StrVar, FlagsVar, MatchStartVar, MatchEndVar, LimitVar)
	return cret
}

var xTextIterBackwardSentenceStart func(uintptr) bool

// Moves backward to the previous sentence start.
//
// If @iter is already at the start of a sentence, moves backward
// to the next one.
//
// Sentence boundaries are determined by Pango and should
// be correct for nearly any language.
func (x *TextIter) BackwardSentenceStart() bool {

	cret := xTextIterBackwardSentenceStart(x.GoPointer())
	return cret
}

var xTextIterBackwardSentenceStarts func(uintptr, int) bool

// Calls gtk_text_iter_backward_sentence_start() up to @count times.
//
// If @count is negative, moves forward instead of backward.
func (x *TextIter) BackwardSentenceStarts(CountVar int) bool {

	cret := xTextIterBackwardSentenceStarts(x.GoPointer(), CountVar)
	return cret
}

var xTextIterBackwardToTagToggle func(uintptr, uintptr) bool

// Moves backward to the next toggle (on or off) of the
// @tag, or to the next toggle of any tag if
// @tag is %NULL.
//
// If no matching tag toggles are found,
// returns %FALSE, otherwise %TRUE. Does not return toggles
// located at @iter, only toggles before @iter. Sets @iter
// to the location of the toggle, or the start of the buffer
// if no toggle is found.
func (x *TextIter) BackwardToTagToggle(TagVar *TextTag) bool {

	cret := xTextIterBackwardToTagToggle(x.GoPointer(), TagVar.GoPointer())
	return cret
}

var xTextIterBackwardVisibleCursorPosition func(uintptr) bool

// Moves @iter forward to the previous visible cursor position.
//
// See [method@Gtk.TextIter.backward_cursor_position] for details.
func (x *TextIter) BackwardVisibleCursorPosition() bool {

	cret := xTextIterBackwardVisibleCursorPosition(x.GoPointer())
	return cret
}

var xTextIterBackwardVisibleCursorPositions func(uintptr, int) bool

// Moves up to @count visible cursor positions.
//
// See [method@Gtk.TextIter.backward_cursor_position] for details.
func (x *TextIter) BackwardVisibleCursorPositions(CountVar int) bool {

	cret := xTextIterBackwardVisibleCursorPositions(x.GoPointer(), CountVar)
	return cret
}

var xTextIterBackwardVisibleLine func(uintptr) bool

// Moves @iter to the start of the previous visible line.
//
// Returns %TRUE if
// @iter could be moved; i.e. if @iter was at character offset 0, this
// function returns %FALSE. Therefore if @iter was already on line 0,
// but not at the start of the line, @iter is snapped to the start of
// the line and the function returns %TRUE. (Note that this implies that
// in a loop calling this function, the line number may not change on
// every iteration, if your first iteration is on line 0.)
func (x *TextIter) BackwardVisibleLine() bool {

	cret := xTextIterBackwardVisibleLine(x.GoPointer())
	return cret
}

var xTextIterBackwardVisibleLines func(uintptr, int) bool

// Moves @count visible lines backward, if possible.
//
// If @count would move past the start or end of the buffer, moves to
// the start or end of the buffer.
//
// The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or
// moved onto the end iterator, then %FALSE is returned. If @count is 0,
// the function does nothing and returns %FALSE. If @count is negative,
// moves forward by 0 - @count lines.
func (x *TextIter) BackwardVisibleLines(CountVar int) bool {

	cret := xTextIterBackwardVisibleLines(x.GoPointer(), CountVar)
	return cret
}

var xTextIterBackwardVisibleWordStart func(uintptr) bool

// Moves backward to the previous visible word start.
//
// If @iter is currently on a word start, moves backward to the
// next one after that.
//
// Word breaks are determined by Pango and should be correct
// for nearly any language.
func (x *TextIter) BackwardVisibleWordStart() bool {

	cret := xTextIterBackwardVisibleWordStart(x.GoPointer())
	return cret
}

var xTextIterBackwardVisibleWordStarts func(uintptr, int) bool

// Calls gtk_text_iter_backward_visible_word_start() up to @count times.
func (x *TextIter) BackwardVisibleWordStarts(CountVar int) bool {

	cret := xTextIterBackwardVisibleWordStarts(x.GoPointer(), CountVar)
	return cret
}

var xTextIterBackwardWordStart func(uintptr) bool

// Moves backward to the previous word start.
//
// If @iter is currently on a word start, moves backward to the
// next one after that.
//
// Word breaks are determined by Pango and should be correct
// for nearly any language
func (x *TextIter) BackwardWordStart() bool {

	cret := xTextIterBackwardWordStart(x.GoPointer())
	return cret
}

var xTextIterBackwardWordStarts func(uintptr, int) bool

// Calls gtk_text_iter_backward_word_start() up to @count times.
func (x *TextIter) BackwardWordStarts(CountVar int) bool {

	cret := xTextIterBackwardWordStarts(x.GoPointer(), CountVar)
	return cret
}

var xTextIterCanInsert func(uintptr, bool) bool

// Considering the default editability of the buffer, and tags that
// affect editability, determines whether text inserted at @iter would
// be editable.
//
// If text inserted at @iter would be editable then the
// user should be allowed to insert text at @iter.
// [method@Gtk.TextBuffer.insert_interactive] uses this function
// to decide whether insertions are allowed at a given position.
func (x *TextIter) CanInsert(DefaultEditabilityVar bool) bool {

	cret := xTextIterCanInsert(x.GoPointer(), DefaultEditabilityVar)
	return cret
}

var xTextIterCompare func(uintptr, *TextIter) int

// A qsort()-style function that returns negative if @lhs is less than
// @rhs, positive if @lhs is greater than @rhs, and 0 if they’re equal.
//
// Ordering is in character offset order, i.e. the first character
// in the buffer is less than the second character in the buffer.
func (x *TextIter) Compare(RhsVar *TextIter) int {

	cret := xTextIterCompare(x.GoPointer(), RhsVar)
	return cret
}

var xTextIterCopy func(uintptr) *TextIter

// Creates a dynamically-allocated copy of an iterator.
//
// This function is not useful in applications, because
// iterators can be copied with a simple assignment
// (`GtkTextIter i = j;`).
//
// The function is used by language bindings.
func (x *TextIter) Copy() *TextIter {

	cret := xTextIterCopy(x.GoPointer())
	return cret
}

var xTextIterEditable func(uintptr, bool) bool

// Returns whether the character at @iter is within an editable region
// of text.
//
// Non-editable text is “locked” and can’t be changed by the
// user via `GtkTextView`. If no tags applied to this text affect
// editability, @default_setting will be returned.
//
// You don’t want to use this function to decide whether text can be
// inserted at @iter, because for insertion you don’t want to know
// whether the char at @iter is inside an editable range, you want to
// know whether a new character inserted at @iter would be inside an
// editable range. Use [method@Gtk.TextIter.can_insert] to handle this
// case.
func (x *TextIter) Editable(DefaultSettingVar bool) bool {

	cret := xTextIterEditable(x.GoPointer(), DefaultSettingVar)
	return cret
}

var xTextIterEndsLine func(uintptr) bool

// Returns %TRUE if @iter points to the start of the paragraph
// delimiter characters for a line.
//
// Delimiters will be either a newline, a carriage return, a carriage
// return followed by a newline, or a Unicode paragraph separator
// character.
//
// Note that an iterator pointing to the \n of a \r\n pair will not be
// counted as the end of a line, the line ends before the \r. The end
// iterator is considered to be at the end of a line, even though there
// are no paragraph delimiter chars there.
func (x *TextIter) EndsLine() bool {

	cret := xTextIterEndsLine(x.GoPointer())
	return cret
}

var xTextIterEndsSentence func(uintptr) bool

// Determines whether @iter ends a sentence.
//
// Sentence boundaries are determined by Pango and should
// be correct for nearly any language.
func (x *TextIter) EndsSentence() bool {

	cret := xTextIterEndsSentence(x.GoPointer())
	return cret
}

var xTextIterEndsTag func(uintptr, uintptr) bool

// Returns %TRUE if @tag is toggled off at exactly this point.
//
// If @tag is %NULL, returns %TRUE if any tag is toggled off at this point.
//
// Note that if this function returns %TRUE, it means that
// @iter is at the end of the tagged range, but that the character
// at @iter is outside the tagged range. In other words,
// unlike [method@Gtk.TextIter.starts_tag], if this function
// returns %TRUE, [method@Gtk.TextIter.has_tag] will return
// %FALSE for the same parameters.
func (x *TextIter) EndsTag(TagVar *TextTag) bool {

	cret := xTextIterEndsTag(x.GoPointer(), TagVar.GoPointer())
	return cret
}

var xTextIterEndsWord func(uintptr) bool

// Determines whether @iter ends a natural-language word.
//
// Word breaks are determined by Pango and should be correct
// for nearly any language.
func (x *TextIter) EndsWord() bool {

	cret := xTextIterEndsWord(x.GoPointer())
	return cret
}

var xTextIterEqual func(uintptr, *TextIter) bool

// Tests whether two iterators are equal, using the fastest possible
// mechanism.
//
// This function is very fast; you can expect it to perform
// better than e.g. getting the character offset for each
// iterator and comparing the offsets yourself. Also, it’s a
// bit faster than [method@Gtk.TextIter.compare].
func (x *TextIter) Equal(RhsVar *TextIter) bool {

	cret := xTextIterEqual(x.GoPointer(), RhsVar)
	return cret
}

var xTextIterForwardChar func(uintptr) bool

// Moves @iter forward by one character offset.
//
// Note that images embedded in the buffer occupy 1 character slot, so
// this function may actually move onto an image instead of a character,
// if you have images in your buffer. If @iter is the end iterator or
// one character before it, @iter will now point at the end iterator,
// and this function returns %FALSE for convenience when writing loops.
func (x *TextIter) ForwardChar() bool {

	cret := xTextIterForwardChar(x.GoPointer())
	return cret
}

var xTextIterForwardChars func(uintptr, int) bool

// Moves @count characters if possible.
//
// If @count would move past the start or end of the buffer,
// moves to the start or end of the buffer.
//
// The return value indicates whether the new position of
// @iter is different from its original position, and dereferenceable
// (the last iterator in the buffer is not dereferenceable). If @count
// is 0, the function does nothing and returns %FALSE.
func (x *TextIter) ForwardChars(CountVar int) bool {

	cret := xTextIterForwardChars(x.GoPointer(), CountVar)
	return cret
}

var xTextIterForwardCursorPosition func(uintptr) bool

// Moves @iter forward by a single cursor position.
//
// Cursor positions are (unsurprisingly) positions where the
// cursor can appear. Perhaps surprisingly, there may not be
// a cursor position between all characters. The most common
// example for European languages would be a carriage return/newline
// sequence.
//
// For some Unicode characters, the equivalent of say the letter “a”
// with an accent mark will be represented as two characters, first
// the letter then a "combining mark" that causes the accent to be
// rendered; so the cursor can’t go between those two characters.
//
// See also the [struct@Pango.LogAttr] struct and the [func@Pango.break]
// function.
func (x *TextIter) ForwardCursorPosition() bool {

	cret := xTextIterForwardCursorPosition(x.GoPointer())
	return cret
}

var xTextIterForwardCursorPositions func(uintptr, int) bool

// Moves up to @count cursor positions.
//
// See [method@Gtk.TextIter.forward_cursor_position] for details.
func (x *TextIter) ForwardCursorPositions(CountVar int) bool {

	cret := xTextIterForwardCursorPositions(x.GoPointer(), CountVar)
	return cret
}

var xTextIterForwardFindChar func(uintptr, uintptr, uintptr, *TextIter) bool

// Advances @iter, calling @pred on each character.
//
// If @pred returns %TRUE, returns %TRUE and stops scanning.
// If @pred never returns %TRUE, @iter is set to @limit if
// @limit is non-%NULL, otherwise to the end iterator.
func (x *TextIter) ForwardFindChar(PredVar *TextCharPredicate, UserDataVar uintptr, LimitVar *TextIter) bool {

	cret := xTextIterForwardFindChar(x.GoPointer(), glib.NewCallback(PredVar), UserDataVar, LimitVar)
	return cret
}

var xTextIterForwardLine func(uintptr) bool

// Moves @iter to the start of the next line.
//
// If the iter is already on the last line of the buffer,
// moves the iter to the end of the current line. If after
// the operation, the iter is at the end of the buffer and not
// dereferenceable, returns %FALSE. Otherwise, returns %TRUE.
func (x *TextIter) ForwardLine() bool {

	cret := xTextIterForwardLine(x.GoPointer())
	return cret
}

var xTextIterForwardLines func(uintptr, int) bool

// Moves @count lines forward, if possible.
//
// If @count would move past the start or end of the buffer, moves to
// the start or end of the buffer.
//
// The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or
// moved onto the end iterator, then %FALSE is returned. If @count is 0,
// the function does nothing and returns %FALSE. If @count is negative,
// moves backward by 0 - @count lines.
func (x *TextIter) ForwardLines(CountVar int) bool {

	cret := xTextIterForwardLines(x.GoPointer(), CountVar)
	return cret
}

var xTextIterForwardSearch func(uintptr, string, TextSearchFlags, *TextIter, *TextIter, *TextIter) bool

// Searches forward for @str.
//
// Any match is returned by setting @match_start to the first character
// of the match and @match_end to the first character after the match.
// The search will not continue past @limit. Note that a search is a
// linear or O(n) operation, so you may wish to use @limit to avoid
// locking up your UI on large buffers.
//
// @match_start will never be set to a `GtkTextIter` located before @iter,
// even if there is a possible @match_end after or at @iter.
func (x *TextIter) ForwardSearch(StrVar string, FlagsVar TextSearchFlags, MatchStartVar *TextIter, MatchEndVar *TextIter, LimitVar *TextIter) bool {

	cret := xTextIterForwardSearch(x.GoPointer(), StrVar, FlagsVar, MatchStartVar, MatchEndVar, LimitVar)
	return cret
}

var xTextIterForwardSentenceEnd func(uintptr) bool

// Moves forward to the next sentence end.
//
// If @iter is at the end of a sentence, moves to the next
// end of sentence.
//
// Sentence boundaries are determined by Pango and should
// be correct for nearly any language.
func (x *TextIter) ForwardSentenceEnd() bool {

	cret := xTextIterForwardSentenceEnd(x.GoPointer())
	return cret
}

var xTextIterForwardSentenceEnds func(uintptr, int) bool

// Calls gtk_text_iter_forward_sentence_end() @count times.
//
// If @count is negative, moves backward instead of forward.
func (x *TextIter) ForwardSentenceEnds(CountVar int) bool {

	cret := xTextIterForwardSentenceEnds(x.GoPointer(), CountVar)
	return cret
}

var xTextIterForwardToEnd func(uintptr)

// Moves @iter forward to the “end iterator”, which points
// one past the last valid character in the buffer.
//
// gtk_text_iter_get_char() called on the end iterator
// returns 0, which is convenient for writing loops.
func (x *TextIter) ForwardToEnd() {

	xTextIterForwardToEnd(x.GoPointer())

}

var xTextIterForwardToLineEnd func(uintptr) bool

// Moves the iterator to point to the paragraph delimiter characters.
//
// The possible characters are either a newline, a carriage return,
// a carriage return/newline in sequence, or the Unicode paragraph
// separator character.
//
// If the iterator is already at the paragraph delimiter
// characters, moves to the paragraph delimiter characters for the
// next line. If @iter is on the last line in the buffer, which does
// not end in paragraph delimiters, moves to the end iterator (end of
// the last line), and returns %FALSE.
func (x *TextIter) ForwardToLineEnd() bool {

	cret := xTextIterForwardToLineEnd(x.GoPointer())
	return cret
}

var xTextIterForwardToTagToggle func(uintptr, uintptr) bool

// Moves forward to the next toggle (on or off) of the
// @tag, or to the next toggle of any tag if
// @tag is %NULL.
//
// If no matching tag toggles are found,
// returns %FALSE, otherwise %TRUE. Does not return toggles
// located at @iter, only toggles after @iter. Sets @iter to
// the location of the toggle, or to the end of the buffer
// if no toggle is found.
func (x *TextIter) ForwardToTagToggle(TagVar *TextTag) bool {

	cret := xTextIterForwardToTagToggle(x.GoPointer(), TagVar.GoPointer())
	return cret
}

var xTextIterForwardVisibleCursorPosition func(uintptr) bool

// Moves @iter forward to the next visible cursor position.
//
// See [method@Gtk.TextIter.forward_cursor_position] for details.
func (x *TextIter) ForwardVisibleCursorPosition() bool {

	cret := xTextIterForwardVisibleCursorPosition(x.GoPointer())
	return cret
}

var xTextIterForwardVisibleCursorPositions func(uintptr, int) bool

// Moves up to @count visible cursor positions.
//
// See [method@Gtk.TextIter.forward_cursor_position] for details.
func (x *TextIter) ForwardVisibleCursorPositions(CountVar int) bool {

	cret := xTextIterForwardVisibleCursorPositions(x.GoPointer(), CountVar)
	return cret
}

var xTextIterForwardVisibleLine func(uintptr) bool

// Moves @iter to the start of the next visible line.
//
// Returns %TRUE if there
// was a next line to move to, and %FALSE if @iter was simply moved to
// the end of the buffer and is now not dereferenceable, or if @iter was
// already at the end of the buffer.
func (x *TextIter) ForwardVisibleLine() bool {

	cret := xTextIterForwardVisibleLine(x.GoPointer())
	return cret
}

var xTextIterForwardVisibleLines func(uintptr, int) bool

// Moves @count visible lines forward, if possible.
//
// If @count would move past the start or end of the buffer, moves to
// the start or end of the buffer.
//
// The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or
// moved onto the end iterator, then %FALSE is returned. If @count is 0,
// the function does nothing and returns %FALSE. If @count is negative,
// moves backward by 0 - @count lines.
func (x *TextIter) ForwardVisibleLines(CountVar int) bool {

	cret := xTextIterForwardVisibleLines(x.GoPointer(), CountVar)
	return cret
}

var xTextIterForwardVisibleWordEnd func(uintptr) bool

// Moves forward to the next visible word end.
//
// If @iter is currently on a word end, moves forward to the
// next one after that.
//
// Word breaks are determined by Pango and should be correct
// for nearly any language
func (x *TextIter) ForwardVisibleWordEnd() bool {

	cret := xTextIterForwardVisibleWordEnd(x.GoPointer())
	return cret
}

var xTextIterForwardVisibleWordEnds func(uintptr, int) bool

// Calls gtk_text_iter_forward_visible_word_end() up to @count times.
func (x *TextIter) ForwardVisibleWordEnds(CountVar int) bool {

	cret := xTextIterForwardVisibleWordEnds(x.GoPointer(), CountVar)
	return cret
}

var xTextIterForwardWordEnd func(uintptr) bool

// Moves forward to the next word end.
//
// If @iter is currently on a word end, moves forward to the
// next one after that.
//
// Word breaks are determined by Pango and should be correct
// for nearly any language.
func (x *TextIter) ForwardWordEnd() bool {

	cret := xTextIterForwardWordEnd(x.GoPointer())
	return cret
}

var xTextIterForwardWordEnds func(uintptr, int) bool

// Calls gtk_text_iter_forward_word_end() up to @count times.
func (x *TextIter) ForwardWordEnds(CountVar int) bool {

	cret := xTextIterForwardWordEnds(x.GoPointer(), CountVar)
	return cret
}

var xTextIterFree func(uintptr)

// Free an iterator allocated on the heap.
//
// This function is intended for use in language bindings,
// and is not especially useful for applications, because
// iterators can simply be allocated on the stack.
func (x *TextIter) Free() {

	xTextIterFree(x.GoPointer())

}

var xTextIterGetBuffer func(uintptr) uintptr

// Returns the `GtkTextBuffer` this iterator is associated with.
func (x *TextIter) GetBuffer() *TextBuffer {
	var cls *TextBuffer

	cret := xTextIterGetBuffer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextBuffer{}
	cls.Ptr = cret
	return cls
}

var xTextIterGetBytesInLine func(uintptr) int

// Returns the number of bytes in the line containing @iter,
// including the paragraph delimiters.
func (x *TextIter) GetBytesInLine() int {

	cret := xTextIterGetBytesInLine(x.GoPointer())
	return cret
}

var xTextIterGetChar func(uintptr) uint32

// The Unicode character at this iterator is returned.
//
// Equivalent to operator* on a C++ iterator. If the element at
// this iterator is a non-character element, such as an image
// embedded in the buffer, the Unicode “unknown” character 0xFFFC
// is returned. If invoked on the end iterator, zero is returned;
// zero is not a valid Unicode character.
//
// So you can write a loop which ends when this function returns 0.
func (x *TextIter) GetChar() uint32 {

	cret := xTextIterGetChar(x.GoPointer())
	return cret
}

var xTextIterGetCharsInLine func(uintptr) int

// Returns the number of characters in the line containing @iter,
// including the paragraph delimiters.
func (x *TextIter) GetCharsInLine() int {

	cret := xTextIterGetCharsInLine(x.GoPointer())
	return cret
}

var xTextIterGetChildAnchor func(uintptr) uintptr

// If the location at @iter contains a child anchor, the
// anchor is returned.
//
// Otherwise, %NULL is returned.
func (x *TextIter) GetChildAnchor() *TextChildAnchor {
	var cls *TextChildAnchor

	cret := xTextIterGetChildAnchor(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &TextChildAnchor{}
	cls.Ptr = cret
	return cls
}

var xTextIterGetLanguage func(uintptr) *pango.Language

// Returns the language in effect at @iter.
//
// If no tags affecting language apply to @iter, the return
// value is identical to that of [func@Gtk.get_default_language].
func (x *TextIter) GetLanguage() *pango.Language {

	cret := xTextIterGetLanguage(x.GoPointer())
	return cret
}

var xTextIterGetLine func(uintptr) int

// Returns the line number containing the iterator.
//
// Lines in a `GtkTextBuffer` are numbered beginning
// with 0 for the first line in the buffer.
func (x *TextIter) GetLine() int {

	cret := xTextIterGetLine(x.GoPointer())
	return cret
}

var xTextIterGetLineIndex func(uintptr) int

// Returns the byte index of the iterator, counting
// from the start of a newline-terminated line.
//
// Remember that `GtkTextBuffer` encodes text in
// UTF-8, and that characters can require a variable
// number of bytes to represent.
func (x *TextIter) GetLineIndex() int {

	cret := xTextIterGetLineIndex(x.GoPointer())
	return cret
}

var xTextIterGetLineOffset func(uintptr) int

// Returns the character offset of the iterator,
// counting from the start of a newline-terminated line.
//
// The first character on the line has offset 0.
func (x *TextIter) GetLineOffset() int {

	cret := xTextIterGetLineOffset(x.GoPointer())
	return cret
}

var xTextIterGetMarks func(uintptr) *glib.SList

// Returns a list of all `GtkTextMark` at this location.
//
// Because marks are not iterable (they don’t take up any "space"
// in the buffer, they are just marks in between iterable locations),
// multiple marks can exist in the same place.
//
// The returned list is not in any meaningful order.
func (x *TextIter) GetMarks() *glib.SList {

	cret := xTextIterGetMarks(x.GoPointer())
	return cret
}

var xTextIterGetOffset func(uintptr) int

// Returns the character offset of an iterator.
//
// Each character in a `GtkTextBuffer` has an offset,
// starting with 0 for the first character in the buffer.
// Use [method@Gtk,TextBuffer.get_iter_at_offset] to convert
// an offset back into an iterator.
func (x *TextIter) GetOffset() int {

	cret := xTextIterGetOffset(x.GoPointer())
	return cret
}

var xTextIterGetPaintable func(uintptr) uintptr

// If the element at @iter is a paintable, the paintable is returned.
//
// Otherwise, %NULL is returned.
func (x *TextIter) GetPaintable() *gdk.PaintableBase {
	var cls *gdk.PaintableBase

	cret := xTextIterGetPaintable(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.PaintableBase{}
	cls.Ptr = cret
	return cls
}

var xTextIterGetSlice func(uintptr, *TextIter) string

// Returns the text in the given range.
//
// A “slice” is an array of characters encoded in UTF-8 format,
// including the Unicode “unknown” character 0xFFFC for iterable
// non-character elements in the buffer, such as images.
// Because images are encoded in the slice, byte and
// character offsets in the returned array will correspond to byte
// offsets in the text buffer. Note that 0xFFFC can occur in normal
// text as well, so it is not a reliable indicator that a paintable or
// widget is in the buffer.
func (x *TextIter) GetSlice(EndVar *TextIter) string {

	cret := xTextIterGetSlice(x.GoPointer(), EndVar)
	return cret
}

var xTextIterGetTags func(uintptr) *glib.SList

// Returns a list of tags that apply to @iter, in ascending order of
// priority.
//
// The highest-priority tags are last.
//
// The `GtkTextTag`s in the list don’t have a reference added,
// but you have to free the list itself.
func (x *TextIter) GetTags() *glib.SList {

	cret := xTextIterGetTags(x.GoPointer())
	return cret
}

var xTextIterGetText func(uintptr, *TextIter) string

// Returns text in the given range.
//
// If the range
// contains non-text elements such as images, the character and byte
// offsets in the returned string will not correspond to character and
// byte offsets in the buffer. If you want offsets to correspond, see
// [method@Gtk.TextIter.get_slice].
func (x *TextIter) GetText(EndVar *TextIter) string {

	cret := xTextIterGetText(x.GoPointer(), EndVar)
	return cret
}

var xTextIterGetToggledTags func(uintptr, bool) *glib.SList

// Returns a list of `GtkTextTag` that are toggled on or off at this
// point.
//
// If @toggled_on is %TRUE, the list contains tags that are
// toggled on. If a tag is toggled on at @iter, then some non-empty
// range of characters following @iter has that tag applied to it.  If
// a tag is toggled off, then some non-empty range following @iter
// does not have the tag applied to it.
func (x *TextIter) GetToggledTags(ToggledOnVar bool) *glib.SList {

	cret := xTextIterGetToggledTags(x.GoPointer(), ToggledOnVar)
	return cret
}

var xTextIterGetVisibleLineIndex func(uintptr) int

// Returns the number of bytes from the start of the
// line to the given @iter, not counting bytes that
// are invisible due to tags with the “invisible” flag
// toggled on.
func (x *TextIter) GetVisibleLineIndex() int {

	cret := xTextIterGetVisibleLineIndex(x.GoPointer())
	return cret
}

var xTextIterGetVisibleLineOffset func(uintptr) int

// Returns the offset in characters from the start of the
// line to the given @iter, not counting characters that
// are invisible due to tags with the “invisible” flag
// toggled on.
func (x *TextIter) GetVisibleLineOffset() int {

	cret := xTextIterGetVisibleLineOffset(x.GoPointer())
	return cret
}

var xTextIterGetVisibleSlice func(uintptr, *TextIter) string

// Returns visible text in the given range.
//
// Like [method@Gtk.TextIter.get_slice], but invisible text
// is not included. Invisible text is usually invisible because
// a `GtkTextTag` with the “invisible” attribute turned on has
// been applied to it.
func (x *TextIter) GetVisibleSlice(EndVar *TextIter) string {

	cret := xTextIterGetVisibleSlice(x.GoPointer(), EndVar)
	return cret
}

var xTextIterGetVisibleText func(uintptr, *TextIter) string

// Returns visible text in the given range.
//
// Like [method@Gtk.TextIter.get_text], but invisible text
// is not included. Invisible text is usually invisible because
// a `GtkTextTag` with the “invisible” attribute turned on has
// been applied to it.
func (x *TextIter) GetVisibleText(EndVar *TextIter) string {

	cret := xTextIterGetVisibleText(x.GoPointer(), EndVar)
	return cret
}

var xTextIterHasTag func(uintptr, uintptr) bool

// Returns %TRUE if @iter points to a character that is part
// of a range tagged with @tag.
//
// See also [method@Gtk.TextIter.starts_tag] and
// [method@Gtk.TextIter.ends_tag].
func (x *TextIter) HasTag(TagVar *TextTag) bool {

	cret := xTextIterHasTag(x.GoPointer(), TagVar.GoPointer())
	return cret
}

var xTextIterInRange func(uintptr, *TextIter, *TextIter) bool

// Checks whether @iter falls in the range [@start, @end).
//
// @start and @end must be in ascending order.
func (x *TextIter) InRange(StartVar *TextIter, EndVar *TextIter) bool {

	cret := xTextIterInRange(x.GoPointer(), StartVar, EndVar)
	return cret
}

var xTextIterInsideSentence func(uintptr) bool

// Determines whether @iter is inside a sentence (as opposed to in
// between two sentences, e.g. after a period and before the first
// letter of the next sentence).
//
// Sentence boundaries are determined by Pango and should be correct
// for nearly any language.
func (x *TextIter) InsideSentence() bool {

	cret := xTextIterInsideSentence(x.GoPointer())
	return cret
}

var xTextIterInsideWord func(uintptr) bool

// Determines whether the character pointed by @iter is part of a
// natural-language word (as opposed to say inside some whitespace).
//
// Word breaks are determined by Pango and should be correct
// for nearly any language.
//
// Note that if [method@Gtk.TextIter.starts_word] returns %TRUE,
// then this function returns %TRUE too, since @iter points to
// the first character of the word.
func (x *TextIter) InsideWord() bool {

	cret := xTextIterInsideWord(x.GoPointer())
	return cret
}

var xTextIterIsCursorPosition func(uintptr) bool

// Determine if @iter is at a cursor position.
//
// See [method@Gtk.TextIter.forward_cursor_position] or
// [struct@Pango.LogAttr] or [func@Pango.break] for details
// on what a cursor position is.
func (x *TextIter) IsCursorPosition() bool {

	cret := xTextIterIsCursorPosition(x.GoPointer())
	return cret
}

var xTextIterIsEnd func(uintptr) bool

// Returns %TRUE if @iter is the end iterator.
//
// This means it is one past the last dereferenceable iterator
// in the buffer. gtk_text_iter_is_end() is the most efficient
// way to check whether an iterator is the end iterator.
func (x *TextIter) IsEnd() bool {

	cret := xTextIterIsEnd(x.GoPointer())
	return cret
}

var xTextIterIsStart func(uintptr) bool

// Returns %TRUE if @iter is the first iterator in the buffer.
func (x *TextIter) IsStart() bool {

	cret := xTextIterIsStart(x.GoPointer())
	return cret
}

var xTextIterOrder func(uintptr, *TextIter)

// Swaps the value of @first and @second if @second comes before
// @first in the buffer.
//
// That is, ensures that @first and @second are in sequence.
// Most text buffer functions that take a range call this
// automatically on your behalf, so there’s no real reason to
// call it yourself in those cases. There are some exceptions,
// such as [method@Gtk.TextIter.in_range], that expect a
// pre-sorted range.
func (x *TextIter) Order(SecondVar *TextIter) {

	xTextIterOrder(x.GoPointer(), SecondVar)

}

var xTextIterSetLine func(uintptr, int)

// Moves iterator @iter to the start of the line @line_number.
//
// If @line_number is negative or larger than or equal to the number of lines
// in the buffer, moves @iter to the start of the last line in the buffer.
func (x *TextIter) SetLine(LineNumberVar int) {

	xTextIterSetLine(x.GoPointer(), LineNumberVar)

}

var xTextIterSetLineIndex func(uintptr, int)

// Same as gtk_text_iter_set_line_offset(), but works with a
// byte index. The given byte index must be at
// the start of a character, it can’t be in the middle of a UTF-8
// encoded character.
func (x *TextIter) SetLineIndex(ByteOnLineVar int) {

	xTextIterSetLineIndex(x.GoPointer(), ByteOnLineVar)

}

var xTextIterSetLineOffset func(uintptr, int)

// Moves @iter within a line, to a new character (not byte) offset.
//
// The given character offset must be less than or equal to the number
// of characters in the line; if equal, @iter moves to the start of the
// next line. See [method@Gtk.TextIter.set_line_index] if you have a byte
// index rather than a character offset.
func (x *TextIter) SetLineOffset(CharOnLineVar int) {

	xTextIterSetLineOffset(x.GoPointer(), CharOnLineVar)

}

var xTextIterSetOffset func(uintptr, int)

// Sets @iter to point to @char_offset.
//
// @char_offset counts from the start
// of the entire text buffer, starting with 0.
func (x *TextIter) SetOffset(CharOffsetVar int) {

	xTextIterSetOffset(x.GoPointer(), CharOffsetVar)

}

var xTextIterSetVisibleLineIndex func(uintptr, int)

// Like gtk_text_iter_set_line_index(), but the index is in visible
// bytes, i.e. text with a tag making it invisible is not counted
// in the index.
func (x *TextIter) SetVisibleLineIndex(ByteOnLineVar int) {

	xTextIterSetVisibleLineIndex(x.GoPointer(), ByteOnLineVar)

}

var xTextIterSetVisibleLineOffset func(uintptr, int)

// Like gtk_text_iter_set_line_offset(), but the offset is in visible
// characters, i.e. text with a tag making it invisible is not
// counted in the offset.
func (x *TextIter) SetVisibleLineOffset(CharOnLineVar int) {

	xTextIterSetVisibleLineOffset(x.GoPointer(), CharOnLineVar)

}

var xTextIterStartsLine func(uintptr) bool

// Returns %TRUE if @iter begins a paragraph.
//
// This is the case if [method@Gtk.TextIter.get_line_offset]
// would return 0. However this function is potentially more
// efficient than [method@Gtk.TextIter.get_line_offset], because
// it doesn’t have to compute the offset, it just has to see
// whether it’s 0.
func (x *TextIter) StartsLine() bool {

	cret := xTextIterStartsLine(x.GoPointer())
	return cret
}

var xTextIterStartsSentence func(uintptr) bool

// Determines whether @iter begins a sentence.
//
// Sentence boundaries are determined by Pango and
// should be correct for nearly any language.
func (x *TextIter) StartsSentence() bool {

	cret := xTextIterStartsSentence(x.GoPointer())
	return cret
}

var xTextIterStartsTag func(uintptr, uintptr) bool

// Returns %TRUE if @tag is toggled on at exactly this point.
//
// If @tag is %NULL, returns %TRUE if any tag is toggled on at this point.
//
// Note that if this function returns %TRUE, it means that
// @iter is at the beginning of the tagged range, and that the
// character at @iter is inside the tagged range. In other
// words, unlike [method@Gtk.TextIter.ends_tag], if
// this function returns %TRUE, [method@Gtk.TextIter.has_tag
// will also return %TRUE for the same parameters.
func (x *TextIter) StartsTag(TagVar *TextTag) bool {

	cret := xTextIterStartsTag(x.GoPointer(), TagVar.GoPointer())
	return cret
}

var xTextIterStartsWord func(uintptr) bool

// Determines whether @iter begins a natural-language word.
//
// Word breaks are determined by Pango and should be correct
// for nearly any language.
func (x *TextIter) StartsWord() bool {

	cret := xTextIterStartsWord(x.GoPointer())
	return cret
}

var xTextIterTogglesTag func(uintptr, uintptr) bool

// Gets whether a range with @tag applied to it begins
// or ends at @iter.
//
// This is equivalent to (gtk_text_iter_starts_tag() ||
// gtk_text_iter_ends_tag())
func (x *TextIter) TogglesTag(TagVar *TextTag) bool {

	cret := xTextIterTogglesTag(x.GoPointer(), TagVar.GoPointer())
	return cret
}

// Flags affecting how a search is done.
//
// If neither %GTK_TEXT_SEARCH_VISIBLE_ONLY nor %GTK_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded paintables or child widgets.
type TextSearchFlags int

const (

	// Search only visible data. A search match may
	// have invisible text interspersed.
	TextSearchVisibleOnlyValue TextSearchFlags = 1
	// Search only text. A match may have paintables or
	// child widgets mixed inside the matched range.
	TextSearchTextOnlyValue TextSearchFlags = 2
	// The text will be matched regardless of
	// what case it is in.
	TextSearchCaseInsensitiveValue TextSearchFlags = 4
)

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xTextIterAssign, lib, "gtk_text_iter_assign")
	core.PuregoSafeRegister(&xTextIterBackwardChar, lib, "gtk_text_iter_backward_char")
	core.PuregoSafeRegister(&xTextIterBackwardChars, lib, "gtk_text_iter_backward_chars")
	core.PuregoSafeRegister(&xTextIterBackwardCursorPosition, lib, "gtk_text_iter_backward_cursor_position")
	core.PuregoSafeRegister(&xTextIterBackwardCursorPositions, lib, "gtk_text_iter_backward_cursor_positions")
	core.PuregoSafeRegister(&xTextIterBackwardFindChar, lib, "gtk_text_iter_backward_find_char")
	core.PuregoSafeRegister(&xTextIterBackwardLine, lib, "gtk_text_iter_backward_line")
	core.PuregoSafeRegister(&xTextIterBackwardLines, lib, "gtk_text_iter_backward_lines")
	core.PuregoSafeRegister(&xTextIterBackwardSearch, lib, "gtk_text_iter_backward_search")
	core.PuregoSafeRegister(&xTextIterBackwardSentenceStart, lib, "gtk_text_iter_backward_sentence_start")
	core.PuregoSafeRegister(&xTextIterBackwardSentenceStarts, lib, "gtk_text_iter_backward_sentence_starts")
	core.PuregoSafeRegister(&xTextIterBackwardToTagToggle, lib, "gtk_text_iter_backward_to_tag_toggle")
	core.PuregoSafeRegister(&xTextIterBackwardVisibleCursorPosition, lib, "gtk_text_iter_backward_visible_cursor_position")
	core.PuregoSafeRegister(&xTextIterBackwardVisibleCursorPositions, lib, "gtk_text_iter_backward_visible_cursor_positions")
	core.PuregoSafeRegister(&xTextIterBackwardVisibleLine, lib, "gtk_text_iter_backward_visible_line")
	core.PuregoSafeRegister(&xTextIterBackwardVisibleLines, lib, "gtk_text_iter_backward_visible_lines")
	core.PuregoSafeRegister(&xTextIterBackwardVisibleWordStart, lib, "gtk_text_iter_backward_visible_word_start")
	core.PuregoSafeRegister(&xTextIterBackwardVisibleWordStarts, lib, "gtk_text_iter_backward_visible_word_starts")
	core.PuregoSafeRegister(&xTextIterBackwardWordStart, lib, "gtk_text_iter_backward_word_start")
	core.PuregoSafeRegister(&xTextIterBackwardWordStarts, lib, "gtk_text_iter_backward_word_starts")
	core.PuregoSafeRegister(&xTextIterCanInsert, lib, "gtk_text_iter_can_insert")
	core.PuregoSafeRegister(&xTextIterCompare, lib, "gtk_text_iter_compare")
	core.PuregoSafeRegister(&xTextIterCopy, lib, "gtk_text_iter_copy")
	core.PuregoSafeRegister(&xTextIterEditable, lib, "gtk_text_iter_editable")
	core.PuregoSafeRegister(&xTextIterEndsLine, lib, "gtk_text_iter_ends_line")
	core.PuregoSafeRegister(&xTextIterEndsSentence, lib, "gtk_text_iter_ends_sentence")
	core.PuregoSafeRegister(&xTextIterEndsTag, lib, "gtk_text_iter_ends_tag")
	core.PuregoSafeRegister(&xTextIterEndsWord, lib, "gtk_text_iter_ends_word")
	core.PuregoSafeRegister(&xTextIterEqual, lib, "gtk_text_iter_equal")
	core.PuregoSafeRegister(&xTextIterForwardChar, lib, "gtk_text_iter_forward_char")
	core.PuregoSafeRegister(&xTextIterForwardChars, lib, "gtk_text_iter_forward_chars")
	core.PuregoSafeRegister(&xTextIterForwardCursorPosition, lib, "gtk_text_iter_forward_cursor_position")
	core.PuregoSafeRegister(&xTextIterForwardCursorPositions, lib, "gtk_text_iter_forward_cursor_positions")
	core.PuregoSafeRegister(&xTextIterForwardFindChar, lib, "gtk_text_iter_forward_find_char")
	core.PuregoSafeRegister(&xTextIterForwardLine, lib, "gtk_text_iter_forward_line")
	core.PuregoSafeRegister(&xTextIterForwardLines, lib, "gtk_text_iter_forward_lines")
	core.PuregoSafeRegister(&xTextIterForwardSearch, lib, "gtk_text_iter_forward_search")
	core.PuregoSafeRegister(&xTextIterForwardSentenceEnd, lib, "gtk_text_iter_forward_sentence_end")
	core.PuregoSafeRegister(&xTextIterForwardSentenceEnds, lib, "gtk_text_iter_forward_sentence_ends")
	core.PuregoSafeRegister(&xTextIterForwardToEnd, lib, "gtk_text_iter_forward_to_end")
	core.PuregoSafeRegister(&xTextIterForwardToLineEnd, lib, "gtk_text_iter_forward_to_line_end")
	core.PuregoSafeRegister(&xTextIterForwardToTagToggle, lib, "gtk_text_iter_forward_to_tag_toggle")
	core.PuregoSafeRegister(&xTextIterForwardVisibleCursorPosition, lib, "gtk_text_iter_forward_visible_cursor_position")
	core.PuregoSafeRegister(&xTextIterForwardVisibleCursorPositions, lib, "gtk_text_iter_forward_visible_cursor_positions")
	core.PuregoSafeRegister(&xTextIterForwardVisibleLine, lib, "gtk_text_iter_forward_visible_line")
	core.PuregoSafeRegister(&xTextIterForwardVisibleLines, lib, "gtk_text_iter_forward_visible_lines")
	core.PuregoSafeRegister(&xTextIterForwardVisibleWordEnd, lib, "gtk_text_iter_forward_visible_word_end")
	core.PuregoSafeRegister(&xTextIterForwardVisibleWordEnds, lib, "gtk_text_iter_forward_visible_word_ends")
	core.PuregoSafeRegister(&xTextIterForwardWordEnd, lib, "gtk_text_iter_forward_word_end")
	core.PuregoSafeRegister(&xTextIterForwardWordEnds, lib, "gtk_text_iter_forward_word_ends")
	core.PuregoSafeRegister(&xTextIterFree, lib, "gtk_text_iter_free")
	core.PuregoSafeRegister(&xTextIterGetBuffer, lib, "gtk_text_iter_get_buffer")
	core.PuregoSafeRegister(&xTextIterGetBytesInLine, lib, "gtk_text_iter_get_bytes_in_line")
	core.PuregoSafeRegister(&xTextIterGetChar, lib, "gtk_text_iter_get_char")
	core.PuregoSafeRegister(&xTextIterGetCharsInLine, lib, "gtk_text_iter_get_chars_in_line")
	core.PuregoSafeRegister(&xTextIterGetChildAnchor, lib, "gtk_text_iter_get_child_anchor")
	core.PuregoSafeRegister(&xTextIterGetLanguage, lib, "gtk_text_iter_get_language")
	core.PuregoSafeRegister(&xTextIterGetLine, lib, "gtk_text_iter_get_line")
	core.PuregoSafeRegister(&xTextIterGetLineIndex, lib, "gtk_text_iter_get_line_index")
	core.PuregoSafeRegister(&xTextIterGetLineOffset, lib, "gtk_text_iter_get_line_offset")
	core.PuregoSafeRegister(&xTextIterGetMarks, lib, "gtk_text_iter_get_marks")
	core.PuregoSafeRegister(&xTextIterGetOffset, lib, "gtk_text_iter_get_offset")
	core.PuregoSafeRegister(&xTextIterGetPaintable, lib, "gtk_text_iter_get_paintable")
	core.PuregoSafeRegister(&xTextIterGetSlice, lib, "gtk_text_iter_get_slice")
	core.PuregoSafeRegister(&xTextIterGetTags, lib, "gtk_text_iter_get_tags")
	core.PuregoSafeRegister(&xTextIterGetText, lib, "gtk_text_iter_get_text")
	core.PuregoSafeRegister(&xTextIterGetToggledTags, lib, "gtk_text_iter_get_toggled_tags")
	core.PuregoSafeRegister(&xTextIterGetVisibleLineIndex, lib, "gtk_text_iter_get_visible_line_index")
	core.PuregoSafeRegister(&xTextIterGetVisibleLineOffset, lib, "gtk_text_iter_get_visible_line_offset")
	core.PuregoSafeRegister(&xTextIterGetVisibleSlice, lib, "gtk_text_iter_get_visible_slice")
	core.PuregoSafeRegister(&xTextIterGetVisibleText, lib, "gtk_text_iter_get_visible_text")
	core.PuregoSafeRegister(&xTextIterHasTag, lib, "gtk_text_iter_has_tag")
	core.PuregoSafeRegister(&xTextIterInRange, lib, "gtk_text_iter_in_range")
	core.PuregoSafeRegister(&xTextIterInsideSentence, lib, "gtk_text_iter_inside_sentence")
	core.PuregoSafeRegister(&xTextIterInsideWord, lib, "gtk_text_iter_inside_word")
	core.PuregoSafeRegister(&xTextIterIsCursorPosition, lib, "gtk_text_iter_is_cursor_position")
	core.PuregoSafeRegister(&xTextIterIsEnd, lib, "gtk_text_iter_is_end")
	core.PuregoSafeRegister(&xTextIterIsStart, lib, "gtk_text_iter_is_start")
	core.PuregoSafeRegister(&xTextIterOrder, lib, "gtk_text_iter_order")
	core.PuregoSafeRegister(&xTextIterSetLine, lib, "gtk_text_iter_set_line")
	core.PuregoSafeRegister(&xTextIterSetLineIndex, lib, "gtk_text_iter_set_line_index")
	core.PuregoSafeRegister(&xTextIterSetLineOffset, lib, "gtk_text_iter_set_line_offset")
	core.PuregoSafeRegister(&xTextIterSetOffset, lib, "gtk_text_iter_set_offset")
	core.PuregoSafeRegister(&xTextIterSetVisibleLineIndex, lib, "gtk_text_iter_set_visible_line_index")
	core.PuregoSafeRegister(&xTextIterSetVisibleLineOffset, lib, "gtk_text_iter_set_visible_line_offset")
	core.PuregoSafeRegister(&xTextIterStartsLine, lib, "gtk_text_iter_starts_line")
	core.PuregoSafeRegister(&xTextIterStartsSentence, lib, "gtk_text_iter_starts_sentence")
	core.PuregoSafeRegister(&xTextIterStartsTag, lib, "gtk_text_iter_starts_tag")
	core.PuregoSafeRegister(&xTextIterStartsWord, lib, "gtk_text_iter_starts_word")
	core.PuregoSafeRegister(&xTextIterTogglesTag, lib, "gtk_text_iter_toggles_tag")

}
