// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type TreeStoreClass struct {
	_ structs.HostLayout

	ParentClass uintptr

	Padding [8]uintptr
}

func (x *TreeStoreClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type TreeStorePrivate struct {
	_ structs.HostLayout
}

func (x *TreeStorePrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A tree-like data structure that can be used with the GtkTreeView
//
// The `GtkTreeStore` object is a list model for use with a `GtkTreeView`
// widget.  It implements the `GtkTreeModel` interface, and consequently,
// can use all of the methods available there.  It also implements the
// `GtkTreeSortable` interface so it can be sorted by the view.  Finally,
// it also implements the tree
// [drag and drop][gtk3-GtkTreeView-drag-and-drop]
// interfaces.
//
// # GtkTreeStore as GtkBuildable
//
// The GtkTreeStore implementation of the `GtkBuildable` interface allows
// to specify the model columns with a &lt;columns&gt; element that may contain
// multiple &lt;column&gt; elements, each specifying one model column. The “type”
// attribute specifies the data type for the column.
//
// An example of a UI Definition fragment for a tree store:
// |[
// &lt;object class="GtkTreeStore"&gt;
//
//	&lt;columns&gt;
//	  &lt;column type="gchararray"/&gt;
//	  &lt;column type="gchararray"/&gt;
//	  &lt;column type="gint"/&gt;
//	&lt;/columns&gt;
//
// &lt;/object&gt;
// ]|
type TreeStore struct {
	gobject.Object
}

var xTreeStoreGLibType func() types.GType

func TreeStoreGLibType() types.GType {
	return xTreeStoreGLibType()
}

func TreeStoreNewFromInternalPtr(ptr uintptr) *TreeStore {
	cls := &TreeStore{}
	cls.Ptr = ptr
	return cls
}

var xNewTreeStore func(int, ...interface{}) uintptr

// Creates a new tree store as with @n_columns columns each of the types passed
// in.  Note that only types derived from standard GObject fundamental types
// are supported.
//
// As an example,
//
// ```
// gtk_tree_store_new (3, G_TYPE_INT, G_TYPE_STRING, GDK_TYPE_TEXTURE);
// ```
//
// will create a new `GtkTreeStore` with three columns, of type
// `int`, `gchararray`, and `GdkTexture` respectively.
func NewTreeStore(NColumnsVar int, varArgs ...interface{}) *TreeStore {
	var cls *TreeStore

	cret := xNewTreeStore(NColumnsVar, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &TreeStore{}
	cls.Ptr = cret
	return cls
}

var xNewTreeStorev func(int, []types.GType) uintptr

// Non vararg creation function.  Used primarily by language bindings.
func NewTreeStorev(NColumnsVar int, TypesVar []types.GType) *TreeStore {
	var cls *TreeStore

	cret := xNewTreeStorev(NColumnsVar, TypesVar)

	if cret == 0 {
		return nil
	}
	cls = &TreeStore{}
	cls.Ptr = cret
	return cls
}

var xTreeStoreAppend func(uintptr, *TreeIter, *TreeIter)

// Appends a new row to @tree_store.  If @parent is non-%NULL, then it will append the
// new row after the last child of @parent, otherwise it will append a row to
// the top level.  @iter will be changed to point to this new row.  The row will
// be empty after this function is called.  To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
func (x *TreeStore) Append(IterVar *TreeIter, ParentVar *TreeIter) {

	xTreeStoreAppend(x.GoPointer(), IterVar, ParentVar)

}

var xTreeStoreClear func(uintptr)

// Removes all rows from @tree_store
func (x *TreeStore) Clear() {

	xTreeStoreClear(x.GoPointer())

}

var xTreeStoreInsert func(uintptr, *TreeIter, *TreeIter, int)

// Creates a new row at @position.  If parent is non-%NULL, then the row will be
// made a child of @parent.  Otherwise, the row will be created at the toplevel.
// If @position is -1 or is larger than the number of rows at that level, then
// the new row will be inserted to the end of the list.  @iter will be changed
// to point to this new row.  The row will be empty after this function is
// called.  To fill in values, you need to call gtk_tree_store_set() or
// gtk_tree_store_set_value().
func (x *TreeStore) Insert(IterVar *TreeIter, ParentVar *TreeIter, PositionVar int) {

	xTreeStoreInsert(x.GoPointer(), IterVar, ParentVar, PositionVar)

}

var xTreeStoreInsertAfter func(uintptr, *TreeIter, *TreeIter, *TreeIter)

// Inserts a new row after @sibling.  If @sibling is %NULL, then the row will be
// prepended to @parent ’s children.  If @parent and @sibling are %NULL, then
// the row will be prepended to the toplevel.  If both @sibling and @parent are
// set, then @parent must be the parent of @sibling.  When @sibling is set,
// @parent is optional.
//
// @iter will be changed to point to this new row.  The row will be empty after
// this function is called.  To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
func (x *TreeStore) InsertAfter(IterVar *TreeIter, ParentVar *TreeIter, SiblingVar *TreeIter) {

	xTreeStoreInsertAfter(x.GoPointer(), IterVar, ParentVar, SiblingVar)

}

var xTreeStoreInsertBefore func(uintptr, *TreeIter, *TreeIter, *TreeIter)

// Inserts a new row before @sibling.  If @sibling is %NULL, then the row will
// be appended to @parent ’s children.  If @parent and @sibling are %NULL, then
// the row will be appended to the toplevel.  If both @sibling and @parent are
// set, then @parent must be the parent of @sibling.  When @sibling is set,
// @parent is optional.
//
// @iter will be changed to point to this new row.  The row will be empty after
// this function is called.  To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
func (x *TreeStore) InsertBefore(IterVar *TreeIter, ParentVar *TreeIter, SiblingVar *TreeIter) {

	xTreeStoreInsertBefore(x.GoPointer(), IterVar, ParentVar, SiblingVar)

}

var xTreeStoreInsertWithValues func(uintptr, *TreeIter, *TreeIter, int, ...interface{})

// Creates a new row at @position. @iter will be changed to point to this
// new row. If @position is -1, or larger than the number of rows on the list, then
// the new row will be appended to the list. The row will be filled with
// the values given to this function.
//
// Calling
// `gtk_tree_store_insert_with_values (tree_store, iter, position, ...)`
// has the same effect as calling
// |[&lt;!-- language="C" --&gt;
// gtk_tree_store_insert (tree_store, iter, position);
// gtk_tree_store_set (tree_store, iter, ...);
// ]|
// with the different that the former will only emit a row_inserted signal,
// while the latter will emit row_inserted, row_changed and if the tree store
// is sorted, rows_reordered.  Since emitting the rows_reordered signal
// repeatedly can affect the performance of the program,
// gtk_tree_store_insert_with_values() should generally be preferred when
// inserting rows in a sorted tree store.
func (x *TreeStore) InsertWithValues(IterVar *TreeIter, ParentVar *TreeIter, PositionVar int, varArgs ...interface{}) {

	xTreeStoreInsertWithValues(x.GoPointer(), IterVar, ParentVar, PositionVar, varArgs...)

}

var xTreeStoreInsertWithValuesv func(uintptr, *TreeIter, *TreeIter, int, []int, []gobject.Value, int)

// A variant of gtk_tree_store_insert_with_values() which takes
// the columns and values as two arrays, instead of varargs.  This
// function is mainly intended for language bindings.
func (x *TreeStore) InsertWithValuesv(IterVar *TreeIter, ParentVar *TreeIter, PositionVar int, ColumnsVar []int, ValuesVar []gobject.Value, NValuesVar int) {

	xTreeStoreInsertWithValuesv(x.GoPointer(), IterVar, ParentVar, PositionVar, ColumnsVar, ValuesVar, NValuesVar)

}

var xTreeStoreIsAncestor func(uintptr, *TreeIter, *TreeIter) bool

// Returns %TRUE if @iter is an ancestor of @descendant.  That is, @iter is the
// parent (or grandparent or great-grandparent) of @descendant.
func (x *TreeStore) IsAncestor(IterVar *TreeIter, DescendantVar *TreeIter) bool {

	cret := xTreeStoreIsAncestor(x.GoPointer(), IterVar, DescendantVar)
	return cret
}

var xTreeStoreIterDepth func(uintptr, *TreeIter) int

// Returns the depth of @iter.  This will be 0 for anything on the root level, 1
// for anything down a level, etc.
func (x *TreeStore) IterDepth(IterVar *TreeIter) int {

	cret := xTreeStoreIterDepth(x.GoPointer(), IterVar)
	return cret
}

var xTreeStoreIterIsValid func(uintptr, *TreeIter) bool

// Checks if the given iter is a valid iter for this `GtkTreeStore`.
//
// This function is slow. Only use it for debugging and/or testing
// purposes.
func (x *TreeStore) IterIsValid(IterVar *TreeIter) bool {

	cret := xTreeStoreIterIsValid(x.GoPointer(), IterVar)
	return cret
}

var xTreeStoreMoveAfter func(uintptr, *TreeIter, *TreeIter)

// Moves @iter in @tree_store to the position after @position. @iter and
// @position should be in the same level. Note that this function only
// works with unsorted stores. If @position is %NULL, @iter will be moved
// to the start of the level.
func (x *TreeStore) MoveAfter(IterVar *TreeIter, PositionVar *TreeIter) {

	xTreeStoreMoveAfter(x.GoPointer(), IterVar, PositionVar)

}

var xTreeStoreMoveBefore func(uintptr, *TreeIter, *TreeIter)

// Moves @iter in @tree_store to the position before @position. @iter and
// @position should be in the same level. Note that this function only
// works with unsorted stores. If @position is %NULL, @iter will be
// moved to the end of the level.
func (x *TreeStore) MoveBefore(IterVar *TreeIter, PositionVar *TreeIter) {

	xTreeStoreMoveBefore(x.GoPointer(), IterVar, PositionVar)

}

var xTreeStorePrepend func(uintptr, *TreeIter, *TreeIter)

// Prepends a new row to @tree_store.  If @parent is non-%NULL, then it will prepend
// the new row before the first child of @parent, otherwise it will prepend a row
// to the top level.  @iter will be changed to point to this new row.  The row
// will be empty after this function is called.  To fill in values, you need to
// call gtk_tree_store_set() or gtk_tree_store_set_value().
func (x *TreeStore) Prepend(IterVar *TreeIter, ParentVar *TreeIter) {

	xTreeStorePrepend(x.GoPointer(), IterVar, ParentVar)

}

var xTreeStoreRemove func(uintptr, *TreeIter) bool

// Removes @iter from @tree_store.  After being removed, @iter is set to the
// next valid row at that level, or invalidated if it previously pointed to the
// last one.
func (x *TreeStore) Remove(IterVar *TreeIter) bool {

	cret := xTreeStoreRemove(x.GoPointer(), IterVar)
	return cret
}

var xTreeStoreReorder func(uintptr, *TreeIter, []int)

// Reorders the children of @parent in @tree_store to follow the order
// indicated by @new_order. Note that this function only works with
// unsorted stores.
func (x *TreeStore) Reorder(ParentVar *TreeIter, NewOrderVar []int) {

	xTreeStoreReorder(x.GoPointer(), ParentVar, NewOrderVar)

}

var xTreeStoreSet func(uintptr, *TreeIter, ...interface{})

// Sets the value of one or more cells in the row referenced by @iter.
// The variable argument list should contain integer column numbers,
// each column number followed by the value to be set.
// The list is terminated by a -1. For example, to set column 0 with type
// %G_TYPE_STRING to “Foo”, you would write
// `gtk_tree_store_set (store, iter, 0, "Foo", -1)`.
//
// The value will be referenced by the store if it is a %G_TYPE_OBJECT, and it
// will be copied if it is a %G_TYPE_STRING or %G_TYPE_BOXED.
func (x *TreeStore) Set(IterVar *TreeIter, varArgs ...interface{}) {

	xTreeStoreSet(x.GoPointer(), IterVar, varArgs...)

}

var xTreeStoreSetColumnTypes func(uintptr, int, []types.GType)

// This function is meant primarily for `GObjects` that inherit from
// `GtkTreeStore`, and should only be used when constructing a new
// `GtkTreeStore`.  It will not function after a row has been added,
// or a method on the `GtkTreeModel` interface is called.
func (x *TreeStore) SetColumnTypes(NColumnsVar int, TypesVar []types.GType) {

	xTreeStoreSetColumnTypes(x.GoPointer(), NColumnsVar, TypesVar)

}

var xTreeStoreSetValist func(uintptr, *TreeIter, []interface{})

// See gtk_tree_store_set(); this version takes a va_list for
// use by language bindings.
func (x *TreeStore) SetValist(IterVar *TreeIter, VarArgsVar []interface{}) {

	xTreeStoreSetValist(x.GoPointer(), IterVar, VarArgsVar)

}

var xTreeStoreSetValue func(uintptr, *TreeIter, int, *gobject.Value)

// Sets the data in the cell specified by @iter and @column.
// The type of @value must be convertible to the type of the
// column.
func (x *TreeStore) SetValue(IterVar *TreeIter, ColumnVar int, ValueVar *gobject.Value) {

	xTreeStoreSetValue(x.GoPointer(), IterVar, ColumnVar, ValueVar)

}

var xTreeStoreSetValuesv func(uintptr, *TreeIter, []int, []gobject.Value, int)

// A variant of gtk_tree_store_set_valist() which takes
// the columns and values as two arrays, instead of varargs.  This
// function is mainly intended for language bindings or in case
// the number of columns to change is not known until run-time.
func (x *TreeStore) SetValuesv(IterVar *TreeIter, ColumnsVar []int, ValuesVar []gobject.Value, NValuesVar int) {

	xTreeStoreSetValuesv(x.GoPointer(), IterVar, ColumnsVar, ValuesVar, NValuesVar)

}

var xTreeStoreSwap func(uintptr, *TreeIter, *TreeIter)

// Swaps @a and @b in the same level of @tree_store. Note that this function
// only works with unsorted stores.
func (x *TreeStore) Swap(AVar *TreeIter, BVar *TreeIter) {

	xTreeStoreSwap(x.GoPointer(), AVar, BVar)

}

func (c *TreeStore) GoPointer() uintptr {
	return c.Ptr
}

func (c *TreeStore) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *TreeStore) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Asks the `GtkTreeDragDest` to insert a row before the path @dest,
// deriving the contents of the row from @value. If @dest is
// outside the tree so that inserting before it is impossible, %FALSE
// will be returned. Also, %FALSE may be returned if the new row is
// not created for some model-specific reason.  Should robustly handle
// a @dest no longer found in the model!
func (x *TreeStore) DragDataReceived(DestVar *TreePath, ValueVar *gobject.Value) bool {

	cret := XGtkTreeDragDestDragDataReceived(x.GoPointer(), DestVar, ValueVar)
	return cret
}

// Determines whether a drop is possible before the given @dest_path,
// at the same depth as @dest_path. i.e., can we drop the data in
// @value at that location. @dest_path does not have to
// exist; the return value will almost certainly be %FALSE if the
// parent of @dest_path doesn’t exist, though.
func (x *TreeStore) RowDropPossible(DestPathVar *TreePath, ValueVar *gobject.Value) bool {

	cret := XGtkTreeDragDestRowDropPossible(x.GoPointer(), DestPathVar, ValueVar)
	return cret
}

// Asks the `GtkTreeDragSource` to delete the row at @path, because
// it was moved somewhere else via drag-and-drop. Returns %FALSE
// if the deletion fails because @path no longer exists, or for
// some model-specific reason. Should robustly handle a @path no
// longer found in the model!
func (x *TreeStore) DragDataDelete(PathVar *TreePath) bool {

	cret := XGtkTreeDragSourceDragDataDelete(x.GoPointer(), PathVar)
	return cret
}

// Asks the `GtkTreeDragSource` to return a `GdkContentProvider` representing
// the row at @path. Should robustly handle a @path no
// longer found in the model!
func (x *TreeStore) DragDataGet(PathVar *TreePath) *gdk.ContentProvider {
	var cls *gdk.ContentProvider

	cret := XGtkTreeDragSourceDragDataGet(x.GoPointer(), PathVar)

	if cret == 0 {
		return nil
	}
	cls = &gdk.ContentProvider{}
	cls.Ptr = cret
	return cls
}

// Asks the `GtkTreeDragSource` whether a particular row can be used as
// the source of a DND operation. If the source doesn’t implement
// this interface, the row is assumed draggable.
func (x *TreeStore) RowDraggable(PathVar *TreePath) bool {

	cret := XGtkTreeDragSourceRowDraggable(x.GoPointer(), PathVar)
	return cret
}

// Creates a new `GtkTreeModel`, with @child_model as the child_model
// and @root as the virtual root.
func (x *TreeStore) FilterNew(RootVar *TreePath) *TreeModelBase {
	var cls *TreeModelBase

	cret := XGtkTreeModelFilterNew(x.GoPointer(), RootVar)

	if cret == 0 {
		return nil
	}
	cls = &TreeModelBase{}
	cls.Ptr = cret
	return cls
}

// Calls @func on each node in model in a depth-first fashion.
//
// If @func returns %TRUE, then the tree ceases to be walked,
// and gtk_tree_model_foreach() returns.
func (x *TreeStore) Foreach(FuncVar *TreeModelForeachFunc, UserDataVar uintptr) {

	XGtkTreeModelForeach(x.GoPointer(), glib.NewCallback(FuncVar), UserDataVar)

}

// Gets the value of one or more cells in the row referenced by @iter.
//
// The variable argument list should contain integer column numbers,
// each column number followed by a place to store the value being
// retrieved.  The list is terminated by a -1. For example, to get a
// value from column 0 with type %G_TYPE_STRING, you would
// write: `gtk_tree_model_get (model, iter, 0, &amp;place_string_here, -1)`,
// where `place_string_here` is a #gchararray
// to be filled with the string.
//
// Returned values with type %G_TYPE_OBJECT have to be unreferenced,
// values with type %G_TYPE_STRING or %G_TYPE_BOXED have to be freed.
// Other values are passed by value.
func (x *TreeStore) Get(IterVar *TreeIter, varArgs ...interface{}) {

	XGtkTreeModelGet(x.GoPointer(), IterVar, varArgs...)

}

// Returns the type of the column.
func (x *TreeStore) GetColumnType(IndexVar int) types.GType {

	cret := XGtkTreeModelGetColumnType(x.GoPointer(), IndexVar)
	return cret
}

// Returns a set of flags supported by this interface.
//
// The flags are a bitwise combination of `GtkTreeModel`Flags.
// The flags supported should not change during the lifetime
// of the @tree_model.
func (x *TreeStore) GetFlags() TreeModelFlags {

	cret := XGtkTreeModelGetFlags(x.GoPointer())
	return cret
}

// Sets @iter to a valid iterator pointing to @path.
//
// If @path does not exist, @iter is set to an invalid
// iterator and %FALSE is returned.
func (x *TreeStore) GetIter(IterVar *TreeIter, PathVar *TreePath) bool {

	cret := XGtkTreeModelGetIter(x.GoPointer(), IterVar, PathVar)
	return cret
}

// Initializes @iter with the first iterator in the tree
// (the one at the path "0").
//
// Returns %FALSE if the tree is empty, %TRUE otherwise.
func (x *TreeStore) GetIterFirst(IterVar *TreeIter) bool {

	cret := XGtkTreeModelGetIterFirst(x.GoPointer(), IterVar)
	return cret
}

// Sets @iter to a valid iterator pointing to @path_string, if it
// exists.
//
// Otherwise, @iter is left invalid and %FALSE is returned.
func (x *TreeStore) GetIterFromString(IterVar *TreeIter, PathStringVar string) bool {

	cret := XGtkTreeModelGetIterFromString(x.GoPointer(), IterVar, PathStringVar)
	return cret
}

// Returns the number of columns supported by @tree_model.
func (x *TreeStore) GetNColumns() int {

	cret := XGtkTreeModelGetNColumns(x.GoPointer())
	return cret
}

// Returns a newly-created `GtkTreePath` referenced by @iter.
//
// This path should be freed with gtk_tree_path_free().
func (x *TreeStore) GetPath(IterVar *TreeIter) *TreePath {

	cret := XGtkTreeModelGetPath(x.GoPointer(), IterVar)
	return cret
}

// Generates a string representation of the iter.
//
// This string is a “:” separated list of numbers.
// For example, “4:10:0:3” would be an acceptable
// return value for this string.
func (x *TreeStore) GetStringFromIter(IterVar *TreeIter) string {

	cret := XGtkTreeModelGetStringFromIter(x.GoPointer(), IterVar)
	return cret
}

// Gets the value of one or more cells in the row referenced by @iter.
//
// See [method@Gtk.TreeModel.get], this version takes a va_list
// for language bindings to use.
func (x *TreeStore) GetValist(IterVar *TreeIter, VarArgsVar []interface{}) {

	XGtkTreeModelGetValist(x.GoPointer(), IterVar, VarArgsVar)

}

// Initializes and sets @value to that at @column.
//
// When done with @value, g_value_unset() needs to be called
// to free any allocated memory.
func (x *TreeStore) GetValue(IterVar *TreeIter, ColumnVar int, ValueVar *gobject.Value) {

	XGtkTreeModelGetValue(x.GoPointer(), IterVar, ColumnVar, ValueVar)

}

// Sets @iter to point to the first child of @parent.
//
// If @parent has no children, %FALSE is returned and @iter is
// set to be invalid. @parent will remain a valid node after this
// function has been called.
//
// If @parent is %NULL returns the first node, equivalent to
// `gtk_tree_model_get_iter_first (tree_model, iter);`
func (x *TreeStore) IterChildren(IterVar *TreeIter, ParentVar *TreeIter) bool {

	cret := XGtkTreeModelIterChildren(x.GoPointer(), IterVar, ParentVar)
	return cret
}

// Returns %TRUE if @iter has children, %FALSE otherwise.
func (x *TreeStore) IterHasChild(IterVar *TreeIter) bool {

	cret := XGtkTreeModelIterHasChild(x.GoPointer(), IterVar)
	return cret
}

// Returns the number of children that @iter has.
//
// As a special case, if @iter is %NULL, then the number
// of toplevel nodes is returned.
func (x *TreeStore) IterNChildren(IterVar *TreeIter) int {

	cret := XGtkTreeModelIterNChildren(x.GoPointer(), IterVar)
	return cret
}

// Sets @iter to point to the node following it at the current level.
//
// If there is no next @iter, %FALSE is returned and @iter is set
// to be invalid.
func (x *TreeStore) IterNext(IterVar *TreeIter) bool {

	cret := XGtkTreeModelIterNext(x.GoPointer(), IterVar)
	return cret
}

// Sets @iter to be the child of @parent, using the given index.
//
// The first index is 0. If @n is too big, or @parent has no children,
// @iter is set to an invalid iterator and %FALSE is returned. @parent
// will remain a valid node after this function has been called. As a
// special case, if @parent is %NULL, then the @n-th root node
// is set.
func (x *TreeStore) IterNthChild(IterVar *TreeIter, ParentVar *TreeIter, NVar int) bool {

	cret := XGtkTreeModelIterNthChild(x.GoPointer(), IterVar, ParentVar, NVar)
	return cret
}

// Sets @iter to be the parent of @child.
//
// If @child is at the toplevel, and doesn’t have a parent, then
// @iter is set to an invalid iterator and %FALSE is returned.
// @child will remain a valid node after this function has been
// called.
//
// @iter will be initialized before the lookup is performed, so @child
// and @iter cannot point to the same memory location.
func (x *TreeStore) IterParent(IterVar *TreeIter, ChildVar *TreeIter) bool {

	cret := XGtkTreeModelIterParent(x.GoPointer(), IterVar, ChildVar)
	return cret
}

// Sets @iter to point to the previous node at the current level.
//
// If there is no previous @iter, %FALSE is returned and @iter is
// set to be invalid.
func (x *TreeStore) IterPrevious(IterVar *TreeIter) bool {

	cret := XGtkTreeModelIterPrevious(x.GoPointer(), IterVar)
	return cret
}

// Lets the tree ref the node.
//
// This is an optional method for models to implement.
// To be more specific, models may ignore this call as it exists
// primarily for performance reasons.
//
// This function is primarily meant as a way for views to let
// caching models know when nodes are being displayed (and hence,
// whether or not to cache that node). Being displayed means a node
// is in an expanded branch, regardless of whether the node is currently
// visible in the viewport. For example, a file-system based model
// would not want to keep the entire file-hierarchy in memory,
// just the sections that are currently being displayed by
// every current view.
//
// A model should be expected to be able to get an iter independent
// of its reffed state.
func (x *TreeStore) RefNode(IterVar *TreeIter) {

	XGtkTreeModelRefNode(x.GoPointer(), IterVar)

}

// Emits the ::row-changed signal on @tree_model.
//
// See [signal@Gtk.TreeModel::row-changed].
func (x *TreeStore) RowChanged(PathVar *TreePath, IterVar *TreeIter) {

	XGtkTreeModelRowChanged(x.GoPointer(), PathVar, IterVar)

}

// Emits the ::row-deleted signal on @tree_model.
//
// See [signal@Gtk.TreeModel::row-deleted].
//
// This should be called by models after a row has been removed.
// The location pointed to by @path should be the location that
// the row previously was at. It may not be a valid location anymore.
//
// Nodes that are deleted are not unreffed, this means that any
// outstanding references on the deleted node should not be released.
func (x *TreeStore) RowDeleted(PathVar *TreePath) {

	XGtkTreeModelRowDeleted(x.GoPointer(), PathVar)

}

// Emits the ::row-has-child-toggled signal on @tree_model.
//
// See [signal@Gtk.TreeModel::row-has-child-toggled].
//
// This should be called by models after the child
// state of a node changes.
func (x *TreeStore) RowHasChildToggled(PathVar *TreePath, IterVar *TreeIter) {

	XGtkTreeModelRowHasChildToggled(x.GoPointer(), PathVar, IterVar)

}

// Emits the ::row-inserted signal on @tree_model.
//
// See [signal@Gtk.TreeModel::row-inserted].
func (x *TreeStore) RowInserted(PathVar *TreePath, IterVar *TreeIter) {

	XGtkTreeModelRowInserted(x.GoPointer(), PathVar, IterVar)

}

// Emits the ::rows-reordered signal on @tree_model.
//
// See [signal@Gtk.TreeModel::rows-reordered].
//
// This should be called by models when their rows have been
// reordered.
func (x *TreeStore) RowsReordered(PathVar *TreePath, IterVar *TreeIter, NewOrderVar int) {

	XGtkTreeModelRowsReordered(x.GoPointer(), PathVar, IterVar, NewOrderVar)

}

// Emits the ::rows-reordered signal on @tree_model.
//
// See [signal@Gtk.TreeModel::rows-reordered].
//
// This should be called by models when their rows have been
// reordered.
func (x *TreeStore) RowsReorderedWithLength(PathVar *TreePath, IterVar *TreeIter, NewOrderVar []int, LengthVar int) {

	XGtkTreeModelRowsReorderedWithLength(x.GoPointer(), PathVar, IterVar, NewOrderVar, LengthVar)

}

// Lets the tree unref the node.
//
// This is an optional method for models to implement.
// To be more specific, models may ignore this call as it exists
// primarily for performance reasons. For more information on what
// this means, see gtk_tree_model_ref_node().
//
// Please note that nodes that are deleted are not unreffed.
func (x *TreeStore) UnrefNode(IterVar *TreeIter) {

	XGtkTreeModelUnrefNode(x.GoPointer(), IterVar)

}

// Fills in @sort_column_id and @order with the current sort column and the
// order. It returns %TRUE unless the @sort_column_id is
// %GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
// %GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
func (x *TreeStore) GetSortColumnId(SortColumnIdVar int, OrderVar *SortType) bool {

	cret := XGtkTreeSortableGetSortColumnId(x.GoPointer(), SortColumnIdVar, OrderVar)
	return cret
}

// Returns %TRUE if the model has a default sort function. This is used
// primarily by GtkTreeViewColumns in order to determine if a model can
// go back to the default state, or not.
func (x *TreeStore) HasDefaultSortFunc() bool {

	cret := XGtkTreeSortableHasDefaultSortFunc(x.GoPointer())
	return cret
}

// Sets the default comparison function used when sorting to be @sort_func.
// If the current sort column id of @sortable is
// %GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, then the model will sort using
// this function.
//
// If @sort_func is %NULL, then there will be no default comparison function.
// This means that once the model  has been sorted, it can’t go back to the
// default state. In this case, when the current sort column id of @sortable
// is %GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, the model will be unsorted.
func (x *TreeStore) SetDefaultSortFunc(SortFuncVar *TreeIterCompareFunc, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	XGtkTreeSortableSetDefaultSortFunc(x.GoPointer(), glib.NewCallback(SortFuncVar), UserDataVar, glib.NewCallback(DestroyVar))

}

// Sets the current sort column to be @sort_column_id. The @sortable will
// resort itself to reflect this change, after emitting a
// `GtkTreeSortable::sort-column-changed` signal. @sort_column_id may either be
// a regular column id, or one of the following special values:
//
//   - %GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function
//     will be used, if it is set
//
// - %GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur
func (x *TreeStore) SetSortColumnId(SortColumnIdVar int, OrderVar SortType) {

	XGtkTreeSortableSetSortColumnId(x.GoPointer(), SortColumnIdVar, OrderVar)

}

// Sets the comparison function used when sorting to be @sort_func. If the
// current sort column id of @sortable is the same as @sort_column_id, then
// the model will sort using this function.
func (x *TreeStore) SetSortFunc(SortColumnIdVar int, SortFuncVar *TreeIterCompareFunc, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	XGtkTreeSortableSetSortFunc(x.GoPointer(), SortColumnIdVar, glib.NewCallback(SortFuncVar), UserDataVar, glib.NewCallback(DestroyVar))

}

// Emits a `GtkTreeSortable::sort-column-changed` signal on @sortable.
func (x *TreeStore) SortColumnChanged() {

	XGtkTreeSortableSortColumnChanged(x.GoPointer())

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xTreeStoreGLibType, lib, "gtk_tree_store_get_type")

	core.PuregoSafeRegister(&xNewTreeStore, lib, "gtk_tree_store_new")
	core.PuregoSafeRegister(&xNewTreeStorev, lib, "gtk_tree_store_newv")

	core.PuregoSafeRegister(&xTreeStoreAppend, lib, "gtk_tree_store_append")
	core.PuregoSafeRegister(&xTreeStoreClear, lib, "gtk_tree_store_clear")
	core.PuregoSafeRegister(&xTreeStoreInsert, lib, "gtk_tree_store_insert")
	core.PuregoSafeRegister(&xTreeStoreInsertAfter, lib, "gtk_tree_store_insert_after")
	core.PuregoSafeRegister(&xTreeStoreInsertBefore, lib, "gtk_tree_store_insert_before")
	core.PuregoSafeRegister(&xTreeStoreInsertWithValues, lib, "gtk_tree_store_insert_with_values")
	core.PuregoSafeRegister(&xTreeStoreInsertWithValuesv, lib, "gtk_tree_store_insert_with_valuesv")
	core.PuregoSafeRegister(&xTreeStoreIsAncestor, lib, "gtk_tree_store_is_ancestor")
	core.PuregoSafeRegister(&xTreeStoreIterDepth, lib, "gtk_tree_store_iter_depth")
	core.PuregoSafeRegister(&xTreeStoreIterIsValid, lib, "gtk_tree_store_iter_is_valid")
	core.PuregoSafeRegister(&xTreeStoreMoveAfter, lib, "gtk_tree_store_move_after")
	core.PuregoSafeRegister(&xTreeStoreMoveBefore, lib, "gtk_tree_store_move_before")
	core.PuregoSafeRegister(&xTreeStorePrepend, lib, "gtk_tree_store_prepend")
	core.PuregoSafeRegister(&xTreeStoreRemove, lib, "gtk_tree_store_remove")
	core.PuregoSafeRegister(&xTreeStoreReorder, lib, "gtk_tree_store_reorder")
	core.PuregoSafeRegister(&xTreeStoreSet, lib, "gtk_tree_store_set")
	core.PuregoSafeRegister(&xTreeStoreSetColumnTypes, lib, "gtk_tree_store_set_column_types")
	core.PuregoSafeRegister(&xTreeStoreSetValist, lib, "gtk_tree_store_set_valist")
	core.PuregoSafeRegister(&xTreeStoreSetValue, lib, "gtk_tree_store_set_value")
	core.PuregoSafeRegister(&xTreeStoreSetValuesv, lib, "gtk_tree_store_set_valuesv")
	core.PuregoSafeRegister(&xTreeStoreSwap, lib, "gtk_tree_store_swap")

}
