// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type AlternativeTriggerClass struct {
}

func (x *AlternativeTriggerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type KeyvalTriggerClass struct {
}

func (x *KeyvalTriggerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type MnemonicTriggerClass struct {
}

func (x *MnemonicTriggerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type NeverTriggerClass struct {
}

func (x *NeverTriggerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type ShortcutTriggerClass struct {
}

func (x *ShortcutTriggerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A `GtkShortcutTrigger` that combines two triggers.
//
// The `GtkAlternativeTrigger` triggers when either of two trigger.
//
// This can be cascaded to combine more than two triggers.
type AlternativeTrigger struct {
	ShortcutTrigger
}

func AlternativeTriggerNewFromInternalPtr(ptr uintptr) *AlternativeTrigger {
	cls := &AlternativeTrigger{}
	cls.Ptr = ptr
	return cls
}

var xNewAlternativeTrigger func(uintptr, uintptr) uintptr

// Creates a `GtkShortcutTrigger` that will trigger whenever
// either of the two given triggers gets triggered.
//
// Note that nesting is allowed, so if you want more than two
// alternative, create a new alternative trigger for each option.
func NewAlternativeTrigger(FirstVar *ShortcutTrigger, SecondVar *ShortcutTrigger) *AlternativeTrigger {
	var cls *AlternativeTrigger

	cret := xNewAlternativeTrigger(FirstVar.GoPointer(), SecondVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &AlternativeTrigger{}
	cls.Ptr = cret
	return cls
}

var xAlternativeTriggerGetFirst func(uintptr) uintptr

// Gets the first of the two alternative triggers that may
// trigger @self.
//
// [method@Gtk.AlternativeTrigger.get_second] will return
// the other one.
func (x *AlternativeTrigger) GetFirst() *ShortcutTrigger {
	var cls *ShortcutTrigger

	cret := xAlternativeTriggerGetFirst(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ShortcutTrigger{}
	cls.Ptr = cret
	return cls
}

var xAlternativeTriggerGetSecond func(uintptr) uintptr

// Gets the second of the two alternative triggers that may
// trigger @self.
//
// [method@Gtk.AlternativeTrigger.get_first] will return
// the other one.
func (x *AlternativeTrigger) GetSecond() *ShortcutTrigger {
	var cls *ShortcutTrigger

	cret := xAlternativeTriggerGetSecond(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ShortcutTrigger{}
	cls.Ptr = cret
	return cls
}

func (c *AlternativeTrigger) GoPointer() uintptr {
	return c.Ptr
}

func (c *AlternativeTrigger) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A `GtkShortcutTrigger` that triggers when a specific keyval and modifiers are pressed.
type KeyvalTrigger struct {
	ShortcutTrigger
}

func KeyvalTriggerNewFromInternalPtr(ptr uintptr) *KeyvalTrigger {
	cls := &KeyvalTrigger{}
	cls.Ptr = ptr
	return cls
}

var xNewKeyvalTrigger func(uint, gdk.ModifierType) uintptr

// Creates a `GtkShortcutTrigger` that will trigger whenever
// the key with the given @keyval and @modifiers is pressed.
func NewKeyvalTrigger(KeyvalVar uint, ModifiersVar gdk.ModifierType) *KeyvalTrigger {
	var cls *KeyvalTrigger

	cret := xNewKeyvalTrigger(KeyvalVar, ModifiersVar)

	if cret == 0 {
		return nil
	}
	cls = &KeyvalTrigger{}
	cls.Ptr = cret
	return cls
}

var xKeyvalTriggerGetKeyval func(uintptr) uint

// Gets the keyval that must be pressed to succeed
// triggering @self.
func (x *KeyvalTrigger) GetKeyval() uint {

	cret := xKeyvalTriggerGetKeyval(x.GoPointer())
	return cret
}

var xKeyvalTriggerGetModifiers func(uintptr) gdk.ModifierType

// Gets the modifiers that must be present to succeed
// triggering @self.
func (x *KeyvalTrigger) GetModifiers() gdk.ModifierType {

	cret := xKeyvalTriggerGetModifiers(x.GoPointer())
	return cret
}

func (c *KeyvalTrigger) GoPointer() uintptr {
	return c.Ptr
}

func (c *KeyvalTrigger) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A `GtkShortcutTrigger` that triggers when a specific mnemonic is pressed.
//
// Mnemonics require a *mnemonic modifier* (typically &lt;kbd&gt;Alt&lt;/kbd&gt;) to be
// pressed together with the mnemonic key.
type MnemonicTrigger struct {
	ShortcutTrigger
}

func MnemonicTriggerNewFromInternalPtr(ptr uintptr) *MnemonicTrigger {
	cls := &MnemonicTrigger{}
	cls.Ptr = ptr
	return cls
}

var xNewMnemonicTrigger func(uint) uintptr

// Creates a `GtkShortcutTrigger` that will trigger whenever the key with
// the given @keyval is pressed and mnemonics have been activated.
//
// Mnemonics are activated by calling code when a key event with the right
// modifiers is detected.
func NewMnemonicTrigger(KeyvalVar uint) *MnemonicTrigger {
	var cls *MnemonicTrigger

	cret := xNewMnemonicTrigger(KeyvalVar)

	if cret == 0 {
		return nil
	}
	cls = &MnemonicTrigger{}
	cls.Ptr = cret
	return cls
}

var xMnemonicTriggerGetKeyval func(uintptr) uint

// Gets the keyval that must be pressed to succeed triggering @self.
func (x *MnemonicTrigger) GetKeyval() uint {

	cret := xMnemonicTriggerGetKeyval(x.GoPointer())
	return cret
}

func (c *MnemonicTrigger) GoPointer() uintptr {
	return c.Ptr
}

func (c *MnemonicTrigger) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A `GtkShortcutTrigger` that never triggers.
type NeverTrigger struct {
	ShortcutTrigger
}

func NeverTriggerNewFromInternalPtr(ptr uintptr) *NeverTrigger {
	cls := &NeverTrigger{}
	cls.Ptr = ptr
	return cls
}

func (c *NeverTrigger) GoPointer() uintptr {
	return c.Ptr
}

func (c *NeverTrigger) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

var xNeverTriggerGet func() uintptr

// Gets the never trigger.
//
// This is a singleton for a trigger that never triggers.
// Use this trigger instead of %NULL because it implements
// all virtual functions.
func NeverTriggerGet() *NeverTrigger {
	var cls *NeverTrigger

	cret := xNeverTriggerGet()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NeverTrigger{}
	cls.Ptr = cret
	return cls
}

// `GtkShortcutTrigger` tracks how a `GtkShortcut` should be activated.
//
// To find out if a `GtkShortcutTrigger` triggers, you can call
// [method@Gtk.ShortcutTrigger.trigger] on a `GdkEvent`.
//
// `GtkShortcutTriggers` contain functions that allow easy presentation
// to end users as well as being printed for debugging.
//
// All `GtkShortcutTriggers` are immutable, you can only specify their
// properties during construction. If you want to change a trigger, you
// have to replace it with a new one.
type ShortcutTrigger struct {
	gobject.Object
}

func ShortcutTriggerNewFromInternalPtr(ptr uintptr) *ShortcutTrigger {
	cls := &ShortcutTrigger{}
	cls.Ptr = ptr
	return cls
}

var xShortcutTriggerParseString func(string) uintptr

// Tries to parse the given string into a trigger.
//
// On success, the parsed trigger is returned.
// When parsing failed, %NULL is returned.
//
// The accepted strings are:
//
//   - `never`, for `GtkNeverTrigger`
//   - a string parsed by gtk_accelerator_parse(), for a `GtkKeyvalTrigger`, e.g. `&lt;Control&gt;C`
//   - underscore, followed by a single character, for `GtkMnemonicTrigger`, e.g. `_l`
//   - two valid trigger strings, separated by a `|` character, for a
//     `GtkAlternativeTrigger`: `&lt;Control&gt;q|&lt;Control&gt;w`
//
// Note that you will have to escape the `&lt;` and `&gt;` characters when specifying
// triggers in XML files, such as GtkBuilder ui files. Use `&amp;lt;` instead of
// `&lt;` and `&amp;gt;` instead of `&gt;`.
func ShortcutTriggerParseString(StringVar string) *ShortcutTrigger {
	var cls *ShortcutTrigger

	cret := xShortcutTriggerParseString(StringVar)

	if cret == 0 {
		return nil
	}
	cls = &ShortcutTrigger{}
	cls.Ptr = cret
	return cls
}

var xShortcutTriggerCompare func(uintptr, uintptr) int

// The types of @trigger1 and @trigger2 are `gconstpointer` only to allow
// use of this function as a `GCompareFunc`.
//
// They must each be a `GtkShortcutTrigger`.
func (x *ShortcutTrigger) Compare(Trigger2Var uintptr) int {

	cret := xShortcutTriggerCompare(x.GoPointer(), Trigger2Var)
	return cret
}

var xShortcutTriggerEqual func(uintptr, uintptr) bool

// Checks if @trigger1 and @trigger2 trigger under the same conditions.
//
// The types of @one and @two are `gconstpointer` only to allow use of this
// function with `GHashTable`. They must each be a `GtkShortcutTrigger`.
func (x *ShortcutTrigger) Equal(Trigger2Var uintptr) bool {

	cret := xShortcutTriggerEqual(x.GoPointer(), Trigger2Var)
	return cret
}

var xShortcutTriggerHash func(uintptr) uint

// Generates a hash value for a `GtkShortcutTrigger`.
//
// The output of this function is guaranteed to be the same for a given
// value only per-process. It may change between different processor
// architectures or even different versions of GTK. Do not use this
// function as a basis for building protocols or file formats.
//
// The types of @trigger is `gconstpointer` only to allow use of this
// function with `GHashTable`. They must each be a `GtkShortcutTrigger`.
func (x *ShortcutTrigger) Hash() uint {

	cret := xShortcutTriggerHash(x.GoPointer())
	return cret
}

var xShortcutTriggerPrint func(uintptr, *glib.String)

// Prints the given trigger into a string for the developer.
// This is meant for debugging and logging.
//
// The form of the representation may change at any time
// and is not guaranteed to stay identical.
func (x *ShortcutTrigger) Print(StringVar *glib.String) {

	xShortcutTriggerPrint(x.GoPointer(), StringVar)

}

var xShortcutTriggerPrintLabel func(uintptr, uintptr, *glib.String) bool

// Prints the given trigger into a string.
//
// This function is returning a translated string for presentation
// to end users for example in menu items or in help texts.
//
// The @display in use may influence the resulting string in
// various forms, such as resolving hardware keycodes or by
// causing display-specific modifier names.
//
// The form of the representation may change at any time and is
// not guaranteed to stay identical.
func (x *ShortcutTrigger) PrintLabel(DisplayVar *gdk.Display, StringVar *glib.String) bool {

	cret := xShortcutTriggerPrintLabel(x.GoPointer(), DisplayVar.GoPointer(), StringVar)
	return cret
}

var xShortcutTriggerToLabel func(uintptr, uintptr) string

// Gets textual representation for the given trigger.
//
// This function is returning a translated string for
// presentation to end users for example in menu items
// or in help texts.
//
// The @display in use may influence the resulting string in
// various forms, such as resolving hardware keycodes or by
// causing display-specific modifier names.
//
// The form of the representation may change at any time and is
// not guaranteed to stay identical.
func (x *ShortcutTrigger) ToLabel(DisplayVar *gdk.Display) string {

	cret := xShortcutTriggerToLabel(x.GoPointer(), DisplayVar.GoPointer())
	return cret
}

var xShortcutTriggerToString func(uintptr) string

// Prints the given trigger into a human-readable string.
//
// This is a small wrapper around [method@Gtk.ShortcutTrigger.print]
// to help when debugging.
func (x *ShortcutTrigger) ToString() string {

	cret := xShortcutTriggerToString(x.GoPointer())
	return cret
}

var xShortcutTriggerTrigger func(uintptr, uintptr, bool) gdk.KeyMatch

// Checks if the given @event triggers @self.
func (x *ShortcutTrigger) Trigger(EventVar *gdk.Event, EnableMnemonicsVar bool) gdk.KeyMatch {

	cret := xShortcutTriggerTrigger(x.GoPointer(), EventVar.GoPointer(), EnableMnemonicsVar)
	return cret
}

func (c *ShortcutTrigger) GoPointer() uintptr {
	return c.Ptr
}

func (c *ShortcutTrigger) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewAlternativeTrigger, lib, "gtk_alternative_trigger_new")

	core.PuregoSafeRegister(&xAlternativeTriggerGetFirst, lib, "gtk_alternative_trigger_get_first")
	core.PuregoSafeRegister(&xAlternativeTriggerGetSecond, lib, "gtk_alternative_trigger_get_second")

	core.PuregoSafeRegister(&xNewKeyvalTrigger, lib, "gtk_keyval_trigger_new")

	core.PuregoSafeRegister(&xKeyvalTriggerGetKeyval, lib, "gtk_keyval_trigger_get_keyval")
	core.PuregoSafeRegister(&xKeyvalTriggerGetModifiers, lib, "gtk_keyval_trigger_get_modifiers")

	core.PuregoSafeRegister(&xNewMnemonicTrigger, lib, "gtk_mnemonic_trigger_new")

	core.PuregoSafeRegister(&xMnemonicTriggerGetKeyval, lib, "gtk_mnemonic_trigger_get_keyval")

	core.PuregoSafeRegister(&xNeverTriggerGet, lib, "gtk_never_trigger_get")

	core.PuregoSafeRegister(&xShortcutTriggerParseString, lib, "gtk_shortcut_trigger_parse_string")

	core.PuregoSafeRegister(&xShortcutTriggerCompare, lib, "gtk_shortcut_trigger_compare")
	core.PuregoSafeRegister(&xShortcutTriggerEqual, lib, "gtk_shortcut_trigger_equal")
	core.PuregoSafeRegister(&xShortcutTriggerHash, lib, "gtk_shortcut_trigger_hash")
	core.PuregoSafeRegister(&xShortcutTriggerPrint, lib, "gtk_shortcut_trigger_print")
	core.PuregoSafeRegister(&xShortcutTriggerPrintLabel, lib, "gtk_shortcut_trigger_print_label")
	core.PuregoSafeRegister(&xShortcutTriggerToLabel, lib, "gtk_shortcut_trigger_to_label")
	core.PuregoSafeRegister(&xShortcutTriggerToString, lib, "gtk_shortcut_trigger_to_string")
	core.PuregoSafeRegister(&xShortcutTriggerTrigger, lib, "gtk_shortcut_trigger_trigger")

}
