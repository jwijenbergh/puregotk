// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type GestureClickClass struct {
}

func (x *GestureClickClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GtkGestureClick` is a `GtkGesture` implementation for clicks.
//
// It is able to recognize multiple clicks on a nearby zone, which
// can be listened for through the [signal@Gtk.GestureClick::pressed]
// signal. Whenever time or distance between clicks exceed the GTK
// defaults, [signal@Gtk.GestureClick::stopped] is emitted, and the
// click counter is reset.
type GestureClick struct {
	GestureSingle
}

var xGestureClickGLibType func() types.GType

func GestureClickGLibType() types.GType {
	return xGestureClickGLibType()
}

func GestureClickNewFromInternalPtr(ptr uintptr) *GestureClick {
	cls := &GestureClick{}
	cls.Ptr = ptr
	return cls
}

var xNewGestureClick func() uintptr

// Returns a newly created `GtkGesture` that recognizes
// single and multiple presses.
func NewGestureClick() *GestureClick {
	var cls *GestureClick

	cret := xNewGestureClick()

	if cret == 0 {
		return nil
	}
	cls = &GestureClick{}
	cls.Ptr = cret
	return cls
}

func (c *GestureClick) GoPointer() uintptr {
	return c.Ptr
}

func (c *GestureClick) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted whenever a button or touch press happens.
func (x *GestureClick) ConnectPressed(cb *func(GestureClick, int, float64, float64)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "pressed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, NPressVarp int, XVarp float64, YVarp float64) {
		fa := GestureClick{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, NPressVarp, XVarp, YVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "pressed", cbRefPtr)
}

// Emitted when a button or touch is released.
//
// @n_press will report the number of press that is paired to
// this event, note that [signal@Gtk.GestureClick::stopped] may
// have been emitted between the press and its release, @n_press
// will only start over at the next press.
func (x *GestureClick) ConnectReleased(cb *func(GestureClick, int, float64, float64)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "released", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, NPressVarp int, XVarp float64, YVarp float64) {
		fa := GestureClick{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, NPressVarp, XVarp, YVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "released", cbRefPtr)
}

// Emitted whenever any time/distance threshold has been exceeded.
func (x *GestureClick) ConnectStopped(cb *func(GestureClick)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "stopped", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := GestureClick{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "stopped", cbRefPtr)
}

// Emitted whenever the gesture receives a release
// event that had no previous corresponding press.
//
// Due to implicit grabs, this can only happen on situations
// where input is grabbed elsewhere mid-press or the pressed
// widget voluntarily relinquishes its implicit grab.
func (x *GestureClick) ConnectUnpairedRelease(cb *func(GestureClick, float64, float64, uint, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "unpaired-release", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, XVarp float64, YVarp float64, ButtonVarp uint, SequenceVarp uintptr) {
		fa := GestureClick{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, XVarp, YVarp, ButtonVarp, SequenceVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "unpaired-release", cbRefPtr)
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xGestureClickGLibType, lib, "gtk_gesture_click_get_type")

	core.PuregoSafeRegister(&xNewGestureClick, lib, "gtk_gesture_click_new")

}
