// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// `GtkExpander` allows the user to reveal its child by clicking
// on an expander triangle.
//
// ![An example GtkExpander](expander.png)
//
// This is similar to the triangles used in a `GtkTreeView`.
//
// Normally you use an expander as you would use a frame; you create
// the child widget and use [method@Gtk.Expander.set_child] to add it
// to the expander. When the expander is toggled, it will take care of
// showing and hiding the child automatically.
//
// # Special Usage
//
// There are situations in which you may prefer to show and hide the
// expanded widget yourself, such as when you want to actually create
// the widget at expansion time. In this case, create a `GtkExpander`
// but do not add a child to it. The expander widget has an
// [property@Gtk.Expander:expanded[ property which can be used to
// monitor its expansion state. You should watch this property with
// a signal connection as follows:
//
// ```c
// static void
// expander_callback (GObject    *object,
//
//	GParamSpec *param_spec,
//	gpointer    user_data)
//
//	{
//	  GtkExpander *expander;
//
//	  expander = GTK_EXPANDER (object);
//
//	  if (gtk_expander_get_expanded (expander))
//	    {
//	      // Show or create widgets
//	    }
//	  else
//	    {
//	      // Hide or destroy widgets
//	    }
//	}
//
// static void
// create_expander (void)
//
//	{
//	  GtkWidget *expander = gtk_expander_new_with_mnemonic ("_More Options");
//	  g_signal_connect (expander, "notify::expanded",
//	                    G_CALLBACK (expander_callback), NULL);
//
//	  // ...
//	}
//
// ```
//
// # GtkExpander as GtkBuildable
//
// The `GtkExpander` implementation of the `GtkBuildable` interface supports
// placing a child in the label position by specifying “label” as the
// “type” attribute of a &lt;child&gt; element. A normal content child can be
// specified without specifying a &lt;child&gt; type attribute.
//
// An example of a UI definition fragment with GtkExpander:
//
// ```xml
// &lt;object class="GtkExpander"&gt;
//
//	&lt;child type="label"&gt;
//	  &lt;object class="GtkLabel" id="expander-label"/&gt;
//	&lt;/child&gt;
//	&lt;child&gt;
//	  &lt;object class="GtkEntry" id="expander-content"/&gt;
//	&lt;/child&gt;
//
// &lt;/object&gt;
// ```
//
// # CSS nodes
//
// ```
// expander
// ╰── box
//
//	├── title
//	│   ├── arrow
//	│   ╰── &lt;label widget&gt;
//	╰── &lt;child&gt;
//
// ```
//
// `GtkExpander` has three CSS nodes, the main node with the name expander,
// a subnode with name title and node below it with name arrow. The arrow of an
// expander that is showing its child gets the :checked pseudoclass added to it.
//
// # Accessibility
//
// `GtkExpander` uses the %GTK_ACCESSIBLE_ROLE_BUTTON role.
type Expander struct {
	Widget
}

func ExpanderNewFromInternalPtr(ptr uintptr) *Expander {
	cls := &Expander{}
	cls.Ptr = ptr
	return cls
}

var xNewExpander func(string) uintptr

// Creates a new expander using @label as the text of the label.
func NewExpander(LabelVar string) *Expander {
	var cls *Expander

	cret := xNewExpander(LabelVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Expander{}
	cls.Ptr = cret
	return cls
}

var xNewExpanderWithMnemonic func(string) uintptr

// Creates a new expander using @label as the text of the label.
//
// If characters in @label are preceded by an underscore, they are
// underlined. If you need a literal underscore character in a label,
// use “__” (two underscores). The first underlined character represents
// a keyboard accelerator called a mnemonic.
//
// Pressing Alt and that key activates the button.
func NewExpanderWithMnemonic(LabelVar string) *Expander {
	var cls *Expander

	cret := xNewExpanderWithMnemonic(LabelVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Expander{}
	cls.Ptr = cret
	return cls
}

var xExpanderGetChild func(uintptr) uintptr

// Gets the child widget of @expander.
func (x *Expander) GetChild() *Widget {
	var cls *Widget

	cret := xExpanderGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xExpanderGetExpanded func(uintptr) bool

// Queries a `GtkExpander` and returns its current state.
//
// Returns %TRUE if the child widget is revealed.
func (x *Expander) GetExpanded() bool {

	cret := xExpanderGetExpanded(x.GoPointer())
	return cret
}

var xExpanderGetLabel func(uintptr) string

// Fetches the text from a label widget.
//
// This is including any embedded underlines indicating mnemonics and
// Pango markup, as set by [method@Gtk.Expander.set_label]. If the label
// text has not been set the return value will be %NULL. This will be the
// case if you create an empty button with gtk_button_new() to use as a
// container.
func (x *Expander) GetLabel() string {

	cret := xExpanderGetLabel(x.GoPointer())
	return cret
}

var xExpanderGetLabelWidget func(uintptr) uintptr

// Retrieves the label widget for the frame.
func (x *Expander) GetLabelWidget() *Widget {
	var cls *Widget

	cret := xExpanderGetLabelWidget(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xExpanderGetResizeToplevel func(uintptr) bool

// Returns whether the expander will resize the toplevel widget
// containing the expander upon resizing and collpasing.
func (x *Expander) GetResizeToplevel() bool {

	cret := xExpanderGetResizeToplevel(x.GoPointer())
	return cret
}

var xExpanderGetUseMarkup func(uintptr) bool

// Returns whether the label’s text is interpreted as Pango markup.
func (x *Expander) GetUseMarkup() bool {

	cret := xExpanderGetUseMarkup(x.GoPointer())
	return cret
}

var xExpanderGetUseUnderline func(uintptr) bool

// Returns whether an underline in the text indicates a mnemonic.
func (x *Expander) GetUseUnderline() bool {

	cret := xExpanderGetUseUnderline(x.GoPointer())
	return cret
}

var xExpanderSetChild func(uintptr, uintptr)

// Sets the child widget of @expander.
func (x *Expander) SetChild(ChildVar *Widget) {

	xExpanderSetChild(x.GoPointer(), ChildVar.GoPointer())

}

var xExpanderSetExpanded func(uintptr, bool)

// Sets the state of the expander.
//
// Set to %TRUE, if you want the child widget to be revealed,
// and %FALSE if you want the child widget to be hidden.
func (x *Expander) SetExpanded(ExpandedVar bool) {

	xExpanderSetExpanded(x.GoPointer(), ExpandedVar)

}

var xExpanderSetLabel func(uintptr, string)

// Sets the text of the label of the expander to @label.
//
// This will also clear any previously set labels.
func (x *Expander) SetLabel(LabelVar string) {

	xExpanderSetLabel(x.GoPointer(), LabelVar)

}

var xExpanderSetLabelWidget func(uintptr, uintptr)

// Set the label widget for the expander.
//
// This is the widget that will appear embedded alongside
// the expander arrow.
func (x *Expander) SetLabelWidget(LabelWidgetVar *Widget) {

	xExpanderSetLabelWidget(x.GoPointer(), LabelWidgetVar.GoPointer())

}

var xExpanderSetResizeToplevel func(uintptr, bool)

// Sets whether the expander will resize the toplevel widget
// containing the expander upon resizing and collpasing.
func (x *Expander) SetResizeToplevel(ResizeToplevelVar bool) {

	xExpanderSetResizeToplevel(x.GoPointer(), ResizeToplevelVar)

}

var xExpanderSetUseMarkup func(uintptr, bool)

// Sets whether the text of the label contains Pango markup.
func (x *Expander) SetUseMarkup(UseMarkupVar bool) {

	xExpanderSetUseMarkup(x.GoPointer(), UseMarkupVar)

}

var xExpanderSetUseUnderline func(uintptr, bool)

// If true, an underline in the text indicates a mnemonic.
func (x *Expander) SetUseUnderline(UseUnderlineVar bool) {

	xExpanderSetUseUnderline(x.GoPointer(), UseUnderlineVar)

}

func (c *Expander) GoPointer() uintptr {
	return c.Ptr
}

func (c *Expander) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Activates the `GtkExpander`.
func (x *Expander) ConnectActivate(cb *func(Expander)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Expander{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *Expander) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *Expander) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *Expander) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *Expander) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *Expander) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Expander) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *Expander) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Expander) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *Expander) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *Expander) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *Expander) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewExpander, lib, "gtk_expander_new")
	core.PuregoSafeRegister(&xNewExpanderWithMnemonic, lib, "gtk_expander_new_with_mnemonic")

	core.PuregoSafeRegister(&xExpanderGetChild, lib, "gtk_expander_get_child")
	core.PuregoSafeRegister(&xExpanderGetExpanded, lib, "gtk_expander_get_expanded")
	core.PuregoSafeRegister(&xExpanderGetLabel, lib, "gtk_expander_get_label")
	core.PuregoSafeRegister(&xExpanderGetLabelWidget, lib, "gtk_expander_get_label_widget")
	core.PuregoSafeRegister(&xExpanderGetResizeToplevel, lib, "gtk_expander_get_resize_toplevel")
	core.PuregoSafeRegister(&xExpanderGetUseMarkup, lib, "gtk_expander_get_use_markup")
	core.PuregoSafeRegister(&xExpanderGetUseUnderline, lib, "gtk_expander_get_use_underline")
	core.PuregoSafeRegister(&xExpanderSetChild, lib, "gtk_expander_set_child")
	core.PuregoSafeRegister(&xExpanderSetExpanded, lib, "gtk_expander_set_expanded")
	core.PuregoSafeRegister(&xExpanderSetLabel, lib, "gtk_expander_set_label")
	core.PuregoSafeRegister(&xExpanderSetLabelWidget, lib, "gtk_expander_set_label_widget")
	core.PuregoSafeRegister(&xExpanderSetResizeToplevel, lib, "gtk_expander_set_resize_toplevel")
	core.PuregoSafeRegister(&xExpanderSetUseMarkup, lib, "gtk_expander_set_use_markup")
	core.PuregoSafeRegister(&xExpanderSetUseUnderline, lib, "gtk_expander_set_use_underline")

}
