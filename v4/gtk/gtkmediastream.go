// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type MediaStreamClass struct {
	ParentClass uintptr
}

func (x *MediaStreamClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GtkMediaStream` is the integration point for media playback inside GTK.
//
// GTK provides an implementation of the `GtkMediaStream` interface that
// is called [class@Gtk.MediaFile].
//
// Apart from application-facing API for stream playback, `GtkMediaStream`
// has a number of APIs that are only useful for implementations and should
// not be used in applications:
// [method@Gtk.MediaStream.prepared],
// [method@Gtk.MediaStream.unprepared],
// [method@Gtk.MediaStream.update],
// [method@Gtk.MediaStream.ended],
// [method@Gtk.MediaStream.seek_success],
// [method@Gtk.MediaStream.seek_failed],
// [method@Gtk.MediaStream.gerror],
// [method@Gtk.MediaStream.error],
// [method@Gtk.MediaStream.error_valist].
type MediaStream struct {
	gobject.Object
}

func MediaStreamNewFromInternalPtr(ptr uintptr) *MediaStream {
	cls := &MediaStream{}
	cls.Ptr = ptr
	return cls
}

var xMediaStreamEnded func(uintptr)

// Pauses the media stream and marks it as ended.
//
// This is a hint only, calls to [method@Gtk.MediaStream.play]
// may still happen.
//
// The media stream must be prepared when this function is called.
func (x *MediaStream) Ended() {

	xMediaStreamEnded(x.GoPointer())

}

var xMediaStreamError func(uintptr, glib.Quark, int, string, ...interface{})

// Sets @self into an error state using a printf()-style format string.
//
// This is a utility function that calls [method@Gtk.MediaStream.gerror].
// See that function for details.
func (x *MediaStream) Error(DomainVar glib.Quark, CodeVar int, FormatVar string, varArgs ...interface{}) {

	xMediaStreamError(x.GoPointer(), DomainVar, CodeVar, FormatVar, varArgs...)

}

var xMediaStreamErrorValist func(uintptr, glib.Quark, int, string, []interface{})

// Sets @self into an error state using a printf()-style format string.
//
// This is a utility function that calls [method@Gtk.MediaStream.gerror].
// See that function for details.
func (x *MediaStream) ErrorValist(DomainVar glib.Quark, CodeVar int, FormatVar string, ArgsVar []interface{}) {

	xMediaStreamErrorValist(x.GoPointer(), DomainVar, CodeVar, FormatVar, ArgsVar)

}

var xMediaStreamGerror func(uintptr, *glib.Error)

// Sets @self into an error state.
//
// This will pause the stream (you can check for an error
// via [method@Gtk.MediaStream.get_error] in your
// GtkMediaStream.pause() implementation), abort pending
// seeks and mark the stream as prepared.
//
// if the stream is already in an error state, this call
// will be ignored and the existing error will be retained.
//
// To unset an error, the stream must be reset via a call to
// [method@Gtk.MediaStream.unprepared].
func (x *MediaStream) Gerror(ErrorVar *glib.Error) {

	xMediaStreamGerror(x.GoPointer(), ErrorVar)

}

var xMediaStreamGetDuration func(uintptr) int64

// Gets the duration of the stream.
//
// If the duration is not known, 0 will be returned.
func (x *MediaStream) GetDuration() int64 {

	cret := xMediaStreamGetDuration(x.GoPointer())
	return cret
}

var xMediaStreamGetEnded func(uintptr) bool

// Returns whether the streams playback is finished.
func (x *MediaStream) GetEnded() bool {

	cret := xMediaStreamGetEnded(x.GoPointer())
	return cret
}

var xMediaStreamGetError func(uintptr) *glib.Error

// If the stream is in an error state, returns the `GError`
// explaining that state.
//
// Any type of error can be reported here depending on the
// implementation of the media stream.
//
// A media stream in an error cannot be operated on, calls
// like [method@Gtk.MediaStream.play] or
// [method@Gtk.MediaStream.seek] will not have any effect.
//
// `GtkMediaStream` itself does not provide a way to unset
// an error, but implementations may provide options. For example,
// a [class@Gtk.MediaFile] will unset errors when a new source is
// set, e.g. with [method@Gtk.MediaFile.set_file].
func (x *MediaStream) GetError() *glib.Error {

	cret := xMediaStreamGetError(x.GoPointer())
	return cret
}

var xMediaStreamGetLoop func(uintptr) bool

// Returns whether the stream is set to loop.
//
// See [method@Gtk.MediaStream.set_loop] for details.
func (x *MediaStream) GetLoop() bool {

	cret := xMediaStreamGetLoop(x.GoPointer())
	return cret
}

var xMediaStreamGetMuted func(uintptr) bool

// Returns whether the audio for the stream is muted.
//
// See [method@Gtk.MediaStream.set_muted] for details.
func (x *MediaStream) GetMuted() bool {

	cret := xMediaStreamGetMuted(x.GoPointer())
	return cret
}

var xMediaStreamGetPlaying func(uintptr) bool

// Return whether the stream is currently playing.
func (x *MediaStream) GetPlaying() bool {

	cret := xMediaStreamGetPlaying(x.GoPointer())
	return cret
}

var xMediaStreamGetTimestamp func(uintptr) int64

// Returns the current presentation timestamp in microseconds.
func (x *MediaStream) GetTimestamp() int64 {

	cret := xMediaStreamGetTimestamp(x.GoPointer())
	return cret
}

var xMediaStreamGetVolume func(uintptr) float64

// Returns the volume of the audio for the stream.
//
// See [method@Gtk.MediaStream.set_volume] for details.
func (x *MediaStream) GetVolume() float64 {

	cret := xMediaStreamGetVolume(x.GoPointer())
	return cret
}

var xMediaStreamHasAudio func(uintptr) bool

// Returns whether the stream has audio.
func (x *MediaStream) HasAudio() bool {

	cret := xMediaStreamHasAudio(x.GoPointer())
	return cret
}

var xMediaStreamHasVideo func(uintptr) bool

// Returns whether the stream has video.
func (x *MediaStream) HasVideo() bool {

	cret := xMediaStreamHasVideo(x.GoPointer())
	return cret
}

var xMediaStreamIsPrepared func(uintptr) bool

// Returns whether the stream has finished initializing.
//
// At this point the existence of audio and video is known.
func (x *MediaStream) IsPrepared() bool {

	cret := xMediaStreamIsPrepared(x.GoPointer())
	return cret
}

var xMediaStreamIsSeekable func(uintptr) bool

// Checks if a stream may be seekable.
//
// This is meant to be a hint. Streams may not allow seeking even if
// this function returns %TRUE. However, if this function returns
// %FALSE, streams are guaranteed to not be seekable and user interfaces
// may hide controls that allow seeking.
//
// It is allowed to call [method@Gtk.MediaStream.seek] on a non-seekable
// stream, though it will not do anything.
func (x *MediaStream) IsSeekable() bool {

	cret := xMediaStreamIsSeekable(x.GoPointer())
	return cret
}

var xMediaStreamIsSeeking func(uintptr) bool

// Checks if there is currently a seek operation going on.
func (x *MediaStream) IsSeeking() bool {

	cret := xMediaStreamIsSeeking(x.GoPointer())
	return cret
}

var xMediaStreamPause func(uintptr)

// Pauses playback of the stream.
//
// If the stream is not playing, do nothing.
func (x *MediaStream) Pause() {

	xMediaStreamPause(x.GoPointer())

}

var xMediaStreamPlay func(uintptr)

// Starts playing the stream.
//
// If the stream is in error or already playing, do nothing.
func (x *MediaStream) Play() {

	xMediaStreamPlay(x.GoPointer())

}

var xMediaStreamPrepared func(uintptr, bool, bool, bool, int64)

// Same as gtk_media_stream_stream_prepared().
func (x *MediaStream) Prepared(HasAudioVar bool, HasVideoVar bool, SeekableVar bool, DurationVar int64) {

	xMediaStreamPrepared(x.GoPointer(), HasAudioVar, HasVideoVar, SeekableVar, DurationVar)

}

var xMediaStreamRealize func(uintptr, uintptr)

// Called by users to attach the media stream to a `GdkSurface` they manage.
//
// The stream can then access the resources of @surface for its
// rendering purposes. In particular, media streams might want to
// create a `GdkGLContext` or sync to the `GdkFrameClock`.
//
// Whoever calls this function is responsible for calling
// [method@Gtk.MediaStream.unrealize] before either the stream
// or @surface get destroyed.
//
// Multiple calls to this function may happen from different
// users of the video, even with the same @surface. Each of these
// calls must be followed by its own call to
// [method@Gtk.MediaStream.unrealize].
//
// It is not required to call this function to make a media stream work.
func (x *MediaStream) Realize(SurfaceVar *gdk.Surface) {

	xMediaStreamRealize(x.GoPointer(), SurfaceVar.GoPointer())

}

var xMediaStreamSeek func(uintptr, int64)

// Start a seek operation on @self to @timestamp.
//
// If @timestamp is out of range, it will be clamped.
//
// Seek operations may not finish instantly. While a
// seek operation is in process, the [property@Gtk.MediaStream:seeking]
// property will be set.
//
// When calling gtk_media_stream_seek() during an
// ongoing seek operation, the new seek will override
// any pending seek.
func (x *MediaStream) Seek(TimestampVar int64) {

	xMediaStreamSeek(x.GoPointer(), TimestampVar)

}

var xMediaStreamSeekFailed func(uintptr)

// Ends a seek operation started via GtkMediaStream.seek() as a failure.
//
// This will not cause an error on the stream and will assume that
// playback continues as if no seek had happened.
//
// See [method@Gtk.MediaStream.seek_success] for the other way of
// ending a seek.
func (x *MediaStream) SeekFailed() {

	xMediaStreamSeekFailed(x.GoPointer())

}

var xMediaStreamSeekSuccess func(uintptr)

// Ends a seek operation started via GtkMediaStream.seek() successfully.
//
// This function will unset the GtkMediaStream:ended property
// if it was set.
//
// See [method@Gtk.MediaStream.seek_failed] for the other way of
// ending a seek.
func (x *MediaStream) SeekSuccess() {

	xMediaStreamSeekSuccess(x.GoPointer())

}

var xMediaStreamSetLoop func(uintptr, bool)

// Sets whether the stream should loop.
//
// In this case, it will attempt to restart playback
// from the beginning instead of stopping at the end.
//
// Not all streams may support looping, in particular
// non-seekable streams. Those streams will ignore the
// loop setting and just end.
func (x *MediaStream) SetLoop(LoopVar bool) {

	xMediaStreamSetLoop(x.GoPointer(), LoopVar)

}

var xMediaStreamSetMuted func(uintptr, bool)

// Sets whether the audio stream should be muted.
//
// Muting a stream will cause no audio to be played, but it
// does not modify the volume. This means that muting and
// then unmuting the stream will restore the volume settings.
//
// If the stream has no audio, calling this function will
// still work but it will not have an audible effect.
func (x *MediaStream) SetMuted(MutedVar bool) {

	xMediaStreamSetMuted(x.GoPointer(), MutedVar)

}

var xMediaStreamSetPlaying func(uintptr, bool)

// Starts or pauses playback of the stream.
func (x *MediaStream) SetPlaying(PlayingVar bool) {

	xMediaStreamSetPlaying(x.GoPointer(), PlayingVar)

}

var xMediaStreamSetVolume func(uintptr, float64)

// Sets the volume of the audio stream.
//
// This function call will work even if the stream is muted.
//
// The given @volume should range from 0.0 for silence to 1.0
// for as loud as possible. Values outside of this range will
// be clamped to the nearest value.
//
// If the stream has no audio or is muted, calling this function
// will still work but it will not have an immediate audible effect.
// When the stream is unmuted, the new volume setting will take effect.
func (x *MediaStream) SetVolume(VolumeVar float64) {

	xMediaStreamSetVolume(x.GoPointer(), VolumeVar)

}

var xMediaStreamStreamEnded func(uintptr)

// Pauses the media stream and marks it as ended.
//
// This is a hint only, calls to [method@Gtk.MediaStream.play]
// may still happen.
//
// The media stream must be prepared when this function is called.
func (x *MediaStream) StreamEnded() {

	xMediaStreamStreamEnded(x.GoPointer())

}

var xMediaStreamStreamPrepared func(uintptr, bool, bool, bool, int64)

// Called by `GtkMediaStream` implementations to advertise the stream
// being ready to play and providing details about the stream.
//
// Note that the arguments are hints. If the stream implementation
// cannot determine the correct values, it is better to err on the
// side of caution and return %TRUE. User interfaces will use those
// values to determine what controls to show.
//
// This function may not be called again until the stream has been
// reset via [method@Gtk.MediaStream.stream_unprepared].
func (x *MediaStream) StreamPrepared(HasAudioVar bool, HasVideoVar bool, SeekableVar bool, DurationVar int64) {

	xMediaStreamStreamPrepared(x.GoPointer(), HasAudioVar, HasVideoVar, SeekableVar, DurationVar)

}

var xMediaStreamStreamUnprepared func(uintptr)

// Resets a given media stream implementation.
//
// [method@Gtk.MediaStream.stream_prepared] can then be called again.
//
// This function will also reset any error state the stream was in.
func (x *MediaStream) StreamUnprepared() {

	xMediaStreamStreamUnprepared(x.GoPointer())

}

var xMediaStreamUnprepared func(uintptr)

// Same as gtk_media_stream_stream_unprepared().
func (x *MediaStream) Unprepared() {

	xMediaStreamUnprepared(x.GoPointer())

}

var xMediaStreamUnrealize func(uintptr, uintptr)

// Undoes a previous call to gtk_media_stream_realize().
//
// This causes the stream to release all resources it had
// allocated from @surface.
func (x *MediaStream) Unrealize(SurfaceVar *gdk.Surface) {

	xMediaStreamUnrealize(x.GoPointer(), SurfaceVar.GoPointer())

}

var xMediaStreamUpdate func(uintptr, int64)

// Media stream implementations should regularly call this
// function to update the timestamp reported by the stream.
//
// It is up to implementations to call this at the frequency
// they deem appropriate.
//
// The media stream must be prepared when this function is called.
func (x *MediaStream) Update(TimestampVar int64) {

	xMediaStreamUpdate(x.GoPointer(), TimestampVar)

}

func (c *MediaStream) GoPointer() uintptr {
	return c.Ptr
}

func (c *MediaStream) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Compute a concrete size for the `GdkPaintable`.
//
// Applies the sizing algorithm outlined in the
// [CSS Image spec](https://drafts.csswg.org/css-images-3/#default-sizing)
// to the given @paintable. See that link for more details.
//
// It is not necessary to call this function when both @specified_width
// and @specified_height are known, but it is useful to call this
// function in GtkWidget:measure implementations to compute the
// other dimension when only one dimension is given.
func (x *MediaStream) ComputeConcreteSize(SpecifiedWidthVar float64, SpecifiedHeightVar float64, DefaultWidthVar float64, DefaultHeightVar float64, ConcreteWidthVar float64, ConcreteHeightVar float64) {

	gdk.XGdkPaintableComputeConcreteSize(x.GoPointer(), SpecifiedWidthVar, SpecifiedHeightVar, DefaultWidthVar, DefaultHeightVar, ConcreteWidthVar, ConcreteHeightVar)

}

// Gets an immutable paintable for the current contents displayed by @paintable.
//
// This is useful when you want to retain the current state of an animation,
// for example to take a screenshot of a running animation.
//
// If the @paintable is already immutable, it will return itself.
func (x *MediaStream) GetCurrentImage() *gdk.PaintableBase {
	var cls *gdk.PaintableBase

	cret := gdk.XGdkPaintableGetCurrentImage(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gdk.PaintableBase{}
	cls.Ptr = cret
	return cls
}

// Get flags for the paintable.
//
// This is oftentimes useful for optimizations.
//
// See [flags@Gdk.PaintableFlags] for the flags and what they mean.
func (x *MediaStream) GetFlags() gdk.PaintableFlags {

	cret := gdk.XGdkPaintableGetFlags(x.GoPointer())
	return cret
}

// Gets the preferred aspect ratio the @paintable would like to be displayed at.
//
// The aspect ratio is the width divided by the height, so a value of 0.5
// means that the @paintable prefers to be displayed twice as high as it
// is wide. Consumers of this interface can use this to preserve aspect
// ratio when displaying the paintable.
//
// This is a purely informational value and does not in any way limit the
// values that may be passed to [method@Gdk.Paintable.snapshot].
//
// Usually when a @paintable returns nonzero values from
// [method@Gdk.Paintable.get_intrinsic_width] and
// [method@Gdk.Paintable.get_intrinsic_height] the aspect ratio
// should conform to those values, though that is not required.
//
// If the @paintable does not have a preferred aspect ratio,
// it returns 0. Negative values are never returned.
func (x *MediaStream) GetIntrinsicAspectRatio() float64 {

	cret := gdk.XGdkPaintableGetIntrinsicAspectRatio(x.GoPointer())
	return cret
}

// Gets the preferred height the @paintable would like to be displayed at.
//
// Consumers of this interface can use this to reserve enough space to draw
// the paintable.
//
// This is a purely informational value and does not in any way limit the
// values that may be passed to [method@Gdk.Paintable.snapshot].
//
// If the @paintable does not have a preferred height, it returns 0.
// Negative values are never returned.
func (x *MediaStream) GetIntrinsicHeight() int {

	cret := gdk.XGdkPaintableGetIntrinsicHeight(x.GoPointer())
	return cret
}

// Gets the preferred width the @paintable would like to be displayed at.
//
// Consumers of this interface can use this to reserve enough space to draw
// the paintable.
//
// This is a purely informational value and does not in any way limit the
// values that may be passed to [method@Gdk.Paintable.snapshot].
//
// If the @paintable does not have a preferred width, it returns 0.
// Negative values are never returned.
func (x *MediaStream) GetIntrinsicWidth() int {

	cret := gdk.XGdkPaintableGetIntrinsicWidth(x.GoPointer())
	return cret
}

// Called by implementations of `GdkPaintable` to invalidate their contents.
//
// Unless the contents are invalidated, implementations must guarantee that
// multiple calls of [method@Gdk.Paintable.snapshot] produce the same output.
//
// This function will emit the [signal@Gdk.Paintable::invalidate-contents]
// signal.
//
// If a @paintable reports the %GDK_PAINTABLE_STATIC_CONTENTS flag,
// it must not call this function.
func (x *MediaStream) InvalidateContents() {

	gdk.XGdkPaintableInvalidateContents(x.GoPointer())

}

// Called by implementations of `GdkPaintable` to invalidate their size.
//
// As long as the size is not invalidated, @paintable must return the same
// values for its intrinsic width, height and aspect ratio.
//
// This function will emit the [signal@Gdk.Paintable::invalidate-size]
// signal.
//
// If a @paintable reports the %GDK_PAINTABLE_STATIC_SIZE flag,
// it must not call this function.
func (x *MediaStream) InvalidateSize() {

	gdk.XGdkPaintableInvalidateSize(x.GoPointer())

}

// Snapshots the given paintable with the given @width and @height.
//
// The paintable is drawn at the current (0,0) offset of the @snapshot.
// If @width and @height are not larger than zero, this function will
// do nothing.
func (x *MediaStream) Snapshot(SnapshotVar *gdk.Snapshot, WidthVar float64, HeightVar float64) {

	gdk.XGdkPaintableSnapshot(x.GoPointer(), SnapshotVar.GoPointer(), WidthVar, HeightVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xMediaStreamEnded, lib, "gtk_media_stream_ended")
	core.PuregoSafeRegister(&xMediaStreamError, lib, "gtk_media_stream_error")
	core.PuregoSafeRegister(&xMediaStreamErrorValist, lib, "gtk_media_stream_error_valist")
	core.PuregoSafeRegister(&xMediaStreamGerror, lib, "gtk_media_stream_gerror")
	core.PuregoSafeRegister(&xMediaStreamGetDuration, lib, "gtk_media_stream_get_duration")
	core.PuregoSafeRegister(&xMediaStreamGetEnded, lib, "gtk_media_stream_get_ended")
	core.PuregoSafeRegister(&xMediaStreamGetError, lib, "gtk_media_stream_get_error")
	core.PuregoSafeRegister(&xMediaStreamGetLoop, lib, "gtk_media_stream_get_loop")
	core.PuregoSafeRegister(&xMediaStreamGetMuted, lib, "gtk_media_stream_get_muted")
	core.PuregoSafeRegister(&xMediaStreamGetPlaying, lib, "gtk_media_stream_get_playing")
	core.PuregoSafeRegister(&xMediaStreamGetTimestamp, lib, "gtk_media_stream_get_timestamp")
	core.PuregoSafeRegister(&xMediaStreamGetVolume, lib, "gtk_media_stream_get_volume")
	core.PuregoSafeRegister(&xMediaStreamHasAudio, lib, "gtk_media_stream_has_audio")
	core.PuregoSafeRegister(&xMediaStreamHasVideo, lib, "gtk_media_stream_has_video")
	core.PuregoSafeRegister(&xMediaStreamIsPrepared, lib, "gtk_media_stream_is_prepared")
	core.PuregoSafeRegister(&xMediaStreamIsSeekable, lib, "gtk_media_stream_is_seekable")
	core.PuregoSafeRegister(&xMediaStreamIsSeeking, lib, "gtk_media_stream_is_seeking")
	core.PuregoSafeRegister(&xMediaStreamPause, lib, "gtk_media_stream_pause")
	core.PuregoSafeRegister(&xMediaStreamPlay, lib, "gtk_media_stream_play")
	core.PuregoSafeRegister(&xMediaStreamPrepared, lib, "gtk_media_stream_prepared")
	core.PuregoSafeRegister(&xMediaStreamRealize, lib, "gtk_media_stream_realize")
	core.PuregoSafeRegister(&xMediaStreamSeek, lib, "gtk_media_stream_seek")
	core.PuregoSafeRegister(&xMediaStreamSeekFailed, lib, "gtk_media_stream_seek_failed")
	core.PuregoSafeRegister(&xMediaStreamSeekSuccess, lib, "gtk_media_stream_seek_success")
	core.PuregoSafeRegister(&xMediaStreamSetLoop, lib, "gtk_media_stream_set_loop")
	core.PuregoSafeRegister(&xMediaStreamSetMuted, lib, "gtk_media_stream_set_muted")
	core.PuregoSafeRegister(&xMediaStreamSetPlaying, lib, "gtk_media_stream_set_playing")
	core.PuregoSafeRegister(&xMediaStreamSetVolume, lib, "gtk_media_stream_set_volume")
	core.PuregoSafeRegister(&xMediaStreamStreamEnded, lib, "gtk_media_stream_stream_ended")
	core.PuregoSafeRegister(&xMediaStreamStreamPrepared, lib, "gtk_media_stream_stream_prepared")
	core.PuregoSafeRegister(&xMediaStreamStreamUnprepared, lib, "gtk_media_stream_stream_unprepared")
	core.PuregoSafeRegister(&xMediaStreamUnprepared, lib, "gtk_media_stream_unprepared")
	core.PuregoSafeRegister(&xMediaStreamUnrealize, lib, "gtk_media_stream_unrealize")
	core.PuregoSafeRegister(&xMediaStreamUpdate, lib, "gtk_media_stream_update")

}
