// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type DirectoryListClass struct {
	ParentClass uintptr
}

func (x *DirectoryListClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GtkDirectoryList` is a list model that wraps g_file_enumerate_children_async().
//
// It presents a `GListModel` and fills it asynchronously with the `GFileInfo`s
// returned from that function.
//
// Enumeration will start automatically when a the
// [property@Gtk.DirectoryList:file] property is set.
//
// While the `GtkDirectoryList` is being filled, the
// [property@Gtk.DirectoryList:loading] property will be set to %TRUE. You can
// listen to that property if you want to show information like a `GtkSpinner`
// or a "Loading..." text.
//
// If loading fails at any point, the [property@Gtk.DirectoryList:error]
// property will be set to give more indication about the failure.
//
// The `GFileInfo`s returned from a `GtkDirectoryList` have the "standard::file"
// attribute set to the `GFile` they refer to. This way you can get at the file
// that is referred to in the same way you would via g_file_enumerator_get_child().
// This means you do not need access to the `GtkDirectoryList`, but can access
// the `GFile` directly from the `GFileInfo` when operating with a `GtkListView`
// or similar.
type DirectoryList struct {
	gobject.Object
}

func DirectoryListNewFromInternalPtr(ptr uintptr) *DirectoryList {
	cls := &DirectoryList{}
	cls.Ptr = ptr
	return cls
}

var xNewDirectoryList func(string, uintptr) uintptr

// Creates a new `GtkDirectoryList`.
//
// The `GtkDirectoryList` is querying the given @file
// with the given @attributes.
func NewDirectoryList(AttributesVar string, FileVar gio.File) *DirectoryList {
	var cls *DirectoryList

	cret := xNewDirectoryList(AttributesVar, FileVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &DirectoryList{}
	cls.Ptr = cret
	return cls
}

var xDirectoryListGetAttributes func(uintptr) string

// Gets the attributes queried on the children.
func (x *DirectoryList) GetAttributes() string {

	cret := xDirectoryListGetAttributes(x.GoPointer())
	return cret
}

var xDirectoryListGetError func(uintptr) *glib.Error

// Gets the loading error, if any.
//
// If an error occurs during the loading process, the loading process
// will finish and this property allows querying the error that happened.
// This error will persist until a file is loaded again.
//
// An error being set does not mean that no files were loaded, and all
// successfully queried files will remain in the list.
func (x *DirectoryList) GetError() *glib.Error {

	cret := xDirectoryListGetError(x.GoPointer())
	return cret
}

var xDirectoryListGetFile func(uintptr) uintptr

// Gets the file whose children are currently enumerated.
func (x *DirectoryList) GetFile() *gio.FileBase {
	var cls *gio.FileBase

	cret := xDirectoryListGetFile(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.FileBase{}
	cls.Ptr = cret
	return cls
}

var xDirectoryListGetIoPriority func(uintptr) int

// Gets the IO priority set via gtk_directory_list_set_io_priority().
func (x *DirectoryList) GetIoPriority() int {

	cret := xDirectoryListGetIoPriority(x.GoPointer())
	return cret
}

var xDirectoryListGetMonitored func(uintptr) bool

// Returns whether the directory list is monitoring
// the directory for changes.
func (x *DirectoryList) GetMonitored() bool {

	cret := xDirectoryListGetMonitored(x.GoPointer())
	return cret
}

var xDirectoryListIsLoading func(uintptr) bool

// Returns %TRUE if the children enumeration is currently in
// progress.
//
// Files will be added to @self from time to time while loading is
// going on. The order in which are added is undefined and may change
// in between runs.
func (x *DirectoryList) IsLoading() bool {

	cret := xDirectoryListIsLoading(x.GoPointer())
	return cret
}

var xDirectoryListSetAttributes func(uintptr, string)

// Sets the @attributes to be enumerated and starts the enumeration.
//
// If @attributes is %NULL, no attributes will be queried, but a list
// of `GFileInfo`s will still be created.
func (x *DirectoryList) SetAttributes(AttributesVar string) {

	xDirectoryListSetAttributes(x.GoPointer(), AttributesVar)

}

var xDirectoryListSetFile func(uintptr, uintptr)

// Sets the @file to be enumerated and starts the enumeration.
//
// If @file is %NULL, the result will be an empty list.
func (x *DirectoryList) SetFile(FileVar gio.File) {

	xDirectoryListSetFile(x.GoPointer(), FileVar.GoPointer())

}

var xDirectoryListSetIoPriority func(uintptr, int)

// Sets the IO priority to use while loading directories.
//
// Setting the priority while @self is loading will reprioritize the
// ongoing load as soon as possible.
//
// The default IO priority is %G_PRIORITY_DEFAULT, which is higher than
// the GTK redraw priority. If you are loading a lot of directories in
// parallel, lowering it to something like %G_PRIORITY_DEFAULT_IDLE
// may increase responsiveness.
func (x *DirectoryList) SetIoPriority(IoPriorityVar int) {

	xDirectoryListSetIoPriority(x.GoPointer(), IoPriorityVar)

}

var xDirectoryListSetMonitored func(uintptr, bool)

// Sets whether the directory list will monitor the directory
// for changes.
//
// If monitoring is enabled, the ::items-changed signal will
// be emitted when the directory contents change.
//
// When monitoring is turned on after the initial creation
// of the directory list, the directory is reloaded to avoid
// missing files that appeared between the initial loading
// and when monitoring was turned on.
func (x *DirectoryList) SetMonitored(MonitoredVar bool) {

	xDirectoryListSetMonitored(x.GoPointer(), MonitoredVar)

}

func (c *DirectoryList) GoPointer() uintptr {
	return c.Ptr
}

func (c *DirectoryList) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// See also: g_list_model_get_n_items()
func (x *DirectoryList) GetItem(PositionVar uint) uintptr {

	cret := gio.XGListModelGetItem(x.GoPointer(), PositionVar)
	return cret
}

// Gets the type of the items in @list.
//
// All items returned from g_list_model_get_item() are of the type
// returned by this function, or a subtype, or if the type is an
// interface, they are an implementation of that interface.
//
// The item type of a #GListModel can not change during the life of the
// model.
func (x *DirectoryList) GetItemType() []interface{} {

	cret := gio.XGListModelGetItemType(x.GoPointer())
	return cret
}

// Gets the number of items in @list.
//
// Depending on the model implementation, calling this function may be
// less efficient than iterating the list with increasing values for
// @position until g_list_model_get_item() returns %NULL.
func (x *DirectoryList) GetNItems() uint {

	cret := gio.XGListModelGetNItems(x.GoPointer())
	return cret
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// This function is meant to be used by language bindings in place
// of g_list_model_get_item().
//
// See also: g_list_model_get_n_items()
func (x *DirectoryList) GetObject(PositionVar uint) *gobject.Object {
	var cls *gobject.Object

	cret := gio.XGListModelGetObject(x.GoPointer(), PositionVar)

	if cret == 0 {
		return nil
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

// Emits the #GListModel::items-changed signal on @list.
//
// This function should only be called by classes implementing
// #GListModel. It has to be called after the internal representation
// of @list has been updated, because handlers connected to this signal
// might query the new state of the list.
//
// Implementations must only make changes to the model (as visible to
// its consumer) in places that will not cause problems for that
// consumer.  For models that are driven directly by a write API (such
// as #GListStore), changes can be reported in response to uses of that
// API.  For models that represent remote data, changes should only be
// made from a fresh mainloop dispatch.  It is particularly not
// permitted to make changes in response to a call to the #GListModel
// consumer API.
//
// Stated another way: in general, it is assumed that code making a
// series of accesses to the model via the API, without returning to the
// mainloop, and without calling other code, will continue to view the
// same contents of the model.
func (x *DirectoryList) ItemsChanged(PositionVar uint, RemovedVar uint, AddedVar uint) {

	gio.XGListModelItemsChanged(x.GoPointer(), PositionVar, RemovedVar, AddedVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewDirectoryList, lib, "gtk_directory_list_new")

	core.PuregoSafeRegister(&xDirectoryListGetAttributes, lib, "gtk_directory_list_get_attributes")
	core.PuregoSafeRegister(&xDirectoryListGetError, lib, "gtk_directory_list_get_error")
	core.PuregoSafeRegister(&xDirectoryListGetFile, lib, "gtk_directory_list_get_file")
	core.PuregoSafeRegister(&xDirectoryListGetIoPriority, lib, "gtk_directory_list_get_io_priority")
	core.PuregoSafeRegister(&xDirectoryListGetMonitored, lib, "gtk_directory_list_get_monitored")
	core.PuregoSafeRegister(&xDirectoryListIsLoading, lib, "gtk_directory_list_is_loading")
	core.PuregoSafeRegister(&xDirectoryListSetAttributes, lib, "gtk_directory_list_set_attributes")
	core.PuregoSafeRegister(&xDirectoryListSetFile, lib, "gtk_directory_list_set_file")
	core.PuregoSafeRegister(&xDirectoryListSetIoPriority, lib, "gtk_directory_list_set_io_priority")
	core.PuregoSafeRegister(&xDirectoryListSetMonitored, lib, "gtk_directory_list_set_monitored")

}
