// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type ListStoreClass struct {
	ParentClass uintptr

	Padding [8]uintptr
}

func (x *ListStoreClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type ListStorePrivate struct {
}

func (x *ListStorePrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A list-like data structure that can be used with the [class@Gtk.TreeView].
//
// The `GtkListStore` object is a list model for use with a `GtkTreeView`
// widget.  It implements the `GtkTreeModel` interface, and consequentialy,
// can use all of the methods available there.  It also implements the
// `GtkTreeSortable` interface so it can be sorted by the view.
// Finally, it also implements the tree
// [drag](iface.TreeDragSource.html) and [drop](iface.TreeDragDest.html)
// interfaces.
//
// The `GtkListStore` can accept most `GType`s as a column type, though
// it can’t accept all custom types.  Internally, it will keep a copy of
// data passed in (such as a string or a boxed pointer).  Columns that
// accept `GObject`s are handled a little differently.  The
// `GtkListStore` will keep a reference to the object instead of copying the
// value.  As a result, if the object is modified, it is up to the
// application writer to call [method@Gtk.TreeModel.row_changed] to emit the
// [signal@Gtk.TreeModel::row_changed] signal. This most commonly affects lists
// with [class@Gdk.Texture]s stored.
//
// An example for creating a simple list store:
//
// ```c
//
//	enum {
//	  COLUMN_STRING,
//	  COLUMN_INT,
//	  COLUMN_BOOLEAN,
//	  N_COLUMNS
//	};
//
//	{
//	  GtkListStore *list_store;
//	  GtkTreePath *path;
//	  GtkTreeIter iter;
//	  int i;
//
//	  list_store = gtk_list_store_new (N_COLUMNS,
//	                                   G_TYPE_STRING,
//	                                   G_TYPE_INT,
//	                                   G_TYPE_BOOLEAN);
//
//	  for (i = 0; i &lt; 10; i++)
//	    {
//	      char *some_data;
//
//	      some_data = get_some_data (i);
//
//	      // Add a new row to the model
//	      gtk_list_store_append (list_store, &amp;iter);
//	      gtk_list_store_set (list_store, &amp;iter,
//	                          COLUMN_STRING, some_data,
//	                          COLUMN_INT, i,
//	                          COLUMN_BOOLEAN,  FALSE,
//	                          -1);
//
//	      // As the store will keep a copy of the string internally,
//	      // we free some_data.
//	      g_free (some_data);
//	    }
//
//	  // Modify a particular row
//	  path = gtk_tree_path_new_from_string ("4");
//	  gtk_tree_model_get_iter (GTK_TREE_MODEL (list_store),
//	                           &amp;iter,
//	                           path);
//	  gtk_tree_path_free (path);
//	  gtk_list_store_set (list_store, &amp;iter,
//	                      COLUMN_BOOLEAN, TRUE,
//	                      -1);
//	}
//
// ```
//
// # Performance Considerations
//
// Internally, the `GtkListStore` was originally implemented with a linked list
// with a tail pointer.  As a result, it was fast at data insertion and deletion,
// and not fast at random data access.  The `GtkListStore` sets the
// `GTK_TREE_MODEL_ITERS_PERSIST` flag, which means that `GtkTreeIter`s can be
// cached while the row exists.  Thus, if access to a particular row is needed
// often and your code is expected to run on older versions of GTK, it is worth
// keeping the iter around.
//
// # Atomic Operations
//
// It is important to note that only the methods
// gtk_list_store_insert_with_values() and gtk_list_store_insert_with_valuesv()
// are atomic, in the sense that the row is being appended to the store and the
// values filled in in a single operation with regard to `GtkTreeModel` signaling.
// In contrast, using e.g. gtk_list_store_append() and then gtk_list_store_set()
// will first create a row, which triggers the `GtkTreeModel::row-inserted` signal
// on `GtkListStore`. The row, however, is still empty, and any signal handler
// connecting to `GtkTreeModel::row-inserted` on this particular store should be prepared
// for the situation that the row might be empty. This is especially important
// if you are wrapping the `GtkListStore` inside a `GtkTreeModel`Filter and are
// using a `GtkTreeModel`FilterVisibleFunc. Using any of the non-atomic operations
// to append rows to the `GtkListStore` will cause the
// `GtkTreeModel`FilterVisibleFunc to be visited with an empty row first; the
// function must be prepared for that.
//
// # GtkListStore as GtkBuildable
//
// The GtkListStore implementation of the [iface@Gtk.Buildable] interface allows
// to specify the model columns with a `&lt;columns&gt;` element that may contain
// multiple `&lt;column&gt;` elements, each specifying one model column. The “type”
// attribute specifies the data type for the column.
//
// Additionally, it is possible to specify content for the list store
// in the UI definition, with the `&lt;data&gt;` element. It can contain multiple
// `&lt;row&gt;` elements, each specifying to content for one row of the list model.
// Inside a `&lt;row&gt;`, the `&lt;col&gt;` elements specify the content for individual cells.
//
// Note that it is probably more common to define your models in the code,
// and one might consider it a layering violation to specify the content of
// a list store in a UI definition, data, not presentation, and common wisdom
// is to separate the two, as far as possible.
//
// An example of a UI Definition fragment for a list store:
//
// ```xml
// &lt;object class="GtkListStore"&gt;
//
//	&lt;columns&gt;
//	  &lt;column type="gchararray"/&gt;
//	  &lt;column type="gchararray"/&gt;
//	  &lt;column type="gint"/&gt;
//	&lt;/columns&gt;
//	&lt;data&gt;
//	  &lt;row&gt;
//	    &lt;col id="0"&gt;John&lt;/col&gt;
//	    &lt;col id="1"&gt;Doe&lt;/col&gt;
//	    &lt;col id="2"&gt;25&lt;/col&gt;
//	  &lt;/row&gt;
//	  &lt;row&gt;
//	    &lt;col id="0"&gt;Johan&lt;/col&gt;
//	    &lt;col id="1"&gt;Dahlin&lt;/col&gt;
//	    &lt;col id="2"&gt;50&lt;/col&gt;
//	  &lt;/row&gt;
//	&lt;/data&gt;
//
// &lt;/object&gt;
// ```
type ListStore struct {
	gobject.Object
}

func ListStoreNewFromInternalPtr(ptr uintptr) *ListStore {
	cls := &ListStore{}
	cls.Ptr = ptr
	return cls
}

var xNewListStore func(int, ...interface{}) uintptr

// Creates a new list store as with @n_columns columns each of the types passed
// in.  Note that only types derived from standard GObject fundamental types
// are supported.
//
// As an example, `gtk_list_store_new (3, G_TYPE_INT, G_TYPE_STRING,
// GDK_TYPE_TEXTURE);` will create a new `GtkListStore` with three columns, of type
// int, string and `GdkTexture`, respectively.
func NewListStore(NColumnsVar int, varArgs ...interface{}) *ListStore {
	var cls *ListStore

	cret := xNewListStore(NColumnsVar, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &ListStore{}
	cls.Ptr = cret
	return cls
}

var xNewListStorev func(int, []types.GType) uintptr

// Non-vararg creation function.  Used primarily by language bindings.
func NewListStorev(NColumnsVar int, TypesVar []types.GType) *ListStore {
	var cls *ListStore

	cret := xNewListStorev(NColumnsVar, TypesVar)

	if cret == 0 {
		return nil
	}
	cls = &ListStore{}
	cls.Ptr = cret
	return cls
}

var xListStoreAppend func(uintptr, *TreeIter)

// Appends a new row to @list_store.  @iter will be changed to point to this new
// row.  The row will be empty after this function is called.  To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
func (x *ListStore) Append(IterVar *TreeIter) {

	xListStoreAppend(x.GoPointer(), IterVar)

}

var xListStoreClear func(uintptr)

// Removes all rows from the list store.
func (x *ListStore) Clear() {

	xListStoreClear(x.GoPointer())

}

var xListStoreInsert func(uintptr, *TreeIter, int)

// Creates a new row at @position.  @iter will be changed to point to this new
// row.  If @position is -1 or is larger than the number of rows on the list,
// then the new row will be appended to the list. The row will be empty after
// this function is called.  To fill in values, you need to call
// gtk_list_store_set() or gtk_list_store_set_value().
func (x *ListStore) Insert(IterVar *TreeIter, PositionVar int) {

	xListStoreInsert(x.GoPointer(), IterVar, PositionVar)

}

var xListStoreInsertAfter func(uintptr, *TreeIter, *TreeIter)

// Inserts a new row after @sibling. If @sibling is %NULL, then the row will be
// prepended to the beginning of the list. @iter will be changed to point to
// this new row. The row will be empty after this function is called. To fill
// in values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
func (x *ListStore) InsertAfter(IterVar *TreeIter, SiblingVar *TreeIter) {

	xListStoreInsertAfter(x.GoPointer(), IterVar, SiblingVar)

}

var xListStoreInsertBefore func(uintptr, *TreeIter, *TreeIter)

// Inserts a new row before @sibling. If @sibling is %NULL, then the row will
// be appended to the end of the list. @iter will be changed to point to this
// new row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
func (x *ListStore) InsertBefore(IterVar *TreeIter, SiblingVar *TreeIter) {

	xListStoreInsertBefore(x.GoPointer(), IterVar, SiblingVar)

}

var xListStoreInsertWithValues func(uintptr, *TreeIter, int, ...interface{})

// Creates a new row at @position. @iter will be changed to point to this new
// row. If @position is -1, or larger than the number of rows in the list, then
// the new row will be appended to the list. The row will be filled with the
// values given to this function.
//
// Calling
// `gtk_list_store_insert_with_values (list_store, iter, position...)`
// has the same effect as calling:
//
// |[&lt;!-- language="C" --&gt;
// static void
// insert_value (GtkListStore *list_store,
//
//	GtkTreeIter  *iter,
//	int           position)
//
//	{
//	  gtk_list_store_insert (list_store, iter, position);
//	  gtk_list_store_set (list_store,
//	                      iter
//	                      // ...
//	                      );
//	}
//
// ]|
//
// with the difference that the former will only emit `GtkTreeModel`::row-inserted
// once, while the latter will emit `GtkTreeModel`::row-inserted,
// `GtkTreeModel`::row-changed and, if the list store is sorted,
// `GtkTreeModel`::rows-reordered for every inserted value.
//
// Since emitting the `GtkTreeModel::rows-reordered` signal repeatedly can
// affect the performance of the program, gtk_list_store_insert_with_values()
// should generally be preferred when inserting rows in a sorted list store.
func (x *ListStore) InsertWithValues(IterVar *TreeIter, PositionVar int, varArgs ...interface{}) {

	xListStoreInsertWithValues(x.GoPointer(), IterVar, PositionVar, varArgs...)

}

var xListStoreInsertWithValuesv func(uintptr, *TreeIter, int, []int, []gobject.Value, int)

// A variant of gtk_list_store_insert_with_values() which
// takes the columns and values as two arrays, instead of
// varargs.
//
// This function is mainly intended for language-bindings.
func (x *ListStore) InsertWithValuesv(IterVar *TreeIter, PositionVar int, ColumnsVar []int, ValuesVar []gobject.Value, NValuesVar int) {

	xListStoreInsertWithValuesv(x.GoPointer(), IterVar, PositionVar, ColumnsVar, ValuesVar, NValuesVar)

}

var xListStoreIterIsValid func(uintptr, *TreeIter) bool

// Checks if the given iter is a valid iter for this `GtkListStore`.
//
// This function is slow. Only use it for debugging and/or testing
// purposes.
func (x *ListStore) IterIsValid(IterVar *TreeIter) bool {

	cret := xListStoreIterIsValid(x.GoPointer(), IterVar)
	return cret
}

var xListStoreMoveAfter func(uintptr, *TreeIter, *TreeIter)

// Moves @iter in @store to the position after @position. Note that this
// function only works with unsorted stores. If @position is %NULL, @iter
// will be moved to the start of the list.
func (x *ListStore) MoveAfter(IterVar *TreeIter, PositionVar *TreeIter) {

	xListStoreMoveAfter(x.GoPointer(), IterVar, PositionVar)

}

var xListStoreMoveBefore func(uintptr, *TreeIter, *TreeIter)

// Moves @iter in @store to the position before @position. Note that this
// function only works with unsorted stores. If @position is %NULL, @iter
// will be moved to the end of the list.
func (x *ListStore) MoveBefore(IterVar *TreeIter, PositionVar *TreeIter) {

	xListStoreMoveBefore(x.GoPointer(), IterVar, PositionVar)

}

var xListStorePrepend func(uintptr, *TreeIter)

// Prepends a new row to @list_store. @iter will be changed to point to this new
// row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
func (x *ListStore) Prepend(IterVar *TreeIter) {

	xListStorePrepend(x.GoPointer(), IterVar)

}

var xListStoreRemove func(uintptr, *TreeIter) bool

// Removes the given row from the list store.  After being removed,
// @iter is set to be the next valid row, or invalidated if it pointed
// to the last row in @list_store.
func (x *ListStore) Remove(IterVar *TreeIter) bool {

	cret := xListStoreRemove(x.GoPointer(), IterVar)
	return cret
}

var xListStoreReorder func(uintptr, []int)

// Reorders @store to follow the order indicated by @new_order. Note that
// this function only works with unsorted stores.
func (x *ListStore) Reorder(NewOrderVar []int) {

	xListStoreReorder(x.GoPointer(), NewOrderVar)

}

var xListStoreSet func(uintptr, *TreeIter, ...interface{})

// Sets the value of one or more cells in the row referenced by @iter.
// The variable argument list should contain integer column numbers,
// each column number followed by the value to be set.
// The list is terminated by a -1. For example, to set column 0 with type
// %G_TYPE_STRING to “Foo”, you would write `gtk_list_store_set (store, iter,
// 0, "Foo", -1)`.
//
// The value will be referenced by the store if it is a %G_TYPE_OBJECT, and it
// will be copied if it is a %G_TYPE_STRING or %G_TYPE_BOXED.
func (x *ListStore) Set(IterVar *TreeIter, varArgs ...interface{}) {

	xListStoreSet(x.GoPointer(), IterVar, varArgs...)

}

var xListStoreSetColumnTypes func(uintptr, int, []types.GType)

// This function is meant primarily for `GObject`s that inherit from `GtkListStore`,
// and should only be used when constructing a new `GtkListStore`.  It will not
// function after a row has been added, or a method on the `GtkTreeModel`
// interface is called.
func (x *ListStore) SetColumnTypes(NColumnsVar int, TypesVar []types.GType) {

	xListStoreSetColumnTypes(x.GoPointer(), NColumnsVar, TypesVar)

}

var xListStoreSetValist func(uintptr, *TreeIter, []interface{})

// See gtk_list_store_set(); this version takes a va_list for use by language
// bindings.
func (x *ListStore) SetValist(IterVar *TreeIter, VarArgsVar []interface{}) {

	xListStoreSetValist(x.GoPointer(), IterVar, VarArgsVar)

}

var xListStoreSetValue func(uintptr, *TreeIter, int, *gobject.Value)

// Sets the data in the cell specified by @iter and @column.
// The type of @value must be convertible to the type of the
// column.
func (x *ListStore) SetValue(IterVar *TreeIter, ColumnVar int, ValueVar *gobject.Value) {

	xListStoreSetValue(x.GoPointer(), IterVar, ColumnVar, ValueVar)

}

var xListStoreSetValuesv func(uintptr, *TreeIter, []int, []gobject.Value, int)

// A variant of gtk_list_store_set_valist() which
// takes the columns and values as two arrays, instead of
// varargs. This function is mainly intended for
// language-bindings and in case the number of columns to
// change is not known until run-time.
func (x *ListStore) SetValuesv(IterVar *TreeIter, ColumnsVar []int, ValuesVar []gobject.Value, NValuesVar int) {

	xListStoreSetValuesv(x.GoPointer(), IterVar, ColumnsVar, ValuesVar, NValuesVar)

}

var xListStoreSwap func(uintptr, *TreeIter, *TreeIter)

// Swaps @a and @b in @store. Note that this function only works with
// unsorted stores.
func (x *ListStore) Swap(AVar *TreeIter, BVar *TreeIter) {

	xListStoreSwap(x.GoPointer(), AVar, BVar)

}

func (c *ListStore) GoPointer() uintptr {
	return c.Ptr
}

func (c *ListStore) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *ListStore) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Asks the `GtkTreeDragDest` to insert a row before the path @dest,
// deriving the contents of the row from @value. If @dest is
// outside the tree so that inserting before it is impossible, %FALSE
// will be returned. Also, %FALSE may be returned if the new row is
// not created for some model-specific reason.  Should robustly handle
// a @dest no longer found in the model!
func (x *ListStore) DragDataReceived(DestVar *TreePath, ValueVar *gobject.Value) bool {

	cret := XGtkTreeDragDestDragDataReceived(x.GoPointer(), DestVar, ValueVar)
	return cret
}

// Determines whether a drop is possible before the given @dest_path,
// at the same depth as @dest_path. i.e., can we drop the data in
// @value at that location. @dest_path does not have to
// exist; the return value will almost certainly be %FALSE if the
// parent of @dest_path doesn’t exist, though.
func (x *ListStore) RowDropPossible(DestPathVar *TreePath, ValueVar *gobject.Value) bool {

	cret := XGtkTreeDragDestRowDropPossible(x.GoPointer(), DestPathVar, ValueVar)
	return cret
}

// Asks the `GtkTreeDragSource` to delete the row at @path, because
// it was moved somewhere else via drag-and-drop. Returns %FALSE
// if the deletion fails because @path no longer exists, or for
// some model-specific reason. Should robustly handle a @path no
// longer found in the model!
func (x *ListStore) DragDataDelete(PathVar *TreePath) bool {

	cret := XGtkTreeDragSourceDragDataDelete(x.GoPointer(), PathVar)
	return cret
}

// Asks the `GtkTreeDragSource` to return a `GdkContentProvider` representing
// the row at @path. Should robustly handle a @path no
// longer found in the model!
func (x *ListStore) DragDataGet(PathVar *TreePath) *gdk.ContentProvider {
	var cls *gdk.ContentProvider

	cret := XGtkTreeDragSourceDragDataGet(x.GoPointer(), PathVar)

	if cret == 0 {
		return nil
	}
	cls = &gdk.ContentProvider{}
	cls.Ptr = cret
	return cls
}

// Asks the `GtkTreeDragSource` whether a particular row can be used as
// the source of a DND operation. If the source doesn’t implement
// this interface, the row is assumed draggable.
func (x *ListStore) RowDraggable(PathVar *TreePath) bool {

	cret := XGtkTreeDragSourceRowDraggable(x.GoPointer(), PathVar)
	return cret
}

// Creates a new `GtkTreeModel`, with @child_model as the child_model
// and @root as the virtual root.
func (x *ListStore) FilterNew(RootVar *TreePath) *TreeModelBase {
	var cls *TreeModelBase

	cret := XGtkTreeModelFilterNew(x.GoPointer(), RootVar)

	if cret == 0 {
		return nil
	}
	cls = &TreeModelBase{}
	cls.Ptr = cret
	return cls
}

// Calls @func on each node in model in a depth-first fashion.
//
// If @func returns %TRUE, then the tree ceases to be walked,
// and gtk_tree_model_foreach() returns.
func (x *ListStore) Foreach(FuncVar *TreeModelForeachFunc, UserDataVar uintptr) {

	XGtkTreeModelForeach(x.GoPointer(), glib.NewCallback(FuncVar), UserDataVar)

}

// Gets the value of one or more cells in the row referenced by @iter.
//
// The variable argument list should contain integer column numbers,
// each column number followed by a place to store the value being
// retrieved.  The list is terminated by a -1. For example, to get a
// value from column 0 with type %G_TYPE_STRING, you would
// write: `gtk_tree_model_get (model, iter, 0, &amp;place_string_here, -1)`,
// where `place_string_here` is a #gchararray
// to be filled with the string.
//
// Returned values with type %G_TYPE_OBJECT have to be unreferenced,
// values with type %G_TYPE_STRING or %G_TYPE_BOXED have to be freed.
// Other values are passed by value.
func (x *ListStore) Get(IterVar *TreeIter, varArgs ...interface{}) {

	XGtkTreeModelGet(x.GoPointer(), IterVar, varArgs...)

}

// Returns the type of the column.
func (x *ListStore) GetColumnType(IndexVar int) types.GType {

	cret := XGtkTreeModelGetColumnType(x.GoPointer(), IndexVar)
	return cret
}

// Returns a set of flags supported by this interface.
//
// The flags are a bitwise combination of `GtkTreeModel`Flags.
// The flags supported should not change during the lifetime
// of the @tree_model.
func (x *ListStore) GetFlags() TreeModelFlags {

	cret := XGtkTreeModelGetFlags(x.GoPointer())
	return cret
}

// Sets @iter to a valid iterator pointing to @path.
//
// If @path does not exist, @iter is set to an invalid
// iterator and %FALSE is returned.
func (x *ListStore) GetIter(IterVar *TreeIter, PathVar *TreePath) bool {

	cret := XGtkTreeModelGetIter(x.GoPointer(), IterVar, PathVar)
	return cret
}

// Initializes @iter with the first iterator in the tree
// (the one at the path "0").
//
// Returns %FALSE if the tree is empty, %TRUE otherwise.
func (x *ListStore) GetIterFirst(IterVar *TreeIter) bool {

	cret := XGtkTreeModelGetIterFirst(x.GoPointer(), IterVar)
	return cret
}

// Sets @iter to a valid iterator pointing to @path_string, if it
// exists.
//
// Otherwise, @iter is left invalid and %FALSE is returned.
func (x *ListStore) GetIterFromString(IterVar *TreeIter, PathStringVar string) bool {

	cret := XGtkTreeModelGetIterFromString(x.GoPointer(), IterVar, PathStringVar)
	return cret
}

// Returns the number of columns supported by @tree_model.
func (x *ListStore) GetNColumns() int {

	cret := XGtkTreeModelGetNColumns(x.GoPointer())
	return cret
}

// Returns a newly-created `GtkTreePath` referenced by @iter.
//
// This path should be freed with gtk_tree_path_free().
func (x *ListStore) GetPath(IterVar *TreeIter) *TreePath {

	cret := XGtkTreeModelGetPath(x.GoPointer(), IterVar)
	return cret
}

// Generates a string representation of the iter.
//
// This string is a “:” separated list of numbers.
// For example, “4:10:0:3” would be an acceptable
// return value for this string.
func (x *ListStore) GetStringFromIter(IterVar *TreeIter) string {

	cret := XGtkTreeModelGetStringFromIter(x.GoPointer(), IterVar)
	return cret
}

// Gets the value of one or more cells in the row referenced by @iter.
//
// See [method@Gtk.TreeModel.get], this version takes a va_list
// for language bindings to use.
func (x *ListStore) GetValist(IterVar *TreeIter, VarArgsVar []interface{}) {

	XGtkTreeModelGetValist(x.GoPointer(), IterVar, VarArgsVar)

}

// Initializes and sets @value to that at @column.
//
// When done with @value, g_value_unset() needs to be called
// to free any allocated memory.
func (x *ListStore) GetValue(IterVar *TreeIter, ColumnVar int, ValueVar *gobject.Value) {

	XGtkTreeModelGetValue(x.GoPointer(), IterVar, ColumnVar, ValueVar)

}

// Sets @iter to point to the first child of @parent.
//
// If @parent has no children, %FALSE is returned and @iter is
// set to be invalid. @parent will remain a valid node after this
// function has been called.
//
// If @parent is %NULL returns the first node, equivalent to
// `gtk_tree_model_get_iter_first (tree_model, iter);`
func (x *ListStore) IterChildren(IterVar *TreeIter, ParentVar *TreeIter) bool {

	cret := XGtkTreeModelIterChildren(x.GoPointer(), IterVar, ParentVar)
	return cret
}

// Returns %TRUE if @iter has children, %FALSE otherwise.
func (x *ListStore) IterHasChild(IterVar *TreeIter) bool {

	cret := XGtkTreeModelIterHasChild(x.GoPointer(), IterVar)
	return cret
}

// Returns the number of children that @iter has.
//
// As a special case, if @iter is %NULL, then the number
// of toplevel nodes is returned.
func (x *ListStore) IterNChildren(IterVar *TreeIter) int {

	cret := XGtkTreeModelIterNChildren(x.GoPointer(), IterVar)
	return cret
}

// Sets @iter to point to the node following it at the current level.
//
// If there is no next @iter, %FALSE is returned and @iter is set
// to be invalid.
func (x *ListStore) IterNext(IterVar *TreeIter) bool {

	cret := XGtkTreeModelIterNext(x.GoPointer(), IterVar)
	return cret
}

// Sets @iter to be the child of @parent, using the given index.
//
// The first index is 0. If @n is too big, or @parent has no children,
// @iter is set to an invalid iterator and %FALSE is returned. @parent
// will remain a valid node after this function has been called. As a
// special case, if @parent is %NULL, then the @n-th root node
// is set.
func (x *ListStore) IterNthChild(IterVar *TreeIter, ParentVar *TreeIter, NVar int) bool {

	cret := XGtkTreeModelIterNthChild(x.GoPointer(), IterVar, ParentVar, NVar)
	return cret
}

// Sets @iter to be the parent of @child.
//
// If @child is at the toplevel, and doesn’t have a parent, then
// @iter is set to an invalid iterator and %FALSE is returned.
// @child will remain a valid node after this function has been
// called.
//
// @iter will be initialized before the lookup is performed, so @child
// and @iter cannot point to the same memory location.
func (x *ListStore) IterParent(IterVar *TreeIter, ChildVar *TreeIter) bool {

	cret := XGtkTreeModelIterParent(x.GoPointer(), IterVar, ChildVar)
	return cret
}

// Sets @iter to point to the previous node at the current level.
//
// If there is no previous @iter, %FALSE is returned and @iter is
// set to be invalid.
func (x *ListStore) IterPrevious(IterVar *TreeIter) bool {

	cret := XGtkTreeModelIterPrevious(x.GoPointer(), IterVar)
	return cret
}

// Lets the tree ref the node.
//
// This is an optional method for models to implement.
// To be more specific, models may ignore this call as it exists
// primarily for performance reasons.
//
// This function is primarily meant as a way for views to let
// caching models know when nodes are being displayed (and hence,
// whether or not to cache that node). Being displayed means a node
// is in an expanded branch, regardless of whether the node is currently
// visible in the viewport. For example, a file-system based model
// would not want to keep the entire file-hierarchy in memory,
// just the sections that are currently being displayed by
// every current view.
//
// A model should be expected to be able to get an iter independent
// of its reffed state.
func (x *ListStore) RefNode(IterVar *TreeIter) {

	XGtkTreeModelRefNode(x.GoPointer(), IterVar)

}

// Emits the ::row-changed signal on @tree_model.
//
// See [signal@Gtk.TreeModel::row-changed].
func (x *ListStore) RowChanged(PathVar *TreePath, IterVar *TreeIter) {

	XGtkTreeModelRowChanged(x.GoPointer(), PathVar, IterVar)

}

// Emits the ::row-deleted signal on @tree_model.
//
// See [signal@Gtk.TreeModel::row-deleted].
//
// This should be called by models after a row has been removed.
// The location pointed to by @path should be the location that
// the row previously was at. It may not be a valid location anymore.
//
// Nodes that are deleted are not unreffed, this means that any
// outstanding references on the deleted node should not be released.
func (x *ListStore) RowDeleted(PathVar *TreePath) {

	XGtkTreeModelRowDeleted(x.GoPointer(), PathVar)

}

// Emits the ::row-has-child-toggled signal on @tree_model.
//
// See [signal@Gtk.TreeModel::row-has-child-toggled].
//
// This should be called by models after the child
// state of a node changes.
func (x *ListStore) RowHasChildToggled(PathVar *TreePath, IterVar *TreeIter) {

	XGtkTreeModelRowHasChildToggled(x.GoPointer(), PathVar, IterVar)

}

// Emits the ::row-inserted signal on @tree_model.
//
// See [signal@Gtk.TreeModel::row-inserted].
func (x *ListStore) RowInserted(PathVar *TreePath, IterVar *TreeIter) {

	XGtkTreeModelRowInserted(x.GoPointer(), PathVar, IterVar)

}

// Emits the ::rows-reordered signal on @tree_model.
//
// See [signal@Gtk.TreeModel::rows-reordered].
//
// This should be called by models when their rows have been
// reordered.
func (x *ListStore) RowsReordered(PathVar *TreePath, IterVar *TreeIter, NewOrderVar int) {

	XGtkTreeModelRowsReordered(x.GoPointer(), PathVar, IterVar, NewOrderVar)

}

// Emits the ::rows-reordered signal on @tree_model.
//
// See [signal@Gtk.TreeModel::rows-reordered].
//
// This should be called by models when their rows have been
// reordered.
func (x *ListStore) RowsReorderedWithLength(PathVar *TreePath, IterVar *TreeIter, NewOrderVar []int, LengthVar int) {

	XGtkTreeModelRowsReorderedWithLength(x.GoPointer(), PathVar, IterVar, NewOrderVar, LengthVar)

}

// Lets the tree unref the node.
//
// This is an optional method for models to implement.
// To be more specific, models may ignore this call as it exists
// primarily for performance reasons. For more information on what
// this means, see gtk_tree_model_ref_node().
//
// Please note that nodes that are deleted are not unreffed.
func (x *ListStore) UnrefNode(IterVar *TreeIter) {

	XGtkTreeModelUnrefNode(x.GoPointer(), IterVar)

}

// Fills in @sort_column_id and @order with the current sort column and the
// order. It returns %TRUE unless the @sort_column_id is
// %GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
// %GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
func (x *ListStore) GetSortColumnId(SortColumnIdVar int, OrderVar *SortType) bool {

	cret := XGtkTreeSortableGetSortColumnId(x.GoPointer(), SortColumnIdVar, OrderVar)
	return cret
}

// Returns %TRUE if the model has a default sort function. This is used
// primarily by GtkTreeViewColumns in order to determine if a model can
// go back to the default state, or not.
func (x *ListStore) HasDefaultSortFunc() bool {

	cret := XGtkTreeSortableHasDefaultSortFunc(x.GoPointer())
	return cret
}

// Sets the default comparison function used when sorting to be @sort_func.
// If the current sort column id of @sortable is
// %GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, then the model will sort using
// this function.
//
// If @sort_func is %NULL, then there will be no default comparison function.
// This means that once the model  has been sorted, it can’t go back to the
// default state. In this case, when the current sort column id of @sortable
// is %GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, the model will be unsorted.
func (x *ListStore) SetDefaultSortFunc(SortFuncVar *TreeIterCompareFunc, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	XGtkTreeSortableSetDefaultSortFunc(x.GoPointer(), glib.NewCallback(SortFuncVar), UserDataVar, glib.NewCallback(DestroyVar))

}

// Sets the current sort column to be @sort_column_id. The @sortable will
// resort itself to reflect this change, after emitting a
// `GtkTreeSortable::sort-column-changed` signal. @sort_column_id may either be
// a regular column id, or one of the following special values:
//
//   - %GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function
//     will be used, if it is set
//
// - %GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur
func (x *ListStore) SetSortColumnId(SortColumnIdVar int, OrderVar SortType) {

	XGtkTreeSortableSetSortColumnId(x.GoPointer(), SortColumnIdVar, OrderVar)

}

// Sets the comparison function used when sorting to be @sort_func. If the
// current sort column id of @sortable is the same as @sort_column_id, then
// the model will sort using this function.
func (x *ListStore) SetSortFunc(SortColumnIdVar int, SortFuncVar *TreeIterCompareFunc, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	XGtkTreeSortableSetSortFunc(x.GoPointer(), SortColumnIdVar, glib.NewCallback(SortFuncVar), UserDataVar, glib.NewCallback(DestroyVar))

}

// Emits a `GtkTreeSortable::sort-column-changed` signal on @sortable.
func (x *ListStore) SortColumnChanged() {

	XGtkTreeSortableSortColumnChanged(x.GoPointer())

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewListStore, lib, "gtk_list_store_new")
	core.PuregoSafeRegister(&xNewListStorev, lib, "gtk_list_store_newv")

	core.PuregoSafeRegister(&xListStoreAppend, lib, "gtk_list_store_append")
	core.PuregoSafeRegister(&xListStoreClear, lib, "gtk_list_store_clear")
	core.PuregoSafeRegister(&xListStoreInsert, lib, "gtk_list_store_insert")
	core.PuregoSafeRegister(&xListStoreInsertAfter, lib, "gtk_list_store_insert_after")
	core.PuregoSafeRegister(&xListStoreInsertBefore, lib, "gtk_list_store_insert_before")
	core.PuregoSafeRegister(&xListStoreInsertWithValues, lib, "gtk_list_store_insert_with_values")
	core.PuregoSafeRegister(&xListStoreInsertWithValuesv, lib, "gtk_list_store_insert_with_valuesv")
	core.PuregoSafeRegister(&xListStoreIterIsValid, lib, "gtk_list_store_iter_is_valid")
	core.PuregoSafeRegister(&xListStoreMoveAfter, lib, "gtk_list_store_move_after")
	core.PuregoSafeRegister(&xListStoreMoveBefore, lib, "gtk_list_store_move_before")
	core.PuregoSafeRegister(&xListStorePrepend, lib, "gtk_list_store_prepend")
	core.PuregoSafeRegister(&xListStoreRemove, lib, "gtk_list_store_remove")
	core.PuregoSafeRegister(&xListStoreReorder, lib, "gtk_list_store_reorder")
	core.PuregoSafeRegister(&xListStoreSet, lib, "gtk_list_store_set")
	core.PuregoSafeRegister(&xListStoreSetColumnTypes, lib, "gtk_list_store_set_column_types")
	core.PuregoSafeRegister(&xListStoreSetValist, lib, "gtk_list_store_set_valist")
	core.PuregoSafeRegister(&xListStoreSetValue, lib, "gtk_list_store_set_value")
	core.PuregoSafeRegister(&xListStoreSetValuesv, lib, "gtk_list_store_set_valuesv")
	core.PuregoSafeRegister(&xListStoreSwap, lib, "gtk_list_store_swap")

}
