// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type SingleSelectionClass struct {
	ParentClass uintptr
}

func (x *SingleSelectionClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GtkSingleSelection` is a `GtkSelectionModel` that allows selecting a single
// item.
//
// Note that the selection is *persistent* -- if the selected item is removed
// and re-added in the same [signal@Gio.ListModel::items-changed] emission, it
// stays selected. In particular, this means that changing the sort order of an
// underlying sort model will preserve the selection.
type SingleSelection struct {
	gobject.Object
}

func SingleSelectionNewFromInternalPtr(ptr uintptr) *SingleSelection {
	cls := &SingleSelection{}
	cls.Ptr = ptr
	return cls
}

var xNewSingleSelection func(uintptr) uintptr

// Creates a new selection to handle @model.
func NewSingleSelection(ModelVar gio.ListModel) *SingleSelection {
	var cls *SingleSelection

	cret := xNewSingleSelection(ModelVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &SingleSelection{}
	cls.Ptr = cret
	return cls
}

var xSingleSelectionGetAutoselect func(uintptr) bool

// Checks if autoselect has been enabled or disabled via
// gtk_single_selection_set_autoselect().
func (x *SingleSelection) GetAutoselect() bool {

	cret := xSingleSelectionGetAutoselect(x.GoPointer())
	return cret
}

var xSingleSelectionGetCanUnselect func(uintptr) bool

// If %TRUE, gtk_selection_model_unselect_item() is supported and allows
// unselecting the selected item.
func (x *SingleSelection) GetCanUnselect() bool {

	cret := xSingleSelectionGetCanUnselect(x.GoPointer())
	return cret
}

var xSingleSelectionGetModel func(uintptr) uintptr

// Gets the model that @self is wrapping.
func (x *SingleSelection) GetModel() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := xSingleSelectionGetModel(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

var xSingleSelectionGetSelected func(uintptr) uint

// Gets the position of the selected item.
//
// If no item is selected, %GTK_INVALID_LIST_POSITION is returned.
func (x *SingleSelection) GetSelected() uint {

	cret := xSingleSelectionGetSelected(x.GoPointer())
	return cret
}

var xSingleSelectionGetSelectedItem func(uintptr) uintptr

// Gets the selected item.
//
// If no item is selected, %NULL is returned.
func (x *SingleSelection) GetSelectedItem() *gobject.Object {
	var cls *gobject.Object

	cret := xSingleSelectionGetSelectedItem(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

var xSingleSelectionSetAutoselect func(uintptr, bool)

// Enables or disables autoselect.
//
// If @autoselect is %TRUE, @self will enforce that an item is always
// selected. It will select a new item when the currently selected
// item is deleted and it will disallow unselecting the current item.
func (x *SingleSelection) SetAutoselect(AutoselectVar bool) {

	xSingleSelectionSetAutoselect(x.GoPointer(), AutoselectVar)

}

var xSingleSelectionSetCanUnselect func(uintptr, bool)

// If %TRUE, unselecting the current item via
// gtk_selection_model_unselect_item() is supported.
//
// Note that setting [property@Gtk.SingleSelection:autoselect] will
// cause unselecting to not work, so it practically makes no sense
// to set both at the same time the same time.
func (x *SingleSelection) SetCanUnselect(CanUnselectVar bool) {

	xSingleSelectionSetCanUnselect(x.GoPointer(), CanUnselectVar)

}

var xSingleSelectionSetModel func(uintptr, uintptr)

// Sets the model that @self should wrap.
//
// If @model is %NULL, @self will be empty.
func (x *SingleSelection) SetModel(ModelVar gio.ListModel) {

	xSingleSelectionSetModel(x.GoPointer(), ModelVar.GoPointer())

}

var xSingleSelectionSetSelected func(uintptr, uint)

// Selects the item at the given position.
//
// If the list does not have an item at @position or
// %GTK_INVALID_LIST_POSITION is given, the behavior depends on the
// value of the [property@Gtk.SingleSelection:autoselect] property:
// If it is set, no change will occur and the old item will stay
// selected. If it is unset, the selection will be unset and no item
// will be selected.
func (x *SingleSelection) SetSelected(PositionVar uint) {

	xSingleSelectionSetSelected(x.GoPointer(), PositionVar)

}

func (c *SingleSelection) GoPointer() uintptr {
	return c.Ptr
}

func (c *SingleSelection) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// See also: g_list_model_get_n_items()
func (x *SingleSelection) GetItem(PositionVar uint) uintptr {

	cret := gio.XGListModelGetItem(x.GoPointer(), PositionVar)
	return cret
}

// Gets the type of the items in @list.
//
// All items returned from g_list_model_get_item() are of the type
// returned by this function, or a subtype, or if the type is an
// interface, they are an implementation of that interface.
//
// The item type of a #GListModel can not change during the life of the
// model.
func (x *SingleSelection) GetItemType() []interface{} {

	cret := gio.XGListModelGetItemType(x.GoPointer())
	return cret
}

// Gets the number of items in @list.
//
// Depending on the model implementation, calling this function may be
// less efficient than iterating the list with increasing values for
// @position until g_list_model_get_item() returns %NULL.
func (x *SingleSelection) GetNItems() uint {

	cret := gio.XGListModelGetNItems(x.GoPointer())
	return cret
}

// Get the item at @position.
//
// If @position is greater than the number of items in @list, %NULL is
// returned.
//
// %NULL is never returned for an index that is smaller than the length
// of the list.
//
// This function is meant to be used by language bindings in place
// of g_list_model_get_item().
//
// See also: g_list_model_get_n_items()
func (x *SingleSelection) GetObject(PositionVar uint) *gobject.Object {
	var cls *gobject.Object

	cret := gio.XGListModelGetObject(x.GoPointer(), PositionVar)

	if cret == 0 {
		return nil
	}
	cls = &gobject.Object{}
	cls.Ptr = cret
	return cls
}

// Emits the #GListModel::items-changed signal on @list.
//
// This function should only be called by classes implementing
// #GListModel. It has to be called after the internal representation
// of @list has been updated, because handlers connected to this signal
// might query the new state of the list.
//
// Implementations must only make changes to the model (as visible to
// its consumer) in places that will not cause problems for that
// consumer.  For models that are driven directly by a write API (such
// as #GListStore), changes can be reported in response to uses of that
// API.  For models that represent remote data, changes should only be
// made from a fresh mainloop dispatch.  It is particularly not
// permitted to make changes in response to a call to the #GListModel
// consumer API.
//
// Stated another way: in general, it is assumed that code making a
// series of accesses to the model via the API, without returning to the
// mainloop, and without calling other code, will continue to view the
// same contents of the model.
func (x *SingleSelection) ItemsChanged(PositionVar uint, RemovedVar uint, AddedVar uint) {

	gio.XGListModelItemsChanged(x.GoPointer(), PositionVar, RemovedVar, AddedVar)

}

// Gets the set containing all currently selected items in the model.
//
// This function may be slow, so if you are only interested in single item,
// consider using [method@Gtk.SelectionModel.is_selected] or if you are only
// interested in a few, consider [method@Gtk.SelectionModel.get_selection_in_range].
func (x *SingleSelection) GetSelection() *Bitset {

	cret := XGtkSelectionModelGetSelection(x.GoPointer())
	return cret
}

// Gets the set of selected items in a range.
//
// This function is an optimization for
// [method@Gtk.SelectionModel.get_selection] when you are only
// interested in part of the model's selected state. A common use
// case is in response to the [signal@Gtk.SelectionModel::selection-changed]
// signal.
func (x *SingleSelection) GetSelectionInRange(PositionVar uint, NItemsVar uint) *Bitset {

	cret := XGtkSelectionModelGetSelectionInRange(x.GoPointer(), PositionVar, NItemsVar)
	return cret
}

// Checks if the given item is selected.
func (x *SingleSelection) IsSelected(PositionVar uint) bool {

	cret := XGtkSelectionModelIsSelected(x.GoPointer(), PositionVar)
	return cret
}

// Requests to select all items in the model.
func (x *SingleSelection) SelectAll() bool {

	cret := XGtkSelectionModelSelectAll(x.GoPointer())
	return cret
}

// Requests to select an item in the model.
func (x *SingleSelection) SelectItem(PositionVar uint, UnselectRestVar bool) bool {

	cret := XGtkSelectionModelSelectItem(x.GoPointer(), PositionVar, UnselectRestVar)
	return cret
}

// Requests to select a range of items in the model.
func (x *SingleSelection) SelectRange(PositionVar uint, NItemsVar uint, UnselectRestVar bool) bool {

	cret := XGtkSelectionModelSelectRange(x.GoPointer(), PositionVar, NItemsVar, UnselectRestVar)
	return cret
}

// Helper function for implementations of `GtkSelectionModel`.
//
// Call this when a the selection changes to emit the
// [signal@Gtk.SelectionModel::selection-changed] signal.
func (x *SingleSelection) SelectionChanged(PositionVar uint, NItemsVar uint) {

	XGtkSelectionModelSelectionChanged(x.GoPointer(), PositionVar, NItemsVar)

}

// Make selection changes.
//
// This is the most advanced selection updating method that allows
// the most fine-grained control over selection changes. If you can,
// you should try the simpler versions, as implementations are more
// likely to implement support for those.
//
// Requests that the selection state of all positions set in @mask
// be updated to the respective value in the @selected bitmask.
//
// In pseudocode, it would look something like this:
//
// ```c
// for (i = 0; i &lt; n_items; i++)
//
//	{
//	  // don't change values not in the mask
//	  if (!gtk_bitset_contains (mask, i))
//	    continue;
//
//	  if (gtk_bitset_contains (selected, i))
//	    select_item (i);
//	  else
//	    unselect_item (i);
//	}
//
// gtk_selection_model_selection_changed (model,
//
//	first_changed_item,
//	n_changed_items);
//
// ```
//
// @mask and @selected must not be modified. They may refer to the
// same bitset, which would mean that every item in the set should
// be selected.
func (x *SingleSelection) SetSelection(SelectedVar *Bitset, MaskVar *Bitset) bool {

	cret := XGtkSelectionModelSetSelection(x.GoPointer(), SelectedVar, MaskVar)
	return cret
}

// Requests to unselect all items in the model.
func (x *SingleSelection) UnselectAll() bool {

	cret := XGtkSelectionModelUnselectAll(x.GoPointer())
	return cret
}

// Requests to unselect an item in the model.
func (x *SingleSelection) UnselectItem(PositionVar uint) bool {

	cret := XGtkSelectionModelUnselectItem(x.GoPointer(), PositionVar)
	return cret
}

// Requests to unselect a range of items in the model.
func (x *SingleSelection) UnselectRange(PositionVar uint, NItemsVar uint) bool {

	cret := XGtkSelectionModelUnselectRange(x.GoPointer(), PositionVar, NItemsVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewSingleSelection, lib, "gtk_single_selection_new")

	core.PuregoSafeRegister(&xSingleSelectionGetAutoselect, lib, "gtk_single_selection_get_autoselect")
	core.PuregoSafeRegister(&xSingleSelectionGetCanUnselect, lib, "gtk_single_selection_get_can_unselect")
	core.PuregoSafeRegister(&xSingleSelectionGetModel, lib, "gtk_single_selection_get_model")
	core.PuregoSafeRegister(&xSingleSelectionGetSelected, lib, "gtk_single_selection_get_selected")
	core.PuregoSafeRegister(&xSingleSelectionGetSelectedItem, lib, "gtk_single_selection_get_selected_item")
	core.PuregoSafeRegister(&xSingleSelectionSetAutoselect, lib, "gtk_single_selection_set_autoselect")
	core.PuregoSafeRegister(&xSingleSelectionSetCanUnselect, lib, "gtk_single_selection_set_can_unselect")
	core.PuregoSafeRegister(&xSingleSelectionSetModel, lib, "gtk_single_selection_set_model")
	core.PuregoSafeRegister(&xSingleSelectionSetSelected, lib, "gtk_single_selection_set_selected")

}
