// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// User-provided callback function to create a popup for a
// `GtkMenuButton` on demand.
//
// This function is called when the popup of @menu_button is shown,
// but none has been provided via [method@Gtk.MenuButton.set_popover]
// or [method@Gtk.MenuButton.set_menu_model].
type MenuButtonCreatePopupFunc func(uintptr, uintptr)

// The `GtkMenuButton` widget is used to display a popup when clicked.
//
// ![An example GtkMenuButton](menu-button.png)
//
// This popup can be provided either as a `GtkPopover` or as an abstract
// `GMenuModel`.
//
// The `GtkMenuButton` widget can show either an icon (set with the
// [property@Gtk.MenuButton:icon-name] property) or a label (set with the
// [property@Gtk.MenuButton:label] property). If neither is explicitly set,
// a [class@Gtk.Image] is automatically created, using an arrow image oriented
// according to [property@Gtk.MenuButton:direction] or the generic
// “open-menu-symbolic” icon if the direction is not set.
//
// The positioning of the popup is determined by the
// [property@Gtk.MenuButton:direction] property of the menu button.
//
// For menus, the [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign]
// properties of the menu are also taken into account. For example, when the
// direction is %GTK_ARROW_DOWN and the horizontal alignment is %GTK_ALIGN_START,
// the menu will be positioned below the button, with the starting edge
// (depending on the text direction) of the menu aligned with the starting
// edge of the button. If there is not enough space below the button, the
// menu is popped up above the button instead. If the alignment would move
// part of the menu offscreen, it is “pushed in”.
//
// |           | start                | center                | end                |
// | -         | ---                  | ---                   | ---                |
// | **down**  | ![](down-start.png)  | ![](down-center.png)  | ![](down-end.png)  |
// | **up**    | ![](up-start.png)    | ![](up-center.png)    | ![](up-end.png)    |
// | **left**  | ![](left-start.png)  | ![](left-center.png)  | ![](left-end.png)  |
// | **right** | ![](right-start.png) | ![](right-center.png) | ![](right-end.png) |
//
// # CSS nodes
//
// ```
// menubutton
// ╰── button.toggle
//
//	╰── &lt;content&gt;
//	     ╰── [arrow]
//
// ```
//
// `GtkMenuButton` has a single CSS node with name `menubutton`
// which contains a `button` node with a `.toggle` style class.
//
// If the button contains an icon, it will have the `.image-button` style class,
// if it contains text, it will have `.text-button` style class. If an arrow is
// visible in addition to an icon, text or a custom child, it will also have
// `.arrow-button` style class.
//
// Inside the toggle button content, there is an `arrow` node for
// the indicator, which will carry one of the `.none`, `.up`, `.down`,
// `.left` or `.right` style classes to indicate the direction that
// the menu will appear in. The CSS is expected to provide a suitable
// image for each of these cases using the `-gtk-icon-source` property.
//
// Optionally, the `menubutton` node can carry the `.circular` style class
// to request a round appearance.
//
// # Accessibility
//
// `GtkMenuButton` uses the %GTK_ACCESSIBLE_ROLE_BUTTON role.
type MenuButton struct {
	Widget
}

func MenuButtonNewFromInternalPtr(ptr uintptr) *MenuButton {
	cls := &MenuButton{}
	cls.Ptr = ptr
	return cls
}

var xNewMenuButton func() uintptr

// Creates a new `GtkMenuButton` widget with downwards-pointing
// arrow as the only child.
//
// You can replace the child widget with another `GtkWidget`
// should you wish to.
func NewMenuButton() *MenuButton {
	var cls *MenuButton

	cret := xNewMenuButton()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &MenuButton{}
	cls.Ptr = cret
	return cls
}

var xMenuButtonGetAlwaysShowArrow func(uintptr) bool

// Gets whether to show a dropdown arrow even when using an icon.
func (x *MenuButton) GetAlwaysShowArrow() bool {

	cret := xMenuButtonGetAlwaysShowArrow(x.GoPointer())
	return cret
}

var xMenuButtonGetChild func(uintptr) uintptr

// Gets the child widget of @menu_button.
func (x *MenuButton) GetChild() *Widget {
	var cls *Widget

	cret := xMenuButtonGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

var xMenuButtonGetDirection func(uintptr) ArrowType

// Returns the direction the popup will be pointing at when popped up.
func (x *MenuButton) GetDirection() ArrowType {

	cret := xMenuButtonGetDirection(x.GoPointer())
	return cret
}

var xMenuButtonGetHasFrame func(uintptr) bool

// Returns whether the button has a frame.
func (x *MenuButton) GetHasFrame() bool {

	cret := xMenuButtonGetHasFrame(x.GoPointer())
	return cret
}

var xMenuButtonGetIconName func(uintptr) string

// Gets the name of the icon shown in the button.
func (x *MenuButton) GetIconName() string {

	cret := xMenuButtonGetIconName(x.GoPointer())
	return cret
}

var xMenuButtonGetLabel func(uintptr) string

// Gets the label shown in the button
func (x *MenuButton) GetLabel() string {

	cret := xMenuButtonGetLabel(x.GoPointer())
	return cret
}

var xMenuButtonGetMenuModel func(uintptr) uintptr

// Returns the `GMenuModel` used to generate the popup.
func (x *MenuButton) GetMenuModel() *gio.MenuModel {
	var cls *gio.MenuModel

	cret := xMenuButtonGetMenuModel(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.MenuModel{}
	cls.Ptr = cret
	return cls
}

var xMenuButtonGetPopover func(uintptr) uintptr

// Returns the `GtkPopover` that pops out of the button.
//
// If the button is not using a `GtkPopover`, this function
// returns %NULL.
func (x *MenuButton) GetPopover() *Popover {
	var cls *Popover

	cret := xMenuButtonGetPopover(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Popover{}
	cls.Ptr = cret
	return cls
}

var xMenuButtonGetPrimary func(uintptr) bool

// Returns whether the menu button acts as a primary menu.
func (x *MenuButton) GetPrimary() bool {

	cret := xMenuButtonGetPrimary(x.GoPointer())
	return cret
}

var xMenuButtonGetUseUnderline func(uintptr) bool

// Returns whether an embedded underline in the text indicates a
// mnemonic.
func (x *MenuButton) GetUseUnderline() bool {

	cret := xMenuButtonGetUseUnderline(x.GoPointer())
	return cret
}

var xMenuButtonPopdown func(uintptr)

// Dismiss the menu.
func (x *MenuButton) Popdown() {

	xMenuButtonPopdown(x.GoPointer())

}

var xMenuButtonPopup func(uintptr)

// Pop up the menu.
func (x *MenuButton) Popup() {

	xMenuButtonPopup(x.GoPointer())

}

var xMenuButtonSetAlwaysShowArrow func(uintptr, bool)

// Sets whether to show a dropdown arrow even when using an icon or a custom
// child.
func (x *MenuButton) SetAlwaysShowArrow(AlwaysShowArrowVar bool) {

	xMenuButtonSetAlwaysShowArrow(x.GoPointer(), AlwaysShowArrowVar)

}

var xMenuButtonSetChild func(uintptr, uintptr)

// Sets the child widget of @menu_button.
//
// Setting a child resets [property@Gtk.MenuButton:label] and
// [property@Gtk.MenuButton:icon-name].
//
// If [property@Gtk.MenuButton:always-show-arrow] is set to `TRUE` and
// [property@Gtk.MenuButton:direction] is not `GTK_ARROW_NONE`, a dropdown arrow
// will be shown next to the child.
func (x *MenuButton) SetChild(ChildVar *Widget) {

	xMenuButtonSetChild(x.GoPointer(), ChildVar.GoPointer())

}

var xMenuButtonSetCreatePopupFunc func(uintptr, uintptr, uintptr, uintptr)

// Sets @func to be called when a popup is about to be shown.
//
// @func should use one of
//
//   - [method@Gtk.MenuButton.set_popover]
//   - [method@Gtk.MenuButton.set_menu_model]
//
// to set a popup for @menu_button.
// If @func is non-%NULL, @menu_button will always be sensitive.
//
// Using this function will not reset the menu widget attached to
// @menu_button. Instead, this can be done manually in @func.
func (x *MenuButton) SetCreatePopupFunc(FuncVar *MenuButtonCreatePopupFunc, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify) {

	xMenuButtonSetCreatePopupFunc(x.GoPointer(), glib.NewCallback(FuncVar), UserDataVar, glib.NewCallback(DestroyNotifyVar))

}

var xMenuButtonSetDirection func(uintptr, ArrowType)

// Sets the direction in which the popup will be popped up.
//
// If the button is automatically populated with an arrow icon,
// its direction will be changed to match.
//
// If the does not fit in the available space in the given direction,
// GTK will its best to keep it inside the screen and fully visible.
//
// If you pass %GTK_ARROW_NONE for a @direction, the popup will behave
// as if you passed %GTK_ARROW_DOWN (although you won’t see any arrows).
func (x *MenuButton) SetDirection(DirectionVar ArrowType) {

	xMenuButtonSetDirection(x.GoPointer(), DirectionVar)

}

var xMenuButtonSetHasFrame func(uintptr, bool)

// Sets the style of the button.
func (x *MenuButton) SetHasFrame(HasFrameVar bool) {

	xMenuButtonSetHasFrame(x.GoPointer(), HasFrameVar)

}

var xMenuButtonSetIconName func(uintptr, string)

// Sets the name of an icon to show inside the menu button.
//
// Setting icon name resets [property@Gtk.MenuButton:label] and
// [property@Gtk.MenuButton:child].
//
// If [property@Gtk.MenuButton:always-show-arrow] is set to `TRUE` and
// [property@Gtk.MenuButton:direction] is not `GTK_ARROW_NONE`, a dropdown arrow
// will be shown next to the icon.
func (x *MenuButton) SetIconName(IconNameVar string) {

	xMenuButtonSetIconName(x.GoPointer(), IconNameVar)

}

var xMenuButtonSetLabel func(uintptr, string)

// Sets the label to show inside the menu button.
//
// Setting a label resets [property@Gtk.MenuButton:icon-name] and
// [property@Gtk.MenuButton:child].
//
// If [property@Gtk.MenuButton:direction] is not `GTK_ARROW_NONE`, a dropdown
// arrow will be shown next to the label.
func (x *MenuButton) SetLabel(LabelVar string) {

	xMenuButtonSetLabel(x.GoPointer(), LabelVar)

}

var xMenuButtonSetMenuModel func(uintptr, uintptr)

// Sets the `GMenuModel` from which the popup will be constructed.
//
// If @menu_model is %NULL, the button is disabled.
//
// A [class@Gtk.Popover] will be created from the menu model with
// [ctor@Gtk.PopoverMenu.new_from_model]. Actions will be connected
// as documented for this function.
//
// If [property@Gtk.MenuButton:popover] is already set, it will be
// dissociated from the @menu_button, and the property is set to %NULL.
func (x *MenuButton) SetMenuModel(MenuModelVar *gio.MenuModel) {

	xMenuButtonSetMenuModel(x.GoPointer(), MenuModelVar.GoPointer())

}

var xMenuButtonSetPopover func(uintptr, uintptr)

// Sets the `GtkPopover` that will be popped up when the @menu_button is clicked.
//
// If @popover is %NULL, the button is disabled.
//
// If [property@Gtk.MenuButton:menu-model] is set, the menu model is dissociated
// from the @menu_button, and the property is set to %NULL.
func (x *MenuButton) SetPopover(PopoverVar *Widget) {

	xMenuButtonSetPopover(x.GoPointer(), PopoverVar.GoPointer())

}

var xMenuButtonSetPrimary func(uintptr, bool)

// Sets whether menu button acts as a primary menu.
//
// Primary menus can be opened with the &lt;kbd&gt;F10&lt;/kbd&gt; key.
func (x *MenuButton) SetPrimary(PrimaryVar bool) {

	xMenuButtonSetPrimary(x.GoPointer(), PrimaryVar)

}

var xMenuButtonSetUseUnderline func(uintptr, bool)

// If true, an underline in the text indicates a mnemonic.
func (x *MenuButton) SetUseUnderline(UseUnderlineVar bool) {

	xMenuButtonSetUseUnderline(x.GoPointer(), UseUnderlineVar)

}

func (c *MenuButton) GoPointer() uintptr {
	return c.Ptr
}

func (c *MenuButton) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted to when the menu button is activated.
//
// The `::activate` signal on `GtkMenuButton` is an action signal and
// emitting it causes the button to pop up its menu.
func (x *MenuButton) ConnectActivate(cb *func(MenuButton)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := MenuButton{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "activate", cbRefPtr)
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *MenuButton) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *MenuButton) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *MenuButton) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *MenuButton) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *MenuButton) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *MenuButton) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []AccessibleProperty, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *MenuButton) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *MenuButton) UpdateRelationValue(NRelationsVar int, RelationsVar []AccessibleRelation, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *MenuButton) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *MenuButton) UpdateStateValue(NStatesVar int, StatesVar []AccessibleState, ValuesVar []gobject.Value) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *MenuButton) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewMenuButton, lib, "gtk_menu_button_new")

	core.PuregoSafeRegister(&xMenuButtonGetAlwaysShowArrow, lib, "gtk_menu_button_get_always_show_arrow")
	core.PuregoSafeRegister(&xMenuButtonGetChild, lib, "gtk_menu_button_get_child")
	core.PuregoSafeRegister(&xMenuButtonGetDirection, lib, "gtk_menu_button_get_direction")
	core.PuregoSafeRegister(&xMenuButtonGetHasFrame, lib, "gtk_menu_button_get_has_frame")
	core.PuregoSafeRegister(&xMenuButtonGetIconName, lib, "gtk_menu_button_get_icon_name")
	core.PuregoSafeRegister(&xMenuButtonGetLabel, lib, "gtk_menu_button_get_label")
	core.PuregoSafeRegister(&xMenuButtonGetMenuModel, lib, "gtk_menu_button_get_menu_model")
	core.PuregoSafeRegister(&xMenuButtonGetPopover, lib, "gtk_menu_button_get_popover")
	core.PuregoSafeRegister(&xMenuButtonGetPrimary, lib, "gtk_menu_button_get_primary")
	core.PuregoSafeRegister(&xMenuButtonGetUseUnderline, lib, "gtk_menu_button_get_use_underline")
	core.PuregoSafeRegister(&xMenuButtonPopdown, lib, "gtk_menu_button_popdown")
	core.PuregoSafeRegister(&xMenuButtonPopup, lib, "gtk_menu_button_popup")
	core.PuregoSafeRegister(&xMenuButtonSetAlwaysShowArrow, lib, "gtk_menu_button_set_always_show_arrow")
	core.PuregoSafeRegister(&xMenuButtonSetChild, lib, "gtk_menu_button_set_child")
	core.PuregoSafeRegister(&xMenuButtonSetCreatePopupFunc, lib, "gtk_menu_button_set_create_popup_func")
	core.PuregoSafeRegister(&xMenuButtonSetDirection, lib, "gtk_menu_button_set_direction")
	core.PuregoSafeRegister(&xMenuButtonSetHasFrame, lib, "gtk_menu_button_set_has_frame")
	core.PuregoSafeRegister(&xMenuButtonSetIconName, lib, "gtk_menu_button_set_icon_name")
	core.PuregoSafeRegister(&xMenuButtonSetLabel, lib, "gtk_menu_button_set_label")
	core.PuregoSafeRegister(&xMenuButtonSetMenuModel, lib, "gtk_menu_button_set_menu_model")
	core.PuregoSafeRegister(&xMenuButtonSetPopover, lib, "gtk_menu_button_set_popover")
	core.PuregoSafeRegister(&xMenuButtonSetPrimary, lib, "gtk_menu_button_set_primary")
	core.PuregoSafeRegister(&xMenuButtonSetUseUnderline, lib, "gtk_menu_button_set_use_underline")

}
