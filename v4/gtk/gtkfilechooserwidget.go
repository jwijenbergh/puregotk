// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// `GtkFileChooserWidget` is a widget for choosing files.
//
// It exposes the [iface@Gtk.FileChooser] interface, and you should
// use the methods of this interface to interact with the
// widget.
//
// # CSS nodes
//
// `GtkFileChooserWidget` has a single CSS node with name filechooser.
type FileChooserWidget struct {
	Widget
}

func FileChooserWidgetNewFromInternalPtr(ptr uintptr) *FileChooserWidget {
	cls := &FileChooserWidget{}
	cls.Ptr = ptr
	return cls
}

var xNewFileChooserWidget func(FileChooserAction) uintptr

// Creates a new `GtkFileChooserWidget`.
//
// This is a file chooser widget that can be embedded in custom
// windows, and it is the same widget that is used by
// `GtkFileChooserDialog`.
func NewFileChooserWidget(ActionVar FileChooserAction) *FileChooserWidget {
	var cls *FileChooserWidget

	cret := xNewFileChooserWidget(ActionVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FileChooserWidget{}
	cls.Ptr = cret
	return cls
}

func (c *FileChooserWidget) GoPointer() uintptr {
	return c.Ptr
}

func (c *FileChooserWidget) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This is used to make the file chooser show the user's Desktop
// folder in the file list.
//
// The default binding for this signal is &lt;kbd&gt;Alt&lt;/kbd&gt;-&lt;kbd&gt;D&lt;/kbd&gt;.
func (x *FileChooserWidget) ConnectDesktopFolder(cb *func(FileChooserWidget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "desktop-folder", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FileChooserWidget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "desktop-folder", cbRefPtr)
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This is used to make the file chooser go to a child of the
// current folder in the file hierarchy. The subfolder that will
// be used is displayed in the path bar widget of the file chooser.
// For example, if the path bar is showing "/foo/bar/baz", with bar
// currently displayed, then this will cause the file chooser to
// switch to the "baz" subfolder.
//
// The default binding for this signal is &lt;kbd&gt;Alt&lt;/kbd&gt;-&lt;kbd&gt;Down&lt;/kbd&gt;.
func (x *FileChooserWidget) ConnectDownFolder(cb *func(FileChooserWidget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "down-folder", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FileChooserWidget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "down-folder", cbRefPtr)
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This is used to make the file chooser show the user's home
// folder in the file list.
//
// The default binding for this signal is &lt;kbd&gt;Alt&lt;/kbd&gt;-&lt;kbd&gt;Home&lt;/kbd&gt;.
func (x *FileChooserWidget) ConnectHomeFolder(cb *func(FileChooserWidget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "home-folder", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FileChooserWidget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "home-folder", cbRefPtr)
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This is used to make the file chooser show a "Location" prompt which
// the user can use to manually type the name of the file he wishes to select.
//
// The default bindings for this signal are &lt;kbd&gt;Control&lt;/kbd&gt;-&lt;kbd&gt;L&lt;/kbd&gt;
// with a @path string of "" (the empty string). It is also bound to
// &lt;kbd&gt;/&lt;/kbd&gt; with a @path string of "`/`" (a slash):  this lets you
// type `/` and immediately type a path name. On Unix systems, this is
// bound to &lt;kbd&gt;~&lt;/kbd&gt; (tilde) with a @path string of "~" itself for
// access to home directories.
func (x *FileChooserWidget) ConnectLocationPopup(cb *func(FileChooserWidget, string)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "location-popup", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, PathVarp string) {
		fa := FileChooserWidget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, PathVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "location-popup", cbRefPtr)
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This is used to make the file chooser show a "Location" prompt
// when the user pastes into a `GtkFileChooserWidget`.
//
// The default binding for this signal is &lt;kbd&gt;Control&lt;/kbd&gt;-&lt;kbd&gt;V&lt;/kbd&gt;.
func (x *FileChooserWidget) ConnectLocationPopupOnPaste(cb *func(FileChooserWidget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "location-popup-on-paste", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FileChooserWidget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "location-popup-on-paste", cbRefPtr)
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This is used to toggle the visibility of a "Location" prompt
// which the user can use to manually type the name of the file
// he wishes to select.
//
// The default binding for this signal is &lt;kbd&gt;Control&lt;/kbd&gt;-&lt;kbd&gt;L&lt;/kbd&gt;.
func (x *FileChooserWidget) ConnectLocationTogglePopup(cb *func(FileChooserWidget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "location-toggle-popup", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FileChooserWidget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "location-toggle-popup", cbRefPtr)
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This is used to move the focus to the places sidebar.
//
// The default binding for this signal is &lt;kbd&gt;Alt&lt;/kbd&gt;-&lt;kbd&gt;P&lt;/kbd&gt;.
func (x *FileChooserWidget) ConnectPlacesShortcut(cb *func(FileChooserWidget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "places-shortcut", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FileChooserWidget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "places-shortcut", cbRefPtr)
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This is used to make the file chooser switch to the bookmark
// specified in the @bookmark_index parameter. For example, if
// you have three bookmarks, you can pass 0, 1, 2 to this signal
// to switch to each of them, respectively.
//
// The default binding for this signal is &lt;kbd&gt;Alt&lt;/kbd&gt;-&lt;kbd&gt;1&lt;/kbd&gt;,
// &lt;kbd&gt;Alt&lt;/kbd&gt;-&lt;kbd&gt;2&lt;/kbd&gt;, etc. until &lt;kbd&gt;Alt&lt;/kbd&gt;-&lt;kbd&gt;0&lt;/kbd&gt;.
// Note that in the default binding, that &lt;kbd&gt;Alt&lt;/kbd&gt;-&lt;kbd&gt;1&lt;/kbd&gt; is
// actually defined to switch to the bookmark at index 0, and so on
// successively.
func (x *FileChooserWidget) ConnectQuickBookmark(cb *func(FileChooserWidget, int)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "quick-bookmark", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, BookmarkIndexVarp int) {
		fa := FileChooserWidget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, BookmarkIndexVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "quick-bookmark", cbRefPtr)
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This is used to make the file chooser show the Recent location.
//
// The default binding for this signal is &lt;kbd&gt;Alt&lt;/kbd&gt;-&lt;kbd&gt;R&lt;/kbd&gt;.
func (x *FileChooserWidget) ConnectRecentShortcut(cb *func(FileChooserWidget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "recent-shortcut", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FileChooserWidget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "recent-shortcut", cbRefPtr)
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This is used to make the file chooser show the search entry.
//
// The default binding for this signal is &lt;kbd&gt;Alt&lt;/kbd&gt;-&lt;kbd&gt;S&lt;/kbd&gt;.
func (x *FileChooserWidget) ConnectSearchShortcut(cb *func(FileChooserWidget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "search-shortcut", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FileChooserWidget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "search-shortcut", cbRefPtr)
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This is used to make the file chooser display hidden files.
//
// The default binding for this signal is &lt;kbd&gt;Control&lt;/kbd&gt;-&lt;kbd&gt;H&lt;/kbd&gt;.
func (x *FileChooserWidget) ConnectShowHidden(cb *func(FileChooserWidget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "show-hidden", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FileChooserWidget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "show-hidden", cbRefPtr)
}

// Emitted when the user asks for it.
//
// This is a [keybinding signal](class.SignalAction.html).
//
// This is used to make the file chooser go to the parent
// of the current folder in the file hierarchy.
//
// The default binding for this signal is &lt;kbd&gt;Alt&lt;/kbd&gt;-&lt;kbd&gt;Up&lt;/kbd&gt;.
func (x *FileChooserWidget) ConnectUpFolder(cb *func(FileChooserWidget)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "up-folder", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := FileChooserWidget{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "up-folder", cbRefPtr)
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *FileChooserWidget) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *FileChooserWidget) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *FileChooserWidget) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *FileChooserWidget) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *FileChooserWidget) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *FileChooserWidget) UpdatePropertyValue(NPropertiesVar int, PropertiesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *FileChooserWidget) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *FileChooserWidget) UpdateRelationValue(NRelationsVar int, RelationsVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *FileChooserWidget) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *FileChooserWidget) UpdateStateValue(NStatesVar int, StatesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *FileChooserWidget) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Adds a 'choice' to the file chooser.
//
// This is typically implemented as a combobox or, for boolean choices,
// as a checkbutton. You can select a value using
// [method@Gtk.FileChooser.set_choice] before the dialog is shown,
// and you can obtain the user-selected value in the
// [signal@Gtk.Dialog::response] signal handler using
// [method@Gtk.FileChooser.get_choice].
func (x *FileChooserWidget) AddChoice(IdVar string, LabelVar string, OptionsVar []string, OptionLabelsVar []string) {

	XGtkFileChooserAddChoice(x.GoPointer(), IdVar, LabelVar, OptionsVar, OptionLabelsVar)

}

// Adds @filter to the list of filters that the user can select between.
//
// When a filter is selected, only files that are passed by that
// filter are displayed.
//
// Note that the @chooser takes ownership of the filter if it is floating,
// so you have to ref and sink it if you want to keep a reference.
func (x *FileChooserWidget) AddFilter(FilterVar *FileFilter) {

	XGtkFileChooserAddFilter(x.GoPointer(), FilterVar.GoPointer())

}

// Adds a folder to be displayed with the shortcut folders
// in a file chooser.
func (x *FileChooserWidget) AddShortcutFolder(FolderVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserAddShortcutFolder(x.GoPointer(), FolderVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Gets the type of operation that the file chooser is performing.
func (x *FileChooserWidget) GetAction() FileChooserAction {

	cret := XGtkFileChooserGetAction(x.GoPointer())
	return cret
}

// Gets the currently selected option in the 'choice' with the given ID.
func (x *FileChooserWidget) GetChoice(IdVar string) string {

	cret := XGtkFileChooserGetChoice(x.GoPointer(), IdVar)
	return cret
}

// Gets whether file chooser will offer to create new folders.
func (x *FileChooserWidget) GetCreateFolders() bool {

	cret := XGtkFileChooserGetCreateFolders(x.GoPointer())
	return cret
}

// Gets the current folder of @chooser as `GFile`.
func (x *FileChooserWidget) GetCurrentFolder() *gio.FileBase {
	var cls *gio.FileBase

	cret := XGtkFileChooserGetCurrentFolder(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.FileBase{}
	cls.Ptr = cret
	return cls
}

// Gets the current name in the file selector, as entered by the user.
//
// This is meant to be used in save dialogs, to get the currently typed
// filename when the file itself does not exist yet.
func (x *FileChooserWidget) GetCurrentName() string {

	cret := XGtkFileChooserGetCurrentName(x.GoPointer())
	return cret
}

// Gets the `GFile` for the currently selected file in
// the file selector.
//
// If multiple files are selected, one of the files will be
// returned at random.
//
// If the file chooser is in folder mode, this function returns
// the selected folder.
func (x *FileChooserWidget) GetFile() *gio.FileBase {
	var cls *gio.FileBase

	cret := XGtkFileChooserGetFile(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.FileBase{}
	cls.Ptr = cret
	return cls
}

// Lists all the selected files and subfolders in the current folder
// of @chooser as `GFile`.
func (x *FileChooserWidget) GetFiles() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := XGtkFileChooserGetFiles(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

// Gets the current filter.
func (x *FileChooserWidget) GetFilter() *FileFilter {
	var cls *FileFilter

	cret := XGtkFileChooserGetFilter(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FileFilter{}
	cls.Ptr = cret
	return cls
}

// Gets the current set of user-selectable filters, as a list model.
//
// See [method@Gtk.FileChooser.add_filter] and
// [method@Gtk.FileChooser.remove_filter] for changing individual filters.
//
// You should not modify the returned list model. Future changes to
// @chooser may or may not affect the returned model.
func (x *FileChooserWidget) GetFilters() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := XGtkFileChooserGetFilters(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

// Gets whether multiple files can be selected in the file
// chooser.
func (x *FileChooserWidget) GetSelectMultiple() bool {

	cret := XGtkFileChooserGetSelectMultiple(x.GoPointer())
	return cret
}

// Queries the list of shortcut folders in the file chooser.
//
// You should not modify the returned list model. Future changes to
// @chooser may or may not affect the returned model.
func (x *FileChooserWidget) GetShortcutFolders() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := XGtkFileChooserGetShortcutFolders(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

// Removes a 'choice' that has been added with gtk_file_chooser_add_choice().
func (x *FileChooserWidget) RemoveChoice(IdVar string) {

	XGtkFileChooserRemoveChoice(x.GoPointer(), IdVar)

}

// Removes @filter from the list of filters that the user can select between.
func (x *FileChooserWidget) RemoveFilter(FilterVar *FileFilter) {

	XGtkFileChooserRemoveFilter(x.GoPointer(), FilterVar.GoPointer())

}

// Removes a folder from the shortcut folders in a file chooser.
func (x *FileChooserWidget) RemoveShortcutFolder(FolderVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserRemoveShortcutFolder(x.GoPointer(), FolderVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the type of operation that the chooser is performing.
//
// The user interface is adapted to suit the selected action.
//
// For example, an option to create a new folder might be shown
// if the action is %GTK_FILE_CHOOSER_ACTION_SAVE but not if the
// action is %GTK_FILE_CHOOSER_ACTION_OPEN.
func (x *FileChooserWidget) SetAction(ActionVar FileChooserAction) {

	XGtkFileChooserSetAction(x.GoPointer(), ActionVar)

}

// Selects an option in a 'choice' that has been added with
// gtk_file_chooser_add_choice().
//
// For a boolean choice, the possible options are "true" and "false".
func (x *FileChooserWidget) SetChoice(IdVar string, OptionVar string) {

	XGtkFileChooserSetChoice(x.GoPointer(), IdVar, OptionVar)

}

// Sets whether file chooser will offer to create new folders.
//
// This is only relevant if the action is not set to be
// %GTK_FILE_CHOOSER_ACTION_OPEN.
func (x *FileChooserWidget) SetCreateFolders(CreateFoldersVar bool) {

	XGtkFileChooserSetCreateFolders(x.GoPointer(), CreateFoldersVar)

}

// Sets the current folder for @chooser from a `GFile`.
func (x *FileChooserWidget) SetCurrentFolder(FileVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserSetCurrentFolder(x.GoPointer(), FileVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the current name in the file selector, as if entered
// by the user.
//
// Note that the name passed in here is a UTF-8 string rather
// than a filename. This function is meant for such uses as a
// suggested name in a “Save As...” dialog.  You can pass
// “Untitled.doc” or a similarly suitable suggestion for the @name.
//
// If you want to preselect a particular existing file, you should
// use [method@Gtk.FileChooser.set_file] instead.
//
// Please see the documentation for those functions for an example
// of using [method@Gtk.FileChooser.set_current_name] as well.
func (x *FileChooserWidget) SetCurrentName(NameVar string) {

	XGtkFileChooserSetCurrentName(x.GoPointer(), NameVar)

}

// Sets @file as the current filename for the file chooser.
//
// This includes changing to the file’s parent folder and actually selecting
// the file in list. If the @chooser is in %GTK_FILE_CHOOSER_ACTION_SAVE mode,
// the file’s base name will also appear in the dialog’s file name entry.
//
// If the file name isn’t in the current folder of @chooser, then the current
// folder of @chooser will be changed to the folder containing @file.
//
// Note that the file must exist, or nothing will be done except
// for the directory change.
//
// If you are implementing a save dialog, you should use this function if
// you already have a file name to which the user may save; for example,
// when the user opens an existing file and then does “Save As…”. If you
// don’t have a file name already — for example, if the user just created
// a new file and is saving it for the first time, do not call this function.
//
// Instead, use something similar to this:
//
// ```c
// static void
// prepare_file_chooser (GtkFileChooser *chooser,
//
//	GFile          *existing_file)
//
//	{
//	  gboolean document_is_new = (existing_file == NULL);
//
//	  if (document_is_new)
//	    {
//	      GFile *default_file_for_saving = g_file_new_for_path ("./out.txt");
//	      // the user just created a new document
//	      gtk_file_chooser_set_current_folder (chooser, default_file_for_saving, NULL);
//	      gtk_file_chooser_set_current_name (chooser, "Untitled document");
//	      g_object_unref (default_file_for_saving);
//	    }
//	  else
//	    {
//	      // the user edited an existing document
//	      gtk_file_chooser_set_file (chooser, existing_file, NULL);
//	    }
//	}
//
// ```
func (x *FileChooserWidget) SetFile(FileVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserSetFile(x.GoPointer(), FileVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the current filter.
//
// Only the files that pass the filter will be displayed.
// If the user-selectable list of filters is non-empty, then
// the filter should be one of the filters in that list.
//
// Setting the current filter when the list of filters is
// empty is useful if you want to restrict the displayed
// set of files without letting the user change it.
func (x *FileChooserWidget) SetFilter(FilterVar *FileFilter) {

	XGtkFileChooserSetFilter(x.GoPointer(), FilterVar.GoPointer())

}

// Sets whether multiple files can be selected in the file chooser.
//
// This is only relevant if the action is set to be
// %GTK_FILE_CHOOSER_ACTION_OPEN or
// %GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
func (x *FileChooserWidget) SetSelectMultiple(SelectMultipleVar bool) {

	XGtkFileChooserSetSelectMultiple(x.GoPointer(), SelectMultipleVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewFileChooserWidget, lib, "gtk_file_chooser_widget_new")

}
