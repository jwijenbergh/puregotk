// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gsk"
)

// `GtkFileChooserDialog` is a dialog suitable for use with
// “File Open” or “File Save” commands.
//
// ![An example GtkFileChooserDialog](filechooser.png)
//
// This widget works by putting a [class@Gtk.FileChooserWidget]
// inside a [class@Gtk.Dialog]. It exposes the [iface@Gtk.FileChooser]
// interface, so you can use all of the [iface@Gtk.FileChooser] functions
// on the file chooser dialog as well as those for [class@Gtk.Dialog].
//
// Note that `GtkFileChooserDialog` does not have any methods of its
// own. Instead, you should use the functions that work on a
// [iface@Gtk.FileChooser].
//
// If you want to integrate well with the platform you should use the
// [class@Gtk.FileChooserNative] API, which will use a platform-specific
// dialog if available and fall back to `GtkFileChooserDialog`
// otherwise.
//
// ## Typical usage
//
// In the simplest of cases, you can the following code to use
// `GtkFileChooserDialog` to select a file for opening:
//
// ```c
// static void
// on_open_response (GtkDialog *dialog,
//
//	int        response)
//
//	{
//	  if (response == GTK_RESPONSE_ACCEPT)
//	    {
//	      GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
//
//	      g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//	      open_file (file);
//	    }
//
//	  gtk_window_destroy (GTK_WINDOW (dialog));
//	}
//
//	// ...
//	GtkWidget *dialog;
//	GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//	dialog = gtk_file_chooser_dialog_new ("Open File",
//	                                      parent_window,
//	                                      action,
//	                                      _("_Cancel"),
//	                                      GTK_RESPONSE_CANCEL,
//	                                      _("_Open"),
//	                                      GTK_RESPONSE_ACCEPT,
//	                                      NULL);
//
//	gtk_widget_show (dialog);
//
//	g_signal_connect (dialog, "response",
//	                  G_CALLBACK (on_open_response),
//	                  NULL);
//
// ```
//
// To use a dialog for saving, you can use this:
//
// ```c
// static void
// on_save_response (GtkDialog *dialog,
//
//	int        response)
//
//	{
//	  if (response == GTK_RESPONSE_ACCEPT)
//	    {
//	      GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
//
//	      g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//	      save_to_file (file);
//	    }
//
//	  gtk_window_destroy (GTK_WINDOW (dialog));
//	}
//
//	// ...
//	GtkWidget *dialog;
//	GtkFileChooser *chooser;
//	GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//
//	dialog = gtk_file_chooser_dialog_new ("Save File",
//	                                      parent_window,
//	                                      action,
//	                                      _("_Cancel"),
//	                                      GTK_RESPONSE_CANCEL,
//	                                      _("_Save"),
//	                                      GTK_RESPONSE_ACCEPT,
//	                                      NULL);
//	chooser = GTK_FILE_CHOOSER (dialog);
//
//	if (user_edited_a_new_document)
//	  gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//	else
//	  gtk_file_chooser_set_file (chooser, existing_filename);
//
//	gtk_widget_show (dialog);
//
//	g_signal_connect (dialog, "response",
//	                  G_CALLBACK (on_save_response),
//	                  NULL);
//
// ```
//
// ## Setting up a file chooser dialog
//
// There are various cases in which you may need to use a `GtkFileChooserDialog`:
//
// - To select a file for opening, use %GTK_FILE_CHOOSER_ACTION_OPEN.
//
//   - To save a file for the first time, use %GTK_FILE_CHOOSER_ACTION_SAVE,
//     and suggest a name such as “Untitled” with
//     [method@Gtk.FileChooser.set_current_name].
//
//   - To save a file under a different name, use %GTK_FILE_CHOOSER_ACTION_SAVE,
//     and set the existing file with [method@Gtk.FileChooser.set_file].
//
// - To choose a folder instead of a filem use %GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
//
// In general, you should only cause the file chooser to show a specific
// folder when it is appropriate to use [method@Gtk.FileChooser.set_file],
// i.e. when you are doing a “Save As” command and you already have a file
// saved somewhere.
//
// ## Response Codes
//
// `GtkFileChooserDialog` inherits from [class@Gtk.Dialog], so buttons that
// go in its action area have response codes such as %GTK_RESPONSE_ACCEPT and
// %GTK_RESPONSE_CANCEL. For example, you could call
// [ctor@Gtk.FileChooserDialog.new] as follows:
//
// ```c
// GtkWidget *dialog;
// GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
// dialog = gtk_file_chooser_dialog_new ("Open File",
//
//	parent_window,
//	action,
//	_("_Cancel"),
//	GTK_RESPONSE_CANCEL,
//	_("_Open"),
//	GTK_RESPONSE_ACCEPT,
//	NULL);
//
// ```
//
// This will create buttons for “Cancel” and “Open” that use predefined
// response identifiers from [enum@Gtk.ResponseType].  For most dialog
// boxes you can use your own custom response codes rather than the
// ones in [enum@Gtk.ResponseType], but `GtkFileChooserDialog` assumes that
// its “accept”-type action, e.g. an “Open” or “Save” button,
// will have one of the following response codes:
//
// - %GTK_RESPONSE_ACCEPT
// - %GTK_RESPONSE_OK
// - %GTK_RESPONSE_YES
// - %GTK_RESPONSE_APPLY
//
// This is because `GtkFileChooserDialog` must intercept responses and switch
// to folders if appropriate, rather than letting the dialog terminate — the
// implementation uses these known response codes to know which responses can
// be blocked if appropriate.
//
// To summarize, make sure you use a predefined response code
// when you use `GtkFileChooserDialog` to ensure proper operation.
type FileChooserDialog struct {
	Dialog
}

func FileChooserDialogNewFromInternalPtr(ptr uintptr) *FileChooserDialog {
	cls := &FileChooserDialog{}
	cls.Ptr = ptr
	return cls
}

var xNewFileChooserDialog func(string, uintptr, FileChooserAction, string, ...interface{}) uintptr

// Creates a new `GtkFileChooserDialog`.
//
// This function is analogous to [ctor@Gtk.Dialog.new_with_buttons].
func NewFileChooserDialog(TitleVar string, ParentVar *Window, ActionVar FileChooserAction, FirstButtonTextVar string, varArgs ...interface{}) *FileChooserDialog {
	var cls *FileChooserDialog

	cret := xNewFileChooserDialog(TitleVar, ParentVar.GoPointer(), ActionVar, FirstButtonTextVar, varArgs...)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FileChooserDialog{}
	cls.Ptr = cret
	return cls
}

func (c *FileChooserDialog) GoPointer() uintptr {
	return c.Ptr
}

func (c *FileChooserDialog) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
func (x *FileChooserDialog) GetAccessibleRole() AccessibleRole {

	cret := XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Resets the accessible @property to its default value.
func (x *FileChooserDialog) ResetProperty(PropertyVar AccessibleProperty) {

	XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible @relation to its default value.
func (x *FileChooserDialog) ResetRelation(RelationVar AccessibleRelation) {

	XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible @state to its default value.
func (x *FileChooserDialog) ResetState(StateVar AccessibleState) {

	XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *FileChooserDialog) UpdateProperty(FirstPropertyVar AccessibleProperty, varArgs ...interface{}) {

	XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *FileChooserDialog) UpdatePropertyValue(NPropertiesVar int, PropertiesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by %NULL, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *FileChooserDialog) UpdateRelation(FirstRelationVar AccessibleRelation, varArgs ...interface{}) {

	XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *FileChooserDialog) UpdateRelationValue(NRelationsVar int, RelationsVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states. See the [enum@Gtk.AccessibleState]
// documentation for the value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// Example:
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *FileChooserDialog) UpdateState(FirstStateVar AccessibleState, varArgs ...interface{}) {

	XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *FileChooserDialog) UpdateStateValue(NStatesVar int, StatesVar uintptr, ValuesVar uintptr) {

	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the &lt;object&gt; tag used to construct the @buildable.
func (x *FileChooserDialog) GetBuildableId() string {

	cret := XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Adds a 'choice' to the file chooser.
//
// This is typically implemented as a combobox or, for boolean choices,
// as a checkbutton. You can select a value using
// [method@Gtk.FileChooser.set_choice] before the dialog is shown,
// and you can obtain the user-selected value in the
// [signal@Gtk.Dialog::response] signal handler using
// [method@Gtk.FileChooser.get_choice].
func (x *FileChooserDialog) AddChoice(IdVar string, LabelVar string, OptionsVar []string, OptionLabelsVar []string) {

	XGtkFileChooserAddChoice(x.GoPointer(), IdVar, LabelVar, OptionsVar, OptionLabelsVar)

}

// Adds @filter to the list of filters that the user can select between.
//
// When a filter is selected, only files that are passed by that
// filter are displayed.
//
// Note that the @chooser takes ownership of the filter if it is floating,
// so you have to ref and sink it if you want to keep a reference.
func (x *FileChooserDialog) AddFilter(FilterVar *FileFilter) {

	XGtkFileChooserAddFilter(x.GoPointer(), FilterVar.GoPointer())

}

// Adds a folder to be displayed with the shortcut folders
// in a file chooser.
func (x *FileChooserDialog) AddShortcutFolder(FolderVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserAddShortcutFolder(x.GoPointer(), FolderVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Gets the type of operation that the file chooser is performing.
func (x *FileChooserDialog) GetAction() FileChooserAction {

	cret := XGtkFileChooserGetAction(x.GoPointer())
	return cret
}

// Gets the currently selected option in the 'choice' with the given ID.
func (x *FileChooserDialog) GetChoice(IdVar string) string {

	cret := XGtkFileChooserGetChoice(x.GoPointer(), IdVar)
	return cret
}

// Gets whether file chooser will offer to create new folders.
func (x *FileChooserDialog) GetCreateFolders() bool {

	cret := XGtkFileChooserGetCreateFolders(x.GoPointer())
	return cret
}

// Gets the current folder of @chooser as `GFile`.
func (x *FileChooserDialog) GetCurrentFolder() *gio.FileBase {
	var cls *gio.FileBase

	cret := XGtkFileChooserGetCurrentFolder(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.FileBase{}
	cls.Ptr = cret
	return cls
}

// Gets the current name in the file selector, as entered by the user.
//
// This is meant to be used in save dialogs, to get the currently typed
// filename when the file itself does not exist yet.
func (x *FileChooserDialog) GetCurrentName() string {

	cret := XGtkFileChooserGetCurrentName(x.GoPointer())
	return cret
}

// Gets the `GFile` for the currently selected file in
// the file selector.
//
// If multiple files are selected, one of the files will be
// returned at random.
//
// If the file chooser is in folder mode, this function returns
// the selected folder.
func (x *FileChooserDialog) GetFile() *gio.FileBase {
	var cls *gio.FileBase

	cret := XGtkFileChooserGetFile(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.FileBase{}
	cls.Ptr = cret
	return cls
}

// Lists all the selected files and subfolders in the current folder
// of @chooser as `GFile`.
func (x *FileChooserDialog) GetFiles() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := XGtkFileChooserGetFiles(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

// Gets the current filter.
func (x *FileChooserDialog) GetFilter() *FileFilter {
	var cls *FileFilter

	cret := XGtkFileChooserGetFilter(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FileFilter{}
	cls.Ptr = cret
	return cls
}

// Gets the current set of user-selectable filters, as a list model.
//
// See [method@Gtk.FileChooser.add_filter] and
// [method@Gtk.FileChooser.remove_filter] for changing individual filters.
//
// You should not modify the returned list model. Future changes to
// @chooser may or may not affect the returned model.
func (x *FileChooserDialog) GetFilters() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := XGtkFileChooserGetFilters(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

// Gets whether multiple files can be selected in the file
// chooser.
func (x *FileChooserDialog) GetSelectMultiple() bool {

	cret := XGtkFileChooserGetSelectMultiple(x.GoPointer())
	return cret
}

// Queries the list of shortcut folders in the file chooser.
//
// You should not modify the returned list model. Future changes to
// @chooser may or may not affect the returned model.
func (x *FileChooserDialog) GetShortcutFolders() *gio.ListModelBase {
	var cls *gio.ListModelBase

	cret := XGtkFileChooserGetShortcutFolders(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.ListModelBase{}
	cls.Ptr = cret
	return cls
}

// Removes a 'choice' that has been added with gtk_file_chooser_add_choice().
func (x *FileChooserDialog) RemoveChoice(IdVar string) {

	XGtkFileChooserRemoveChoice(x.GoPointer(), IdVar)

}

// Removes @filter from the list of filters that the user can select between.
func (x *FileChooserDialog) RemoveFilter(FilterVar *FileFilter) {

	XGtkFileChooserRemoveFilter(x.GoPointer(), FilterVar.GoPointer())

}

// Removes a folder from the shortcut folders in a file chooser.
func (x *FileChooserDialog) RemoveShortcutFolder(FolderVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserRemoveShortcutFolder(x.GoPointer(), FolderVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the type of operation that the chooser is performing.
//
// The user interface is adapted to suit the selected action.
//
// For example, an option to create a new folder might be shown
// if the action is %GTK_FILE_CHOOSER_ACTION_SAVE but not if the
// action is %GTK_FILE_CHOOSER_ACTION_OPEN.
func (x *FileChooserDialog) SetAction(ActionVar FileChooserAction) {

	XGtkFileChooserSetAction(x.GoPointer(), ActionVar)

}

// Selects an option in a 'choice' that has been added with
// gtk_file_chooser_add_choice().
//
// For a boolean choice, the possible options are "true" and "false".
func (x *FileChooserDialog) SetChoice(IdVar string, OptionVar string) {

	XGtkFileChooserSetChoice(x.GoPointer(), IdVar, OptionVar)

}

// Sets whether file chooser will offer to create new folders.
//
// This is only relevant if the action is not set to be
// %GTK_FILE_CHOOSER_ACTION_OPEN.
func (x *FileChooserDialog) SetCreateFolders(CreateFoldersVar bool) {

	XGtkFileChooserSetCreateFolders(x.GoPointer(), CreateFoldersVar)

}

// Sets the current folder for @chooser from a `GFile`.
func (x *FileChooserDialog) SetCurrentFolder(FileVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserSetCurrentFolder(x.GoPointer(), FileVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the current name in the file selector, as if entered
// by the user.
//
// Note that the name passed in here is a UTF-8 string rather
// than a filename. This function is meant for such uses as a
// suggested name in a “Save As...” dialog.  You can pass
// “Untitled.doc” or a similarly suitable suggestion for the @name.
//
// If you want to preselect a particular existing file, you should
// use [method@Gtk.FileChooser.set_file] instead.
//
// Please see the documentation for those functions for an example
// of using [method@Gtk.FileChooser.set_current_name] as well.
func (x *FileChooserDialog) SetCurrentName(NameVar string) {

	XGtkFileChooserSetCurrentName(x.GoPointer(), NameVar)

}

// Sets @file as the current filename for the file chooser.
//
// This includes changing to the file’s parent folder and actually selecting
// the file in list. If the @chooser is in %GTK_FILE_CHOOSER_ACTION_SAVE mode,
// the file’s base name will also appear in the dialog’s file name entry.
//
// If the file name isn’t in the current folder of @chooser, then the current
// folder of @chooser will be changed to the folder containing @file.
//
// Note that the file must exist, or nothing will be done except
// for the directory change.
//
// If you are implementing a save dialog, you should use this function if
// you already have a file name to which the user may save; for example,
// when the user opens an existing file and then does “Save As…”. If you
// don’t have a file name already — for example, if the user just created
// a new file and is saving it for the first time, do not call this function.
//
// Instead, use something similar to this:
//
// ```c
// static void
// prepare_file_chooser (GtkFileChooser *chooser,
//
//	GFile          *existing_file)
//
//	{
//	  gboolean document_is_new = (existing_file == NULL);
//
//	  if (document_is_new)
//	    {
//	      GFile *default_file_for_saving = g_file_new_for_path ("./out.txt");
//	      // the user just created a new document
//	      gtk_file_chooser_set_current_folder (chooser, default_file_for_saving, NULL);
//	      gtk_file_chooser_set_current_name (chooser, "Untitled document");
//	      g_object_unref (default_file_for_saving);
//	    }
//	  else
//	    {
//	      // the user edited an existing document
//	      gtk_file_chooser_set_file (chooser, existing_file, NULL);
//	    }
//	}
//
// ```
func (x *FileChooserDialog) SetFile(FileVar gio.File) (bool, error) {
	var cerr *glib.Error

	cret := XGtkFileChooserSetFile(x.GoPointer(), FileVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Sets the current filter.
//
// Only the files that pass the filter will be displayed.
// If the user-selectable list of filters is non-empty, then
// the filter should be one of the filters in that list.
//
// Setting the current filter when the list of filters is
// empty is useful if you want to restrict the displayed
// set of files without letting the user change it.
func (x *FileChooserDialog) SetFilter(FilterVar *FileFilter) {

	XGtkFileChooserSetFilter(x.GoPointer(), FilterVar.GoPointer())

}

// Sets whether multiple files can be selected in the file chooser.
//
// This is only relevant if the action is set to be
// %GTK_FILE_CHOOSER_ACTION_OPEN or
// %GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
func (x *FileChooserDialog) SetSelectMultiple(SelectMultipleVar bool) {

	XGtkFileChooserSetSelectMultiple(x.GoPointer(), SelectMultipleVar)

}

// Returns the renderer that is used for this `GtkNative`.
func (x *FileChooserDialog) GetRenderer() *gsk.Renderer {
	var cls *gsk.Renderer

	cret := XGtkNativeGetRenderer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gsk.Renderer{}
	cls.Ptr = cret
	return cls
}

// Returns the surface of this `GtkNative`.
func (x *FileChooserDialog) GetSurface() *gdk.Surface {
	var cls *gdk.Surface

	cret := XGtkNativeGetSurface(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Surface{}
	cls.Ptr = cret
	return cls
}

// Retrieves the surface transform of @self.
//
// This is the translation from @self's surface coordinates into
// @self's widget coordinates.
func (x *FileChooserDialog) GetSurfaceTransform(XVar float64, YVar float64) {

	XGtkNativeGetSurfaceTransform(x.GoPointer(), XVar, YVar)

}

// Realizes a `GtkNative`.
//
// This should only be used by subclasses.
func (x *FileChooserDialog) Realize() {

	XGtkNativeRealize(x.GoPointer())

}

// Unrealizes a `GtkNative`.
//
// This should only be used by subclasses.
func (x *FileChooserDialog) Unrealize() {

	XGtkNativeUnrealize(x.GoPointer())

}

// Returns the display that this `GtkRoot` is on.
func (x *FileChooserDialog) GetDisplay() *gdk.Display {
	var cls *gdk.Display

	cret := XGtkRootGetDisplay(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Display{}
	cls.Ptr = cret
	return cls
}

// Retrieves the current focused widget within the root.
//
// Note that this is the widget that would have the focus
// if the root is active; if the root is not focused then
// `gtk_widget_has_focus (widget)` will be %FALSE for the
// widget.
func (x *FileChooserDialog) GetFocus() *Widget {
	var cls *Widget

	cret := XGtkRootGetFocus(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Widget{}
	cls.Ptr = cret
	return cls
}

// If @focus is not the current focus widget, and is focusable, sets
// it as the focus widget for the root.
//
// If @focus is %NULL, unsets the focus widget for the root.
//
// To set the focus to a particular widget in the root, it is usually
// more convenient to use [method@Gtk.Widget.grab_focus] instead of
// this function.
func (x *FileChooserDialog) SetFocus(FocusVar *Widget) {

	XGtkRootSetFocus(x.GoPointer(), FocusVar.GoPointer())

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewFileChooserDialog, lib, "gtk_file_chooser_dialog_new")

}
