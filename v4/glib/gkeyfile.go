// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// The GKeyFile struct contains only private data
// and should not be accessed directly.
type KeyFile struct {
}

func (x *KeyFile) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewKeyFile func() *KeyFile

// Creates a new empty #GKeyFile object. Use
// g_key_file_load_from_file(), g_key_file_load_from_data(),
// g_key_file_load_from_dirs() or g_key_file_load_from_data_dirs() to
// read an existing key file.
func NewKeyFile() *KeyFile {

	cret := xNewKeyFile()
	return cret
}

var xKeyFileFree func(uintptr)

// Clears all keys and groups from @key_file, and decreases the
// reference count by 1. If the reference count reaches zero,
// frees the key file and all its allocated memory.
func (x *KeyFile) Free() {

	xKeyFileFree(x.GoPointer())

}

var xKeyFileGetBoolean func(uintptr, string, string, **Error) bool

// Returns the value associated with @key under @group_name as a
// boolean.
//
// If @key cannot be found then %FALSE is returned and @error is set
// to %G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value
// associated with @key cannot be interpreted as a boolean then %FALSE
// is returned and @error is set to %G_KEY_FILE_ERROR_INVALID_VALUE.
func (x *KeyFile) GetBoolean(GroupNameVar string, KeyVar string) (bool, error) {
	var cerr *Error

	cret := xKeyFileGetBoolean(x.GoPointer(), GroupNameVar, KeyVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetBooleanList func(uintptr, string, string, uint, **Error) uintptr

// Returns the values associated with @key under @group_name as
// booleans.
//
// If @key cannot be found then %NULL is returned and @error is set to
// %G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
// with @key cannot be interpreted as booleans then %NULL is returned
// and @error is set to %G_KEY_FILE_ERROR_INVALID_VALUE.
func (x *KeyFile) GetBooleanList(GroupNameVar string, KeyVar string, LengthVar uint) (uintptr, error) {
	var cerr *Error

	cret := xKeyFileGetBooleanList(x.GoPointer(), GroupNameVar, KeyVar, LengthVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetComment func(uintptr, string, string, **Error) string

// Retrieves a comment above @key from @group_name.
// If @key is %NULL then @comment will be read from above
// @group_name. If both @key and @group_name are %NULL, then
// @comment will be read from above the first group in the file.
//
// Note that the returned string does not include the '#' comment markers,
// but does include any whitespace after them (on each line). It includes
// the line breaks between lines, but does not include the final line break.
func (x *KeyFile) GetComment(GroupNameVar string, KeyVar string) (string, error) {
	var cerr *Error

	cret := xKeyFileGetComment(x.GoPointer(), GroupNameVar, KeyVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetDouble func(uintptr, string, string, **Error) float64

// Returns the value associated with @key under @group_name as a
// double. If @group_name is %NULL, the start_group is used.
//
// If @key cannot be found then 0.0 is returned and @error is set to
// %G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
// with @key cannot be interpreted as a double then 0.0 is returned
// and @error is set to %G_KEY_FILE_ERROR_INVALID_VALUE.
func (x *KeyFile) GetDouble(GroupNameVar string, KeyVar string) (float64, error) {
	var cerr *Error

	cret := xKeyFileGetDouble(x.GoPointer(), GroupNameVar, KeyVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetDoubleList func(uintptr, string, string, uint, **Error) uintptr

// Returns the values associated with @key under @group_name as
// doubles.
//
// If @key cannot be found then %NULL is returned and @error is set to
// %G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
// with @key cannot be interpreted as doubles then %NULL is returned
// and @error is set to %G_KEY_FILE_ERROR_INVALID_VALUE.
func (x *KeyFile) GetDoubleList(GroupNameVar string, KeyVar string, LengthVar uint) (uintptr, error) {
	var cerr *Error

	cret := xKeyFileGetDoubleList(x.GoPointer(), GroupNameVar, KeyVar, LengthVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetGroups func(uintptr, uint) uintptr

// Returns all groups in the key file loaded with @key_file.
// The array of returned groups will be %NULL-terminated, so
// @length may optionally be %NULL.
func (x *KeyFile) GetGroups(LengthVar uint) uintptr {

	cret := xKeyFileGetGroups(x.GoPointer(), LengthVar)
	return cret
}

var xKeyFileGetInt64 func(uintptr, string, string, **Error) int64

// Returns the value associated with @key under @group_name as a signed
// 64-bit integer. This is similar to g_key_file_get_integer() but can return
// 64-bit results without truncation.
func (x *KeyFile) GetInt64(GroupNameVar string, KeyVar string) (int64, error) {
	var cerr *Error

	cret := xKeyFileGetInt64(x.GoPointer(), GroupNameVar, KeyVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetInteger func(uintptr, string, string, **Error) int

// Returns the value associated with @key under @group_name as an
// integer.
//
// If @key cannot be found then 0 is returned and @error is set to
// %G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
// with @key cannot be interpreted as an integer, or is out of range
// for a #gint, then 0 is returned
// and @error is set to %G_KEY_FILE_ERROR_INVALID_VALUE.
func (x *KeyFile) GetInteger(GroupNameVar string, KeyVar string) (int, error) {
	var cerr *Error

	cret := xKeyFileGetInteger(x.GoPointer(), GroupNameVar, KeyVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetIntegerList func(uintptr, string, string, uint, **Error) uintptr

// Returns the values associated with @key under @group_name as
// integers.
//
// If @key cannot be found then %NULL is returned and @error is set to
// %G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
// with @key cannot be interpreted as integers, or are out of range for
// #gint, then %NULL is returned
// and @error is set to %G_KEY_FILE_ERROR_INVALID_VALUE.
func (x *KeyFile) GetIntegerList(GroupNameVar string, KeyVar string, LengthVar uint) (uintptr, error) {
	var cerr *Error

	cret := xKeyFileGetIntegerList(x.GoPointer(), GroupNameVar, KeyVar, LengthVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetKeys func(uintptr, string, uint, **Error) uintptr

// Returns all keys for the group name @group_name.  The array of
// returned keys will be %NULL-terminated, so @length may
// optionally be %NULL. In the event that the @group_name cannot
// be found, %NULL is returned and @error is set to
// %G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
func (x *KeyFile) GetKeys(GroupNameVar string, LengthVar uint) (uintptr, error) {
	var cerr *Error

	cret := xKeyFileGetKeys(x.GoPointer(), GroupNameVar, LengthVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetLocaleForKey func(uintptr, string, string, string) string

// Returns the actual locale which the result of
// g_key_file_get_locale_string() or g_key_file_get_locale_string_list()
// came from.
//
// If calling g_key_file_get_locale_string() or
// g_key_file_get_locale_string_list() with exactly the same @key_file,
// @group_name, @key and @locale, the result of those functions will
// have originally been tagged with the locale that is the result of
// this function.
func (x *KeyFile) GetLocaleForKey(GroupNameVar string, KeyVar string, LocaleVar string) string {

	cret := xKeyFileGetLocaleForKey(x.GoPointer(), GroupNameVar, KeyVar, LocaleVar)
	return cret
}

var xKeyFileGetLocaleString func(uintptr, string, string, string, **Error) string

// Returns the value associated with @key under @group_name
// translated in the given @locale if available.  If @locale is
// %NULL then the current locale is assumed.
//
// If @locale is to be non-%NULL, or if the current locale will change over
// the lifetime of the #GKeyFile, it must be loaded with
// %G_KEY_FILE_KEEP_TRANSLATIONS in order to load strings for all locales.
//
// If @key cannot be found then %NULL is returned and @error is set
// to %G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the value associated
// with @key cannot be interpreted or no suitable translation can
// be found then the untranslated value is returned.
func (x *KeyFile) GetLocaleString(GroupNameVar string, KeyVar string, LocaleVar string) (string, error) {
	var cerr *Error

	cret := xKeyFileGetLocaleString(x.GoPointer(), GroupNameVar, KeyVar, LocaleVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetLocaleStringList func(uintptr, string, string, string, uint, **Error) uintptr

// Returns the values associated with @key under @group_name
// translated in the given @locale if available.  If @locale is
// %NULL then the current locale is assumed.
//
// If @locale is to be non-%NULL, or if the current locale will change over
// the lifetime of the #GKeyFile, it must be loaded with
// %G_KEY_FILE_KEEP_TRANSLATIONS in order to load strings for all locales.
//
// If @key cannot be found then %NULL is returned and @error is set
// to %G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the values associated
// with @key cannot be interpreted or no suitable translations
// can be found then the untranslated values are returned. The
// returned array is %NULL-terminated, so @length may optionally
// be %NULL.
func (x *KeyFile) GetLocaleStringList(GroupNameVar string, KeyVar string, LocaleVar string, LengthVar uint) (uintptr, error) {
	var cerr *Error

	cret := xKeyFileGetLocaleStringList(x.GoPointer(), GroupNameVar, KeyVar, LocaleVar, LengthVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetStartGroup func(uintptr) string

// Returns the name of the start group of the file.
func (x *KeyFile) GetStartGroup() string {

	cret := xKeyFileGetStartGroup(x.GoPointer())
	return cret
}

var xKeyFileGetString func(uintptr, string, string, **Error) string

// Returns the string value associated with @key under @group_name.
// Unlike g_key_file_get_value(), this function handles escape sequences
// like \s.
//
// In the event the key cannot be found, %NULL is returned and
// @error is set to %G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
// event that the @group_name cannot be found, %NULL is returned
// and @error is set to %G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
func (x *KeyFile) GetString(GroupNameVar string, KeyVar string) (string, error) {
	var cerr *Error

	cret := xKeyFileGetString(x.GoPointer(), GroupNameVar, KeyVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetStringList func(uintptr, string, string, uint, **Error) uintptr

// Returns the values associated with @key under @group_name.
//
// In the event the key cannot be found, %NULL is returned and
// @error is set to %G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
// event that the @group_name cannot be found, %NULL is returned
// and @error is set to %G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
func (x *KeyFile) GetStringList(GroupNameVar string, KeyVar string, LengthVar uint) (uintptr, error) {
	var cerr *Error

	cret := xKeyFileGetStringList(x.GoPointer(), GroupNameVar, KeyVar, LengthVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetUint64 func(uintptr, string, string, **Error) uint64

// Returns the value associated with @key under @group_name as an unsigned
// 64-bit integer. This is similar to g_key_file_get_integer() but can return
// large positive results without truncation.
func (x *KeyFile) GetUint64(GroupNameVar string, KeyVar string) (uint64, error) {
	var cerr *Error

	cret := xKeyFileGetUint64(x.GoPointer(), GroupNameVar, KeyVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileGetValue func(uintptr, string, string, **Error) string

// Returns the raw value associated with @key under @group_name.
// Use g_key_file_get_string() to retrieve an unescaped UTF-8 string.
//
// In the event the key cannot be found, %NULL is returned and
// @error is set to %G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
// event that the @group_name cannot be found, %NULL is returned
// and @error is set to %G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
func (x *KeyFile) GetValue(GroupNameVar string, KeyVar string) (string, error) {
	var cerr *Error

	cret := xKeyFileGetValue(x.GoPointer(), GroupNameVar, KeyVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileHasGroup func(uintptr, string) bool

// Looks whether the key file has the group @group_name.
func (x *KeyFile) HasGroup(GroupNameVar string) bool {

	cret := xKeyFileHasGroup(x.GoPointer(), GroupNameVar)
	return cret
}

var xKeyFileHasKey func(uintptr, string, string, **Error) bool

// Looks whether the key file has the key @key in the group
// @group_name.
//
// Note that this function does not follow the rules for #GError strictly;
// the return value both carries meaning and signals an error.  To use
// this function, you must pass a #GError pointer in @error, and check
// whether it is not %NULL to see if an error occurred.
//
// Language bindings should use g_key_file_get_value() to test whether
// or not a key exists.
func (x *KeyFile) HasKey(GroupNameVar string, KeyVar string) (bool, error) {
	var cerr *Error

	cret := xKeyFileHasKey(x.GoPointer(), GroupNameVar, KeyVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileLoadFromBytes func(uintptr, *Bytes, KeyFileFlags, **Error) bool

// Loads a key file from the data in @bytes into an empty #GKeyFile structure.
// If the object cannot be created then %error is set to a #GKeyFileError.
func (x *KeyFile) LoadFromBytes(BytesVar *Bytes, FlagsVar KeyFileFlags) (bool, error) {
	var cerr *Error

	cret := xKeyFileLoadFromBytes(x.GoPointer(), BytesVar, FlagsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileLoadFromData func(uintptr, string, uint, KeyFileFlags, **Error) bool

// Loads a key file from memory into an empty #GKeyFile structure.
// If the object cannot be created then %error is set to a #GKeyFileError.
func (x *KeyFile) LoadFromData(DataVar string, LengthVar uint, FlagsVar KeyFileFlags) (bool, error) {
	var cerr *Error

	cret := xKeyFileLoadFromData(x.GoPointer(), DataVar, LengthVar, FlagsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileLoadFromDataDirs func(uintptr, string, string, KeyFileFlags, **Error) bool

// This function looks for a key file named @file in the paths
// returned from g_get_user_data_dir() and g_get_system_data_dirs(),
// loads the file into @key_file and returns the file's full path in
// @full_path.  If the file could not be loaded then an %error is
// set to either a #GFileError or #GKeyFileError.
func (x *KeyFile) LoadFromDataDirs(FileVar string, FullPathVar string, FlagsVar KeyFileFlags) (bool, error) {
	var cerr *Error

	cret := xKeyFileLoadFromDataDirs(x.GoPointer(), FileVar, FullPathVar, FlagsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileLoadFromDirs func(uintptr, string, uintptr, string, KeyFileFlags, **Error) bool

// This function looks for a key file named @file in the paths
// specified in @search_dirs, loads the file into @key_file and
// returns the file's full path in @full_path.
//
// If the file could not be found in any of the @search_dirs,
// %G_KEY_FILE_ERROR_NOT_FOUND is returned. If
// the file is found but the OS returns an error when opening or reading the
// file, a %G_FILE_ERROR is returned. If there is a problem parsing the file, a
// %G_KEY_FILE_ERROR is returned.
func (x *KeyFile) LoadFromDirs(FileVar string, SearchDirsVar uintptr, FullPathVar string, FlagsVar KeyFileFlags) (bool, error) {
	var cerr *Error

	cret := xKeyFileLoadFromDirs(x.GoPointer(), FileVar, SearchDirsVar, FullPathVar, FlagsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileLoadFromFile func(uintptr, string, KeyFileFlags, **Error) bool

// Loads a key file into an empty #GKeyFile structure.
//
// If the OS returns an error when opening or reading the file, a
// %G_FILE_ERROR is returned. If there is a problem parsing the file, a
// %G_KEY_FILE_ERROR is returned.
//
// This function will never return a %G_KEY_FILE_ERROR_NOT_FOUND error. If the
// @file is not found, %G_FILE_ERROR_NOENT is returned.
func (x *KeyFile) LoadFromFile(FileVar string, FlagsVar KeyFileFlags) (bool, error) {
	var cerr *Error

	cret := xKeyFileLoadFromFile(x.GoPointer(), FileVar, FlagsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileRef func(uintptr) *KeyFile

// Increases the reference count of @key_file.
func (x *KeyFile) Ref() *KeyFile {

	cret := xKeyFileRef(x.GoPointer())
	return cret
}

var xKeyFileRemoveComment func(uintptr, string, string, **Error) bool

// Removes a comment above @key from @group_name.
// If @key is %NULL then @comment will be removed above @group_name.
// If both @key and @group_name are %NULL, then @comment will
// be removed above the first group in the file.
func (x *KeyFile) RemoveComment(GroupNameVar string, KeyVar string) (bool, error) {
	var cerr *Error

	cret := xKeyFileRemoveComment(x.GoPointer(), GroupNameVar, KeyVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileRemoveGroup func(uintptr, string, **Error) bool

// Removes the specified group, @group_name,
// from the key file.
func (x *KeyFile) RemoveGroup(GroupNameVar string) (bool, error) {
	var cerr *Error

	cret := xKeyFileRemoveGroup(x.GoPointer(), GroupNameVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileRemoveKey func(uintptr, string, string, **Error) bool

// Removes @key in @group_name from the key file.
func (x *KeyFile) RemoveKey(GroupNameVar string, KeyVar string) (bool, error) {
	var cerr *Error

	cret := xKeyFileRemoveKey(x.GoPointer(), GroupNameVar, KeyVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileSaveToFile func(uintptr, string, **Error) bool

// Writes the contents of @key_file to @filename using
// g_file_set_contents(). If you need stricter guarantees about durability of
// the written file than are provided by g_file_set_contents(), use
// g_file_set_contents_full() with the return value of g_key_file_to_data().
//
// This function can fail for any of the reasons that
// g_file_set_contents() may fail.
func (x *KeyFile) SaveToFile(FilenameVar string) (bool, error) {
	var cerr *Error

	cret := xKeyFileSaveToFile(x.GoPointer(), FilenameVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileSetBoolean func(uintptr, string, string, bool)

// Associates a new boolean value with @key under @group_name.
// If @key cannot be found then it is created.
func (x *KeyFile) SetBoolean(GroupNameVar string, KeyVar string, ValueVar bool) {

	xKeyFileSetBoolean(x.GoPointer(), GroupNameVar, KeyVar, ValueVar)

}

var xKeyFileSetBooleanList func(uintptr, string, string, uintptr, uint)

// Associates a list of boolean values with @key under @group_name.
// If @key cannot be found then it is created.
// If @group_name is %NULL, the start_group is used.
func (x *KeyFile) SetBooleanList(GroupNameVar string, KeyVar string, ListVar uintptr, LengthVar uint) {

	xKeyFileSetBooleanList(x.GoPointer(), GroupNameVar, KeyVar, ListVar, LengthVar)

}

var xKeyFileSetComment func(uintptr, string, string, string, **Error) bool

// Places a comment above @key from @group_name.
//
// If @key is %NULL then @comment will be written above @group_name.
// If both @key and @group_name  are %NULL, then @comment will be
// written above the first group in the file.
//
// Note that this function prepends a '#' comment marker to
// each line of @comment.
func (x *KeyFile) SetComment(GroupNameVar string, KeyVar string, CommentVar string) (bool, error) {
	var cerr *Error

	cret := xKeyFileSetComment(x.GoPointer(), GroupNameVar, KeyVar, CommentVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileSetDouble func(uintptr, string, string, float64)

// Associates a new double value with @key under @group_name.
// If @key cannot be found then it is created.
func (x *KeyFile) SetDouble(GroupNameVar string, KeyVar string, ValueVar float64) {

	xKeyFileSetDouble(x.GoPointer(), GroupNameVar, KeyVar, ValueVar)

}

var xKeyFileSetDoubleList func(uintptr, string, string, uintptr, uint)

// Associates a list of double values with @key under
// @group_name.  If @key cannot be found then it is created.
func (x *KeyFile) SetDoubleList(GroupNameVar string, KeyVar string, ListVar uintptr, LengthVar uint) {

	xKeyFileSetDoubleList(x.GoPointer(), GroupNameVar, KeyVar, ListVar, LengthVar)

}

var xKeyFileSetInt64 func(uintptr, string, string, int64)

// Associates a new integer value with @key under @group_name.
// If @key cannot be found then it is created.
func (x *KeyFile) SetInt64(GroupNameVar string, KeyVar string, ValueVar int64) {

	xKeyFileSetInt64(x.GoPointer(), GroupNameVar, KeyVar, ValueVar)

}

var xKeyFileSetInteger func(uintptr, string, string, int)

// Associates a new integer value with @key under @group_name.
// If @key cannot be found then it is created.
func (x *KeyFile) SetInteger(GroupNameVar string, KeyVar string, ValueVar int) {

	xKeyFileSetInteger(x.GoPointer(), GroupNameVar, KeyVar, ValueVar)

}

var xKeyFileSetIntegerList func(uintptr, string, string, uintptr, uint)

// Associates a list of integer values with @key under @group_name.
// If @key cannot be found then it is created.
func (x *KeyFile) SetIntegerList(GroupNameVar string, KeyVar string, ListVar uintptr, LengthVar uint) {

	xKeyFileSetIntegerList(x.GoPointer(), GroupNameVar, KeyVar, ListVar, LengthVar)

}

var xKeyFileSetListSeparator func(uintptr, byte)

// Sets the character which is used to separate
// values in lists. Typically ';' or ',' are used
// as separators. The default list separator is ';'.
func (x *KeyFile) SetListSeparator(SeparatorVar byte) {

	xKeyFileSetListSeparator(x.GoPointer(), SeparatorVar)

}

var xKeyFileSetLocaleString func(uintptr, string, string, string, string)

// Associates a string value for @key and @locale under @group_name.
// If the translation for @key cannot be found then it is created.
func (x *KeyFile) SetLocaleString(GroupNameVar string, KeyVar string, LocaleVar string, StringVar string) {

	xKeyFileSetLocaleString(x.GoPointer(), GroupNameVar, KeyVar, LocaleVar, StringVar)

}

var xKeyFileSetLocaleStringList func(uintptr, string, string, string, uintptr, uint)

// Associates a list of string values for @key and @locale under
// @group_name.  If the translation for @key cannot be found then
// it is created.
func (x *KeyFile) SetLocaleStringList(GroupNameVar string, KeyVar string, LocaleVar string, ListVar uintptr, LengthVar uint) {

	xKeyFileSetLocaleStringList(x.GoPointer(), GroupNameVar, KeyVar, LocaleVar, ListVar, LengthVar)

}

var xKeyFileSetString func(uintptr, string, string, string)

// Associates a new string value with @key under @group_name.
// If @key cannot be found then it is created.
// If @group_name cannot be found then it is created.
// Unlike g_key_file_set_value(), this function handles characters
// that need escaping, such as newlines.
func (x *KeyFile) SetString(GroupNameVar string, KeyVar string, StringVar string) {

	xKeyFileSetString(x.GoPointer(), GroupNameVar, KeyVar, StringVar)

}

var xKeyFileSetStringList func(uintptr, string, string, uintptr, uint)

// Associates a list of string values for @key under @group_name.
// If @key cannot be found then it is created.
// If @group_name cannot be found then it is created.
func (x *KeyFile) SetStringList(GroupNameVar string, KeyVar string, ListVar uintptr, LengthVar uint) {

	xKeyFileSetStringList(x.GoPointer(), GroupNameVar, KeyVar, ListVar, LengthVar)

}

var xKeyFileSetUint64 func(uintptr, string, string, uint64)

// Associates a new integer value with @key under @group_name.
// If @key cannot be found then it is created.
func (x *KeyFile) SetUint64(GroupNameVar string, KeyVar string, ValueVar uint64) {

	xKeyFileSetUint64(x.GoPointer(), GroupNameVar, KeyVar, ValueVar)

}

var xKeyFileSetValue func(uintptr, string, string, string)

// Associates a new value with @key under @group_name.
//
// If @key cannot be found then it is created. If @group_name cannot
// be found then it is created. To set an UTF-8 string which may contain
// characters that need escaping (such as newlines or spaces), use
// g_key_file_set_string().
func (x *KeyFile) SetValue(GroupNameVar string, KeyVar string, ValueVar string) {

	xKeyFileSetValue(x.GoPointer(), GroupNameVar, KeyVar, ValueVar)

}

var xKeyFileToData func(uintptr, uint, **Error) string

// This function outputs @key_file as a string.
//
// Note that this function never reports an error,
// so it is safe to pass %NULL as @error.
func (x *KeyFile) ToData(LengthVar uint) (string, error) {
	var cerr *Error

	cret := xKeyFileToData(x.GoPointer(), LengthVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xKeyFileUnref func(uintptr)

// Decreases the reference count of @key_file by 1. If the reference count
// reaches zero, frees the key file and all its allocated memory.
func (x *KeyFile) Unref() {

	xKeyFileUnref(x.GoPointer())

}

const (
	// The name of the main group of a desktop entry file, as defined in the
	// [Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec).
	// Consult the specification for more
	// details about the meanings of the keys below.
	KEY_FILE_DESKTOP_GROUP string = "Desktop Entry"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a string list
	// giving the available application actions.
	KEY_FILE_DESKTOP_KEY_ACTIONS string = "Actions"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a list
	// of strings giving the categories in which the desktop entry
	// should be shown in a menu.
	KEY_FILE_DESKTOP_KEY_CATEGORIES string = "Categories"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
	// string giving the tooltip for the desktop entry.
	KEY_FILE_DESKTOP_KEY_COMMENT string = "Comment"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
	// set to true if the application is D-Bus activatable.
	KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE string = "DBusActivatable"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a string
	// giving the command line to execute. It is only valid for desktop
	// entries with the `Application` type.
	KEY_FILE_DESKTOP_KEY_EXEC string = "Exec"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
	// string giving the generic name of the desktop entry.
	KEY_FILE_DESKTOP_KEY_GENERIC_NAME string = "GenericName"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
	// stating whether the desktop entry has been deleted by the user.
	KEY_FILE_DESKTOP_KEY_HIDDEN string = "Hidden"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
	// string giving the name of the icon to be displayed for the desktop
	// entry.
	KEY_FILE_DESKTOP_KEY_ICON string = "Icon"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a list
	// of strings giving the MIME types supported by this desktop entry.
	KEY_FILE_DESKTOP_KEY_MIME_TYPE string = "MimeType"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
	// string giving the specific name of the desktop entry.
	KEY_FILE_DESKTOP_KEY_NAME string = "Name"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a list of
	// strings identifying the environments that should not display the
	// desktop entry.
	KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN string = "NotShowIn"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
	// stating whether the desktop entry should be shown in menus.
	KEY_FILE_DESKTOP_KEY_NO_DISPLAY string = "NoDisplay"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a list of
	// strings identifying the environments that should display the
	// desktop entry.
	KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN string = "OnlyShowIn"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a string
	// containing the working directory to run the program in. It is only
	// valid for desktop entries with the `Application` type.
	KEY_FILE_DESKTOP_KEY_PATH string = "Path"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
	// stating whether the application supports the
	// [Startup Notification Protocol Specification](http://www.freedesktop.org/Standards/startup-notification-spec).
	KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY string = "StartupNotify"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is string
	// identifying the WM class or name hint of a window that the application
	// will create, which can be used to emulate Startup Notification with
	// older applications.
	KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS string = "StartupWMClass"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
	// stating whether the program should be run in a terminal window.
	//
	// It is only valid for desktop entries with the `Application` type.
	KEY_FILE_DESKTOP_KEY_TERMINAL string = "Terminal"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a string
	// giving the file name of a binary on disk used to determine if the
	// program is actually installed. It is only valid for desktop entries
	// with the `Application` type.
	KEY_FILE_DESKTOP_KEY_TRY_EXEC string = "TryExec"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a string
	// giving the type of the desktop entry.
	//
	// Usually %G_KEY_FILE_DESKTOP_TYPE_APPLICATION,
	// %G_KEY_FILE_DESKTOP_TYPE_LINK, or
	// %G_KEY_FILE_DESKTOP_TYPE_DIRECTORY.
	KEY_FILE_DESKTOP_KEY_TYPE string = "Type"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a string
	// giving the URL to access. It is only valid for desktop entries
	// with the `Link` type.
	KEY_FILE_DESKTOP_KEY_URL string = "URL"
	// A key under %G_KEY_FILE_DESKTOP_GROUP, whose value is a string
	// giving the version of the Desktop Entry Specification used for
	// the desktop entry file.
	KEY_FILE_DESKTOP_KEY_VERSION string = "Version"
	// The value of the %G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
	// entries representing applications.
	KEY_FILE_DESKTOP_TYPE_APPLICATION string = "Application"
	// The value of the %G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
	// entries representing directories.
	KEY_FILE_DESKTOP_TYPE_DIRECTORY string = "Directory"
	// The value of the %G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
	// entries representing links to documents.
	KEY_FILE_DESKTOP_TYPE_LINK string = "Link"
)

// Flags which influence the parsing.
type KeyFileFlags int

const (

	// No flags, default behaviour
	GKeyFileNoneValue KeyFileFlags = 0
	// Use this flag if you plan to write the
	//   (possibly modified) contents of the key file back to a file;
	//   otherwise all comments will be lost when the key file is
	//   written back.
	GKeyFileKeepCommentsValue KeyFileFlags = 1
	// Use this flag if you plan to write the
	//   (possibly modified) contents of the key file back to a file;
	//   otherwise only the translations for the current language will be
	//   written back.
	GKeyFileKeepTranslationsValue KeyFileFlags = 2
)

// Error codes returned by key file parsing.
type KeyFileError int

const (

	// the text being parsed was in
	//   an unknown encoding
	GKeyFileErrorUnknownEncodingValue KeyFileError = 0
	// document was ill-formed
	GKeyFileErrorParseValue KeyFileError = 1
	// the file was not found
	GKeyFileErrorNotFoundValue KeyFileError = 2
	// a requested key was not found
	GKeyFileErrorKeyNotFoundValue KeyFileError = 3
	// a requested group was not found
	GKeyFileErrorGroupNotFoundValue KeyFileError = 4
	// a value could not be parsed
	GKeyFileErrorInvalidValueValue KeyFileError = 5
)

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewKeyFile, lib, "g_key_file_new")

	core.PuregoSafeRegister(&xKeyFileFree, lib, "g_key_file_free")
	core.PuregoSafeRegister(&xKeyFileGetBoolean, lib, "g_key_file_get_boolean")
	core.PuregoSafeRegister(&xKeyFileGetBooleanList, lib, "g_key_file_get_boolean_list")
	core.PuregoSafeRegister(&xKeyFileGetComment, lib, "g_key_file_get_comment")
	core.PuregoSafeRegister(&xKeyFileGetDouble, lib, "g_key_file_get_double")
	core.PuregoSafeRegister(&xKeyFileGetDoubleList, lib, "g_key_file_get_double_list")
	core.PuregoSafeRegister(&xKeyFileGetGroups, lib, "g_key_file_get_groups")
	core.PuregoSafeRegister(&xKeyFileGetInt64, lib, "g_key_file_get_int64")
	core.PuregoSafeRegister(&xKeyFileGetInteger, lib, "g_key_file_get_integer")
	core.PuregoSafeRegister(&xKeyFileGetIntegerList, lib, "g_key_file_get_integer_list")
	core.PuregoSafeRegister(&xKeyFileGetKeys, lib, "g_key_file_get_keys")
	core.PuregoSafeRegister(&xKeyFileGetLocaleForKey, lib, "g_key_file_get_locale_for_key")
	core.PuregoSafeRegister(&xKeyFileGetLocaleString, lib, "g_key_file_get_locale_string")
	core.PuregoSafeRegister(&xKeyFileGetLocaleStringList, lib, "g_key_file_get_locale_string_list")
	core.PuregoSafeRegister(&xKeyFileGetStartGroup, lib, "g_key_file_get_start_group")
	core.PuregoSafeRegister(&xKeyFileGetString, lib, "g_key_file_get_string")
	core.PuregoSafeRegister(&xKeyFileGetStringList, lib, "g_key_file_get_string_list")
	core.PuregoSafeRegister(&xKeyFileGetUint64, lib, "g_key_file_get_uint64")
	core.PuregoSafeRegister(&xKeyFileGetValue, lib, "g_key_file_get_value")
	core.PuregoSafeRegister(&xKeyFileHasGroup, lib, "g_key_file_has_group")
	core.PuregoSafeRegister(&xKeyFileHasKey, lib, "g_key_file_has_key")
	core.PuregoSafeRegister(&xKeyFileLoadFromBytes, lib, "g_key_file_load_from_bytes")
	core.PuregoSafeRegister(&xKeyFileLoadFromData, lib, "g_key_file_load_from_data")
	core.PuregoSafeRegister(&xKeyFileLoadFromDataDirs, lib, "g_key_file_load_from_data_dirs")
	core.PuregoSafeRegister(&xKeyFileLoadFromDirs, lib, "g_key_file_load_from_dirs")
	core.PuregoSafeRegister(&xKeyFileLoadFromFile, lib, "g_key_file_load_from_file")
	core.PuregoSafeRegister(&xKeyFileRef, lib, "g_key_file_ref")
	core.PuregoSafeRegister(&xKeyFileRemoveComment, lib, "g_key_file_remove_comment")
	core.PuregoSafeRegister(&xKeyFileRemoveGroup, lib, "g_key_file_remove_group")
	core.PuregoSafeRegister(&xKeyFileRemoveKey, lib, "g_key_file_remove_key")
	core.PuregoSafeRegister(&xKeyFileSaveToFile, lib, "g_key_file_save_to_file")
	core.PuregoSafeRegister(&xKeyFileSetBoolean, lib, "g_key_file_set_boolean")
	core.PuregoSafeRegister(&xKeyFileSetBooleanList, lib, "g_key_file_set_boolean_list")
	core.PuregoSafeRegister(&xKeyFileSetComment, lib, "g_key_file_set_comment")
	core.PuregoSafeRegister(&xKeyFileSetDouble, lib, "g_key_file_set_double")
	core.PuregoSafeRegister(&xKeyFileSetDoubleList, lib, "g_key_file_set_double_list")
	core.PuregoSafeRegister(&xKeyFileSetInt64, lib, "g_key_file_set_int64")
	core.PuregoSafeRegister(&xKeyFileSetInteger, lib, "g_key_file_set_integer")
	core.PuregoSafeRegister(&xKeyFileSetIntegerList, lib, "g_key_file_set_integer_list")
	core.PuregoSafeRegister(&xKeyFileSetListSeparator, lib, "g_key_file_set_list_separator")
	core.PuregoSafeRegister(&xKeyFileSetLocaleString, lib, "g_key_file_set_locale_string")
	core.PuregoSafeRegister(&xKeyFileSetLocaleStringList, lib, "g_key_file_set_locale_string_list")
	core.PuregoSafeRegister(&xKeyFileSetString, lib, "g_key_file_set_string")
	core.PuregoSafeRegister(&xKeyFileSetStringList, lib, "g_key_file_set_string_list")
	core.PuregoSafeRegister(&xKeyFileSetUint64, lib, "g_key_file_set_uint64")
	core.PuregoSafeRegister(&xKeyFileSetValue, lib, "g_key_file_set_value")
	core.PuregoSafeRegister(&xKeyFileToData, lib, "g_key_file_to_data")
	core.PuregoSafeRegister(&xKeyFileUnref, lib, "g_key_file_unref")

}
