// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

var xAtomicRcBoxAcquire func(uintptr) uintptr

// Atomically acquires a reference on the data pointed by @mem_block.
func AtomicRcBoxAcquire(MemBlockVar uintptr) uintptr {

	cret := xAtomicRcBoxAcquire(MemBlockVar)
	return cret
}

var xAtomicRcBoxAlloc func(uint) uintptr

// Allocates @block_size bytes of memory, and adds atomic
// reference counting semantics to it.
//
// The data will be freed when its reference count drops to
// zero.
//
// The allocated data is guaranteed to be suitably aligned for any
// built-in type.
func AtomicRcBoxAlloc(BlockSizeVar uint) uintptr {

	cret := xAtomicRcBoxAlloc(BlockSizeVar)
	return cret
}

var xAtomicRcBoxAlloc0 func(uint) uintptr

// Allocates @block_size bytes of memory, and adds atomic
// reference counting semantics to it.
//
// The contents of the returned data is set to zero.
//
// The data will be freed when its reference count drops to
// zero.
//
// The allocated data is guaranteed to be suitably aligned for any
// built-in type.
func AtomicRcBoxAlloc0(BlockSizeVar uint) uintptr {

	cret := xAtomicRcBoxAlloc0(BlockSizeVar)
	return cret
}

var xAtomicRcBoxDup func(uint, uintptr) uintptr

// Allocates a new block of data with atomic reference counting
// semantics, and copies @block_size bytes of @mem_block
// into it.
func AtomicRcBoxDup(BlockSizeVar uint, MemBlockVar uintptr) uintptr {

	cret := xAtomicRcBoxDup(BlockSizeVar, MemBlockVar)
	return cret
}

var xAtomicRcBoxGetSize func(uintptr) uint

// Retrieves the size of the reference counted data pointed by @mem_block.
func AtomicRcBoxGetSize(MemBlockVar uintptr) uint {

	cret := xAtomicRcBoxGetSize(MemBlockVar)
	return cret
}

var xAtomicRcBoxRelease func(uintptr)

// Atomically releases a reference on the data pointed by @mem_block.
//
// If the reference was the last one, it will free the
// resources allocated for @mem_block.
func AtomicRcBoxRelease(MemBlockVar uintptr) {

	xAtomicRcBoxRelease(MemBlockVar)

}

var xAtomicRcBoxReleaseFull func(uintptr, uintptr)

// Atomically releases a reference on the data pointed by @mem_block.
//
// If the reference was the last one, it will call @clear_func
// to clear the contents of @mem_block, and then will free the
// resources allocated for @mem_block.
func AtomicRcBoxReleaseFull(MemBlockVar uintptr, ClearFuncVar *DestroyNotify) {

	xAtomicRcBoxReleaseFull(MemBlockVar, NewCallback(ClearFuncVar))

}

var xRcBoxAcquire func(uintptr) uintptr

// Acquires a reference on the data pointed by @mem_block.
func RcBoxAcquire(MemBlockVar uintptr) uintptr {

	cret := xRcBoxAcquire(MemBlockVar)
	return cret
}

var xRcBoxAlloc func(uint) uintptr

// Allocates @block_size bytes of memory, and adds reference
// counting semantics to it.
//
// The data will be freed when its reference count drops to
// zero.
//
// The allocated data is guaranteed to be suitably aligned for any
// built-in type.
func RcBoxAlloc(BlockSizeVar uint) uintptr {

	cret := xRcBoxAlloc(BlockSizeVar)
	return cret
}

var xRcBoxAlloc0 func(uint) uintptr

// Allocates @block_size bytes of memory, and adds reference
// counting semantics to it.
//
// The contents of the returned data is set to zero.
//
// The data will be freed when its reference count drops to
// zero.
//
// The allocated data is guaranteed to be suitably aligned for any
// built-in type.
func RcBoxAlloc0(BlockSizeVar uint) uintptr {

	cret := xRcBoxAlloc0(BlockSizeVar)
	return cret
}

var xRcBoxDup func(uint, uintptr) uintptr

// Allocates a new block of data with reference counting
// semantics, and copies @block_size bytes of @mem_block
// into it.
func RcBoxDup(BlockSizeVar uint, MemBlockVar uintptr) uintptr {

	cret := xRcBoxDup(BlockSizeVar, MemBlockVar)
	return cret
}

var xRcBoxGetSize func(uintptr) uint

// Retrieves the size of the reference counted data pointed by @mem_block.
func RcBoxGetSize(MemBlockVar uintptr) uint {

	cret := xRcBoxGetSize(MemBlockVar)
	return cret
}

var xRcBoxRelease func(uintptr)

// Releases a reference on the data pointed by @mem_block.
//
// If the reference was the last one, it will free the
// resources allocated for @mem_block.
func RcBoxRelease(MemBlockVar uintptr) {

	xRcBoxRelease(MemBlockVar)

}

var xRcBoxReleaseFull func(uintptr, uintptr)

// Releases a reference on the data pointed by @mem_block.
//
// If the reference was the last one, it will call @clear_func
// to clear the contents of @mem_block, and then will free the
// resources allocated for @mem_block.
func RcBoxReleaseFull(MemBlockVar uintptr, ClearFuncVar *DestroyNotify) {

	xRcBoxReleaseFull(MemBlockVar, NewCallback(ClearFuncVar))

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xAtomicRcBoxAcquire, lib, "g_atomic_rc_box_acquire")
	core.PuregoSafeRegister(&xAtomicRcBoxAlloc, lib, "g_atomic_rc_box_alloc")
	core.PuregoSafeRegister(&xAtomicRcBoxAlloc0, lib, "g_atomic_rc_box_alloc0")
	core.PuregoSafeRegister(&xAtomicRcBoxDup, lib, "g_atomic_rc_box_dup")
	core.PuregoSafeRegister(&xAtomicRcBoxGetSize, lib, "g_atomic_rc_box_get_size")
	core.PuregoSafeRegister(&xAtomicRcBoxRelease, lib, "g_atomic_rc_box_release")
	core.PuregoSafeRegister(&xAtomicRcBoxReleaseFull, lib, "g_atomic_rc_box_release_full")
	core.PuregoSafeRegister(&xRcBoxAcquire, lib, "g_rc_box_acquire")
	core.PuregoSafeRegister(&xRcBoxAlloc, lib, "g_rc_box_alloc")
	core.PuregoSafeRegister(&xRcBoxAlloc0, lib, "g_rc_box_alloc0")
	core.PuregoSafeRegister(&xRcBoxDup, lib, "g_rc_box_dup")
	core.PuregoSafeRegister(&xRcBoxGetSize, lib, "g_rc_box_get_size")
	core.PuregoSafeRegister(&xRcBoxRelease, lib, "g_rc_box_release")
	core.PuregoSafeRegister(&xRcBoxReleaseFull, lib, "g_rc_box_release_full")

}
