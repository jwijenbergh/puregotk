// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Prototype of a #GChildWatchSource callback, called when a child
// process has exited.
//
// To interpret @wait_status, see the documentation
// for g_spawn_check_wait_status(). In particular,
// on Unix platforms, note that it is usually not equal
// to the integer passed to `exit()` or returned from `main()`.
type ChildWatchFunc func(Pid, int, uintptr)

// Specifies the type of function passed to g_clear_handle_id().
// The implementation is expected to free the resource identified
// by @handle_id; for instance, if @handle_id is a #GSource ID,
// g_source_remove() can be used.
type ClearHandleFunc func(uint)

// Dispose function for @source. See g_source_set_dispose_function() for
// details.
type SourceDisposeFunc func(*Source)

// This is just a placeholder for #GClosureMarshal,
// which cannot be used here for dependency reasons.
type SourceDummyMarshal func()

// Specifies the type of function passed to g_timeout_add(),
// g_timeout_add_full(), g_idle_add(), and g_idle_add_full().
//
// When calling g_source_set_callback(), you may need to cast a function of a
// different type to this type. Use G_SOURCE_FUNC() to avoid warnings about
// incompatible function types.
type SourceFunc func(uintptr) bool

// The `GMainContext` struct is an opaque data
// type representing a set of sources to be handled in a main loop.
type MainContext struct {
	_ structs.HostLayout
}

var xMainContextGLibType func() types.GType

func MainContextGLibType() types.GType {
	return xMainContextGLibType()
}

func (x *MainContext) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewMainContext func() *MainContext

// Creates a new #GMainContext structure.
func NewMainContext() *MainContext {

	cret := xNewMainContext()
	return cret
}

var xNewMainContextWithFlags func(MainContextFlags) *MainContext

// Creates a new #GMainContext structure.
func NewMainContextWithFlags(FlagsVar MainContextFlags) *MainContext {

	cret := xNewMainContextWithFlags(FlagsVar)
	return cret
}

var xMainContextAcquire func(uintptr) bool

// Tries to become the owner of the specified context.
// If some other thread is the owner of the context,
// returns %FALSE immediately. Ownership is properly
// recursive: the owner can require ownership again
// and will release ownership when g_main_context_release()
// is called as many times as g_main_context_acquire().
//
// You must be the owner of a context before you
// can call g_main_context_prepare(), g_main_context_query(),
// g_main_context_check(), g_main_context_dispatch().
func (x *MainContext) Acquire() bool {

	cret := xMainContextAcquire(x.GoPointer())
	return cret
}

var xMainContextAddPoll func(uintptr, *PollFD, int)

// Adds a file descriptor to the set of file descriptors polled for
// this context. This will very seldom be used directly. Instead
// a typical event source will use g_source_add_unix_fd() instead.
func (x *MainContext) AddPoll(FdVar *PollFD, PriorityVar int) {

	xMainContextAddPoll(x.GoPointer(), FdVar, PriorityVar)

}

var xMainContextCheck func(uintptr, int, []PollFD, int) bool

// Passes the results of polling back to the main loop. You should be
// careful to pass @fds and its length @n_fds as received from
// g_main_context_query(), as this functions relies on assumptions
// on how @fds is filled.
//
// You must have successfully acquired the context with
// g_main_context_acquire() before you may call this function.
func (x *MainContext) Check(MaxPriorityVar int, FdsVar []PollFD, NFdsVar int) bool {

	cret := xMainContextCheck(x.GoPointer(), MaxPriorityVar, FdsVar, NFdsVar)
	return cret
}

var xMainContextDispatch func(uintptr)

// Dispatches all pending sources.
//
// You must have successfully acquired the context with
// g_main_context_acquire() before you may call this function.
func (x *MainContext) Dispatch() {

	xMainContextDispatch(x.GoPointer())

}

var xMainContextFindSourceByFuncsUserData func(uintptr, *SourceFuncs, uintptr) *Source

// Finds a source with the given source functions and user data.  If
// multiple sources exist with the same source function and user data,
// the first one found will be returned.
func (x *MainContext) FindSourceByFuncsUserData(FuncsVar *SourceFuncs, UserDataVar uintptr) *Source {

	cret := xMainContextFindSourceByFuncsUserData(x.GoPointer(), FuncsVar, UserDataVar)
	return cret
}

var xMainContextFindSourceById func(uintptr, uint) *Source

// Finds a #GSource given a pair of context and ID.
//
// It is a programmer error to attempt to look up a non-existent source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a
// source ID which may have already been removed.  An example is when
// scheduling an idle to run in another thread with g_idle_add(): the
// idle may already have run and been removed by the time this function
// is called on its (now invalid) source ID.  This source ID may have
// been reissued, leading to the operation being performed against the
// wrong source.
func (x *MainContext) FindSourceById(SourceIdVar uint) *Source {

	cret := xMainContextFindSourceById(x.GoPointer(), SourceIdVar)
	return cret
}

var xMainContextFindSourceByUserData func(uintptr, uintptr) *Source

// Finds a source with the given user data for the callback.  If
// multiple sources exist with the same user data, the first
// one found will be returned.
func (x *MainContext) FindSourceByUserData(UserDataVar uintptr) *Source {

	cret := xMainContextFindSourceByUserData(x.GoPointer(), UserDataVar)
	return cret
}

var xMainContextGetPollFunc func(uintptr) uintptr

// Gets the poll function set by g_main_context_set_poll_func().
func (x *MainContext) GetPollFunc() uintptr {

	cret := xMainContextGetPollFunc(x.GoPointer())
	return cret
}

var xMainContextInvoke func(uintptr, uintptr, uintptr)

// Invokes a function in such a way that @context is owned during the
// invocation of @function.
//
// If @context is %NULL then the global default main context — as
// returned by g_main_context_default() — is used.
//
// If @context is owned by the current thread, @function is called
// directly.  Otherwise, if @context is the thread-default main context
// of the current thread and g_main_context_acquire() succeeds, then
// @function is called and g_main_context_release() is called
// afterwards.
//
// In any other case, an idle source is created to call @function and
// that source is attached to @context (presumably to be run in another
// thread).  The idle source is attached with %G_PRIORITY_DEFAULT
// priority.  If you want a different priority, use
// g_main_context_invoke_full().
//
// Note that, as with normal idle functions, @function should probably
// return %FALSE.  If it returns %TRUE, it will be continuously run in a
// loop (and may prevent this call from returning).
func (x *MainContext) Invoke(FunctionVar *SourceFunc, DataVar uintptr) {

	xMainContextInvoke(x.GoPointer(), NewCallback(FunctionVar), DataVar)

}

var xMainContextInvokeFull func(uintptr, int, uintptr, uintptr, uintptr)

// Invokes a function in such a way that @context is owned during the
// invocation of @function.
//
// This function is the same as g_main_context_invoke() except that it
// lets you specify the priority in case @function ends up being
// scheduled as an idle and also lets you give a #GDestroyNotify for @data.
//
// @notify should not assume that it is called from any particular
// thread or with any particular context acquired.
func (x *MainContext) InvokeFull(PriorityVar int, FunctionVar *SourceFunc, DataVar uintptr, NotifyVar *DestroyNotify) {

	xMainContextInvokeFull(x.GoPointer(), PriorityVar, NewCallback(FunctionVar), DataVar, NewCallback(NotifyVar))

}

var xMainContextIsOwner func(uintptr) bool

// Determines whether this thread holds the (recursive)
// ownership of this #GMainContext. This is useful to
// know before waiting on another thread that may be
// blocking to get ownership of @context.
func (x *MainContext) IsOwner() bool {

	cret := xMainContextIsOwner(x.GoPointer())
	return cret
}

var xMainContextIteration func(uintptr, bool) bool

// Runs a single iteration for the given main loop. This involves
// checking to see if any event sources are ready to be processed,
// then if no events sources are ready and @may_block is %TRUE, waiting
// for a source to become ready, then dispatching the highest priority
// events sources that are ready. Otherwise, if @may_block is %FALSE
// sources are not waited to become ready, only those highest priority
// events sources will be dispatched (if any), that are ready at this
// given moment without further waiting.
//
// Note that even when @may_block is %TRUE, it is still possible for
// g_main_context_iteration() to return %FALSE, since the wait may
// be interrupted for other reasons than an event source becoming ready.
func (x *MainContext) Iteration(MayBlockVar bool) bool {

	cret := xMainContextIteration(x.GoPointer(), MayBlockVar)
	return cret
}

var xMainContextPending func(uintptr) bool

// Checks if any sources have pending events for the given context.
func (x *MainContext) Pending() bool {

	cret := xMainContextPending(x.GoPointer())
	return cret
}

var xMainContextPopThreadDefault func(uintptr)

// Pops @context off the thread-default context stack (verifying that
// it was on the top of the stack).
func (x *MainContext) PopThreadDefault() {

	xMainContextPopThreadDefault(x.GoPointer())

}

var xMainContextPrepare func(uintptr, int) bool

// Prepares to poll sources within a main loop. The resulting information
// for polling is determined by calling g_main_context_query ().
//
// You must have successfully acquired the context with
// g_main_context_acquire() before you may call this function.
func (x *MainContext) Prepare(PriorityVar int) bool {

	cret := xMainContextPrepare(x.GoPointer(), PriorityVar)
	return cret
}

var xMainContextPushThreadDefault func(uintptr)

// Acquires @context and sets it as the thread-default context for the
// current thread. This will cause certain asynchronous operations
// (such as most [gio][gio]-based I/O) which are
// started in this thread to run under @context and deliver their
// results to its main loop, rather than running under the global
// default context in the main thread. Note that calling this function
// changes the context returned by g_main_context_get_thread_default(),
// not the one returned by g_main_context_default(), so it does not affect
// the context used by functions like g_idle_add().
//
// Normally you would call this function shortly after creating a new
// thread, passing it a #GMainContext which will be run by a
// #GMainLoop in that thread, to set a new default context for all
// async operations in that thread. In this case you may not need to
// ever call g_main_context_pop_thread_default(), assuming you want the
// new #GMainContext to be the default for the whole lifecycle of the
// thread.
//
// If you don't have control over how the new thread was created (e.g.
// in the new thread isn't newly created, or if the thread life
// cycle is managed by a #GThreadPool), it is always suggested to wrap
// the logic that needs to use the new #GMainContext inside a
// g_main_context_push_thread_default() / g_main_context_pop_thread_default()
// pair, otherwise threads that are re-used will end up never explicitly
// releasing the #GMainContext reference they hold.
//
// In some cases you may want to schedule a single operation in a
// non-default context, or temporarily use a non-default context in
// the main thread. In that case, you can wrap the call to the
// asynchronous operation inside a
// g_main_context_push_thread_default() /
// g_main_context_pop_thread_default() pair, but it is up to you to
// ensure that no other asynchronous operations accidentally get
// started while the non-default context is active.
//
// Beware that libraries that predate this function may not correctly
// handle being used from a thread with a thread-default context. Eg,
// see g_file_supports_thread_contexts().
func (x *MainContext) PushThreadDefault() {

	xMainContextPushThreadDefault(x.GoPointer())

}

var xMainContextQuery func(uintptr, int, int, []PollFD, int) int

// Determines information necessary to poll this main loop. You should
// be careful to pass the resulting @fds array and its length @n_fds
// as is when calling g_main_context_check(), as this function relies
// on assumptions made when the array is filled.
//
// You must have successfully acquired the context with
// g_main_context_acquire() before you may call this function.
func (x *MainContext) Query(MaxPriorityVar int, TimeoutVar int, FdsVar []PollFD, NFdsVar int) int {

	cret := xMainContextQuery(x.GoPointer(), MaxPriorityVar, TimeoutVar, FdsVar, NFdsVar)
	return cret
}

var xMainContextRef func(uintptr) *MainContext

// Increases the reference count on a #GMainContext object by one.
func (x *MainContext) Ref() *MainContext {

	cret := xMainContextRef(x.GoPointer())
	return cret
}

var xMainContextRelease func(uintptr)

// Releases ownership of a context previously acquired by this thread
// with g_main_context_acquire(). If the context was acquired multiple
// times, the ownership will be released only when g_main_context_release()
// is called as many times as it was acquired.
func (x *MainContext) Release() {

	xMainContextRelease(x.GoPointer())

}

var xMainContextRemovePoll func(uintptr, *PollFD)

// Removes file descriptor from the set of file descriptors to be
// polled for a particular context.
func (x *MainContext) RemovePoll(FdVar *PollFD) {

	xMainContextRemovePoll(x.GoPointer(), FdVar)

}

var xMainContextSetPollFunc func(uintptr, uintptr)

// Sets the function to use to handle polling of file descriptors. It
// will be used instead of the poll() system call
// (or GLib's replacement function, which is used where
// poll() isn't available).
//
// This function could possibly be used to integrate the GLib event
// loop with an external event loop.
func (x *MainContext) SetPollFunc(FuncVar *PollFunc) {

	xMainContextSetPollFunc(x.GoPointer(), NewCallback(FuncVar))

}

var xMainContextUnref func(uintptr)

// Decreases the reference count on a #GMainContext object by one. If
// the result is zero, free the context and free all associated memory.
func (x *MainContext) Unref() {

	xMainContextUnref(x.GoPointer())

}

var xMainContextWait func(uintptr, *Cond, *Mutex) bool

// Tries to become the owner of the specified context,
// as with g_main_context_acquire(). But if another thread
// is the owner, atomically drop @mutex and wait on @cond until
// that owner releases ownership or until @cond is signaled, then
// try again (once) to become the owner.
func (x *MainContext) Wait(CondVar *Cond, MutexVar *Mutex) bool {

	cret := xMainContextWait(x.GoPointer(), CondVar, MutexVar)
	return cret
}

var xMainContextWakeup func(uintptr)

// If @context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking
// and return.  Otherwise, cause the next invocation of
// g_main_context_iteration() to return without blocking.
//
// This API is useful for low-level control over #GMainContext; for
// example, integrating it with main loop implementations such as
// #GMainLoop.
//
// Another related use for this function is when implementing a main
// loop with a termination condition, computed from multiple threads:
//
// |[&lt;!-- language="C" --&gt;
//
//	#define NUM_TASKS 10
//	static gint tasks_remaining = NUM_TASKS;  // (atomic)
//	...
//
//	while (g_atomic_int_get (&amp;tasks_remaining) != 0)
//	  g_main_context_iteration (NULL, TRUE);
//
// ]|
//
// Then in a thread:
// |[&lt;!-- language="C" --&gt;
//
//	perform_work();
//
//	if (g_atomic_int_dec_and_test (&amp;tasks_remaining))
//	  g_main_context_wakeup (NULL);
//
// ]|
func (x *MainContext) Wakeup() {

	xMainContextWakeup(x.GoPointer())

}

// The `GMainLoop` struct is an opaque data type
// representing the main event loop of a GLib or GTK+ application.
type MainLoop struct {
	_ structs.HostLayout
}

var xMainLoopGLibType func() types.GType

func MainLoopGLibType() types.GType {
	return xMainLoopGLibType()
}

func (x *MainLoop) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewMainLoop func(*MainContext, bool) *MainLoop

// Creates a new #GMainLoop structure.
func NewMainLoop(ContextVar *MainContext, IsRunningVar bool) *MainLoop {

	cret := xNewMainLoop(ContextVar, IsRunningVar)
	return cret
}

var xMainLoopGetContext func(uintptr) *MainContext

// Returns the #GMainContext of @loop.
func (x *MainLoop) GetContext() *MainContext {

	cret := xMainLoopGetContext(x.GoPointer())
	return cret
}

var xMainLoopIsRunning func(uintptr) bool

// Checks to see if the main loop is currently being run via g_main_loop_run().
func (x *MainLoop) IsRunning() bool {

	cret := xMainLoopIsRunning(x.GoPointer())
	return cret
}

var xMainLoopQuit func(uintptr)

// Stops a #GMainLoop from running. Any calls to g_main_loop_run()
// for the loop will return.
//
// Note that sources that have already been dispatched when
// g_main_loop_quit() is called will still be executed.
func (x *MainLoop) Quit() {

	xMainLoopQuit(x.GoPointer())

}

var xMainLoopRef func(uintptr) *MainLoop

// Increases the reference count on a #GMainLoop object by one.
func (x *MainLoop) Ref() *MainLoop {

	cret := xMainLoopRef(x.GoPointer())
	return cret
}

var xMainLoopRun func(uintptr)

// Runs a main loop until g_main_loop_quit() is called on the loop.
// If this is called for the thread of the loop's #GMainContext,
// it will process events from the loop, otherwise it will
// simply wait.
func (x *MainLoop) Run() {

	xMainLoopRun(x.GoPointer())

}

var xMainLoopUnref func(uintptr)

// Decreases the reference count on a #GMainLoop object by one. If
// the result is zero, free the loop and free all associated memory.
func (x *MainLoop) Unref() {

	xMainLoopUnref(x.GoPointer())

}

// The `GSource` struct is an opaque data type
// representing an event source.
type Source struct {
	_ structs.HostLayout

	CallbackData uintptr

	CallbackFuncs *SourceCallbackFuncs

	SourceFuncs *SourceFuncs

	RefCount uint

	Context *MainContext

	Priority int32

	Flags uint

	SourceId uint

	PollFds *SList

	Prev *Source

	Next *Source

	Name uintptr

	Priv *SourcePrivate
}

var xSourceGLibType func() types.GType

func SourceGLibType() types.GType {
	return xSourceGLibType()
}

func (x *Source) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewSource func(*SourceFuncs, uint) *Source

// Creates a new #GSource structure. The size is specified to
// allow creating structures derived from #GSource that contain
// additional data. The size passed in must be at least
// `sizeof (GSource)`.
//
// The source will not initially be associated with any #GMainContext
// and must be added to one with g_source_attach() before it will be
// executed.
func NewSource(SourceFuncsVar *SourceFuncs, StructSizeVar uint) *Source {

	cret := xNewSource(SourceFuncsVar, StructSizeVar)
	return cret
}

var xSourceAddChildSource func(uintptr, *Source)

// Adds @child_source to @source as a "polled" source; when @source is
// added to a #GMainContext, @child_source will be automatically added
// with the same priority, when @child_source is triggered, it will
// cause @source to dispatch (in addition to calling its own
// callback), and when @source is destroyed, it will destroy
// @child_source as well. (@source will also still be dispatched if
// its own prepare/check functions indicate that it is ready.)
//
// If you don't need @child_source to do anything on its own when it
// triggers, you can call g_source_set_dummy_callback() on it to set a
// callback that does nothing (except return %TRUE if appropriate).
//
// @source will hold a reference on @child_source while @child_source
// is attached to it.
//
// This API is only intended to be used by implementations of #GSource.
// Do not call this API on a #GSource that you did not create.
func (x *Source) AddChildSource(ChildSourceVar *Source) {

	xSourceAddChildSource(x.GoPointer(), ChildSourceVar)

}

var xSourceAddPoll func(uintptr, *PollFD)

// Adds a file descriptor to the set of file descriptors polled for
// this source. This is usually combined with g_source_new() to add an
// event source. The event source's check function will typically test
// the @revents field in the #GPollFD struct and return %TRUE if events need
// to be processed.
//
// This API is only intended to be used by implementations of #GSource.
// Do not call this API on a #GSource that you did not create.
//
// Using this API forces the linear scanning of event sources on each
// main loop iteration.  Newly-written event sources should try to use
// g_source_add_unix_fd() instead of this API.
func (x *Source) AddPoll(FdVar *PollFD) {

	xSourceAddPoll(x.GoPointer(), FdVar)

}

var xSourceAddUnixFd func(uintptr, int, IOCondition) uintptr

// Monitors @fd for the IO events in @events.
//
// The tag returned by this function can be used to remove or modify the
// monitoring of the fd using g_source_remove_unix_fd() or
// g_source_modify_unix_fd().
//
// It is not necessary to remove the fd before destroying the source; it
// will be cleaned up automatically.
//
// This API is only intended to be used by implementations of #GSource.
// Do not call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (x *Source) AddUnixFd(FdVar int, EventsVar IOCondition) uintptr {

	cret := xSourceAddUnixFd(x.GoPointer(), FdVar, EventsVar)
	return cret
}

var xSourceAttach func(uintptr, *MainContext) uint

// Adds a #GSource to a @context so that it will be executed within
// that context. Remove it by calling g_source_destroy().
//
// This function is safe to call from any thread, regardless of which thread
// the @context is running in.
func (x *Source) Attach(ContextVar *MainContext) uint {

	cret := xSourceAttach(x.GoPointer(), ContextVar)
	return cret
}

var xSourceDestroy func(uintptr)

// Removes a source from its #GMainContext, if any, and mark it as
// destroyed.  The source cannot be subsequently added to another
// context. It is safe to call this on sources which have already been
// removed from their context.
//
// This does not unref the #GSource: if you still hold a reference, use
// g_source_unref() to drop it.
//
// This function is safe to call from any thread, regardless of which thread
// the #GMainContext is running in.
//
// If the source is currently attached to a #GMainContext, destroying it
// will effectively unset the callback similar to calling g_source_set_callback().
// This can mean, that the data's #GDestroyNotify gets called right away.
func (x *Source) Destroy() {

	xSourceDestroy(x.GoPointer())

}

var xSourceGetCanRecurse func(uintptr) bool

// Checks whether a source is allowed to be called recursively.
// see g_source_set_can_recurse().
func (x *Source) GetCanRecurse() bool {

	cret := xSourceGetCanRecurse(x.GoPointer())
	return cret
}

var xSourceGetContext func(uintptr) *MainContext

// Gets the #GMainContext with which the source is associated.
//
// You can call this on a source that has been destroyed, provided
// that the #GMainContext it was attached to still exists (in which
// case it will return that #GMainContext). In particular, you can
// always call this function on the source returned from
// g_main_current_source(). But calling this function on a source
// whose #GMainContext has been destroyed is an error.
func (x *Source) GetContext() *MainContext {

	cret := xSourceGetContext(x.GoPointer())
	return cret
}

var xSourceGetCurrentTime func(uintptr, *TimeVal)

// This function ignores @source and is otherwise the same as
// g_get_current_time().
func (x *Source) GetCurrentTime(TimevalVar *TimeVal) {

	xSourceGetCurrentTime(x.GoPointer(), TimevalVar)

}

var xSourceGetId func(uintptr) uint

// Returns the numeric ID for a particular source. The ID of a source
// is a positive integer which is unique within a particular main loop
// context. The reverse
// mapping from ID to source is done by g_main_context_find_source_by_id().
//
// You can only call this function while the source is associated to a
// #GMainContext instance; calling this function before g_source_attach()
// or after g_source_destroy() yields undefined behavior. The ID returned
// is unique within the #GMainContext instance passed to g_source_attach().
func (x *Source) GetId() uint {

	cret := xSourceGetId(x.GoPointer())
	return cret
}

var xSourceGetName func(uintptr) string

// Gets a name for the source, used in debugging and profiling.  The
// name may be #NULL if it has never been set with g_source_set_name().
func (x *Source) GetName() string {

	cret := xSourceGetName(x.GoPointer())
	return cret
}

var xSourceGetPriority func(uintptr) int

// Gets the priority of a source.
func (x *Source) GetPriority() int {

	cret := xSourceGetPriority(x.GoPointer())
	return cret
}

var xSourceGetReadyTime func(uintptr) int64

// Gets the "ready time" of @source, as set by
// g_source_set_ready_time().
//
// Any time before the current monotonic time (including 0) is an
// indication that the source will fire immediately.
func (x *Source) GetReadyTime() int64 {

	cret := xSourceGetReadyTime(x.GoPointer())
	return cret
}

var xSourceGetTime func(uintptr) int64

// Gets the time to be used when checking this source. The advantage of
// calling this function over calling g_get_monotonic_time() directly is
// that when checking multiple sources, GLib can cache a single value
// instead of having to repeatedly get the system monotonic time.
//
// The time here is the system monotonic time, if available, or some
// other reasonable alternative otherwise.  See g_get_monotonic_time().
func (x *Source) GetTime() int64 {

	cret := xSourceGetTime(x.GoPointer())
	return cret
}

var xSourceIsDestroyed func(uintptr) bool

// Returns whether @source has been destroyed.
//
// This is important when you operate upon your objects
// from within idle handlers, but may have freed the object
// before the dispatch of your idle handler.
//
// |[&lt;!-- language="C" --&gt;
// static gboolean
// idle_callback (gpointer data)
//
//	{
//	  SomeWidget *self = data;
//
//	  g_mutex_lock (&amp;self-&gt;idle_id_mutex);
//	  // do stuff with self
//	  self-&gt;idle_id = 0;
//	  g_mutex_unlock (&amp;self-&gt;idle_id_mutex);
//
//	  return G_SOURCE_REMOVE;
//	}
//
// static void
// some_widget_do_stuff_later (SomeWidget *self)
//
//	{
//	  g_mutex_lock (&amp;self-&gt;idle_id_mutex);
//	  self-&gt;idle_id = g_idle_add (idle_callback, self);
//	  g_mutex_unlock (&amp;self-&gt;idle_id_mutex);
//	}
//
// static void
// some_widget_init (SomeWidget *self)
//
//	{
//	  g_mutex_init (&amp;self-&gt;idle_id_mutex);
//
//	  // ...
//	}
//
// static void
// some_widget_finalize (GObject *object)
//
//	{
//	  SomeWidget *self = SOME_WIDGET (object);
//
//	  if (self-&gt;idle_id)
//	    g_source_remove (self-&gt;idle_id);
//
//	  g_mutex_clear (&amp;self-&gt;idle_id_mutex);
//
//	  G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
//	}
//
// ]|
//
// This will fail in a multi-threaded application if the
// widget is destroyed before the idle handler fires due
// to the use after free in the callback. A solution, to
// this particular problem, is to check to if the source
// has already been destroy within the callback.
//
// |[&lt;!-- language="C" --&gt;
// static gboolean
// idle_callback (gpointer data)
//
//	{
//	  SomeWidget *self = data;
//
//	  g_mutex_lock (&amp;self-&gt;idle_id_mutex);
//	  if (!g_source_is_destroyed (g_main_current_source ()))
//	    {
//	      // do stuff with self
//	    }
//	  g_mutex_unlock (&amp;self-&gt;idle_id_mutex);
//
//	  return FALSE;
//	}
//
// ]|
//
// Calls to this function from a thread other than the one acquired by the
// #GMainContext the #GSource is attached to are typically redundant, as the
// source could be destroyed immediately after this function returns. However,
// once a source is destroyed it cannot be un-destroyed, so this function can be
// used for opportunistic checks from any thread.
func (x *Source) IsDestroyed() bool {

	cret := xSourceIsDestroyed(x.GoPointer())
	return cret
}

var xSourceModifyUnixFd func(uintptr, uintptr, IOCondition)

// Updates the event mask to watch for the fd identified by @tag.
//
// @tag is the tag returned from g_source_add_unix_fd().
//
// If you want to remove a fd, don't set its event mask to zero.
// Instead, call g_source_remove_unix_fd().
//
// This API is only intended to be used by implementations of #GSource.
// Do not call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (x *Source) ModifyUnixFd(TagVar uintptr, NewEventsVar IOCondition) {

	xSourceModifyUnixFd(x.GoPointer(), TagVar, NewEventsVar)

}

var xSourceQueryUnixFd func(uintptr, uintptr) IOCondition

// Queries the events reported for the fd corresponding to @tag on
// @source during the last poll.
//
// The return value of this function is only defined when the function
// is called from the check or dispatch functions for @source.
//
// This API is only intended to be used by implementations of #GSource.
// Do not call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (x *Source) QueryUnixFd(TagVar uintptr) IOCondition {

	cret := xSourceQueryUnixFd(x.GoPointer(), TagVar)
	return cret
}

var xSourceRef func(uintptr) *Source

// Increases the reference count on a source by one.
func (x *Source) Ref() *Source {

	cret := xSourceRef(x.GoPointer())
	return cret
}

var xSourceRemoveChildSource func(uintptr, *Source)

// Detaches @child_source from @source and destroys it.
//
// This API is only intended to be used by implementations of #GSource.
// Do not call this API on a #GSource that you did not create.
func (x *Source) RemoveChildSource(ChildSourceVar *Source) {

	xSourceRemoveChildSource(x.GoPointer(), ChildSourceVar)

}

var xSourceRemovePoll func(uintptr, *PollFD)

// Removes a file descriptor from the set of file descriptors polled for
// this source.
//
// This API is only intended to be used by implementations of #GSource.
// Do not call this API on a #GSource that you did not create.
func (x *Source) RemovePoll(FdVar *PollFD) {

	xSourceRemovePoll(x.GoPointer(), FdVar)

}

var xSourceRemoveUnixFd func(uintptr, uintptr)

// Reverses the effect of a previous call to g_source_add_unix_fd().
//
// You only need to call this if you want to remove an fd from being
// watched while keeping the same source around.  In the normal case you
// will just want to destroy the source.
//
// This API is only intended to be used by implementations of #GSource.
// Do not call this API on a #GSource that you did not create.
//
// As the name suggests, this function is not available on Windows.
func (x *Source) RemoveUnixFd(TagVar uintptr) {

	xSourceRemoveUnixFd(x.GoPointer(), TagVar)

}

var xSourceSetCallback func(uintptr, uintptr, uintptr, uintptr)

// Sets the callback function for a source. The callback for a source is
// called from the source's dispatch function.
//
// The exact type of @func depends on the type of source; ie. you
// should not count on @func being called with @data as its first
// parameter. Cast @func with G_SOURCE_FUNC() to avoid warnings about
// incompatible function types.
//
// See [memory management of sources][mainloop-memory-management] for details
// on how to handle memory management of @data.
//
// Typically, you won't use this function. Instead use functions specific
// to the type of source you are using, such as g_idle_add() or g_timeout_add().
//
// It is safe to call this function multiple times on a source which has already
// been attached to a context. The changes will take effect for the next time
// the source is dispatched after this call returns.
//
// Note that g_source_destroy() for a currently attached source has the effect
// of also unsetting the callback.
func (x *Source) SetCallback(FuncVar *SourceFunc, DataVar uintptr, NotifyVar *DestroyNotify) {

	xSourceSetCallback(x.GoPointer(), NewCallback(FuncVar), DataVar, NewCallback(NotifyVar))

}

var xSourceSetCallbackIndirect func(uintptr, uintptr, *SourceCallbackFuncs)

// Sets the callback function storing the data as a refcounted callback
// "object". This is used internally. Note that calling
// g_source_set_callback_indirect() assumes
// an initial reference count on @callback_data, and thus
// @callback_funcs-&gt;unref will eventually be called once more
// than @callback_funcs-&gt;ref.
//
// It is safe to call this function multiple times on a source which has already
// been attached to a context. The changes will take effect for the next time
// the source is dispatched after this call returns.
func (x *Source) SetCallbackIndirect(CallbackDataVar uintptr, CallbackFuncsVar *SourceCallbackFuncs) {

	xSourceSetCallbackIndirect(x.GoPointer(), CallbackDataVar, CallbackFuncsVar)

}

var xSourceSetCanRecurse func(uintptr, bool)

// Sets whether a source can be called recursively. If @can_recurse is
// %TRUE, then while the source is being dispatched then this source
// will be processed normally. Otherwise, all processing of this
// source is blocked until the dispatch function returns.
func (x *Source) SetCanRecurse(CanRecurseVar bool) {

	xSourceSetCanRecurse(x.GoPointer(), CanRecurseVar)

}

var xSourceSetDisposeFunction func(uintptr, uintptr)

// Set @dispose as dispose function on @source. @dispose will be called once
// the reference count of @source reaches 0 but before any of the state of the
// source is freed, especially before the finalize function is called.
//
// This means that at this point @source is still a valid #GSource and it is
// allow for the reference count to increase again until @dispose returns.
//
// The dispose function can be used to clear any "weak" references to the
// @source in other data structures in a thread-safe way where it is possible
// for another thread to increase the reference count of @source again while
// it is being freed.
//
// The finalize function can not be used for this purpose as at that point
// @source is already partially freed and not valid anymore.
//
// This should only ever be called from #GSource implementations.
func (x *Source) SetDisposeFunction(DisposeVar *SourceDisposeFunc) {

	xSourceSetDisposeFunction(x.GoPointer(), NewCallback(DisposeVar))

}

var xSourceSetFuncs func(uintptr, *SourceFuncs)

// Sets the source functions (can be used to override
// default implementations) of an unattached source.
func (x *Source) SetFuncs(FuncsVar *SourceFuncs) {

	xSourceSetFuncs(x.GoPointer(), FuncsVar)

}

var xSourceSetName func(uintptr, string)

// Sets a name for the source, used in debugging and profiling.
// The name defaults to #NULL.
//
// The source name should describe in a human-readable way
// what the source does. For example, "X11 event queue"
// or "GTK+ repaint idle handler" or whatever it is.
//
// It is permitted to call this function multiple times, but is not
// recommended due to the potential performance impact.  For example,
// one could change the name in the "check" function of a #GSourceFuncs
// to include details like the event type in the source name.
//
// Use caution if changing the name while another thread may be
// accessing it with g_source_get_name(); that function does not copy
// the value, and changing the value will free it while the other thread
// may be attempting to use it.
//
// Also see g_source_set_static_name().
func (x *Source) SetName(NameVar string) {

	xSourceSetName(x.GoPointer(), NameVar)

}

var xSourceSetPriority func(uintptr, int)

// Sets the priority of a source. While the main loop is being run, a
// source will be dispatched if it is ready to be dispatched and no
// sources at a higher (numerically smaller) priority are ready to be
// dispatched.
//
// A child source always has the same priority as its parent.  It is not
// permitted to change the priority of a source once it has been added
// as a child of another source.
func (x *Source) SetPriority(PriorityVar int) {

	xSourceSetPriority(x.GoPointer(), PriorityVar)

}

var xSourceSetReadyTime func(uintptr, int64)

// Sets a #GSource to be dispatched when the given monotonic time is
// reached (or passed).  If the monotonic time is in the past (as it
// always will be if @ready_time is 0) then the source will be
// dispatched immediately.
//
// If @ready_time is -1 then the source is never woken up on the basis
// of the passage of time.
//
// Dispatching the source does not reset the ready time.  You should do
// so yourself, from the source dispatch function.
//
// Note that if you have a pair of sources where the ready time of one
// suggests that it will be delivered first but the priority for the
// other suggests that it would be delivered first, and the ready time
// for both sources is reached during the same main context iteration,
// then the order of dispatch is undefined.
//
// It is a no-op to call this function on a #GSource which has already been
// destroyed with g_source_destroy().
//
// This API is only intended to be used by implementations of #GSource.
// Do not call this API on a #GSource that you did not create.
func (x *Source) SetReadyTime(ReadyTimeVar int64) {

	xSourceSetReadyTime(x.GoPointer(), ReadyTimeVar)

}

var xSourceSetStaticName func(uintptr, string)

// A variant of g_source_set_name() that does not
// duplicate the @name, and can only be used with
// string literals.
func (x *Source) SetStaticName(NameVar string) {

	xSourceSetStaticName(x.GoPointer(), NameVar)

}

var xSourceUnref func(uintptr)

// Decreases the reference count of a source by one. If the
// resulting reference count is zero the source and associated
// memory will be destroyed.
func (x *Source) Unref() {

	xSourceUnref(x.GoPointer())

}

// The `GSourceCallbackFuncs` struct contains
// functions for managing callback objects.
type SourceCallbackFuncs struct {
	_ structs.HostLayout
}

func (x *SourceCallbackFuncs) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// The `GSourceFuncs` struct contains a table of
// functions used to handle event sources in a generic manner.
//
// For idle sources, the prepare and check functions always return %TRUE
// to indicate that the source is always ready to be processed. The prepare
// function also returns a timeout value of 0 to ensure that the poll() call
// doesn't block (since that would be time wasted which could have been spent
// running the idle function).
//
// For timeout sources, the prepare and check functions both return %TRUE
// if the timeout interval has expired. The prepare function also returns
// a timeout value to ensure that the poll() call doesn't block too long
// and miss the next timeout.
//
// For file descriptor sources, the prepare function typically returns %FALSE,
// since it must wait until poll() has been called before it knows whether
// any events need to be processed. It sets the returned timeout to -1 to
// indicate that it doesn't mind how long the poll() call blocks. In the
// check function, it tests the results of the poll() call to see if the
// required condition has been met, and returns %TRUE if so.
type SourceFuncs struct {
	_ structs.HostLayout

	ClosureCallback SourceFunc

	ClosureMarshal SourceDummyMarshal
}

func (x *SourceFuncs) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type SourcePrivate struct {
	_ structs.HostLayout
}

func (x *SourcePrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Opaque type. See g_main_context_pusher_new() for details.
type MainContextPusher = uintptr

const (
	// Use this for default priority event sources.
	//
	// In GLib this priority is used when adding timeout functions
	// with g_timeout_add(). In GDK this priority is used for events
	// from the X server.
	PRIORITY_DEFAULT int = 0
	// Use this for default priority idle functions.
	//
	// In GLib this priority is used when adding idle functions with
	// g_idle_add().
	PRIORITY_DEFAULT_IDLE int = 200
	// Use this for high priority event sources.
	//
	// It is not used within GLib or GTK+.
	PRIORITY_HIGH int = -100
	// Use this for high priority idle functions.
	//
	// GTK+ uses %G_PRIORITY_HIGH_IDLE + 10 for resizing operations,
	// and %G_PRIORITY_HIGH_IDLE + 20 for redrawing operations. (This is
	// done to ensure that any pending resizes are processed before any
	// pending redraws, so that widgets are not redrawn twice unnecessarily.)
	PRIORITY_HIGH_IDLE int = 100
	// Use this for very low priority background tasks.
	//
	// It is not used within GLib or GTK+.
	PRIORITY_LOW int = 300
	// Use this macro as the return value of a #GSourceFunc to leave
	// the #GSource in the main loop.
	SOURCE_CONTINUE bool = true
	// Use this macro as the return value of a #GSourceFunc to remove
	// the #GSource from the main loop.
	SOURCE_REMOVE bool = false
)

// Flags to pass to g_main_context_new_with_flags() which affect the behaviour
// of a #GMainContext.
type MainContextFlags int

const (

	// Default behaviour.
	GMainContextFlagsNoneValue MainContextFlags = 0
	// Assume that polling for events will
	// free the thread to process other jobs. That's useful if you're using
	// `g_main_context_{prepare,query,check,dispatch}` to integrate GMainContext in
	// other event loops.
	GMainContextFlagsOwnerlessPollingValue MainContextFlags = 1
)

var xChildWatchAdd func(Pid, uintptr, uintptr) uint

// Sets a function to be called when the child indicated by @pid
// exits, at a default priority, %G_PRIORITY_DEFAULT.
//
// If you obtain @pid from g_spawn_async() or g_spawn_async_with_pipes()
// you will need to pass %G_SPAWN_DO_NOT_REAP_CHILD as flag to
// the spawn function for the child watching to work.
//
// Note that on platforms where #GPid must be explicitly closed
// (see g_spawn_close_pid()) @pid must not be closed while the
// source is still active. Typically, you will want to call
// g_spawn_close_pid() in the callback function for the source.
//
// GLib supports only a single callback per process id.
// On POSIX platforms, the same restrictions mentioned for
// g_child_watch_source_new() apply to this function.
//
// This internally creates a main loop source using
// g_child_watch_source_new() and attaches it to the main loop context
// using g_source_attach(). You can do these steps manually if you
// need greater control.
func ChildWatchAdd(PidVar Pid, FunctionVar *ChildWatchFunc, DataVar uintptr) uint {

	cret := xChildWatchAdd(PidVar, NewCallback(FunctionVar), DataVar)
	return cret
}

var xChildWatchAddFull func(int, Pid, uintptr, uintptr, uintptr) uint

// Sets a function to be called when the child indicated by @pid
// exits, at the priority @priority.
//
// If you obtain @pid from g_spawn_async() or g_spawn_async_with_pipes()
// you will need to pass %G_SPAWN_DO_NOT_REAP_CHILD as flag to
// the spawn function for the child watching to work.
//
// In many programs, you will want to call g_spawn_check_wait_status()
// in the callback to determine whether or not the child exited
// successfully.
//
// Also, note that on platforms where #GPid must be explicitly closed
// (see g_spawn_close_pid()) @pid must not be closed while the source
// is still active.  Typically, you should invoke g_spawn_close_pid()
// in the callback function for the source.
//
// GLib supports only a single callback per process id.
// On POSIX platforms, the same restrictions mentioned for
// g_child_watch_source_new() apply to this function.
//
// This internally creates a main loop source using
// g_child_watch_source_new() and attaches it to the main loop context
// using g_source_attach(). You can do these steps manually if you
// need greater control.
func ChildWatchAddFull(PriorityVar int, PidVar Pid, FunctionVar *ChildWatchFunc, DataVar uintptr, NotifyVar *DestroyNotify) uint {

	cret := xChildWatchAddFull(PriorityVar, PidVar, NewCallback(FunctionVar), DataVar, NewCallback(NotifyVar))
	return cret
}

var xChildWatchSourceNew func(Pid) *Source

// Creates a new child_watch source.
//
// The source will not initially be associated with any #GMainContext
// and must be added to one with g_source_attach() before it will be
// executed.
//
// Note that child watch sources can only be used in conjunction with
// `g_spawn...` when the %G_SPAWN_DO_NOT_REAP_CHILD flag is used.
//
// Note that on platforms where #GPid must be explicitly closed
// (see g_spawn_close_pid()) @pid must not be closed while the
// source is still active. Typically, you will want to call
// g_spawn_close_pid() in the callback function for the source.
//
// On POSIX platforms, the following restrictions apply to this API
// due to limitations in POSIX process interfaces:
//
//   - @pid must be a child of this process
//   - @pid must be positive
//   - the application must not call `waitpid` with a non-positive
//     first argument, for instance in another thread
//   - the application must not wait for @pid to exit by any other
//     mechanism, including `waitpid(pid, ...)` or a second child-watch
//     source for the same @pid
//   - the application must not ignore `SIGCHLD`
//
// If any of those conditions are not met, this and related APIs will
// not work correctly. This can often be diagnosed via a GLib warning
// stating that `ECHILD` was received by `waitpid`.
//
// Calling `waitpid` for specific processes other than @pid remains a
// valid thing to do.
func ChildWatchSourceNew(PidVar Pid) *Source {

	cret := xChildWatchSourceNew(PidVar)
	return cret
}

var xClearHandleId func(uint, uintptr)

// Clears a numeric handler, such as a #GSource ID.
//
// @tag_ptr must be a valid pointer to the variable holding the handler.
//
// If the ID is zero then this function does nothing.
// Otherwise, clear_func() is called with the ID as a parameter, and the tag is
// set to zero.
//
// A macro is also included that allows this function to be used without
// pointer casts.
func ClearHandleId(TagPtrVar uint, ClearFuncVar *ClearHandleFunc) {

	xClearHandleId(TagPtrVar, NewCallback(ClearFuncVar))

}

var xGetCurrentTime func(*TimeVal)

// Equivalent to the UNIX gettimeofday() function, but portable.
//
// You may find g_get_real_time() to be more convenient.
func GetCurrentTime(ResultVar *TimeVal) {

	xGetCurrentTime(ResultVar)

}

var xGetMonotonicTime func() int64

// Queries the system monotonic time.
//
// The monotonic clock will always increase and doesn't suffer
// discontinuities when the user (or NTP) changes the system time.  It
// may or may not continue to tick during times where the machine is
// suspended.
//
// We try to use the clock that corresponds as closely as possible to
// the passage of time as measured by system calls such as poll() but it
// may not always be possible to do this.
func GetMonotonicTime() int64 {

	cret := xGetMonotonicTime()
	return cret
}

var xGetRealTime func() int64

// Queries the system wall-clock time.
//
// This call is functionally equivalent to g_get_current_time() except
// that the return value is often more convenient than dealing with a
// #GTimeVal.
//
// You should only use this call if you are actually interested in the real
// wall-clock time.  g_get_monotonic_time() is probably more useful for
// measuring intervals.
func GetRealTime() int64 {

	cret := xGetRealTime()
	return cret
}

var xIdleAdd func(uintptr, uintptr) uint

// Adds a function to be called whenever there are no higher priority
// events pending to the default main loop. The function is given the
// default idle priority, %G_PRIORITY_DEFAULT_IDLE.  If the function
// returns %FALSE it is automatically removed from the list of event
// sources and will not be called again.
//
// See [memory management of sources][mainloop-memory-management] for details
// on how to handle the return value and memory management of @data.
//
// This internally creates a main loop source using g_idle_source_new()
// and attaches it to the global #GMainContext using g_source_attach(), so
// the callback will be invoked in whichever thread is running that main
// context. You can do these steps manually if you need greater control or to
// use a custom main context.
func IdleAdd(FunctionVar *SourceFunc, DataVar uintptr) uint {

	cret := xIdleAdd(NewCallback(FunctionVar), DataVar)
	return cret
}

var xIdleAddFull func(int, uintptr, uintptr, uintptr) uint

// Adds a function to be called whenever there are no higher priority
// events pending.
//
// If the function returns %G_SOURCE_REMOVE or %FALSE it is automatically
// removed from the list of event sources and will not be called again.
//
// See [memory management of sources][mainloop-memory-management] for details
// on how to handle the return value and memory management of @data.
//
// This internally creates a main loop source using g_idle_source_new()
// and attaches it to the global #GMainContext using g_source_attach(), so
// the callback will be invoked in whichever thread is running that main
// context. You can do these steps manually if you need greater control or to
// use a custom main context.
func IdleAddFull(PriorityVar int, FunctionVar *SourceFunc, DataVar uintptr, NotifyVar *DestroyNotify) uint {

	cret := xIdleAddFull(PriorityVar, NewCallback(FunctionVar), DataVar, NewCallback(NotifyVar))
	return cret
}

var xIdleRemoveByData func(uintptr) bool

// Removes the idle function with the given data.
func IdleRemoveByData(DataVar uintptr) bool {

	cret := xIdleRemoveByData(DataVar)
	return cret
}

var xIdleSourceNew func() *Source

// Creates a new idle source.
//
// The source will not initially be associated with any #GMainContext
// and must be added to one with g_source_attach() before it will be
// executed. Note that the default priority for idle sources is
// %G_PRIORITY_DEFAULT_IDLE, as compared to other sources which
// have a default priority of %G_PRIORITY_DEFAULT.
func IdleSourceNew() *Source {

	cret := xIdleSourceNew()
	return cret
}

var xMainContextDefault func() *MainContext

// Returns the global default main context. This is the main context
// used for main loop functions when a main loop is not explicitly
// specified, and corresponds to the "main" main loop. See also
// g_main_context_get_thread_default().
func MainContextDefault() *MainContext {

	cret := xMainContextDefault()
	return cret
}

var xMainContextGetThreadDefault func() *MainContext

// Gets the thread-default #GMainContext for this thread. Asynchronous
// operations that want to be able to be run in contexts other than
// the default one should call this method or
// g_main_context_ref_thread_default() to get a #GMainContext to add
// their #GSources to. (Note that even in single-threaded
// programs applications may sometimes want to temporarily push a
// non-default context, so it is not safe to assume that this will
// always return %NULL if you are running in the default thread.)
//
// If you need to hold a reference on the context, use
// g_main_context_ref_thread_default() instead.
func MainContextGetThreadDefault() *MainContext {

	cret := xMainContextGetThreadDefault()
	return cret
}

var xMainContextRefThreadDefault func() *MainContext

// Gets the thread-default #GMainContext for this thread, as with
// g_main_context_get_thread_default(), but also adds a reference to
// it with g_main_context_ref(). In addition, unlike
// g_main_context_get_thread_default(), if the thread-default context
// is the global default context, this will return that #GMainContext
// (with a ref added to it) rather than returning %NULL.
func MainContextRefThreadDefault() *MainContext {

	cret := xMainContextRefThreadDefault()
	return cret
}

var xMainCurrentSource func() *Source

// Returns the currently firing source for this thread.
func MainCurrentSource() *Source {

	cret := xMainCurrentSource()
	return cret
}

var xMainDepth func() int

// Returns the depth of the stack of calls to
// g_main_context_dispatch() on any #GMainContext in the current thread.
//
//	That is, when called from the toplevel, it gives 0. When
//
// called from within a callback from g_main_context_iteration()
// (or g_main_loop_run(), etc.) it returns 1. When called from within
// a callback to a recursive call to g_main_context_iteration(),
// it returns 2. And so forth.
//
// This function is useful in a situation like the following:
// Imagine an extremely simple "garbage collected" system.
//
// |[&lt;!-- language="C" --&gt;
// static GList *free_list;
//
// gpointer
// allocate_memory (gsize size)
//
//	{
//	  gpointer result = g_malloc (size);
//	  free_list = g_list_prepend (free_list, result);
//	  return result;
//	}
//
// void
// free_allocated_memory (void)
//
//	{
//	  GList *l;
//	  for (l = free_list; l; l = l-&gt;next);
//	    g_free (l-&gt;data);
//	  g_list_free (free_list);
//	  free_list = NULL;
//	 }
//
// [...]
//
// while (TRUE);
//
//	{
//	  g_main_context_iteration (NULL, TRUE);
//	  free_allocated_memory();
//	 }
//
// ]|
//
// This works from an application, however, if you want to do the same
// thing from a library, it gets more difficult, since you no longer
// control the main loop. You might think you can simply use an idle
// function to make the call to free_allocated_memory(), but that
// doesn't work, since the idle function could be called from a
// recursive callback. This can be fixed by using g_main_depth()
//
// |[&lt;!-- language="C" --&gt;
// gpointer
// allocate_memory (gsize size)
//
//	{
//	  FreeListBlock *block = g_new (FreeListBlock, 1);
//	  block-&gt;mem = g_malloc (size);
//	  block-&gt;depth = g_main_depth ();
//	  free_list = g_list_prepend (free_list, block);
//	  return block-&gt;mem;
//	}
//
// void
// free_allocated_memory (void)
//
//	{
//	  GList *l;
//
//	  int depth = g_main_depth ();
//	  for (l = free_list; l; );
//	    {
//	      GList *next = l-&gt;next;
//	      FreeListBlock *block = l-&gt;data;
//	      if (block-&gt;depth &gt; depth)
//	        {
//	          g_free (block-&gt;mem);
//	          g_free (block);
//	          free_list = g_list_delete_link (free_list, l);
//	        }
//
//	      l = next;
//	    }
//	  }
//
// ]|
//
// There is a temptation to use g_main_depth() to solve
// problems with reentrancy. For instance, while waiting for data
// to be received from the network in response to a menu item,
// the menu item might be selected again. It might seem that
// one could make the menu item's callback return immediately
// and do nothing if g_main_depth() returns a value greater than 1.
// However, this should be avoided since the user then sees selecting
// the menu item do nothing. Furthermore, you'll find yourself adding
// these checks all over your code, since there are doubtless many,
// many things that the user could do. Instead, you can use the
// following techniques:
//
//  1. Use gtk_widget_set_sensitive() or modal dialogs to prevent
//     the user from interacting with elements while the main
//     loop is recursing.
//
//  2. Avoid main loop recursion in situations where you can't handle
//     arbitrary  callbacks. Instead, structure your code so that you
//     simply return to the main loop and then get called again when
//     there is more work to do.
func MainDepth() int {

	cret := xMainDepth()
	return cret
}

var xSourceRemove func(uint) bool

// Removes the source with the given ID from the default main context. You must
// use g_source_destroy() for sources added to a non-default main context.
//
// The ID of a #GSource is given by g_source_get_id(), or will be
// returned by the functions g_source_attach(), g_idle_add(),
// g_idle_add_full(), g_timeout_add(), g_timeout_add_full(),
// g_child_watch_add(), g_child_watch_add_full(), g_io_add_watch(), and
// g_io_add_watch_full().
//
// It is a programmer error to attempt to remove a non-existent source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a
// source ID which may have already been removed.  An example is when
// scheduling an idle to run in another thread with g_idle_add(): the
// idle may already have run and been removed by the time this function
// is called on its (now invalid) source ID.  This source ID may have
// been reissued, leading to the operation being performed against the
// wrong source.
func SourceRemove(TagVar uint) bool {

	cret := xSourceRemove(TagVar)
	return cret
}

var xSourceRemoveByFuncsUserData func(*SourceFuncs, uintptr) bool

// Removes a source from the default main loop context given the
// source functions and user data. If multiple sources exist with the
// same source functions and user data, only one will be destroyed.
func SourceRemoveByFuncsUserData(FuncsVar *SourceFuncs, UserDataVar uintptr) bool {

	cret := xSourceRemoveByFuncsUserData(FuncsVar, UserDataVar)
	return cret
}

var xSourceRemoveByUserData func(uintptr) bool

// Removes a source from the default main loop context given the user
// data for the callback. If multiple sources exist with the same user
// data, only one will be destroyed.
func SourceRemoveByUserData(UserDataVar uintptr) bool {

	cret := xSourceRemoveByUserData(UserDataVar)
	return cret
}

var xSourceSetNameById func(uint, string)

// Sets the name of a source using its ID.
//
// This is a convenience utility to set source names from the return
// value of g_idle_add(), g_timeout_add(), etc.
//
// It is a programmer error to attempt to set the name of a non-existent
// source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a
// source ID which may have already been removed.  An example is when
// scheduling an idle to run in another thread with g_idle_add(): the
// idle may already have run and been removed by the time this function
// is called on its (now invalid) source ID.  This source ID may have
// been reissued, leading to the operation being performed against the
// wrong source.
func SourceSetNameById(TagVar uint, NameVar string) {

	xSourceSetNameById(TagVar, NameVar)

}

var xTimeoutAdd func(uint, uintptr, uintptr) uint

// Sets a function to be called at regular intervals, with the default
// priority, %G_PRIORITY_DEFAULT.
//
// The given @function is called repeatedly until it returns %G_SOURCE_REMOVE
// or %FALSE, at which point the timeout is automatically destroyed and the
// function will not be called again. The first call to the function will be
// at the end of the first @interval.
//
// Note that timeout functions may be delayed, due to the processing of other
// event sources. Thus they should not be relied on for precise timing.
// After each call to the timeout function, the time of the next
// timeout is recalculated based on the current time and the given interval
// (it does not try to 'catch up' time lost in delays).
//
// See [memory management of sources][mainloop-memory-management] for details
// on how to handle the return value and memory management of @data.
//
// If you want to have a timer in the "seconds" range and do not care
// about the exact time of the first call of the timer, use the
// g_timeout_add_seconds() function; this function allows for more
// optimizations and more efficient system power usage.
//
// This internally creates a main loop source using g_timeout_source_new()
// and attaches it to the global #GMainContext using g_source_attach(), so
// the callback will be invoked in whichever thread is running that main
// context. You can do these steps manually if you need greater control or to
// use a custom main context.
//
// It is safe to call this function from any thread.
//
// The interval given is in terms of monotonic time, not wall clock
// time.  See g_get_monotonic_time().
func TimeoutAdd(IntervalVar uint, FunctionVar *SourceFunc, DataVar uintptr) uint {

	cret := xTimeoutAdd(IntervalVar, NewCallback(FunctionVar), DataVar)
	return cret
}

var xTimeoutAddFull func(int, uint, uintptr, uintptr, uintptr) uint

// Sets a function to be called at regular intervals, with the given
// priority.  The function is called repeatedly until it returns
// %FALSE, at which point the timeout is automatically destroyed and
// the function will not be called again.  The @notify function is
// called when the timeout is destroyed.  The first call to the
// function will be at the end of the first @interval.
//
// Note that timeout functions may be delayed, due to the processing of other
// event sources. Thus they should not be relied on for precise timing.
// After each call to the timeout function, the time of the next
// timeout is recalculated based on the current time and the given interval
// (it does not try to 'catch up' time lost in delays).
//
// See [memory management of sources][mainloop-memory-management] for details
// on how to handle the return value and memory management of @data.
//
// This internally creates a main loop source using g_timeout_source_new()
// and attaches it to the global #GMainContext using g_source_attach(), so
// the callback will be invoked in whichever thread is running that main
// context. You can do these steps manually if you need greater control or to
// use a custom main context.
//
// The interval given is in terms of monotonic time, not wall clock time.
// See g_get_monotonic_time().
func TimeoutAddFull(PriorityVar int, IntervalVar uint, FunctionVar *SourceFunc, DataVar uintptr, NotifyVar *DestroyNotify) uint {

	cret := xTimeoutAddFull(PriorityVar, IntervalVar, NewCallback(FunctionVar), DataVar, NewCallback(NotifyVar))
	return cret
}

var xTimeoutAddSeconds func(uint, uintptr, uintptr) uint

// Sets a function to be called at regular intervals with the default
// priority, %G_PRIORITY_DEFAULT.
//
// The function is called repeatedly until it returns %G_SOURCE_REMOVE
// or %FALSE, at which point the timeout is automatically destroyed
// and the function will not be called again.
//
// This internally creates a main loop source using
// g_timeout_source_new_seconds() and attaches it to the main loop context
// using g_source_attach(). You can do these steps manually if you need
// greater control. Also see g_timeout_add_seconds_full().
//
// It is safe to call this function from any thread.
//
// Note that the first call of the timer may not be precise for timeouts
// of one second. If you need finer precision and have such a timeout,
// you may want to use g_timeout_add() instead.
//
// See [memory management of sources][mainloop-memory-management] for details
// on how to handle the return value and memory management of @data.
//
// The interval given is in terms of monotonic time, not wall clock
// time.  See g_get_monotonic_time().
func TimeoutAddSeconds(IntervalVar uint, FunctionVar *SourceFunc, DataVar uintptr) uint {

	cret := xTimeoutAddSeconds(IntervalVar, NewCallback(FunctionVar), DataVar)
	return cret
}

var xTimeoutAddSecondsFull func(int, uint, uintptr, uintptr, uintptr) uint

// Sets a function to be called at regular intervals, with @priority.
//
// The function is called repeatedly until it returns %G_SOURCE_REMOVE
// or %FALSE, at which point the timeout is automatically destroyed and
// the function will not be called again.
//
// Unlike g_timeout_add(), this function operates at whole second granularity.
// The initial starting point of the timer is determined by the implementation
// and the implementation is expected to group multiple timers together so that
// they fire all at the same time. To allow this grouping, the @interval to the
// first timer is rounded and can deviate up to one second from the specified
// interval. Subsequent timer iterations will generally run at the specified
// interval.
//
// Note that timeout functions may be delayed, due to the processing of other
// event sources. Thus they should not be relied on for precise timing.
// After each call to the timeout function, the time of the next
// timeout is recalculated based on the current time and the given @interval
//
// See [memory management of sources][mainloop-memory-management] for details
// on how to handle the return value and memory management of @data.
//
// If you want timing more precise than whole seconds, use g_timeout_add()
// instead.
//
// The grouping of timers to fire at the same time results in a more power
// and CPU efficient behavior so if your timer is in multiples of seconds
// and you don't require the first timer exactly one second from now, the
// use of g_timeout_add_seconds() is preferred over g_timeout_add().
//
// This internally creates a main loop source using
// g_timeout_source_new_seconds() and attaches it to the main loop context
// using g_source_attach(). You can do these steps manually if you need
// greater control.
//
// It is safe to call this function from any thread.
//
// The interval given is in terms of monotonic time, not wall clock
// time.  See g_get_monotonic_time().
func TimeoutAddSecondsFull(PriorityVar int, IntervalVar uint, FunctionVar *SourceFunc, DataVar uintptr, NotifyVar *DestroyNotify) uint {

	cret := xTimeoutAddSecondsFull(PriorityVar, IntervalVar, NewCallback(FunctionVar), DataVar, NewCallback(NotifyVar))
	return cret
}

var xTimeoutSourceNew func(uint) *Source

// Creates a new timeout source.
//
// The source will not initially be associated with any #GMainContext
// and must be added to one with g_source_attach() before it will be
// executed.
//
// The interval given is in terms of monotonic time, not wall clock
// time.  See g_get_monotonic_time().
func TimeoutSourceNew(IntervalVar uint) *Source {

	cret := xTimeoutSourceNew(IntervalVar)
	return cret
}

var xTimeoutSourceNewSeconds func(uint) *Source

// Creates a new timeout source.
//
// The source will not initially be associated with any #GMainContext
// and must be added to one with g_source_attach() before it will be
// executed.
//
// The scheduling granularity/accuracy of this timeout source will be
// in seconds.
//
// The interval given is in terms of monotonic time, not wall clock time.
// See g_get_monotonic_time().
func TimeoutSourceNewSeconds(IntervalVar uint) *Source {

	cret := xTimeoutSourceNewSeconds(IntervalVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xChildWatchAdd, lib, "g_child_watch_add")
	core.PuregoSafeRegister(&xChildWatchAddFull, lib, "g_child_watch_add_full")
	core.PuregoSafeRegister(&xChildWatchSourceNew, lib, "g_child_watch_source_new")
	core.PuregoSafeRegister(&xClearHandleId, lib, "g_clear_handle_id")
	core.PuregoSafeRegister(&xGetCurrentTime, lib, "g_get_current_time")
	core.PuregoSafeRegister(&xGetMonotonicTime, lib, "g_get_monotonic_time")
	core.PuregoSafeRegister(&xGetRealTime, lib, "g_get_real_time")
	core.PuregoSafeRegister(&xIdleAdd, lib, "g_idle_add")
	core.PuregoSafeRegister(&xIdleAddFull, lib, "g_idle_add_full")
	core.PuregoSafeRegister(&xIdleRemoveByData, lib, "g_idle_remove_by_data")
	core.PuregoSafeRegister(&xIdleSourceNew, lib, "g_idle_source_new")
	core.PuregoSafeRegister(&xMainContextDefault, lib, "g_main_context_default")
	core.PuregoSafeRegister(&xMainContextGetThreadDefault, lib, "g_main_context_get_thread_default")
	core.PuregoSafeRegister(&xMainContextRefThreadDefault, lib, "g_main_context_ref_thread_default")
	core.PuregoSafeRegister(&xMainCurrentSource, lib, "g_main_current_source")
	core.PuregoSafeRegister(&xMainDepth, lib, "g_main_depth")
	core.PuregoSafeRegister(&xSourceRemove, lib, "g_source_remove")
	core.PuregoSafeRegister(&xSourceRemoveByFuncsUserData, lib, "g_source_remove_by_funcs_user_data")
	core.PuregoSafeRegister(&xSourceRemoveByUserData, lib, "g_source_remove_by_user_data")
	core.PuregoSafeRegister(&xSourceSetNameById, lib, "g_source_set_name_by_id")
	core.PuregoSafeRegister(&xTimeoutAdd, lib, "g_timeout_add")
	core.PuregoSafeRegister(&xTimeoutAddFull, lib, "g_timeout_add_full")
	core.PuregoSafeRegister(&xTimeoutAddSeconds, lib, "g_timeout_add_seconds")
	core.PuregoSafeRegister(&xTimeoutAddSecondsFull, lib, "g_timeout_add_seconds_full")
	core.PuregoSafeRegister(&xTimeoutSourceNew, lib, "g_timeout_source_new")
	core.PuregoSafeRegister(&xTimeoutSourceNewSeconds, lib, "g_timeout_source_new_seconds")

	core.PuregoSafeRegister(&xMainContextGLibType, lib, "g_main_context_get_type")

	core.PuregoSafeRegister(&xNewMainContext, lib, "g_main_context_new")
	core.PuregoSafeRegister(&xNewMainContextWithFlags, lib, "g_main_context_new_with_flags")

	core.PuregoSafeRegister(&xMainContextAcquire, lib, "g_main_context_acquire")
	core.PuregoSafeRegister(&xMainContextAddPoll, lib, "g_main_context_add_poll")
	core.PuregoSafeRegister(&xMainContextCheck, lib, "g_main_context_check")
	core.PuregoSafeRegister(&xMainContextDispatch, lib, "g_main_context_dispatch")
	core.PuregoSafeRegister(&xMainContextFindSourceByFuncsUserData, lib, "g_main_context_find_source_by_funcs_user_data")
	core.PuregoSafeRegister(&xMainContextFindSourceById, lib, "g_main_context_find_source_by_id")
	core.PuregoSafeRegister(&xMainContextFindSourceByUserData, lib, "g_main_context_find_source_by_user_data")
	core.PuregoSafeRegister(&xMainContextGetPollFunc, lib, "g_main_context_get_poll_func")
	core.PuregoSafeRegister(&xMainContextInvoke, lib, "g_main_context_invoke")
	core.PuregoSafeRegister(&xMainContextInvokeFull, lib, "g_main_context_invoke_full")
	core.PuregoSafeRegister(&xMainContextIsOwner, lib, "g_main_context_is_owner")
	core.PuregoSafeRegister(&xMainContextIteration, lib, "g_main_context_iteration")
	core.PuregoSafeRegister(&xMainContextPending, lib, "g_main_context_pending")
	core.PuregoSafeRegister(&xMainContextPopThreadDefault, lib, "g_main_context_pop_thread_default")
	core.PuregoSafeRegister(&xMainContextPrepare, lib, "g_main_context_prepare")
	core.PuregoSafeRegister(&xMainContextPushThreadDefault, lib, "g_main_context_push_thread_default")
	core.PuregoSafeRegister(&xMainContextQuery, lib, "g_main_context_query")
	core.PuregoSafeRegister(&xMainContextRef, lib, "g_main_context_ref")
	core.PuregoSafeRegister(&xMainContextRelease, lib, "g_main_context_release")
	core.PuregoSafeRegister(&xMainContextRemovePoll, lib, "g_main_context_remove_poll")
	core.PuregoSafeRegister(&xMainContextSetPollFunc, lib, "g_main_context_set_poll_func")
	core.PuregoSafeRegister(&xMainContextUnref, lib, "g_main_context_unref")
	core.PuregoSafeRegister(&xMainContextWait, lib, "g_main_context_wait")
	core.PuregoSafeRegister(&xMainContextWakeup, lib, "g_main_context_wakeup")

	core.PuregoSafeRegister(&xMainLoopGLibType, lib, "g_main_loop_get_type")

	core.PuregoSafeRegister(&xNewMainLoop, lib, "g_main_loop_new")

	core.PuregoSafeRegister(&xMainLoopGetContext, lib, "g_main_loop_get_context")
	core.PuregoSafeRegister(&xMainLoopIsRunning, lib, "g_main_loop_is_running")
	core.PuregoSafeRegister(&xMainLoopQuit, lib, "g_main_loop_quit")
	core.PuregoSafeRegister(&xMainLoopRef, lib, "g_main_loop_ref")
	core.PuregoSafeRegister(&xMainLoopRun, lib, "g_main_loop_run")
	core.PuregoSafeRegister(&xMainLoopUnref, lib, "g_main_loop_unref")

	core.PuregoSafeRegister(&xSourceGLibType, lib, "g_source_get_type")

	core.PuregoSafeRegister(&xNewSource, lib, "g_source_new")

	core.PuregoSafeRegister(&xSourceAddChildSource, lib, "g_source_add_child_source")
	core.PuregoSafeRegister(&xSourceAddPoll, lib, "g_source_add_poll")
	core.PuregoSafeRegister(&xSourceAddUnixFd, lib, "g_source_add_unix_fd")
	core.PuregoSafeRegister(&xSourceAttach, lib, "g_source_attach")
	core.PuregoSafeRegister(&xSourceDestroy, lib, "g_source_destroy")
	core.PuregoSafeRegister(&xSourceGetCanRecurse, lib, "g_source_get_can_recurse")
	core.PuregoSafeRegister(&xSourceGetContext, lib, "g_source_get_context")
	core.PuregoSafeRegister(&xSourceGetCurrentTime, lib, "g_source_get_current_time")
	core.PuregoSafeRegister(&xSourceGetId, lib, "g_source_get_id")
	core.PuregoSafeRegister(&xSourceGetName, lib, "g_source_get_name")
	core.PuregoSafeRegister(&xSourceGetPriority, lib, "g_source_get_priority")
	core.PuregoSafeRegister(&xSourceGetReadyTime, lib, "g_source_get_ready_time")
	core.PuregoSafeRegister(&xSourceGetTime, lib, "g_source_get_time")
	core.PuregoSafeRegister(&xSourceIsDestroyed, lib, "g_source_is_destroyed")
	core.PuregoSafeRegister(&xSourceModifyUnixFd, lib, "g_source_modify_unix_fd")
	core.PuregoSafeRegister(&xSourceQueryUnixFd, lib, "g_source_query_unix_fd")
	core.PuregoSafeRegister(&xSourceRef, lib, "g_source_ref")
	core.PuregoSafeRegister(&xSourceRemoveChildSource, lib, "g_source_remove_child_source")
	core.PuregoSafeRegister(&xSourceRemovePoll, lib, "g_source_remove_poll")
	core.PuregoSafeRegister(&xSourceRemoveUnixFd, lib, "g_source_remove_unix_fd")
	core.PuregoSafeRegister(&xSourceSetCallback, lib, "g_source_set_callback")
	core.PuregoSafeRegister(&xSourceSetCallbackIndirect, lib, "g_source_set_callback_indirect")
	core.PuregoSafeRegister(&xSourceSetCanRecurse, lib, "g_source_set_can_recurse")
	core.PuregoSafeRegister(&xSourceSetDisposeFunction, lib, "g_source_set_dispose_function")
	core.PuregoSafeRegister(&xSourceSetFuncs, lib, "g_source_set_funcs")
	core.PuregoSafeRegister(&xSourceSetName, lib, "g_source_set_name")
	core.PuregoSafeRegister(&xSourceSetPriority, lib, "g_source_set_priority")
	core.PuregoSafeRegister(&xSourceSetReadyTime, lib, "g_source_set_ready_time")
	core.PuregoSafeRegister(&xSourceSetStaticName, lib, "g_source_set_static_name")
	core.PuregoSafeRegister(&xSourceUnref, lib, "g_source_unref")

}
