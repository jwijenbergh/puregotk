// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// An opaque data structure representing a set of bookmarks.
type BookmarkFile struct {
	_ structs.HostLayout
}

func (x *BookmarkFile) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xBookmarkFileAddApplication func(uintptr, string, string, string)

// Adds the application with @name and @exec to the list of
// applications that have registered a bookmark for @uri into
// @bookmark.
//
// Every bookmark inside a #GBookmarkFile must have at least an
// application registered.  Each application must provide a name, a
// command line useful for launching the bookmark, the number of times
// the bookmark has been registered by the application and the last
// time the application registered this bookmark.
//
// If @name is %NULL, the name of the application will be the
// same returned by g_get_application_name(); if @exec is %NULL, the
// command line will be a composition of the program name as
// returned by g_get_prgname() and the "\%u" modifier, which will be
// expanded to the bookmark's URI.
//
// This function will automatically take care of updating the
// registrations count and timestamping in case an application
// with the same @name had already registered a bookmark for
// @uri inside @bookmark.
//
// If no bookmark for @uri is found, one is created.
func (x *BookmarkFile) AddApplication(UriVar string, NameVar string, ExecVar string) {

	xBookmarkFileAddApplication(x.GoPointer(), UriVar, NameVar, ExecVar)

}

var xBookmarkFileAddGroup func(uintptr, string, string)

// Adds @group to the list of groups to which the bookmark for @uri
// belongs to.
//
// If no bookmark for @uri is found then it is created.
func (x *BookmarkFile) AddGroup(UriVar string, GroupVar string) {

	xBookmarkFileAddGroup(x.GoPointer(), UriVar, GroupVar)

}

var xBookmarkFileFree func(uintptr)

// Frees a #GBookmarkFile.
func (x *BookmarkFile) Free() {

	xBookmarkFileFree(x.GoPointer())

}

var xBookmarkFileGetAdded func(uintptr, string, **Error) int32

// Gets the time the bookmark for @uri was added to @bookmark
//
// In the event the URI cannot be found, -1 is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (x *BookmarkFile) GetAdded(UriVar string) (int32, error) {
	var cerr *Error

	cret := xBookmarkFileGetAdded(x.GoPointer(), UriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetAddedDateTime func(uintptr, string, **Error) *DateTime

// Gets the time the bookmark for @uri was added to @bookmark
//
// In the event the URI cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (x *BookmarkFile) GetAddedDateTime(UriVar string) (*DateTime, error) {
	var cerr *Error

	cret := xBookmarkFileGetAddedDateTime(x.GoPointer(), UriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetAppInfo func(uintptr, string, string, string, uint, int32, **Error) bool

// Gets the registration information of @app_name for the bookmark for
// @uri.  See g_bookmark_file_set_application_info() for more information about
// the returned data.
//
// The string returned in @app_exec must be freed.
//
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
// event that no application with name @app_name has registered a bookmark
// for @uri,  %FALSE is returned and error is set to
// %G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting
// the command line fails, an error of the %G_SHELL_ERROR domain is
// set and %FALSE is returned.
func (x *BookmarkFile) GetAppInfo(UriVar string, NameVar string, ExecVar string, CountVar uint, StampVar int32) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileGetAppInfo(x.GoPointer(), UriVar, NameVar, ExecVar, CountVar, StampVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetApplicationInfo func(uintptr, string, string, string, uint, **DateTime, **Error) bool

// Gets the registration information of @app_name for the bookmark for
// @uri.  See g_bookmark_file_set_application_info() for more information about
// the returned data.
//
// The string returned in @app_exec must be freed.
//
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
// event that no application with name @app_name has registered a bookmark
// for @uri,  %FALSE is returned and error is set to
// %G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting
// the command line fails, an error of the %G_SHELL_ERROR domain is
// set and %FALSE is returned.
func (x *BookmarkFile) GetApplicationInfo(UriVar string, NameVar string, ExecVar string, CountVar uint, StampVar **DateTime) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileGetApplicationInfo(x.GoPointer(), UriVar, NameVar, ExecVar, CountVar, StampVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetApplications func(uintptr, string, uint, **Error) []string

// Retrieves the names of the applications that have registered the
// bookmark for @uri.
//
// In the event the URI cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (x *BookmarkFile) GetApplications(UriVar string, LengthVar uint) ([]string, error) {
	var cerr *Error

	cret := xBookmarkFileGetApplications(x.GoPointer(), UriVar, LengthVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetDescription func(uintptr, string, **Error) string

// Retrieves the description of the bookmark for @uri.
//
// In the event the URI cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (x *BookmarkFile) GetDescription(UriVar string) (string, error) {
	var cerr *Error

	cret := xBookmarkFileGetDescription(x.GoPointer(), UriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetGroups func(uintptr, string, uint, **Error) []string

// Retrieves the list of group names of the bookmark for @uri.
//
// In the event the URI cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
//
// The returned array is %NULL terminated, so @length may optionally
// be %NULL.
func (x *BookmarkFile) GetGroups(UriVar string, LengthVar uint) ([]string, error) {
	var cerr *Error

	cret := xBookmarkFileGetGroups(x.GoPointer(), UriVar, LengthVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetIcon func(uintptr, string, string, string, **Error) bool

// Gets the icon of the bookmark for @uri.
//
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (x *BookmarkFile) GetIcon(UriVar string, HrefVar string, MimeTypeVar string) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileGetIcon(x.GoPointer(), UriVar, HrefVar, MimeTypeVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetIsPrivate func(uintptr, string, **Error) bool

// Gets whether the private flag of the bookmark for @uri is set.
//
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
// event that the private flag cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (x *BookmarkFile) GetIsPrivate(UriVar string) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileGetIsPrivate(x.GoPointer(), UriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetMimeType func(uintptr, string, **Error) string

// Retrieves the MIME type of the resource pointed by @uri.
//
// In the event the URI cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
// event that the MIME type cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (x *BookmarkFile) GetMimeType(UriVar string) (string, error) {
	var cerr *Error

	cret := xBookmarkFileGetMimeType(x.GoPointer(), UriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetModified func(uintptr, string, **Error) int32

// Gets the time when the bookmark for @uri was last modified.
//
// In the event the URI cannot be found, -1 is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (x *BookmarkFile) GetModified(UriVar string) (int32, error) {
	var cerr *Error

	cret := xBookmarkFileGetModified(x.GoPointer(), UriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetModifiedDateTime func(uintptr, string, **Error) *DateTime

// Gets the time when the bookmark for @uri was last modified.
//
// In the event the URI cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (x *BookmarkFile) GetModifiedDateTime(UriVar string) (*DateTime, error) {
	var cerr *Error

	cret := xBookmarkFileGetModifiedDateTime(x.GoPointer(), UriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetSize func(uintptr) int

// Gets the number of bookmarks inside @bookmark.
func (x *BookmarkFile) GetSize() int {

	cret := xBookmarkFileGetSize(x.GoPointer())
	return cret
}

var xBookmarkFileGetTitle func(uintptr, string, **Error) string

// Returns the title of the bookmark for @uri.
//
// If @uri is %NULL, the title of @bookmark is returned.
//
// In the event the URI cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (x *BookmarkFile) GetTitle(UriVar string) (string, error) {
	var cerr *Error

	cret := xBookmarkFileGetTitle(x.GoPointer(), UriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetUris func(uintptr, uint) []string

// Returns all URIs of the bookmarks in the bookmark file @bookmark.
// The array of returned URIs will be %NULL-terminated, so @length may
// optionally be %NULL.
func (x *BookmarkFile) GetUris(LengthVar uint) []string {

	cret := xBookmarkFileGetUris(x.GoPointer(), LengthVar)
	return cret
}

var xBookmarkFileGetVisited func(uintptr, string, **Error) int32

// Gets the time the bookmark for @uri was last visited.
//
// In the event the URI cannot be found, -1 is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (x *BookmarkFile) GetVisited(UriVar string) (int32, error) {
	var cerr *Error

	cret := xBookmarkFileGetVisited(x.GoPointer(), UriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileGetVisitedDateTime func(uintptr, string, **Error) *DateTime

// Gets the time the bookmark for @uri was last visited.
//
// In the event the URI cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (x *BookmarkFile) GetVisitedDateTime(UriVar string) (*DateTime, error) {
	var cerr *Error

	cret := xBookmarkFileGetVisitedDateTime(x.GoPointer(), UriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileHasApplication func(uintptr, string, string, **Error) bool

// Checks whether the bookmark for @uri inside @bookmark has been
// registered by application @name.
//
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (x *BookmarkFile) HasApplication(UriVar string, NameVar string) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileHasApplication(x.GoPointer(), UriVar, NameVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileHasGroup func(uintptr, string, string, **Error) bool

// Checks whether @group appears in the list of groups to which
// the bookmark for @uri belongs to.
//
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (x *BookmarkFile) HasGroup(UriVar string, GroupVar string) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileHasGroup(x.GoPointer(), UriVar, GroupVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileHasItem func(uintptr, string) bool

// Looks whether the desktop bookmark has an item with its URI set to @uri.
func (x *BookmarkFile) HasItem(UriVar string) bool {

	cret := xBookmarkFileHasItem(x.GoPointer(), UriVar)
	return cret
}

var xBookmarkFileLoadFromData func(uintptr, []byte, uint, **Error) bool

// Loads a bookmark file from memory into an empty #GBookmarkFile
// structure.  If the object cannot be created then @error is set to a
// #GBookmarkFileError.
func (x *BookmarkFile) LoadFromData(DataVar []byte, LengthVar uint) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileLoadFromData(x.GoPointer(), DataVar, LengthVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileLoadFromDataDirs func(uintptr, string, string, **Error) bool

// This function looks for a desktop bookmark file named @file in the
// paths returned from g_get_user_data_dir() and g_get_system_data_dirs(),
// loads the file into @bookmark and returns the file's full path in
// @full_path.  If the file could not be loaded then @error is
// set to either a #GFileError or #GBookmarkFileError.
func (x *BookmarkFile) LoadFromDataDirs(FileVar string, FullPathVar string) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileLoadFromDataDirs(x.GoPointer(), FileVar, FullPathVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileLoadFromFile func(uintptr, string, **Error) bool

// Loads a desktop bookmark file into an empty #GBookmarkFile structure.
// If the file could not be loaded then @error is set to either a #GFileError
// or #GBookmarkFileError.
func (x *BookmarkFile) LoadFromFile(FilenameVar string) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileLoadFromFile(x.GoPointer(), FilenameVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileMoveItem func(uintptr, string, string, **Error) bool

// Changes the URI of a bookmark item from @old_uri to @new_uri.  Any
// existing bookmark for @new_uri will be overwritten.  If @new_uri is
// %NULL, then the bookmark is removed.
//
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (x *BookmarkFile) MoveItem(OldUriVar string, NewUriVar string) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileMoveItem(x.GoPointer(), OldUriVar, NewUriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileRemoveApplication func(uintptr, string, string, **Error) bool

// Removes application registered with @name from the list of applications
// that have registered a bookmark for @uri inside @bookmark.
//
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
// In the event that no application with name @app_name has registered
// a bookmark for @uri,  %FALSE is returned and error is set to
// %G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.
func (x *BookmarkFile) RemoveApplication(UriVar string, NameVar string) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileRemoveApplication(x.GoPointer(), UriVar, NameVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileRemoveGroup func(uintptr, string, string, **Error) bool

// Removes @group from the list of groups to which the bookmark
// for @uri belongs to.
//
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
// In the event no group was defined, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (x *BookmarkFile) RemoveGroup(UriVar string, GroupVar string) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileRemoveGroup(x.GoPointer(), UriVar, GroupVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileRemoveItem func(uintptr, string, **Error) bool

// Removes the bookmark for @uri from the bookmark file @bookmark.
func (x *BookmarkFile) RemoveItem(UriVar string) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileRemoveItem(x.GoPointer(), UriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileSetAdded func(uintptr, string, int32)

// Sets the time the bookmark for @uri was added into @bookmark.
//
// If no bookmark for @uri is found then it is created.
func (x *BookmarkFile) SetAdded(UriVar string, AddedVar int32) {

	xBookmarkFileSetAdded(x.GoPointer(), UriVar, AddedVar)

}

var xBookmarkFileSetAddedDateTime func(uintptr, string, *DateTime)

// Sets the time the bookmark for @uri was added into @bookmark.
//
// If no bookmark for @uri is found then it is created.
func (x *BookmarkFile) SetAddedDateTime(UriVar string, AddedVar *DateTime) {

	xBookmarkFileSetAddedDateTime(x.GoPointer(), UriVar, AddedVar)

}

var xBookmarkFileSetAppInfo func(uintptr, string, string, string, int, int32, **Error) bool

// Sets the meta-data of application @name inside the list of
// applications that have registered a bookmark for @uri inside
// @bookmark.
//
// You should rarely use this function; use g_bookmark_file_add_application()
// and g_bookmark_file_remove_application() instead.
//
// @name can be any UTF-8 encoded string used to identify an
// application.
// @exec can have one of these two modifiers: "\%f", which will
// be expanded as the local file name retrieved from the bookmark's
// URI; "\%u", which will be expanded as the bookmark's URI.
// The expansion is done automatically when retrieving the stored
// command line using the g_bookmark_file_get_application_info() function.
// @count is the number of times the application has registered the
// bookmark; if is &lt; 0, the current registration count will be increased
// by one, if is 0, the application with @name will be removed from
// the list of registered applications.
// @stamp is the Unix time of the last registration; if it is -1, the
// current time will be used.
//
// If you try to remove an application by setting its registration count to
// zero, and no bookmark for @uri is found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly,
// in the event that no application @name has registered a bookmark
// for @uri,  %FALSE is returned and error is set to
// %G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.  Otherwise, if no bookmark
// for @uri is found, one is created.
func (x *BookmarkFile) SetAppInfo(UriVar string, NameVar string, ExecVar string, CountVar int, StampVar int32) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileSetAppInfo(x.GoPointer(), UriVar, NameVar, ExecVar, CountVar, StampVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileSetApplicationInfo func(uintptr, string, string, string, int, *DateTime, **Error) bool

// Sets the meta-data of application @name inside the list of
// applications that have registered a bookmark for @uri inside
// @bookmark.
//
// You should rarely use this function; use g_bookmark_file_add_application()
// and g_bookmark_file_remove_application() instead.
//
// @name can be any UTF-8 encoded string used to identify an
// application.
// @exec can have one of these two modifiers: "\%f", which will
// be expanded as the local file name retrieved from the bookmark's
// URI; "\%u", which will be expanded as the bookmark's URI.
// The expansion is done automatically when retrieving the stored
// command line using the g_bookmark_file_get_application_info() function.
// @count is the number of times the application has registered the
// bookmark; if is &lt; 0, the current registration count will be increased
// by one, if is 0, the application with @name will be removed from
// the list of registered applications.
// @stamp is the Unix time of the last registration.
//
// If you try to remove an application by setting its registration count to
// zero, and no bookmark for @uri is found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly,
// in the event that no application @name has registered a bookmark
// for @uri,  %FALSE is returned and error is set to
// %G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.  Otherwise, if no bookmark
// for @uri is found, one is created.
func (x *BookmarkFile) SetApplicationInfo(UriVar string, NameVar string, ExecVar string, CountVar int, StampVar *DateTime) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileSetApplicationInfo(x.GoPointer(), UriVar, NameVar, ExecVar, CountVar, StampVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileSetDescription func(uintptr, string, string)

// Sets @description as the description of the bookmark for @uri.
//
// If @uri is %NULL, the description of @bookmark is set.
//
// If a bookmark for @uri cannot be found then it is created.
func (x *BookmarkFile) SetDescription(UriVar string, DescriptionVar string) {

	xBookmarkFileSetDescription(x.GoPointer(), UriVar, DescriptionVar)

}

var xBookmarkFileSetGroups func(uintptr, string, []string, uint)

// Sets a list of group names for the item with URI @uri.  Each previously
// set group name list is removed.
//
// If @uri cannot be found then an item for it is created.
func (x *BookmarkFile) SetGroups(UriVar string, GroupsVar []string, LengthVar uint) {

	xBookmarkFileSetGroups(x.GoPointer(), UriVar, GroupsVar, LengthVar)

}

var xBookmarkFileSetIcon func(uintptr, string, string, string)

// Sets the icon for the bookmark for @uri. If @href is %NULL, unsets
// the currently set icon. @href can either be a full URL for the icon
// file or the icon name following the Icon Naming specification.
//
// If no bookmark for @uri is found one is created.
func (x *BookmarkFile) SetIcon(UriVar string, HrefVar string, MimeTypeVar string) {

	xBookmarkFileSetIcon(x.GoPointer(), UriVar, HrefVar, MimeTypeVar)

}

var xBookmarkFileSetIsPrivate func(uintptr, string, bool)

// Sets the private flag of the bookmark for @uri.
//
// If a bookmark for @uri cannot be found then it is created.
func (x *BookmarkFile) SetIsPrivate(UriVar string, IsPrivateVar bool) {

	xBookmarkFileSetIsPrivate(x.GoPointer(), UriVar, IsPrivateVar)

}

var xBookmarkFileSetMimeType func(uintptr, string, string)

// Sets @mime_type as the MIME type of the bookmark for @uri.
//
// If a bookmark for @uri cannot be found then it is created.
func (x *BookmarkFile) SetMimeType(UriVar string, MimeTypeVar string) {

	xBookmarkFileSetMimeType(x.GoPointer(), UriVar, MimeTypeVar)

}

var xBookmarkFileSetModified func(uintptr, string, int32)

// Sets the last time the bookmark for @uri was last modified.
//
// If no bookmark for @uri is found then it is created.
//
// The "modified" time should only be set when the bookmark's meta-data
// was actually changed.  Every function of #GBookmarkFile that
// modifies a bookmark also changes the modification time, except for
// g_bookmark_file_set_visited_date_time().
func (x *BookmarkFile) SetModified(UriVar string, ModifiedVar int32) {

	xBookmarkFileSetModified(x.GoPointer(), UriVar, ModifiedVar)

}

var xBookmarkFileSetModifiedDateTime func(uintptr, string, *DateTime)

// Sets the last time the bookmark for @uri was last modified.
//
// If no bookmark for @uri is found then it is created.
//
// The "modified" time should only be set when the bookmark's meta-data
// was actually changed.  Every function of #GBookmarkFile that
// modifies a bookmark also changes the modification time, except for
// g_bookmark_file_set_visited_date_time().
func (x *BookmarkFile) SetModifiedDateTime(UriVar string, ModifiedVar *DateTime) {

	xBookmarkFileSetModifiedDateTime(x.GoPointer(), UriVar, ModifiedVar)

}

var xBookmarkFileSetTitle func(uintptr, string, string)

// Sets @title as the title of the bookmark for @uri inside the
// bookmark file @bookmark.
//
// If @uri is %NULL, the title of @bookmark is set.
//
// If a bookmark for @uri cannot be found then it is created.
func (x *BookmarkFile) SetTitle(UriVar string, TitleVar string) {

	xBookmarkFileSetTitle(x.GoPointer(), UriVar, TitleVar)

}

var xBookmarkFileSetVisited func(uintptr, string, int32)

// Sets the time the bookmark for @uri was last visited.
//
// If no bookmark for @uri is found then it is created.
//
// The "visited" time should only be set if the bookmark was launched,
// either using the command line retrieved by g_bookmark_file_get_application_info()
// or by the default application for the bookmark's MIME type, retrieved
// using g_bookmark_file_get_mime_type().  Changing the "visited" time
// does not affect the "modified" time.
func (x *BookmarkFile) SetVisited(UriVar string, VisitedVar int32) {

	xBookmarkFileSetVisited(x.GoPointer(), UriVar, VisitedVar)

}

var xBookmarkFileSetVisitedDateTime func(uintptr, string, *DateTime)

// Sets the time the bookmark for @uri was last visited.
//
// If no bookmark for @uri is found then it is created.
//
// The "visited" time should only be set if the bookmark was launched,
// either using the command line retrieved by g_bookmark_file_get_application_info()
// or by the default application for the bookmark's MIME type, retrieved
// using g_bookmark_file_get_mime_type().  Changing the "visited" time
// does not affect the "modified" time.
func (x *BookmarkFile) SetVisitedDateTime(UriVar string, VisitedVar *DateTime) {

	xBookmarkFileSetVisitedDateTime(x.GoPointer(), UriVar, VisitedVar)

}

var xBookmarkFileToData func(uintptr, uint, **Error) []byte

// This function outputs @bookmark as a string.
func (x *BookmarkFile) ToData(LengthVar uint) ([]byte, error) {
	var cerr *Error

	cret := xBookmarkFileToData(x.GoPointer(), LengthVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xBookmarkFileToFile func(uintptr, string, **Error) bool

// This function outputs @bookmark into a file.  The write process is
// guaranteed to be atomic by using g_file_set_contents() internally.
func (x *BookmarkFile) ToFile(FilenameVar string) (bool, error) {
	var cerr *Error

	cret := xBookmarkFileToFile(x.GoPointer(), FilenameVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

// Error codes returned by bookmark file parsing.
type BookmarkFileError int

const (

	// URI was ill-formed
	GBookmarkFileErrorInvalidUriValue BookmarkFileError = 0
	// a requested field was not found
	GBookmarkFileErrorInvalidValueValue BookmarkFileError = 1
	// a requested application did
	//     not register a bookmark
	GBookmarkFileErrorAppNotRegisteredValue BookmarkFileError = 2
	// a requested URI was not found
	GBookmarkFileErrorUriNotFoundValue BookmarkFileError = 3
	// document was ill formed
	GBookmarkFileErrorReadValue BookmarkFileError = 4
	// the text being parsed was
	//     in an unknown encoding
	GBookmarkFileErrorUnknownEncodingValue BookmarkFileError = 5
	// an error occurred while writing
	GBookmarkFileErrorWriteValue BookmarkFileError = 6
	// requested file was not found
	GBookmarkFileErrorFileNotFoundValue BookmarkFileError = 7
)

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xBookmarkFileAddApplication, lib, "g_bookmark_file_add_application")
	core.PuregoSafeRegister(&xBookmarkFileAddGroup, lib, "g_bookmark_file_add_group")
	core.PuregoSafeRegister(&xBookmarkFileFree, lib, "g_bookmark_file_free")
	core.PuregoSafeRegister(&xBookmarkFileGetAdded, lib, "g_bookmark_file_get_added")
	core.PuregoSafeRegister(&xBookmarkFileGetAddedDateTime, lib, "g_bookmark_file_get_added_date_time")
	core.PuregoSafeRegister(&xBookmarkFileGetAppInfo, lib, "g_bookmark_file_get_app_info")
	core.PuregoSafeRegister(&xBookmarkFileGetApplicationInfo, lib, "g_bookmark_file_get_application_info")
	core.PuregoSafeRegister(&xBookmarkFileGetApplications, lib, "g_bookmark_file_get_applications")
	core.PuregoSafeRegister(&xBookmarkFileGetDescription, lib, "g_bookmark_file_get_description")
	core.PuregoSafeRegister(&xBookmarkFileGetGroups, lib, "g_bookmark_file_get_groups")
	core.PuregoSafeRegister(&xBookmarkFileGetIcon, lib, "g_bookmark_file_get_icon")
	core.PuregoSafeRegister(&xBookmarkFileGetIsPrivate, lib, "g_bookmark_file_get_is_private")
	core.PuregoSafeRegister(&xBookmarkFileGetMimeType, lib, "g_bookmark_file_get_mime_type")
	core.PuregoSafeRegister(&xBookmarkFileGetModified, lib, "g_bookmark_file_get_modified")
	core.PuregoSafeRegister(&xBookmarkFileGetModifiedDateTime, lib, "g_bookmark_file_get_modified_date_time")
	core.PuregoSafeRegister(&xBookmarkFileGetSize, lib, "g_bookmark_file_get_size")
	core.PuregoSafeRegister(&xBookmarkFileGetTitle, lib, "g_bookmark_file_get_title")
	core.PuregoSafeRegister(&xBookmarkFileGetUris, lib, "g_bookmark_file_get_uris")
	core.PuregoSafeRegister(&xBookmarkFileGetVisited, lib, "g_bookmark_file_get_visited")
	core.PuregoSafeRegister(&xBookmarkFileGetVisitedDateTime, lib, "g_bookmark_file_get_visited_date_time")
	core.PuregoSafeRegister(&xBookmarkFileHasApplication, lib, "g_bookmark_file_has_application")
	core.PuregoSafeRegister(&xBookmarkFileHasGroup, lib, "g_bookmark_file_has_group")
	core.PuregoSafeRegister(&xBookmarkFileHasItem, lib, "g_bookmark_file_has_item")
	core.PuregoSafeRegister(&xBookmarkFileLoadFromData, lib, "g_bookmark_file_load_from_data")
	core.PuregoSafeRegister(&xBookmarkFileLoadFromDataDirs, lib, "g_bookmark_file_load_from_data_dirs")
	core.PuregoSafeRegister(&xBookmarkFileLoadFromFile, lib, "g_bookmark_file_load_from_file")
	core.PuregoSafeRegister(&xBookmarkFileMoveItem, lib, "g_bookmark_file_move_item")
	core.PuregoSafeRegister(&xBookmarkFileRemoveApplication, lib, "g_bookmark_file_remove_application")
	core.PuregoSafeRegister(&xBookmarkFileRemoveGroup, lib, "g_bookmark_file_remove_group")
	core.PuregoSafeRegister(&xBookmarkFileRemoveItem, lib, "g_bookmark_file_remove_item")
	core.PuregoSafeRegister(&xBookmarkFileSetAdded, lib, "g_bookmark_file_set_added")
	core.PuregoSafeRegister(&xBookmarkFileSetAddedDateTime, lib, "g_bookmark_file_set_added_date_time")
	core.PuregoSafeRegister(&xBookmarkFileSetAppInfo, lib, "g_bookmark_file_set_app_info")
	core.PuregoSafeRegister(&xBookmarkFileSetApplicationInfo, lib, "g_bookmark_file_set_application_info")
	core.PuregoSafeRegister(&xBookmarkFileSetDescription, lib, "g_bookmark_file_set_description")
	core.PuregoSafeRegister(&xBookmarkFileSetGroups, lib, "g_bookmark_file_set_groups")
	core.PuregoSafeRegister(&xBookmarkFileSetIcon, lib, "g_bookmark_file_set_icon")
	core.PuregoSafeRegister(&xBookmarkFileSetIsPrivate, lib, "g_bookmark_file_set_is_private")
	core.PuregoSafeRegister(&xBookmarkFileSetMimeType, lib, "g_bookmark_file_set_mime_type")
	core.PuregoSafeRegister(&xBookmarkFileSetModified, lib, "g_bookmark_file_set_modified")
	core.PuregoSafeRegister(&xBookmarkFileSetModifiedDateTime, lib, "g_bookmark_file_set_modified_date_time")
	core.PuregoSafeRegister(&xBookmarkFileSetTitle, lib, "g_bookmark_file_set_title")
	core.PuregoSafeRegister(&xBookmarkFileSetVisited, lib, "g_bookmark_file_set_visited")
	core.PuregoSafeRegister(&xBookmarkFileSetVisitedDateTime, lib, "g_bookmark_file_set_visited_date_time")
	core.PuregoSafeRegister(&xBookmarkFileToData, lib, "g_bookmark_file_to_data")
	core.PuregoSafeRegister(&xBookmarkFileToFile, lib, "g_bookmark_file_to_file")

}
