// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// Specifies the type of the function passed to g_regex_replace_eval().
// It is called for each occurrence of the pattern in the string passed
// to g_regex_replace_eval(), and it should append the replacement to
// @result.
type RegexEvalCallback func(*MatchInfo, *String, uintptr) bool

// A GMatchInfo is an opaque struct used to return information about
// matches.
type MatchInfo struct {
}

func (x *MatchInfo) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xMatchInfoExpandReferences func(uintptr, string, **Error) string

// Returns a new string containing the text in @string_to_expand with
// references and escape sequences expanded. References refer to the last
// match done with @string against @regex and have the same syntax used by
// g_regex_replace().
//
// The @string_to_expand must be UTF-8 encoded even if %G_REGEX_RAW was
// passed to g_regex_new().
//
// The backreferences are extracted from the string passed to the match
// function, so you cannot call this function after freeing the string.
//
// @match_info may be %NULL in which case @string_to_expand must not
// contain references. For instance "foo\n" does not refer to an actual
// pattern and '\n' merely will be replaced with \n character,
// while to expand "\0" (whole match) one needs the result of a match.
// Use g_regex_check_replacement() to find out whether @string_to_expand
// contains references.
func (x *MatchInfo) ExpandReferences(StringToExpandVar string) (string, error) {
	var cerr *Error

	cret := xMatchInfoExpandReferences(x.GoPointer(), StringToExpandVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xMatchInfoFetch func(uintptr, int) string

// Retrieves the text matching the @match_num'th capturing
// parentheses. 0 is the full text of the match, 1 is the first paren
// set, 2 the second, and so on.
//
// If @match_num is a valid sub pattern but it didn't match anything
// (e.g. sub pattern 1, matching "b" against "(a)?b") then an empty
// string is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved
// string is not that of a set of parentheses but that of a matched
// substring. Substrings are matched in reverse order of length, so
// 0 is the longest match.
//
// The string is fetched from the string passed to the match function,
// so you cannot call this function after freeing the string.
func (x *MatchInfo) Fetch(MatchNumVar int) string {

	cret := xMatchInfoFetch(x.GoPointer(), MatchNumVar)
	return cret
}

var xMatchInfoFetchAll func(uintptr) []string

// Bundles up pointers to each of the matching substrings from a match
// and stores them in an array of gchar pointers. The first element in
// the returned array is the match number 0, i.e. the entire matched
// text.
//
// If a sub pattern didn't match anything (e.g. sub pattern 1, matching
// "b" against "(a)?b") then an empty string is inserted.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved
// strings are not that matched by sets of parentheses but that of the
// matched substring. Substrings are matched in reverse order of length,
// so the first one is the longest match.
//
// The strings are fetched from the string passed to the match function,
// so you cannot call this function after freeing the string.
func (x *MatchInfo) FetchAll() []string {

	cret := xMatchInfoFetchAll(x.GoPointer())
	return cret
}

var xMatchInfoFetchNamed func(uintptr, string) string

// Retrieves the text matching the capturing parentheses named @name.
//
// If @name is a valid sub pattern name but it didn't match anything
// (e.g. sub pattern "X", matching "b" against "(?P&lt;X&gt;a)?b")
// then an empty string is returned.
//
// The string is fetched from the string passed to the match function,
// so you cannot call this function after freeing the string.
func (x *MatchInfo) FetchNamed(NameVar string) string {

	cret := xMatchInfoFetchNamed(x.GoPointer(), NameVar)
	return cret
}

var xMatchInfoFetchNamedPos func(uintptr, string, int, int) bool

// Retrieves the position in bytes of the capturing parentheses named @name.
//
// If @name is a valid sub pattern name but it didn't match anything
// (e.g. sub pattern "X", matching "b" against "(?P&lt;X&gt;a)?b")
// then @start_pos and @end_pos are set to -1 and %TRUE is returned.
func (x *MatchInfo) FetchNamedPos(NameVar string, StartPosVar int, EndPosVar int) bool {

	cret := xMatchInfoFetchNamedPos(x.GoPointer(), NameVar, StartPosVar, EndPosVar)
	return cret
}

var xMatchInfoFetchPos func(uintptr, int, int, int) bool

// Retrieves the position in bytes of the @match_num'th capturing
// parentheses. 0 is the full text of the match, 1 is the first
// paren set, 2 the second, and so on.
//
// If @match_num is a valid sub pattern but it didn't match anything
// (e.g. sub pattern 1, matching "b" against "(a)?b") then @start_pos
// and @end_pos are set to -1 and %TRUE is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved
// position is not that of a set of parentheses but that of a matched
// substring. Substrings are matched in reverse order of length, so
// 0 is the longest match.
func (x *MatchInfo) FetchPos(MatchNumVar int, StartPosVar int, EndPosVar int) bool {

	cret := xMatchInfoFetchPos(x.GoPointer(), MatchNumVar, StartPosVar, EndPosVar)
	return cret
}

var xMatchInfoFree func(uintptr)

// If @match_info is not %NULL, calls g_match_info_unref(); otherwise does
// nothing.
func (x *MatchInfo) Free() {

	xMatchInfoFree(x.GoPointer())

}

var xMatchInfoGetMatchCount func(uintptr) int

// Retrieves the number of matched substrings (including substring 0,
// that is the whole matched text), so 1 is returned if the pattern
// has no substrings in it and 0 is returned if the match failed.
//
// If the last match was obtained using the DFA algorithm, that is
// using g_regex_match_all() or g_regex_match_all_full(), the retrieved
// count is not that of the number of capturing parentheses but that of
// the number of matched substrings.
func (x *MatchInfo) GetMatchCount() int {

	cret := xMatchInfoGetMatchCount(x.GoPointer())
	return cret
}

var xMatchInfoGetRegex func(uintptr) *Regex

// Returns #GRegex object used in @match_info. It belongs to Glib
// and must not be freed. Use g_regex_ref() if you need to keep it
// after you free @match_info object.
func (x *MatchInfo) GetRegex() *Regex {

	cret := xMatchInfoGetRegex(x.GoPointer())
	return cret
}

var xMatchInfoGetString func(uintptr) string

// Returns the string searched with @match_info. This is the
// string passed to g_regex_match() or g_regex_replace() so
// you may not free it before calling this function.
func (x *MatchInfo) GetString() string {

	cret := xMatchInfoGetString(x.GoPointer())
	return cret
}

var xMatchInfoIsPartialMatch func(uintptr) bool

// Usually if the string passed to g_regex_match*() matches as far as
// it goes, but is too short to match the entire pattern, %FALSE is
// returned. There are circumstances where it might be helpful to
// distinguish this case from other cases in which there is no match.
//
// Consider, for example, an application where a human is required to
// type in data for a field with specific formatting requirements. An
// example might be a date in the form ddmmmyy, defined by the pattern
// "^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$".
// If the application sees the userâ€™s keystrokes one by one, and can
// check that what has been typed so far is potentially valid, it is
// able to raise an error as soon as a mistake is made.
//
// GRegex supports the concept of partial matching by means of the
// %G_REGEX_MATCH_PARTIAL_SOFT and %G_REGEX_MATCH_PARTIAL_HARD flags.
// When they are used, the return code for
// g_regex_match() or g_regex_match_full() is, as usual, %TRUE
// for a complete match, %FALSE otherwise. But, when these functions
// return %FALSE, you can check if the match was partial calling
// g_match_info_is_partial_match().
//
// The difference between %G_REGEX_MATCH_PARTIAL_SOFT and
// %G_REGEX_MATCH_PARTIAL_HARD is that when a partial match is encountered
// with %G_REGEX_MATCH_PARTIAL_SOFT, matching continues to search for a
// possible complete match, while with %G_REGEX_MATCH_PARTIAL_HARD matching
// stops at the partial match.
// When both %G_REGEX_MATCH_PARTIAL_SOFT and %G_REGEX_MATCH_PARTIAL_HARD
// are set, the latter takes precedence.
//
// There were formerly some restrictions on the pattern for partial matching.
// The restrictions no longer apply.
//
// See pcrepartial(3) for more information on partial matching.
func (x *MatchInfo) IsPartialMatch() bool {

	cret := xMatchInfoIsPartialMatch(x.GoPointer())
	return cret
}

var xMatchInfoMatches func(uintptr) bool

// Returns whether the previous match operation succeeded.
func (x *MatchInfo) Matches() bool {

	cret := xMatchInfoMatches(x.GoPointer())
	return cret
}

var xMatchInfoNext func(uintptr) bool

// Scans for the next match using the same parameters of the previous
// call to g_regex_match_full() or g_regex_match() that returned
// @match_info.
//
// The match is done on the string passed to the match function, so you
// cannot free it before calling this function.
func (x *MatchInfo) Next() (bool, error) {
	var cerr *Error

	cret := xMatchInfoNext(x.GoPointer())
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xMatchInfoRef func(uintptr) *MatchInfo

// Increases reference count of @match_info by 1.
func (x *MatchInfo) Ref() *MatchInfo {

	cret := xMatchInfoRef(x.GoPointer())
	return cret
}

var xMatchInfoUnref func(uintptr)

// Decreases reference count of @match_info by 1. When reference count drops
// to zero, it frees all the memory associated with the match_info structure.
func (x *MatchInfo) Unref() {

	xMatchInfoUnref(x.GoPointer())

}

// The g_regex_*() functions implement regular
// expression pattern matching using syntax and semantics similar to
// Perl regular expression.
//
// Some functions accept a @start_position argument, setting it differs
// from just passing over a shortened string and setting %G_REGEX_MATCH_NOTBOL
// in the case of a pattern that begins with any kind of lookbehind assertion.
// For example, consider the pattern "\Biss\B" which finds occurrences of "iss"
// in the middle of words. ("\B" matches only if the current position in the
// subject is not a word boundary.) When applied to the string "Mississipi"
// from the fourth byte, namely "issipi", it does not match, because "\B" is
// always false at the start of the subject, which is deemed to be a word
// boundary. However, if the entire string is passed , but with
// @start_position set to 4, it finds the second occurrence of "iss" because
// it is able to look behind the starting point to discover that it is
// preceded by a letter.
//
// Note that, unless you set the %G_REGEX_RAW flag, all the strings passed
// to these functions must be encoded in UTF-8. The lengths and the positions
// inside the strings are in bytes and not in characters, so, for instance,
// "\xc3\xa0" (i.e. "Ã ") is two bytes long but it is treated as a
// single character. If you set %G_REGEX_RAW the strings can be non-valid
// UTF-8 strings and a byte is treated as a character, so "\xc3\xa0" is two
// bytes and two characters long.
//
// When matching a pattern, "\n" matches only against a "\n" character in
// the string, and "\r" matches only a "\r" character. To match any newline
// sequence use "\R". This particular group matches either the two-character
// sequence CR + LF ("\r\n"), or one of the single characters LF (linefeed,
// U+000A, "\n"), VT vertical tab, U+000B, "\v"), FF (formfeed, U+000C, "\f"),
// CR (carriage return, U+000D, "\r"), NEL (next line, U+0085), LS (line
// separator, U+2028), or PS (paragraph separator, U+2029).
//
// The behaviour of the dot, circumflex, and dollar metacharacters are
// affected by newline characters, the default is to recognize any newline
// character (the same characters recognized by "\R"). This can be changed
// with %G_REGEX_NEWLINE_CR, %G_REGEX_NEWLINE_LF and %G_REGEX_NEWLINE_CRLF
// compile options, and with %G_REGEX_MATCH_NEWLINE_ANY,
// %G_REGEX_MATCH_NEWLINE_CR, %G_REGEX_MATCH_NEWLINE_LF and
// %G_REGEX_MATCH_NEWLINE_CRLF match options. These settings are also
// relevant when compiling a pattern if %G_REGEX_EXTENDED is set, and an
// unescaped "#" outside a character class is encountered. This indicates
// a comment that lasts until after the next newline.
//
// When setting the %G_REGEX_JAVASCRIPT_COMPAT flag, pattern syntax and pattern
// matching is changed to be compatible with the way that regular expressions
// work in JavaScript. More precisely, a lonely ']' character in the pattern
// is a syntax error; the '\x' escape only allows 0 to 2 hexadecimal digits, and
// you must use the '\u' escape sequence with 4 hex digits to specify a unicode
// codepoint instead of '\x' or 'x{....}'. If '\x' or '\u' are not followed by
// the specified number of hex digits, they match 'x' and 'u' literally; also
// '\U' always matches 'U' instead of being an error in the pattern. Finally,
// pattern matching is modified so that back references to an unset subpattern
// group produces a match with the empty string instead of an error. See
// pcreapi(3) for more information.
//
// Creating and manipulating the same #GRegex structure from different
// threads is not a problem as #GRegex does not modify its internal
// state between creation and destruction, on the other hand #GMatchInfo
// is not threadsafe.
//
// The regular expressions low-level functionalities are obtained through
// the excellent
// [PCRE](http://www.pcre.org/)
// library written by Philip Hazel.
type Regex struct {
}

func (x *Regex) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewRegex func(string, RegexCompileFlags, RegexMatchFlags, **Error) *Regex

// Compiles the regular expression to an internal form, and does
// the initial setup of the #GRegex structure.
func NewRegex(PatternVar string, CompileOptionsVar RegexCompileFlags, MatchOptionsVar RegexMatchFlags) (*Regex, error) {
	var cerr *Error

	cret := xNewRegex(PatternVar, CompileOptionsVar, MatchOptionsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xRegexGetCaptureCount func(uintptr) int

// Returns the number of capturing subpatterns in the pattern.
func (x *Regex) GetCaptureCount() int {

	cret := xRegexGetCaptureCount(x.GoPointer())
	return cret
}

var xRegexGetCompileFlags func(uintptr) RegexCompileFlags

// Returns the compile options that @regex was created with.
//
// Depending on the version of PCRE that is used, this may or may not
// include flags set by option expressions such as `(?i)` found at the
// top-level within the compiled pattern.
func (x *Regex) GetCompileFlags() RegexCompileFlags {

	cret := xRegexGetCompileFlags(x.GoPointer())
	return cret
}

var xRegexGetHasCrOrLf func(uintptr) bool

// Checks whether the pattern contains explicit CR or LF references.
func (x *Regex) GetHasCrOrLf() bool {

	cret := xRegexGetHasCrOrLf(x.GoPointer())
	return cret
}

var xRegexGetMatchFlags func(uintptr) RegexMatchFlags

// Returns the match options that @regex was created with.
func (x *Regex) GetMatchFlags() RegexMatchFlags {

	cret := xRegexGetMatchFlags(x.GoPointer())
	return cret
}

var xRegexGetMaxBackref func(uintptr) int

// Returns the number of the highest back reference
// in the pattern, or 0 if the pattern does not contain
// back references.
func (x *Regex) GetMaxBackref() int {

	cret := xRegexGetMaxBackref(x.GoPointer())
	return cret
}

var xRegexGetMaxLookbehind func(uintptr) int

// Gets the number of characters in the longest lookbehind assertion in the
// pattern. This information is useful when doing multi-segment matching using
// the partial matching facilities.
func (x *Regex) GetMaxLookbehind() int {

	cret := xRegexGetMaxLookbehind(x.GoPointer())
	return cret
}

var xRegexGetPattern func(uintptr) string

// Gets the pattern string associated with @regex, i.e. a copy of
// the string passed to g_regex_new().
func (x *Regex) GetPattern() string {

	cret := xRegexGetPattern(x.GoPointer())
	return cret
}

var xRegexGetStringNumber func(uintptr, string) int

// Retrieves the number of the subexpression named @name.
func (x *Regex) GetStringNumber(NameVar string) int {

	cret := xRegexGetStringNumber(x.GoPointer(), NameVar)
	return cret
}

var xRegexMatch func(uintptr, string, RegexMatchFlags, **MatchInfo) bool

// Scans for a match in @string for the pattern in @regex.
// The @match_options are combined with the match options specified
// when the @regex structure was created, letting you have more
// flexibility in reusing #GRegex structures.
//
// Unless %G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A #GMatchInfo structure, used to get information on the match,
// is stored in @match_info if not %NULL. Note that if @match_info
// is not %NULL then it is created even if the function returns %FALSE,
// i.e. you must free it regardless if regular expression actually matched.
//
// To retrieve all the non-overlapping matches of the pattern in
// string you can use g_match_info_next().
//
// |[&lt;!-- language="C" --&gt;
// static void
// print_uppercase_words (const gchar *string)
//
//	{
//	  // Print all uppercase-only words.
//	  GRegex *regex;
//	  GMatchInfo *match_info;
//
//	  regex = g_regex_new ("[A-Z]+", 0, 0, NULL);
//	  g_regex_match (regex, string, 0, &amp;match_info);
//	  while (g_match_info_matches (match_info))
//	    {
//	      gchar *word = g_match_info_fetch (match_info, 0);
//	      g_print ("Found: %s\n", word);
//	      g_free (word);
//	      g_match_info_next (match_info, NULL);
//	    }
//	  g_match_info_free (match_info);
//	  g_regex_unref (regex);
//	}
//
// ]|
//
// @string is not copied and is used in #GMatchInfo internally. If
// you use any #GMatchInfo method (except g_match_info_free()) after
// freeing or modifying @string then the behaviour is undefined.
func (x *Regex) Match(StringVar string, MatchOptionsVar RegexMatchFlags, MatchInfoVar **MatchInfo) bool {

	cret := xRegexMatch(x.GoPointer(), StringVar, MatchOptionsVar, MatchInfoVar)
	return cret
}

var xRegexMatchAll func(uintptr, string, RegexMatchFlags, **MatchInfo) bool

// Using the standard algorithm for regular expression matching only
// the longest match in the string is retrieved. This function uses
// a different algorithm so it can retrieve all the possible matches.
// For more documentation see g_regex_match_all_full().
//
// A #GMatchInfo structure, used to get information on the match, is
// stored in @match_info if not %NULL. Note that if @match_info is
// not %NULL then it is created even if the function returns %FALSE,
// i.e. you must free it regardless if regular expression actually
// matched.
//
// @string is not copied and is used in #GMatchInfo internally. If
// you use any #GMatchInfo method (except g_match_info_free()) after
// freeing or modifying @string then the behaviour is undefined.
func (x *Regex) MatchAll(StringVar string, MatchOptionsVar RegexMatchFlags, MatchInfoVar **MatchInfo) bool {

	cret := xRegexMatchAll(x.GoPointer(), StringVar, MatchOptionsVar, MatchInfoVar)
	return cret
}

var xRegexMatchAllFull func(uintptr, []string, int, int, RegexMatchFlags, **MatchInfo, **Error) bool

// Using the standard algorithm for regular expression matching only
// the longest match in the @string is retrieved, it is not possible
// to obtain all the available matches. For instance matching
// "&lt;a&gt; &lt;b&gt; &lt;c&gt;" against the pattern "&lt;.*&gt;"
// you get "&lt;a&gt; &lt;b&gt; &lt;c&gt;".
//
// This function uses a different algorithm (called DFA, i.e. deterministic
// finite automaton), so it can retrieve all the possible matches, all
// starting at the same point in the string. For instance matching
// "&lt;a&gt; &lt;b&gt; &lt;c&gt;" against the pattern "&lt;.*&gt;;"
// you would obtain three matches: "&lt;a&gt; &lt;b&gt; &lt;c&gt;",
// "&lt;a&gt; &lt;b&gt;" and "&lt;a&gt;".
//
// The number of matched strings is retrieved using
// g_match_info_get_match_count(). To obtain the matched strings and
// their position you can use, respectively, g_match_info_fetch() and
// g_match_info_fetch_pos(). Note that the strings are returned in
// reverse order of length; that is, the longest matching string is
// given first.
//
// Note that the DFA algorithm is slower than the standard one and it
// is not able to capture substrings, so backreferences do not work.
//
// Setting @start_position differs from just passing over a shortened
// string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern
// that begins with any kind of lookbehind assertion, such as "\b".
//
// Unless %G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A #GMatchInfo structure, used to get information on the match, is
// stored in @match_info if not %NULL. Note that if @match_info is
// not %NULL then it is created even if the function returns %FALSE,
// i.e. you must free it regardless if regular expression actually
// matched.
//
// @string is not copied and is used in #GMatchInfo internally. If
// you use any #GMatchInfo method (except g_match_info_free()) after
// freeing or modifying @string then the behaviour is undefined.
func (x *Regex) MatchAllFull(StringVar []string, StringLenVar int, StartPositionVar int, MatchOptionsVar RegexMatchFlags, MatchInfoVar **MatchInfo) (bool, error) {
	var cerr *Error

	cret := xRegexMatchAllFull(x.GoPointer(), StringVar, StringLenVar, StartPositionVar, MatchOptionsVar, MatchInfoVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xRegexMatchFull func(uintptr, []string, int, int, RegexMatchFlags, **MatchInfo, **Error) bool

// Scans for a match in @string for the pattern in @regex.
// The @match_options are combined with the match options specified
// when the @regex structure was created, letting you have more
// flexibility in reusing #GRegex structures.
//
// Setting @start_position differs from just passing over a shortened
// string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern
// that begins with any kind of lookbehind assertion, such as "\b".
//
// Unless %G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
//
// A #GMatchInfo structure, used to get information on the match, is
// stored in @match_info if not %NULL. Note that if @match_info is
// not %NULL then it is created even if the function returns %FALSE,
// i.e. you must free it regardless if regular expression actually
// matched.
//
// @string is not copied and is used in #GMatchInfo internally. If
// you use any #GMatchInfo method (except g_match_info_free()) after
// freeing or modifying @string then the behaviour is undefined.
//
// To retrieve all the non-overlapping matches of the pattern in
// string you can use g_match_info_next().
//
// |[&lt;!-- language="C" --&gt;
// static void
// print_uppercase_words (const gchar *string)
//
//	{
//	  // Print all uppercase-only words.
//	  GRegex *regex;
//	  GMatchInfo *match_info;
//	  GError *error = NULL;
//
//	  regex = g_regex_new ("[A-Z]+", 0, 0, NULL);
//	  g_regex_match_full (regex, string, -1, 0, 0, &amp;match_info, &amp;error);
//	  while (g_match_info_matches (match_info))
//	    {
//	      gchar *word = g_match_info_fetch (match_info, 0);
//	      g_print ("Found: %s\n", word);
//	      g_free (word);
//	      g_match_info_next (match_info, &amp;error);
//	    }
//	  g_match_info_free (match_info);
//	  g_regex_unref (regex);
//	  if (error != NULL)
//	    {
//	      g_printerr ("Error while matching: %s\n", error-&gt;message);
//	      g_error_free (error);
//	    }
//	}
//
// ]|
func (x *Regex) MatchFull(StringVar []string, StringLenVar int, StartPositionVar int, MatchOptionsVar RegexMatchFlags, MatchInfoVar **MatchInfo) (bool, error) {
	var cerr *Error

	cret := xRegexMatchFull(x.GoPointer(), StringVar, StringLenVar, StartPositionVar, MatchOptionsVar, MatchInfoVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xRegexRef func(uintptr) *Regex

// Increases reference count of @regex by 1.
func (x *Regex) Ref() *Regex {

	cret := xRegexRef(x.GoPointer())
	return cret
}

var xRegexReplace func(uintptr, []string, int, int, string, RegexMatchFlags, **Error) string

// Replaces all occurrences of the pattern in @regex with the
// replacement text. Backreferences of the form '\number' or
// '\g&lt;number&gt;' in the replacement text are interpolated by the
// number-th captured subexpression of the match, '\g&lt;name&gt;' refers
// to the captured subexpression with the given name. '\0' refers
// to the complete match, but '\0' followed by a number is the octal
// representation of a character. To include a literal '\' in the
// replacement, write '\\\\'.
//
// There are also escapes that changes the case of the following text:
//
// - \l: Convert to lower case the next character
// - \u: Convert to upper case the next character
// - \L: Convert to lower case till \E
// - \U: Convert to upper case till \E
// - \E: End case modification
//
// If you do not need to use backreferences use g_regex_replace_literal().
//
// The @replacement string must be UTF-8 encoded even if %G_REGEX_RAW was
// passed to g_regex_new(). If you want to use not UTF-8 encoded strings
// you can use g_regex_replace_literal().
//
// Setting @start_position differs from just passing over a shortened
// string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern that
// begins with any kind of lookbehind assertion, such as "\b".
func (x *Regex) Replace(StringVar []string, StringLenVar int, StartPositionVar int, ReplacementVar string, MatchOptionsVar RegexMatchFlags) (string, error) {
	var cerr *Error

	cret := xRegexReplace(x.GoPointer(), StringVar, StringLenVar, StartPositionVar, ReplacementVar, MatchOptionsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xRegexReplaceEval func(uintptr, []string, int, int, RegexMatchFlags, uintptr, uintptr, **Error) string

// Replaces occurrences of the pattern in regex with the output of
// @eval for that occurrence.
//
// Setting @start_position differs from just passing over a shortened
// string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern
// that begins with any kind of lookbehind assertion, such as "\b".
//
// The following example uses g_regex_replace_eval() to replace multiple
// strings at once:
// |[&lt;!-- language="C" --&gt;
// static gboolean
// eval_cb (const GMatchInfo *info,
//
//	GString          *res,
//	gpointer          data)
//
//	{
//	  gchar *match;
//	  gchar *r;
//
//	   match = g_match_info_fetch (info, 0);
//	   r = g_hash_table_lookup ((GHashTable *)data, match);
//	   g_string_append (res, r);
//	   g_free (match);
//
//	   return FALSE;
//	}
//
// ...
//
// GRegex *reg;
// GHashTable *h;
// gchar *res;
//
// h = g_hash_table_new (g_str_hash, g_str_equal);
//
// g_hash_table_insert (h, "1", "ONE");
// g_hash_table_insert (h, "2", "TWO");
// g_hash_table_insert (h, "3", "THREE");
// g_hash_table_insert (h, "4", "FOUR");
//
// reg = g_regex_new ("1|2|3|4", 0, 0, NULL);
// res = g_regex_replace_eval (reg, text, -1, 0, 0, eval_cb, h, NULL);
// g_hash_table_destroy (h);
//
// ...
// ]|
func (x *Regex) ReplaceEval(StringVar []string, StringLenVar int, StartPositionVar int, MatchOptionsVar RegexMatchFlags, EvalVar *RegexEvalCallback, UserDataVar uintptr) (string, error) {
	var cerr *Error

	cret := xRegexReplaceEval(x.GoPointer(), StringVar, StringLenVar, StartPositionVar, MatchOptionsVar, NewCallback(EvalVar), UserDataVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xRegexReplaceLiteral func(uintptr, []string, int, int, string, RegexMatchFlags, **Error) string

// Replaces all occurrences of the pattern in @regex with the
// replacement text. @replacement is replaced literally, to
// include backreferences use g_regex_replace().
//
// Setting @start_position differs from just passing over a
// shortened string and setting %G_REGEX_MATCH_NOTBOL in the
// case of a pattern that begins with any kind of lookbehind
// assertion, such as "\b".
func (x *Regex) ReplaceLiteral(StringVar []string, StringLenVar int, StartPositionVar int, ReplacementVar string, MatchOptionsVar RegexMatchFlags) (string, error) {
	var cerr *Error

	cret := xRegexReplaceLiteral(x.GoPointer(), StringVar, StringLenVar, StartPositionVar, ReplacementVar, MatchOptionsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xRegexSplit func(uintptr, string, RegexMatchFlags) []string

// Breaks the string on the pattern, and returns an array of the tokens.
// If the pattern contains capturing parentheses, then the text for each
// of the substrings will also be returned. If the pattern does not match
// anywhere in the string, then the whole string is returned as the first
// token.
//
// As a special case, the result of splitting the empty string "" is an
// empty vector, not a vector containing a single string. The reason for
// this special case is that being able to represent an empty vector is
// typically more useful than consistent handling of empty elements. If
// you do need to represent empty elements, you'll need to check for the
// empty string before calling this function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters.
// For example splitting "ab c" using as a separator "\s*", you will get
// "a", "b" and "c".
func (x *Regex) Split(StringVar string, MatchOptionsVar RegexMatchFlags) []string {

	cret := xRegexSplit(x.GoPointer(), StringVar, MatchOptionsVar)
	return cret
}

var xRegexSplitFull func(uintptr, []string, int, int, RegexMatchFlags, int, **Error) []string

// Breaks the string on the pattern, and returns an array of the tokens.
// If the pattern contains capturing parentheses, then the text for each
// of the substrings will also be returned. If the pattern does not match
// anywhere in the string, then the whole string is returned as the first
// token.
//
// As a special case, the result of splitting the empty string "" is an
// empty vector, not a vector containing a single string. The reason for
// this special case is that being able to represent an empty vector is
// typically more useful than consistent handling of empty elements. If
// you do need to represent empty elements, you'll need to check for the
// empty string before calling this function.
//
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters.
// For example splitting "ab c" using as a separator "\s*", you will get
// "a", "b" and "c".
//
// Setting @start_position differs from just passing over a shortened
// string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern
// that begins with any kind of lookbehind assertion, such as "\b".
func (x *Regex) SplitFull(StringVar []string, StringLenVar int, StartPositionVar int, MatchOptionsVar RegexMatchFlags, MaxTokensVar int) ([]string, error) {
	var cerr *Error

	cret := xRegexSplitFull(x.GoPointer(), StringVar, StringLenVar, StartPositionVar, MatchOptionsVar, MaxTokensVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xRegexUnref func(uintptr)

// Decreases reference count of @regex by 1. When reference count drops
// to zero, it frees all the memory associated with the regex structure.
func (x *Regex) Unref() {

	xRegexUnref(x.GoPointer())

}

// Flags specifying compile-time options.
type RegexCompileFlags int

const (

	// Letters in the pattern match both upper- and
	//     lowercase letters. This option can be changed within a pattern
	//     by a "(?i)" option setting.
	GRegexCaselessValue RegexCompileFlags = 1
	// By default, GRegex treats the strings as consisting
	//     of a single line of characters (even if it actually contains
	//     newlines). The "start of line" metacharacter ("^") matches only
	//     at the start of the string, while the "end of line" metacharacter
	//     ("$") matches only at the end of the string, or before a terminating
	//     newline (unless %G_REGEX_DOLLAR_ENDONLY is set). When
	//     %G_REGEX_MULTILINE is set, the "start of line" and "end of line"
	//     constructs match immediately following or immediately before any
	//     newline in the string, respectively, as well as at the very start
	//     and end. This can be changed within a pattern by a "(?m)" option
	//     setting.
	GRegexMultilineValue RegexCompileFlags = 2
	// A dot metacharacter (".") in the pattern matches all
	//     characters, including newlines. Without it, newlines are excluded.
	//     This option can be changed within a pattern by a ("?s") option setting.
	GRegexDotallValue RegexCompileFlags = 4
	// Whitespace data characters in the pattern are
	//     totally ignored except when escaped or inside a character class.
	//     Whitespace does not include the VT character (code 11). In addition,
	//     characters between an unescaped "#" outside a character class and
	//     the next newline character, inclusive, are also ignored. This can
	//     be changed within a pattern by a "(?x)" option setting.
	GRegexExtendedValue RegexCompileFlags = 8
	// The pattern is forced to be "anchored", that is,
	//     it is constrained to match only at the first matching point in the
	//     string that is being searched. This effect can also be achieved by
	//     appropriate constructs in the pattern itself such as the "^"
	//     metacharacter.
	GRegexAnchoredValue RegexCompileFlags = 16
	// A dollar metacharacter ("$") in the pattern
	//     matches only at the end of the string. Without this option, a
	//     dollar also matches immediately before the final character if
	//     it is a newline (but not before any other newlines). This option
	//     is ignored if %G_REGEX_MULTILINE is set.
	GRegexDollarEndonlyValue RegexCompileFlags = 32
	// Inverts the "greediness" of the quantifiers so that
	//     they are not greedy by default, but become greedy if followed by "?".
	//     It can also be set by a "(?U)" option setting within the pattern.
	GRegexUngreedyValue RegexCompileFlags = 512
	// Usually strings must be valid UTF-8 strings, using this
	//     flag they are considered as a raw sequence of bytes.
	GRegexRawValue RegexCompileFlags = 2048
	// Disables the use of numbered capturing
	//     parentheses in the pattern. Any opening parenthesis that is not
	//     followed by "?" behaves as if it were followed by "?:" but named
	//     parentheses can still be used for capturing (and they acquire numbers
	//     in the usual way).
	GRegexNoAutoCaptureValue RegexCompileFlags = 4096
	// Optimize the regular expression. If the pattern will
	//     be used many times, then it may be worth the effort to optimize it
	//     to improve the speed of matches.
	GRegexOptimizeValue RegexCompileFlags = 8192
	// Limits an unanchored pattern to match before (or at) the
	//     first newline. Since: 2.34
	GRegexFirstlineValue RegexCompileFlags = 262144
	// Names used to identify capturing subpatterns need not
	//     be unique. This can be helpful for certain types of pattern when it
	//     is known that only one instance of the named subpattern can ever be
	//     matched.
	GRegexDupnamesValue RegexCompileFlags = 524288
	// Usually any newline character or character sequence is
	//     recognized. If this option is set, the only recognized newline character
	//     is '\r'.
	GRegexNewlineCrValue RegexCompileFlags = 1048576
	// Usually any newline character or character sequence is
	//     recognized. If this option is set, the only recognized newline character
	//     is '\n'.
	GRegexNewlineLfValue RegexCompileFlags = 2097152
	// Usually any newline character or character sequence is
	//     recognized. If this option is set, the only recognized newline character
	//     sequence is '\r\n'.
	GRegexNewlineCrlfValue RegexCompileFlags = 3145728
	// Usually any newline character or character sequence
	//     is recognized. If this option is set, the only recognized newline character
	//     sequences are '\r', '\n', and '\r\n'. Since: 2.34
	GRegexNewlineAnycrlfValue RegexCompileFlags = 5242880
	// Usually any newline character or character sequence
	//     is recognised. If this option is set, then "\R" only recognizes the newline
	//    characters '\r', '\n' and '\r\n'. Since: 2.34
	GRegexBsrAnycrlfValue RegexCompileFlags = 8388608
	// Changes behaviour so that it is compatible with
	//     JavaScript rather than PCRE. Since: 2.34
	GRegexJavascriptCompatValue RegexCompileFlags = 33554432
)

// Flags specifying match-time options.
type RegexMatchFlags int

const (

	// The pattern is forced to be "anchored", that is,
	//     it is constrained to match only at the first matching point in the
	//     string that is being searched. This effect can also be achieved by
	//     appropriate constructs in the pattern itself such as the "^"
	//     metacharacter.
	GRegexMatchAnchoredValue RegexMatchFlags = 16
	// Specifies that first character of the string is
	//     not the beginning of a line, so the circumflex metacharacter should
	//     not match before it. Setting this without %G_REGEX_MULTILINE (at
	//     compile time) causes circumflex never to match. This option affects
	//     only the behaviour of the circumflex metacharacter, it does not
	//     affect "\A".
	GRegexMatchNotbolValue RegexMatchFlags = 128
	// Specifies that the end of the subject string is
	//     not the end of a line, so the dollar metacharacter should not match
	//     it nor (except in multiline mode) a newline immediately before it.
	//     Setting this without %G_REGEX_MULTILINE (at compile time) causes
	//     dollar never to match. This option affects only the behaviour of
	//     the dollar metacharacter, it does not affect "\Z" or "\z".
	GRegexMatchNoteolValue RegexMatchFlags = 256
	// An empty string is not considered to be a valid
	//     match if this option is set. If there are alternatives in the pattern,
	//     they are tried. If all the alternatives match the empty string, the
	//     entire match fails. For example, if the pattern "a?b?" is applied to
	//     a string not beginning with "a" or "b", it matches the empty string
	//     at the start of the string. With this flag set, this match is not
	//     valid, so GRegex searches further into the string for occurrences
	//     of "a" or "b".
	GRegexMatchNotemptyValue RegexMatchFlags = 1024
	// Turns on the partial matching feature, for more
	//     documentation on partial matching see g_match_info_is_partial_match().
	GRegexMatchPartialValue RegexMatchFlags = 32768
	// Overrides the newline definition set when
	//     creating a new #GRegex, setting the '\r' character as line terminator.
	GRegexMatchNewlineCrValue RegexMatchFlags = 1048576
	// Overrides the newline definition set when
	//     creating a new #GRegex, setting the '\n' character as line terminator.
	GRegexMatchNewlineLfValue RegexMatchFlags = 2097152
	// Overrides the newline definition set when
	//     creating a new #GRegex, setting the '\r\n' characters sequence as line terminator.
	GRegexMatchNewlineCrlfValue RegexMatchFlags = 3145728
	// Overrides the newline definition set when
	//     creating a new #GRegex, any Unicode newline sequence
	//     is recognised as a newline. These are '\r', '\n' and '\rn', and the
	//     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),
	//     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and
	//     U+2029 PARAGRAPH SEPARATOR.
	GRegexMatchNewlineAnyValue RegexMatchFlags = 4194304
	// Overrides the newline definition set when
	//     creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence
	//     is recognized as a newline. Since: 2.34
	GRegexMatchNewlineAnycrlfValue RegexMatchFlags = 5242880
	// Overrides the newline definition for "\R" set when
	//     creating a new #GRegex; only '\r', '\n', or '\r\n' character sequences
	//     are recognized as a newline by "\R". Since: 2.34
	GRegexMatchBsrAnycrlfValue RegexMatchFlags = 8388608
	// Overrides the newline definition for "\R" set when
	//     creating a new #GRegex; any Unicode newline character or character sequence
	//     are recognized as a newline by "\R". These are '\r', '\n' and '\rn', and the
	//     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),
	//     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and
	//     U+2029 PARAGRAPH SEPARATOR. Since: 2.34
	GRegexMatchBsrAnyValue RegexMatchFlags = 16777216
	// An alias for %G_REGEX_MATCH_PARTIAL. Since: 2.34
	GRegexMatchPartialSoftValue RegexMatchFlags = 32768
	// Turns on the partial matching feature. In contrast to
	//     to %G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match
	//     is found, without continuing to search for a possible complete match. See
	//     g_match_info_is_partial_match() for more information. Since: 2.34
	GRegexMatchPartialHardValue RegexMatchFlags = 134217728
	// Like %G_REGEX_MATCH_NOTEMPTY, but only applied to
	//     the start of the matched string. For anchored
	//     patterns this can only happen for pattern containing "\K". Since: 2.34
	GRegexMatchNotemptyAtstartValue RegexMatchFlags = 268435456
)

// Error codes returned by regular expressions functions.
type RegexError int

const (

	// Compilation of the regular expression failed.
	GRegexErrorCompileValue RegexError = 0
	// Optimization of the regular expression failed.
	GRegexErrorOptimizeValue RegexError = 1
	// Replacement failed due to an ill-formed replacement
	//     string.
	GRegexErrorReplaceValue RegexError = 2
	// The match process failed.
	GRegexErrorMatchValue RegexError = 3
	// Internal error of the regular expression engine.
	//     Since 2.16
	GRegexErrorInternalValue RegexError = 4
	// "\\" at end of pattern. Since 2.16
	GRegexErrorStrayBackslashValue RegexError = 101
	// "\\c" at end of pattern. Since 2.16
	GRegexErrorMissingControlCharValue RegexError = 102
	// Unrecognized character follows "\\".
	//     Since 2.16
	GRegexErrorUnrecognizedEscapeValue RegexError = 103
	// Numbers out of order in "{}"
	//     quantifier. Since 2.16
	GRegexErrorQuantifiersOutOfOrderValue RegexError = 104
	// Number too big in "{}" quantifier.
	//     Since 2.16
	GRegexErrorQuantifierTooBigValue RegexError = 105
	// Missing terminating "]" for
	//     character class. Since 2.16
	GRegexErrorUnterminatedCharacterClassValue RegexError = 106
	// Invalid escape sequence
	//     in character class. Since 2.16
	GRegexErrorInvalidEscapeInCharacterClassValue RegexError = 107
	// Range out of order in character class.
	//     Since 2.16
	GRegexErrorRangeOutOfOrderValue RegexError = 108
	// Nothing to repeat. Since 2.16
	GRegexErrorNothingToRepeatValue RegexError = 109
	// Unrecognized character after "(?",
	//     "(?&lt;" or "(?P". Since 2.16
	GRegexErrorUnrecognizedCharacterValue RegexError = 112
	// POSIX named classes are
	//     supported only within a class. Since 2.16
	GRegexErrorPosixNamedClassOutsideClassValue RegexError = 113
	// Missing terminating ")" or ")"
	//     without opening "(". Since 2.16
	GRegexErrorUnmatchedParenthesisValue RegexError = 114
	// Reference to non-existent
	//     subpattern. Since 2.16
	GRegexErrorInexistentSubpatternReferenceValue RegexError = 115
	// Missing terminating ")" after comment.
	//     Since 2.16
	GRegexErrorUnterminatedCommentValue RegexError = 118
	// Regular expression too large.
	//     Since 2.16
	GRegexErrorExpressionTooLargeValue RegexError = 120
	// Failed to get memory. Since 2.16
	GRegexErrorMemoryErrorValue RegexError = 121
	// Lookbehind assertion is not
	//     fixed length. Since 2.16
	GRegexErrorVariableLengthLookbehindValue RegexError = 125
	// Malformed number or name after "(?(".
	//     Since 2.16
	GRegexErrorMalformedConditionValue RegexError = 126
	// Conditional group contains
	//     more than two branches. Since 2.16
	GRegexErrorTooManyConditionalBranchesValue RegexError = 127
	// Assertion expected after "(?(".
	//     Since 2.16
	GRegexErrorAssertionExpectedValue RegexError = 128
	// Unknown POSIX class name.
	//     Since 2.16
	GRegexErrorUnknownPosixClassNameValue RegexError = 130
	// POSIX collating
	//     elements are not supported. Since 2.16
	GRegexErrorPosixCollatingElementsNotSupportedValue RegexError = 131
	// Character value in "\\x{...}" sequence
	//     is too large. Since 2.16
	GRegexErrorHexCodeTooLargeValue RegexError = 134
	// Invalid condition "(?(0)". Since 2.16
	GRegexErrorInvalidConditionValue RegexError = 135
	// \\C not allowed in
	//     lookbehind assertion. Since 2.16
	GRegexErrorSingleByteMatchInLookbehindValue RegexError = 136
	// Recursive call could loop indefinitely.
	//     Since 2.16
	GRegexErrorInfiniteLoopValue RegexError = 140
	// Missing terminator
	//     in subpattern name. Since 2.16
	GRegexErrorMissingSubpatternNameTerminatorValue RegexError = 142
	// Two named subpatterns have
	//     the same name. Since 2.16
	GRegexErrorDuplicateSubpatternNameValue RegexError = 143
	// Malformed "\\P" or "\\p" sequence.
	//     Since 2.16
	GRegexErrorMalformedPropertyValue RegexError = 146
	// Unknown property name after "\\P" or
	//     "\\p". Since 2.16
	GRegexErrorUnknownPropertyValue RegexError = 147
	// Subpattern name is too long
	//     (maximum 32 characters). Since 2.16
	GRegexErrorSubpatternNameTooLongValue RegexError = 148
	// Too many named subpatterns (maximum
	//     10,000). Since 2.16
	GRegexErrorTooManySubpatternsValue RegexError = 149
	// Octal value is greater than "\\377".
	//     Since 2.16
	GRegexErrorInvalidOctalValueValue RegexError = 151
	// "DEFINE" group contains more
	//     than one branch. Since 2.16
	GRegexErrorTooManyBranchesInDefineValue RegexError = 154
	// Repeating a "DEFINE" group is not allowed.
	//     This error is never raised. Since: 2.16 Deprecated: 2.34
	GRegexErrorDefineRepetionValue RegexError = 155
	// Inconsistent newline options.
	//     Since 2.16
	GRegexErrorInconsistentNewlineOptionsValue RegexError = 156
	// "\\g" is not followed by a braced,
	//      angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16
	GRegexErrorMissingBackReferenceValue RegexError = 157
	// relative reference must not be zero. Since: 2.34
	GRegexErrorInvalidRelativeReferenceValue RegexError = 158
	// the backtracing
	//     control verb used does not allow an argument. Since: 2.34
	GRegexErrorBacktrackingControlVerbArgumentForbiddenValue RegexError = 159
	// unknown backtracing
	//     control verb. Since: 2.34
	GRegexErrorUnknownBacktrackingControlVerbValue RegexError = 160
	// number is too big in escape sequence. Since: 2.34
	GRegexErrorNumberTooBigValue RegexError = 161
	// Missing subpattern name. Since: 2.34
	GRegexErrorMissingSubpatternNameValue RegexError = 162
	// Missing digit. Since 2.34
	GRegexErrorMissingDigitValue RegexError = 163
	// In JavaScript compatibility mode,
	//     "[" is an invalid data character. Since: 2.34
	GRegexErrorInvalidDataCharacterValue RegexError = 164
	// different names for subpatterns of the
	//     same number are not allowed. Since: 2.34
	GRegexErrorExtraSubpatternNameValue RegexError = 165
	// the backtracing control
	//     verb requires an argument. Since: 2.34
	GRegexErrorBacktrackingControlVerbArgumentRequiredValue RegexError = 166
	// "\\c" must be followed by an ASCII
	//     character. Since: 2.34
	GRegexErrorInvalidControlCharValue RegexError = 168
	// "\\k" is not followed by a braced, angle-bracketed, or
	//     quoted name. Since: 2.34
	GRegexErrorMissingNameValue RegexError = 169
	// "\\N" is not supported in a class. Since: 2.34
	GRegexErrorNotSupportedInClassValue RegexError = 171
	// too many forward references. Since: 2.34
	GRegexErrorTooManyForwardReferencesValue RegexError = 172
	// the name is too long in "(*MARK)", "(*PRUNE)",
	//     "(*SKIP)", or "(*THEN)". Since: 2.34
	GRegexErrorNameTooLongValue RegexError = 175
	// the character value in the \\u sequence is
	//     too large. Since: 2.34
	GRegexErrorCharacterValueTooLargeValue RegexError = 176
)

var xRegexCheckReplacement func(string, bool, **Error) bool

// Checks whether @replacement is a valid replacement string
// (see g_regex_replace()), i.e. that all escape sequences in
// it are valid.
//
// If @has_references is not %NULL then @replacement is checked
// for pattern references. For instance, replacement text 'foo\n'
// does not contain references and may be evaluated without information
// about actual match, but '\0\1' (whole match followed by first
// subpattern) requires valid #GMatchInfo object.
func RegexCheckReplacement(ReplacementVar string, HasReferencesVar bool) (bool, error) {
	var cerr *Error

	cret := xRegexCheckReplacement(ReplacementVar, HasReferencesVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xRegexEscapeNul func(string, int) string

// Escapes the nul characters in @string to "\x00".  It can be used
// to compile a regex with embedded nul characters.
//
// For completeness, @length can be -1 for a nul-terminated string.
// In this case the output string will be of course equal to @string.
func RegexEscapeNul(StringVar string, LengthVar int) string {

	cret := xRegexEscapeNul(StringVar, LengthVar)
	return cret
}

var xRegexEscapeString func([]string, int) string

// Escapes the special characters used for regular expressions
// in @string, for instance "a.b*c" becomes "a\.b\*c". This
// function is useful to dynamically generate regular expressions.
//
// @string can contain nul characters that are replaced with "\0",
// in this case remember to specify the correct length of @string
// in @length.
func RegexEscapeString(StringVar []string, LengthVar int) string {

	cret := xRegexEscapeString(StringVar, LengthVar)
	return cret
}

var xRegexMatchSimple func(string, string, RegexCompileFlags, RegexMatchFlags) bool

// Scans for a match in @string for @pattern.
//
// This function is equivalent to g_regex_match() but it does not
// require to compile the pattern with g_regex_new(), avoiding some
// lines of code when you need just to do a match without extracting
// substrings, capture counts, and so on.
//
// If this function is to be called on the same @pattern more than
// once, it's more efficient to compile the pattern once with
// g_regex_new() and then use g_regex_match().
func RegexMatchSimple(PatternVar string, StringVar string, CompileOptionsVar RegexCompileFlags, MatchOptionsVar RegexMatchFlags) bool {

	cret := xRegexMatchSimple(PatternVar, StringVar, CompileOptionsVar, MatchOptionsVar)
	return cret
}

var xRegexSplitSimple func(string, string, RegexCompileFlags, RegexMatchFlags) []string

// Breaks the string on the pattern, and returns an array of
// the tokens. If the pattern contains capturing parentheses,
// then the text for each of the substrings will also be returned.
// If the pattern does not match anywhere in the string, then the
// whole string is returned as the first token.
//
// This function is equivalent to g_regex_split() but it does
// not require to compile the pattern with g_regex_new(), avoiding
// some lines of code when you need just to do a split without
// extracting substrings, capture counts, and so on.
//
// If this function is to be called on the same @pattern more than
// once, it's more efficient to compile the pattern once with
// g_regex_new() and then use g_regex_split().
//
// As a special case, the result of splitting the empty string ""
// is an empty vector, not a vector containing a single string.
// The reason for this special case is that being able to represent
// an empty vector is typically more useful than consistent handling
// of empty elements. If you do need to represent empty elements,
// you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits @string into
// separate characters wherever it matches the empty string between
// characters. For example splitting "ab c" using as a separator
// "\s*", you will get "a", "b" and "c".
func RegexSplitSimple(PatternVar string, StringVar string, CompileOptionsVar RegexCompileFlags, MatchOptionsVar RegexMatchFlags) []string {

	cret := xRegexSplitSimple(PatternVar, StringVar, CompileOptionsVar, MatchOptionsVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xRegexCheckReplacement, lib, "g_regex_check_replacement")
	core.PuregoSafeRegister(&xRegexEscapeNul, lib, "g_regex_escape_nul")
	core.PuregoSafeRegister(&xRegexEscapeString, lib, "g_regex_escape_string")
	core.PuregoSafeRegister(&xRegexMatchSimple, lib, "g_regex_match_simple")
	core.PuregoSafeRegister(&xRegexSplitSimple, lib, "g_regex_split_simple")

	core.PuregoSafeRegister(&xMatchInfoExpandReferences, lib, "g_match_info_expand_references")
	core.PuregoSafeRegister(&xMatchInfoFetch, lib, "g_match_info_fetch")
	core.PuregoSafeRegister(&xMatchInfoFetchAll, lib, "g_match_info_fetch_all")
	core.PuregoSafeRegister(&xMatchInfoFetchNamed, lib, "g_match_info_fetch_named")
	core.PuregoSafeRegister(&xMatchInfoFetchNamedPos, lib, "g_match_info_fetch_named_pos")
	core.PuregoSafeRegister(&xMatchInfoFetchPos, lib, "g_match_info_fetch_pos")
	core.PuregoSafeRegister(&xMatchInfoFree, lib, "g_match_info_free")
	core.PuregoSafeRegister(&xMatchInfoGetMatchCount, lib, "g_match_info_get_match_count")
	core.PuregoSafeRegister(&xMatchInfoGetRegex, lib, "g_match_info_get_regex")
	core.PuregoSafeRegister(&xMatchInfoGetString, lib, "g_match_info_get_string")
	core.PuregoSafeRegister(&xMatchInfoIsPartialMatch, lib, "g_match_info_is_partial_match")
	core.PuregoSafeRegister(&xMatchInfoMatches, lib, "g_match_info_matches")
	core.PuregoSafeRegister(&xMatchInfoNext, lib, "g_match_info_next")
	core.PuregoSafeRegister(&xMatchInfoRef, lib, "g_match_info_ref")
	core.PuregoSafeRegister(&xMatchInfoUnref, lib, "g_match_info_unref")

	core.PuregoSafeRegister(&xNewRegex, lib, "g_regex_new")

	core.PuregoSafeRegister(&xRegexGetCaptureCount, lib, "g_regex_get_capture_count")
	core.PuregoSafeRegister(&xRegexGetCompileFlags, lib, "g_regex_get_compile_flags")
	core.PuregoSafeRegister(&xRegexGetHasCrOrLf, lib, "g_regex_get_has_cr_or_lf")
	core.PuregoSafeRegister(&xRegexGetMatchFlags, lib, "g_regex_get_match_flags")
	core.PuregoSafeRegister(&xRegexGetMaxBackref, lib, "g_regex_get_max_backref")
	core.PuregoSafeRegister(&xRegexGetMaxLookbehind, lib, "g_regex_get_max_lookbehind")
	core.PuregoSafeRegister(&xRegexGetPattern, lib, "g_regex_get_pattern")
	core.PuregoSafeRegister(&xRegexGetStringNumber, lib, "g_regex_get_string_number")
	core.PuregoSafeRegister(&xRegexMatch, lib, "g_regex_match")
	core.PuregoSafeRegister(&xRegexMatchAll, lib, "g_regex_match_all")
	core.PuregoSafeRegister(&xRegexMatchAllFull, lib, "g_regex_match_all_full")
	core.PuregoSafeRegister(&xRegexMatchFull, lib, "g_regex_match_full")
	core.PuregoSafeRegister(&xRegexRef, lib, "g_regex_ref")
	core.PuregoSafeRegister(&xRegexReplace, lib, "g_regex_replace")
	core.PuregoSafeRegister(&xRegexReplaceEval, lib, "g_regex_replace_eval")
	core.PuregoSafeRegister(&xRegexReplaceLiteral, lib, "g_regex_replace_literal")
	core.PuregoSafeRegister(&xRegexSplit, lib, "g_regex_split")
	core.PuregoSafeRegister(&xRegexSplitFull, lib, "g_regex_split_full")
	core.PuregoSafeRegister(&xRegexUnref, lib, "g_regex_unref")

}
