// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// The type used for test case functions that take an extra pointer
// argument.
type TestDataFunc func(uintptr)

// The type used for functions that operate on test fixtures.  This is
// used for the fixture setup and teardown functions as well as for the
// testcases themselves.
//
// @user_data is a pointer to the data that was given when registering
// the test case.
//
// @fixture will be a pointer to the area of memory allocated by the
// test framework, of the size requested.  If the requested size was
// zero then @fixture will be equal to @user_data.
type TestFixtureFunc func(uintptr, uintptr)

// The type used for test case functions.
type TestFunc func()

// Specifies the prototype of fatal log handler functions.
type TestLogFatalFunc func(string, LogLevelFlags, string, uintptr) bool

// An opaque structure representing a test case.
type TestCase struct {
}

func (x *TestCase) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTestCaseFree func(uintptr)

// Free the @test_case.
func (x *TestCase) Free() {

	xTestCaseFree(x.GoPointer())

}

type TestConfig struct {
	TestInitialized bool

	TestQuick bool

	TestPerf bool

	TestVerbose bool

	TestQuiet bool

	TestUndefined bool
}

func (x *TestConfig) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

type TestLogBuffer struct {
	Data *String

	Msgs *SList
}

func (x *TestLogBuffer) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTestLogBufferFree func(uintptr)

// Internal function for gtester to free test log messages, no ABI guarantees provided.
func (x *TestLogBuffer) Free() {

	xTestLogBufferFree(x.GoPointer())

}

var xTestLogBufferPop func(uintptr) *TestLogMsg

// Internal function for gtester to retrieve test log messages, no ABI guarantees provided.
func (x *TestLogBuffer) Pop() *TestLogMsg {

	cret := xTestLogBufferPop(x.GoPointer())
	return cret
}

var xTestLogBufferPush func(uintptr, uint, byte)

// Internal function for gtester to decode test log messages, no ABI guarantees provided.
func (x *TestLogBuffer) Push(NBytesVar uint, BytesVar byte) {

	xTestLogBufferPush(x.GoPointer(), NBytesVar, BytesVar)

}

type TestLogMsg struct {
	LogType TestLogType

	NStrings uint

	Strings uintptr

	NNums uint

	Nums float64
}

func (x *TestLogMsg) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTestLogMsgFree func(uintptr)

// Internal function for gtester to free test log messages, no ABI guarantees provided.
func (x *TestLogMsg) Free() {

	xTestLogMsgFree(x.GoPointer())

}

// An opaque structure representing a test suite.
type TestSuite struct {
}

func (x *TestSuite) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTestSuiteAdd func(uintptr, *TestCase)

// Adds @test_case to @suite.
func (x *TestSuite) Add(TestCaseVar *TestCase) {

	xTestSuiteAdd(x.GoPointer(), TestCaseVar)

}

var xTestSuiteAddSuite func(uintptr, *TestSuite)

// Adds @nestedsuite to @suite.
func (x *TestSuite) AddSuite(NestedsuiteVar *TestSuite) {

	xTestSuiteAddSuite(x.GoPointer(), NestedsuiteVar)

}

var xTestSuiteFree func(uintptr)

// Free the @suite and all nested #GTestSuites.
func (x *TestSuite) Free() {

	xTestSuiteFree(x.GoPointer())

}

const (
	// Creates a unique temporary directory for each unit test and uses
	// g_set_user_dirs() to set XDG directories to point into subdirectories of it
	// for the duration of the unit test. The directory tree is cleaned up after the
	// test finishes successfully. Note that this doesn’t take effect until
	// g_test_run() is called, so calls to (for example) g_get_user_home_dir() will
	// return the system-wide value when made in a test program’s main() function.
	//
	// The following functions will return subdirectories of the temporary directory
	// when this option is used. The specific subdirectory paths in use are not
	// guaranteed to be stable API — always use a getter function to retrieve them.
	//
	//  - g_get_home_dir()
	//  - g_get_user_cache_dir()
	//  - g_get_system_config_dirs()
	//  - g_get_user_config_dir()
	//  - g_get_system_data_dirs()
	//  - g_get_user_data_dir()
	//  - g_get_user_state_dir()
	//  - g_get_user_runtime_dir()
	//
	// The subdirectories may not be created by the test harness; as with normal
	// calls to functions like g_get_user_cache_dir(), the caller must be prepared
	// to create the directory if it doesn’t exist.
	TEST_OPTION_ISOLATE_DIRS string = "isolate_dirs"
)

// Flags to pass to g_test_trap_subprocess() to control input and output.
//
// Note that in contrast with g_test_trap_fork(), the default is to
// not show stdout and stderr.
type TestSubprocessFlags int

const (

	// If this flag is given, the child
	//     process will inherit the parent's stdin. Otherwise, the child's
	//     stdin is redirected to `/dev/null`.
	GTestSubprocessInheritStdinValue TestSubprocessFlags = 1
	// If this flag is given, the child
	//     process will inherit the parent's stdout. Otherwise, the child's
	//     stdout will not be visible, but it will be captured to allow
	//     later tests with g_test_trap_assert_stdout().
	GTestSubprocessInheritStdoutValue TestSubprocessFlags = 2
	// If this flag is given, the child
	//     process will inherit the parent's stderr. Otherwise, the child's
	//     stderr will not be visible, but it will be captured to allow
	//     later tests with g_test_trap_assert_stderr().
	GTestSubprocessInheritStderrValue TestSubprocessFlags = 4
)

// Test traps are guards around forked tests.
// These flags determine what traps to set.
type TestTrapFlags int

const (

	// Redirect stdout of the test child to
	//     `/dev/null` so it cannot be observed on the console during test
	//     runs. The actual output is still captured though to allow later
	//     tests with g_test_trap_assert_stdout().
	GTestTrapSilenceStdoutValue TestTrapFlags = 128
	// Redirect stderr of the test child to
	//     `/dev/null` so it cannot be observed on the console during test
	//     runs. The actual output is still captured though to allow later
	//     tests with g_test_trap_assert_stderr().
	GTestTrapSilenceStderrValue TestTrapFlags = 256
	// If this flag is given, stdin of the
	//     child process is shared with stdin of its parent process.
	//     It is redirected to `/dev/null` otherwise.
	GTestTrapInheritStdinValue TestTrapFlags = 512
)

// The type of file to return the filename for, when used with
// g_test_build_filename().
//
// These two options correspond rather directly to the 'dist' and
// 'built' terminology that automake uses and are explicitly used to
// distinguish between the 'srcdir' and 'builddir' being separate.  All
// files in your project should either be dist (in the
// `EXTRA_DIST` or `dist_schema_DATA`
// sense, in which case they will always be in the srcdir) or built (in
// the `BUILT_SOURCES` sense, in which case they will
// always be in the builddir).
//
// Note: as a general rule of automake, files that are generated only as
// part of the build-from-git process (but then are distributed with the
// tarball) always go in srcdir (even if doing a srcdir != builddir
// build from git) and are considered as distributed files.
type TestFileType int

const (

	// a file that was included in the distribution tarball
	GTestDistValue TestFileType = 0
	// a file that was built on the compiling machine
	GTestBuiltValue TestFileType = 1
)

type TestLogType int

const (
	GTestLogNoneValue TestLogType = 0

	GTestLogErrorValue TestLogType = 1

	GTestLogStartBinaryValue TestLogType = 2

	GTestLogListCaseValue TestLogType = 3

	GTestLogSkipCaseValue TestLogType = 4

	GTestLogStartCaseValue TestLogType = 5

	GTestLogStopCaseValue TestLogType = 6

	GTestLogMinResultValue TestLogType = 7

	GTestLogMaxResultValue TestLogType = 8

	GTestLogMessageValue TestLogType = 9

	GTestLogStartSuiteValue TestLogType = 10

	GTestLogStopSuiteValue TestLogType = 11
)

type TestResult int

const (
	GTestRunSuccessValue TestResult = 0

	GTestRunSkippedValue TestResult = 1

	GTestRunFailureValue TestResult = 2

	GTestRunIncompleteValue TestResult = 3
)

var xAssertionMessage func(string, string, int, string, string)

func AssertionMessage(DomainVar string, FileVar string, LineVar int, FuncVar string, MessageVar string) {

	xAssertionMessage(DomainVar, FileVar, LineVar, FuncVar, MessageVar)

}

var xAssertionMessageCmpnum func(string, string, int, string, string, float64, string, float64, byte)

func AssertionMessageCmpnum(DomainVar string, FileVar string, LineVar int, FuncVar string, ExprVar string, Arg1Var float64, CmpVar string, Arg2Var float64, NumtypeVar byte) {

	xAssertionMessageCmpnum(DomainVar, FileVar, LineVar, FuncVar, ExprVar, Arg1Var, CmpVar, Arg2Var, NumtypeVar)

}

var xAssertionMessageCmpstr func(string, string, int, string, string, string, string, string)

func AssertionMessageCmpstr(DomainVar string, FileVar string, LineVar int, FuncVar string, ExprVar string, Arg1Var string, CmpVar string, Arg2Var string) {

	xAssertionMessageCmpstr(DomainVar, FileVar, LineVar, FuncVar, ExprVar, Arg1Var, CmpVar, Arg2Var)

}

var xAssertionMessageCmpstrv func(string, string, int, string, string, string, string, uint)

func AssertionMessageCmpstrv(DomainVar string, FileVar string, LineVar int, FuncVar string, ExprVar string, Arg1Var string, Arg2Var string, FirstWrongIdxVar uint) {

	xAssertionMessageCmpstrv(DomainVar, FileVar, LineVar, FuncVar, ExprVar, Arg1Var, Arg2Var, FirstWrongIdxVar)

}

var xAssertionMessageError func(string, string, int, string, string, *Error, Quark, int)

func AssertionMessageError(DomainVar string, FileVar string, LineVar int, FuncVar string, ExprVar string, ErrorVar *Error, ErrorDomainVar Quark, ErrorCodeVar int) {

	xAssertionMessageError(DomainVar, FileVar, LineVar, FuncVar, ExprVar, ErrorVar, ErrorDomainVar, ErrorCodeVar)

}

var xAssertionMessageExpr func(string, string, int, string, string)

// Internal function used to print messages from the public g_assert() and
// g_assert_not_reached() macros.
func AssertionMessageExpr(DomainVar string, FileVar string, LineVar int, FuncVar string, ExprVar string) {

	xAssertionMessageExpr(DomainVar, FileVar, LineVar, FuncVar, ExprVar)

}

var xStrcmp0 func(string, string) int

// Compares @str1 and @str2 like strcmp(). Handles %NULL
// gracefully by sorting it before non-%NULL strings.
// Comparing two %NULL pointers returns 0.
func Strcmp0(Str1Var string, Str2Var string) int {

	cret := xStrcmp0(Str1Var, Str2Var)
	return cret
}

var xTestAddDataFunc func(string, uintptr, uintptr)

// Create a new test case, similar to g_test_create_case(). However
// the test is assumed to use no fixture, and test suites are automatically
// created on the fly and added to the root fixture, based on the
// slash-separated portions of @testpath. The @test_data argument
// will be passed as first argument to @test_func.
//
// If @testpath includes the component "subprocess" anywhere in it,
// the test will be skipped by default, and only run if explicitly
// required via the `-p` command-line option or g_test_trap_subprocess().
//
// No component of @testpath may start with a dot (`.`) if the
// %G_TEST_OPTION_ISOLATE_DIRS option is being used; and it is recommended to
// do so even if it isn’t.
func TestAddDataFunc(TestpathVar string, TestDataVar uintptr, TestFuncVar *TestDataFunc) {

	xTestAddDataFunc(TestpathVar, TestDataVar, NewCallback(TestFuncVar))

}

var xTestAddDataFuncFull func(string, uintptr, uintptr, uintptr)

// Create a new test case, as with g_test_add_data_func(), but freeing
// @test_data after the test run is complete.
func TestAddDataFuncFull(TestpathVar string, TestDataVar uintptr, TestFuncVar *TestDataFunc, DataFreeFuncVar *DestroyNotify) {

	xTestAddDataFuncFull(TestpathVar, TestDataVar, NewCallback(TestFuncVar), NewCallback(DataFreeFuncVar))

}

var xTestAddFunc func(string, uintptr)

// Create a new test case, similar to g_test_create_case(). However
// the test is assumed to use no fixture, and test suites are automatically
// created on the fly and added to the root fixture, based on the
// slash-separated portions of @testpath.
//
// If @testpath includes the component "subprocess" anywhere in it,
// the test will be skipped by default, and only run if explicitly
// required via the `-p` command-line option or g_test_trap_subprocess().
//
// No component of @testpath may start with a dot (`.`) if the
// %G_TEST_OPTION_ISOLATE_DIRS option is being used; and it is recommended to
// do so even if it isn’t.
func TestAddFunc(TestpathVar string, TestFuncVar *TestFunc) {

	xTestAddFunc(TestpathVar, NewCallback(TestFuncVar))

}

var xTestAddVtable func(string, uint, uintptr, uintptr, uintptr, uintptr)

func TestAddVtable(TestpathVar string, DataSizeVar uint, TestDataVar uintptr, DataSetupVar *TestFixtureFunc, DataTestVar *TestFixtureFunc, DataTeardownVar *TestFixtureFunc) {

	xTestAddVtable(TestpathVar, DataSizeVar, TestDataVar, NewCallback(DataSetupVar), NewCallback(DataTestVar), NewCallback(DataTeardownVar))

}

var xTestAssertExpectedMessagesInternal func(string, string, int, string)

func TestAssertExpectedMessagesInternal(DomainVar string, FileVar string, LineVar int, FuncVar string) {

	xTestAssertExpectedMessagesInternal(DomainVar, FileVar, LineVar, FuncVar)

}

var xTestBug func(string)

// This function adds a message to test reports that
// associates a bug URI with a test case.
//
// Bug URIs are constructed from a base URI set with g_test_bug_base()
// and @bug_uri_snippet. If g_test_bug_base() has not been called, it is
// assumed to be the empty string, so a full URI can be provided to
// g_test_bug() instead.
//
// Since GLib 2.70, the base URI is not prepended to @bug_uri_snippet if it
// is already a valid URI.
func TestBug(BugUriSnippetVar string) {

	xTestBug(BugUriSnippetVar)

}

var xTestBugBase func(string)

// Specify the base URI for bug reports.
//
// The base URI is used to construct bug report messages for
// g_test_message() when g_test_bug() is called.
// Calling this function outside of a test case sets the
// default base URI for all test cases. Calling it from within
// a test case changes the base URI for the scope of the test
// case only.
// Bug URIs are constructed by appending a bug specific URI
// portion to @uri_pattern, or by replacing the special string
// `%s` within @uri_pattern if that is present.
//
// If g_test_bug_base() is not called, bug URIs are formed solely
// from the value provided by g_test_bug().
func TestBugBase(UriPatternVar string) {

	xTestBugBase(UriPatternVar)

}

var xTestBuildFilename func(TestFileType, string, ...interface{}) string

// Creates the pathname to a data file that is required for a test.
//
// This function is conceptually similar to g_build_filename() except
// that the first argument has been replaced with a #GTestFileType
// argument.
//
// The data file should either have been distributed with the module
// containing the test (%G_TEST_DIST) or built as part of the build
// system of that module (%G_TEST_BUILT).
//
// In order for this function to work in srcdir != builddir situations,
// the G_TEST_SRCDIR and G_TEST_BUILDDIR environment variables need to
// have been defined.  As of 2.38, this is done by the glib.mk
// included in GLib.  Please ensure that your copy is up to date before
// using this function.
//
// In case neither variable is set, this function will fall back to
// using the dirname portion of argv[0], possibly removing ".libs".
// This allows for casual running of tests directly from the commandline
// in the srcdir == builddir case and should also support running of
// installed tests, assuming the data files have been installed in the
// same relative path as the test binary.
func TestBuildFilename(FileTypeVar TestFileType, FirstPathVar string, varArgs ...interface{}) string {

	cret := xTestBuildFilename(FileTypeVar, FirstPathVar, varArgs...)
	return cret
}

var xTestCreateCase func(string, uint, uintptr, uintptr, uintptr, uintptr) *TestCase

// Create a new #GTestCase, named @test_name.
//
// This API is fairly low level, and calling g_test_add() or g_test_add_func()
// is preferable.
//
// When this test is executed, a fixture structure of size @data_size
// will be automatically allocated and filled with zeros. Then @data_setup is
// called to initialize the fixture. After fixture setup, the actual test
// function @data_test is called. Once the test run completes, the
// fixture structure is torn down by calling @data_teardown and
// after that the memory is automatically released by the test framework.
//
// Splitting up a test run into fixture setup, test function and
// fixture teardown is most useful if the same fixture type is used for
// multiple tests. In this cases, g_test_create_case() will be
// called with the same type of fixture (the @data_size argument), but varying
// @test_name and @data_test arguments.
func TestCreateCase(TestNameVar string, DataSizeVar uint, TestDataVar uintptr, DataSetupVar *TestFixtureFunc, DataTestVar *TestFixtureFunc, DataTeardownVar *TestFixtureFunc) *TestCase {

	cret := xTestCreateCase(TestNameVar, DataSizeVar, TestDataVar, NewCallback(DataSetupVar), NewCallback(DataTestVar), NewCallback(DataTeardownVar))
	return cret
}

var xTestCreateSuite func(string) *TestSuite

// Create a new test suite with the name @suite_name.
func TestCreateSuite(SuiteNameVar string) *TestSuite {

	cret := xTestCreateSuite(SuiteNameVar)
	return cret
}

var xTestExpectMessage func(string, LogLevelFlags, string)

// Indicates that a message with the given @log_domain and @log_level,
// with text matching @pattern, is expected to be logged. When this
// message is logged, it will not be printed, and the test case will
// not abort.
//
// This API may only be used with the old logging API (g_log() without
// %G_LOG_USE_STRUCTURED defined). It will not work with the structured logging
// API. See [Testing for Messages][testing-for-messages].
//
// Use g_test_assert_expected_messages() to assert that all
// previously-expected messages have been seen and suppressed.
//
// You can call this multiple times in a row, if multiple messages are
// expected as a result of a single call. (The messages must appear in
// the same order as the calls to g_test_expect_message().)
//
// For example:
//
// |[&lt;!-- language="C" --&gt;
//
//	// g_main_context_push_thread_default() should fail if the
//	// context is already owned by another thread.
//	g_test_expect_message (G_LOG_DOMAIN,
//	                       G_LOG_LEVEL_CRITICAL,
//	                       "assertion*acquired_context*failed");
//	g_main_context_push_thread_default (bad_context);
//	g_test_assert_expected_messages ();
//
// ]|
//
// Note that you cannot use this to test g_error() messages, since
// g_error() intentionally never returns even if the program doesn't
// abort; use g_test_trap_subprocess() in this case.
//
// If messages at %G_LOG_LEVEL_DEBUG are emitted, but not explicitly
// expected via g_test_expect_message() then they will be ignored.
func TestExpectMessage(LogDomainVar string, LogLevelVar LogLevelFlags, PatternVar string) {

	xTestExpectMessage(LogDomainVar, LogLevelVar, PatternVar)

}

var xTestFail func()

// Indicates that a test failed. This function can be called
// multiple times from the same test. You can use this function
// if your test failed in a recoverable way.
//
// Do not use this function if the failure of a test could cause
// other tests to malfunction.
//
// Calling this function will not stop the test from running, you
// need to return from the test function yourself. So you can
// produce additional diagnostic messages or even continue running
// the test.
//
// If not called from inside a test, this function does nothing.
//
// Note that unlike g_test_skip() and g_test_incomplete(), this
// function does not log a message alongside the test failure.
// If details of the test failure are available, either log them with
// g_test_message() before g_test_fail(), or use g_test_fail_printf()
// instead.
func TestFail() {

	xTestFail()

}

var xTestFailPrintf func(string, ...interface{})

// Equivalent to g_test_fail(), but also record a message like
// g_test_skip_printf().
func TestFailPrintf(FormatVar string, varArgs ...interface{}) {

	xTestFailPrintf(FormatVar, varArgs...)

}

var xTestFailed func() bool

// Returns whether a test has already failed. This will
// be the case when g_test_fail(), g_test_incomplete()
// or g_test_skip() have been called, but also if an
// assertion has failed.
//
// This can be useful to return early from a test if
// continuing after a failed assertion might be harmful.
//
// The return value of this function is only meaningful
// if it is called from inside a test function.
func TestFailed() bool {

	cret := xTestFailed()
	return cret
}

var xTestGetDir func(TestFileType) string

// Gets the pathname of the directory containing test files of the type
// specified by @file_type.
//
// This is approximately the same as calling g_test_build_filename("."),
// but you don't need to free the return value.
func TestGetDir(FileTypeVar TestFileType) string {

	cret := xTestGetDir(FileTypeVar)
	return cret
}

var xTestGetFilename func(TestFileType, string, ...interface{}) string

// Gets the pathname to a data file that is required for a test.
//
// This is the same as g_test_build_filename() with two differences.
// The first difference is that you must only use this function from within
// a testcase function.  The second difference is that you need not free
// the return value — it will be automatically freed when the testcase
// finishes running.
//
// It is safe to use this function from a thread inside of a testcase
// but you must ensure that all such uses occur before the main testcase
// function returns (ie: it is best to ensure that all threads have been
// joined).
func TestGetFilename(FileTypeVar TestFileType, FirstPathVar string, varArgs ...interface{}) string {

	cret := xTestGetFilename(FileTypeVar, FirstPathVar, varArgs...)
	return cret
}

var xTestGetPath func() string

// Gets the test path for the test currently being run.
//
// In essence, it will be the same string passed as the first argument to
// e.g. g_test_add() when the test was added.
//
// This function returns a valid string only within a test function.
func TestGetPath() string {

	cret := xTestGetPath()
	return cret
}

var xTestGetRoot func() *TestSuite

// Get the toplevel test suite for the test path API.
func TestGetRoot() *TestSuite {

	cret := xTestGetRoot()
	return cret
}

var xTestIncomplete func(string)

// Indicates that a test failed because of some incomplete
// functionality. This function can be called multiple times
// from the same test.
//
// Calling this function will not stop the test from running, you
// need to return from the test function yourself. So you can
// produce additional diagnostic messages or even continue running
// the test.
//
// If not called from inside a test, this function does nothing.
func TestIncomplete(MsgVar string) {

	xTestIncomplete(MsgVar)

}

var xTestIncompletePrintf func(string, ...interface{})

// Equivalent to g_test_incomplete(), but the explanation is formatted
// as if by g_strdup_printf().
func TestIncompletePrintf(FormatVar string, varArgs ...interface{}) {

	xTestIncompletePrintf(FormatVar, varArgs...)

}

var xTestInit func(int, string, ...interface{})

// Initialize the GLib testing framework, e.g. by seeding the
// test random number generator, the name for g_get_prgname()
// and parsing test related command line args.
//
// So far, the following arguments are understood:
//
//   - `-l`: List test cases available in a test executable.
//
//   - `--seed=SEED`: Provide a random seed to reproduce test
//     runs using random numbers.
//
//   - `--verbose`: Run tests verbosely.
//
//   - `-q`, `--quiet`: Run tests quietly.
//
//   - `-p PATH`: Execute all tests matching the given path.
//
//   - `-s PATH`: Skip all tests matching the given path.
//     This can also be used to force a test to run that would otherwise
//     be skipped (ie, a test whose name contains "/subprocess").
//
//   - `-m {perf|slow|thorough|quick|undefined|no-undefined}`: Execute tests according to these test modes:
//
//     `perf`: Performance tests, may take long and report results (off by default).
//
//     `slow`, `thorough`: Slow and thorough tests, may take quite long and maximize coverage
//     (off by default).
//
//     `quick`: Quick tests, should run really quickly and give good coverage (the default).
//
//     `undefined`: Tests for undefined behaviour, may provoke programming errors
//     under g_test_trap_subprocess() or g_test_expect_message() to check
//     that appropriate assertions or warnings are given (the default).
//
//     `no-undefined`: Avoid tests for undefined behaviour
//
// - `--debug-log`: Debug test logging output.
//
// Options which can be passed to @... are:
//
//   - `"no_g_set_prgname"`: Causes g_test_init() to not call g_set_prgname().
//   - %G_TEST_OPTION_ISOLATE_DIRS: Creates a unique temporary directory for each
//     unit test and uses g_set_user_dirs() to set XDG directories to point into
//     that temporary directory for the duration of the unit test. See the
//     documentation for %G_TEST_OPTION_ISOLATE_DIRS.
//
// Since 2.58, if tests are compiled with `G_DISABLE_ASSERT` defined,
// g_test_init() will print an error and exit. This is to prevent no-op tests
// from being executed, as g_assert() is commonly (erroneously) used in unit
// tests, and is a no-op when compiled with `G_DISABLE_ASSERT`. Ensure your
// tests are compiled without `G_DISABLE_ASSERT` defined.
func TestInit(ArgcVar int, ArgvVar string, varArgs ...interface{}) {

	xTestInit(ArgcVar, ArgvVar, varArgs...)

}

var xTestLogSetFatalHandler func(uintptr, uintptr)

// Installs a non-error fatal log handler which can be
// used to decide whether log messages which are counted
// as fatal abort the program.
//
// The use case here is that you are running a test case
// that depends on particular libraries or circumstances
// and cannot prevent certain known critical or warning
// messages. So you install a handler that compares the
// domain and message to precisely not abort in such a case.
//
// Note that the handler is reset at the beginning of
// any test case, so you have to set it inside each test
// function which needs the special behavior.
//
// This handler has no effect on g_error messages.
//
// This handler also has no effect on structured log messages (using
// g_log_structured() or g_log_structured_array()). To change the fatal
// behaviour for specific log messages, programs must install a custom log
// writer function using g_log_set_writer_func().See
// [Using Structured Logging][using-structured-logging].
func TestLogSetFatalHandler(LogFuncVar *TestLogFatalFunc, UserDataVar uintptr) {

	xTestLogSetFatalHandler(NewCallback(LogFuncVar), UserDataVar)

}

var xTestLogTypeName func(TestLogType) string

func TestLogTypeName(LogTypeVar TestLogType) string {

	cret := xTestLogTypeName(LogTypeVar)
	return cret
}

var xTestMaximizedResult func(float64, string, ...interface{})

// Report the result of a performance or measurement test.
// The test should generally strive to maximize the reported
// quantities (larger values are better than smaller ones),
// this and @maximized_quantity can determine sorting
// order for test result reports.
func TestMaximizedResult(MaximizedQuantityVar float64, FormatVar string, varArgs ...interface{}) {

	xTestMaximizedResult(MaximizedQuantityVar, FormatVar, varArgs...)

}

var xTestMessage func(string, ...interface{})

// Add a message to the test report.
func TestMessage(FormatVar string, varArgs ...interface{}) {

	xTestMessage(FormatVar, varArgs...)

}

var xTestMinimizedResult func(float64, string, ...interface{})

// Report the result of a performance or measurement test.
// The test should generally strive to minimize the reported
// quantities (smaller values are better than larger ones),
// this and @minimized_quantity can determine sorting
// order for test result reports.
func TestMinimizedResult(MinimizedQuantityVar float64, FormatVar string, varArgs ...interface{}) {

	xTestMinimizedResult(MinimizedQuantityVar, FormatVar, varArgs...)

}

var xTestQueueDestroy func(uintptr, uintptr)

// This function enqueus a callback @destroy_func to be executed
// during the next test case teardown phase. This is most useful
// to auto destruct allocated test resources at the end of a test run.
// Resources are released in reverse queue order, that means enqueueing
// callback A before callback B will cause B() to be called before
// A() during teardown.
func TestQueueDestroy(DestroyFuncVar *DestroyNotify, DestroyDataVar uintptr) {

	xTestQueueDestroy(NewCallback(DestroyFuncVar), DestroyDataVar)

}

var xTestQueueFree func(uintptr)

// Enqueue a pointer to be released with g_free() during the next
// teardown phase. This is equivalent to calling g_test_queue_destroy()
// with a destroy callback of g_free().
func TestQueueFree(GfreePointerVar uintptr) {

	xTestQueueFree(GfreePointerVar)

}

var xTestRandDouble func() float64

// Get a reproducible random floating point number,
// see g_test_rand_int() for details on test case random numbers.
func TestRandDouble() float64 {

	cret := xTestRandDouble()
	return cret
}

var xTestRandDoubleRange func(float64, float64) float64

// Get a reproducible random floating pointer number out of a specified range,
// see g_test_rand_int() for details on test case random numbers.
func TestRandDoubleRange(RangeStartVar float64, RangeEndVar float64) float64 {

	cret := xTestRandDoubleRange(RangeStartVar, RangeEndVar)
	return cret
}

var xTestRandInt func() int32

// Get a reproducible random integer number.
//
// The random numbers generated by the g_test_rand_*() family of functions
// change with every new test program start, unless the --seed option is
// given when starting test programs.
//
// For individual test cases however, the random number generator is
// reseeded, to avoid dependencies between tests and to make --seed
// effective for all test cases.
func TestRandInt() int32 {

	cret := xTestRandInt()
	return cret
}

var xTestRandIntRange func(int32, int32) int32

// Get a reproducible random integer number out of a specified range,
// see g_test_rand_int() for details on test case random numbers.
func TestRandIntRange(BeginVar int32, EndVar int32) int32 {

	cret := xTestRandIntRange(BeginVar, EndVar)
	return cret
}

var xTestRun func() int

// Runs all tests under the toplevel suite which can be retrieved
// with g_test_get_root(). Similar to g_test_run_suite(), the test
// cases to be run are filtered according to test path arguments
// (`-p testpath` and `-s testpath`) as parsed by g_test_init().
// g_test_run_suite() or g_test_run() may only be called once in a
// program.
//
// In general, the tests and sub-suites within each suite are run in
// the order in which they are defined. However, note that prior to
// GLib 2.36, there was a bug in the `g_test_add_*`
// functions which caused them to create multiple suites with the same
// name, meaning that if you created tests "/foo/simple",
// "/bar/simple", and "/foo/using-bar" in that order, they would get
// run in that order (since g_test_run() would run the first "/foo"
// suite, then the "/bar" suite, then the second "/foo" suite). As of
// 2.36, this bug is fixed, and adding the tests in that order would
// result in a running order of "/foo/simple", "/foo/using-bar",
// "/bar/simple". If this new ordering is sub-optimal (because it puts
// more-complicated tests before simpler ones, making it harder to
// figure out exactly what has failed), you can fix it by changing the
// test paths to group tests by suite in a way that will result in the
// desired running order. Eg, "/simple/foo", "/simple/bar",
// "/complex/foo-using-bar".
//
// However, you should never make the actual result of a test depend
// on the order that tests are run in. If you need to ensure that some
// particular code runs before or after a given test case, use
// g_test_add(), which lets you specify setup and teardown functions.
//
// If all tests are skipped or marked as incomplete (expected failures),
// this function will return 0 if producing TAP output, or 77 (treated
// as "skip test" by Automake) otherwise.
func TestRun() int {

	cret := xTestRun()
	return cret
}

var xTestRunSuite func(*TestSuite) int

// Execute the tests within @suite and all nested #GTestSuites.
// The test suites to be executed are filtered according to
// test path arguments (`-p testpath` and `-s testpath`) as parsed by
// g_test_init(). See the g_test_run() documentation for more
// information on the order that tests are run in.
//
// g_test_run_suite() or g_test_run() may only be called once
// in a program.
func TestRunSuite(SuiteVar *TestSuite) int {

	cret := xTestRunSuite(SuiteVar)
	return cret
}

var xTestSetNonfatalAssertions func()

// Changes the behaviour of the various `g_assert_*()` macros,
// g_test_assert_expected_messages() and the various
// `g_test_trap_assert_*()` macros to not abort to program, but instead
// call g_test_fail() and continue. (This also changes the behavior of
// g_test_fail() so that it will not cause the test program to abort
// after completing the failed test.)
//
// Note that the g_assert_not_reached() and g_assert() macros are not
// affected by this.
//
// This function can only be called after g_test_init().
func TestSetNonfatalAssertions() {

	xTestSetNonfatalAssertions()

}

var xTestSkip func(string)

// Indicates that a test was skipped.
//
// Calling this function will not stop the test from running, you
// need to return from the test function yourself. So you can
// produce additional diagnostic messages or even continue running
// the test.
//
// If not called from inside a test, this function does nothing.
func TestSkip(MsgVar string) {

	xTestSkip(MsgVar)

}

var xTestSkipPrintf func(string, ...interface{})

// Equivalent to g_test_skip(), but the explanation is formatted
// as if by g_strdup_printf().
func TestSkipPrintf(FormatVar string, varArgs ...interface{}) {

	xTestSkipPrintf(FormatVar, varArgs...)

}

var xTestSubprocess func() bool

// Returns %TRUE (after g_test_init() has been called) if the test
// program is running under g_test_trap_subprocess().
func TestSubprocess() bool {

	cret := xTestSubprocess()
	return cret
}

var xTestSummary func(string)

// Set the summary for a test, which describes what the test checks, and how it
// goes about checking it. This may be included in test report output, and is
// useful documentation for anyone reading the source code or modifying a test
// in future. It must be a single line.
//
// This should be called at the top of a test function.
//
// For example:
// |[&lt;!-- language="C" --&gt;
// static void
// test_array_sort (void)
//
//	{
//	  g_test_summary ("Test my_array_sort() sorts the array correctly and stably, "
//	                  "including testing zero length and one-element arrays.");
//
//	  …
//	}
//
// ]|
func TestSummary(SummaryVar string) {

	xTestSummary(SummaryVar)

}

var xTestTimerElapsed func() float64

// Get the number of seconds since the last start of the timer with
// g_test_timer_start().
func TestTimerElapsed() float64 {

	cret := xTestTimerElapsed()
	return cret
}

var xTestTimerLast func() float64

// Report the last result of g_test_timer_elapsed().
func TestTimerLast() float64 {

	cret := xTestTimerLast()
	return cret
}

var xTestTimerStart func()

// Start a timing test. Call g_test_timer_elapsed() when the task is supposed
// to be done. Call this function again to restart the timer.
func TestTimerStart() {

	xTestTimerStart()

}

var xTestTrapAssertions func(string, string, int, string, uint64, string)

func TestTrapAssertions(DomainVar string, FileVar string, LineVar int, FuncVar string, AssertionFlagsVar uint64, PatternVar string) {

	xTestTrapAssertions(DomainVar, FileVar, LineVar, FuncVar, AssertionFlagsVar, PatternVar)

}

var xTestTrapFork func(uint64, TestTrapFlags) bool

// Fork the current test program to execute a test case that might
// not return or that might abort.
//
// If @usec_timeout is non-0, the forked test case is aborted and
// considered failing if its run time exceeds it.
//
// The forking behavior can be configured with the #GTestTrapFlags flags.
//
// In the following example, the test code forks, the forked child
// process produces some sample output and exits successfully.
// The forking parent process then asserts successful child program
// termination and validates child program outputs.
//
// |[&lt;!-- language="C" --&gt;
//
//	static void
//	test_fork_patterns (void)
//	{
//	  if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR))
//	    {
//	      g_print ("some stdout text: somagic17\n");
//	      g_printerr ("some stderr text: semagic43\n");
//	      exit (0); // successful test run
//	    }
//	  g_test_trap_assert_passed ();
//	  g_test_trap_assert_stdout ("*somagic17*");
//	  g_test_trap_assert_stderr ("*semagic43*");
//	}
//
// ]|
func TestTrapFork(UsecTimeoutVar uint64, TestTrapFlagsVar TestTrapFlags) bool {

	cret := xTestTrapFork(UsecTimeoutVar, TestTrapFlagsVar)
	return cret
}

var xTestTrapHasPassed func() bool

// Check the result of the last g_test_trap_subprocess() call.
func TestTrapHasPassed() bool {

	cret := xTestTrapHasPassed()
	return cret
}

var xTestTrapReachedTimeout func() bool

// Check the result of the last g_test_trap_subprocess() call.
func TestTrapReachedTimeout() bool {

	cret := xTestTrapReachedTimeout()
	return cret
}

var xTestTrapSubprocess func(string, uint64, TestSubprocessFlags)

// Respawns the test program to run only @test_path in a subprocess.
// This can be used for a test case that might not return, or that
// might abort.
//
// If @test_path is %NULL then the same test is re-run in a subprocess.
// You can use g_test_subprocess() to determine whether the test is in
// a subprocess or not.
//
// @test_path can also be the name of the parent test, followed by
// "`/subprocess/`" and then a name for the specific subtest (or just
// ending with "`/subprocess`" if the test only has one child test);
// tests with names of this form will automatically be skipped in the
// parent process.
//
// If @usec_timeout is non-0, the test subprocess is aborted and
// considered failing if its run time exceeds it.
//
// The subprocess behavior can be configured with the
// #GTestSubprocessFlags flags.
//
// You can use methods such as g_test_trap_assert_passed(),
// g_test_trap_assert_failed(), and g_test_trap_assert_stderr() to
// check the results of the subprocess. (But note that
// g_test_trap_assert_stdout() and g_test_trap_assert_stderr()
// cannot be used if @test_flags specifies that the child should
// inherit the parent stdout/stderr.)
//
// If your `main ()` needs to behave differently in
// the subprocess, you can call g_test_subprocess() (after calling
// g_test_init()) to see whether you are in a subprocess.
//
// The following example tests that calling
// `my_object_new(1000000)` will abort with an error
// message.
//
// |[&lt;!-- language="C" --&gt;
//
//	static void
//	test_create_large_object (void)
//	{
//	  if (g_test_subprocess ())
//	    {
//	      my_object_new (1000000);
//	      return;
//	    }
//
//	  // Reruns this same test in a subprocess
//	  g_test_trap_subprocess (NULL, 0, 0);
//	  g_test_trap_assert_failed ();
//	  g_test_trap_assert_stderr ("*ERROR*too large*");
//	}
//
//	int
//	main (int argc, char **argv)
//	{
//	  g_test_init (&amp;argc, &amp;argv, NULL);
//
//	  g_test_add_func ("/myobject/create_large_object",
//	                   test_create_large_object);
//	  return g_test_run ();
//	}
//
// ]|
func TestTrapSubprocess(TestPathVar string, UsecTimeoutVar uint64, TestFlagsVar TestSubprocessFlags) {

	xTestTrapSubprocess(TestPathVar, UsecTimeoutVar, TestFlagsVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xAssertionMessage, lib, "g_assertion_message")
	core.PuregoSafeRegister(&xAssertionMessageCmpnum, lib, "g_assertion_message_cmpnum")
	core.PuregoSafeRegister(&xAssertionMessageCmpstr, lib, "g_assertion_message_cmpstr")
	core.PuregoSafeRegister(&xAssertionMessageCmpstrv, lib, "g_assertion_message_cmpstrv")
	core.PuregoSafeRegister(&xAssertionMessageError, lib, "g_assertion_message_error")
	core.PuregoSafeRegister(&xAssertionMessageExpr, lib, "g_assertion_message_expr")
	core.PuregoSafeRegister(&xStrcmp0, lib, "g_strcmp0")
	core.PuregoSafeRegister(&xTestAddDataFunc, lib, "g_test_add_data_func")
	core.PuregoSafeRegister(&xTestAddDataFuncFull, lib, "g_test_add_data_func_full")
	core.PuregoSafeRegister(&xTestAddFunc, lib, "g_test_add_func")
	core.PuregoSafeRegister(&xTestAddVtable, lib, "g_test_add_vtable")
	core.PuregoSafeRegister(&xTestAssertExpectedMessagesInternal, lib, "g_test_assert_expected_messages_internal")
	core.PuregoSafeRegister(&xTestBug, lib, "g_test_bug")
	core.PuregoSafeRegister(&xTestBugBase, lib, "g_test_bug_base")
	core.PuregoSafeRegister(&xTestBuildFilename, lib, "g_test_build_filename")
	core.PuregoSafeRegister(&xTestCreateCase, lib, "g_test_create_case")
	core.PuregoSafeRegister(&xTestCreateSuite, lib, "g_test_create_suite")
	core.PuregoSafeRegister(&xTestExpectMessage, lib, "g_test_expect_message")
	core.PuregoSafeRegister(&xTestFail, lib, "g_test_fail")
	core.PuregoSafeRegister(&xTestFailPrintf, lib, "g_test_fail_printf")
	core.PuregoSafeRegister(&xTestFailed, lib, "g_test_failed")
	core.PuregoSafeRegister(&xTestGetDir, lib, "g_test_get_dir")
	core.PuregoSafeRegister(&xTestGetFilename, lib, "g_test_get_filename")
	core.PuregoSafeRegister(&xTestGetPath, lib, "g_test_get_path")
	core.PuregoSafeRegister(&xTestGetRoot, lib, "g_test_get_root")
	core.PuregoSafeRegister(&xTestIncomplete, lib, "g_test_incomplete")
	core.PuregoSafeRegister(&xTestIncompletePrintf, lib, "g_test_incomplete_printf")
	core.PuregoSafeRegister(&xTestInit, lib, "g_test_init")
	core.PuregoSafeRegister(&xTestLogSetFatalHandler, lib, "g_test_log_set_fatal_handler")
	core.PuregoSafeRegister(&xTestLogTypeName, lib, "g_test_log_type_name")
	core.PuregoSafeRegister(&xTestMaximizedResult, lib, "g_test_maximized_result")
	core.PuregoSafeRegister(&xTestMessage, lib, "g_test_message")
	core.PuregoSafeRegister(&xTestMinimizedResult, lib, "g_test_minimized_result")
	core.PuregoSafeRegister(&xTestQueueDestroy, lib, "g_test_queue_destroy")
	core.PuregoSafeRegister(&xTestQueueFree, lib, "g_test_queue_free")
	core.PuregoSafeRegister(&xTestRandDouble, lib, "g_test_rand_double")
	core.PuregoSafeRegister(&xTestRandDoubleRange, lib, "g_test_rand_double_range")
	core.PuregoSafeRegister(&xTestRandInt, lib, "g_test_rand_int")
	core.PuregoSafeRegister(&xTestRandIntRange, lib, "g_test_rand_int_range")
	core.PuregoSafeRegister(&xTestRun, lib, "g_test_run")
	core.PuregoSafeRegister(&xTestRunSuite, lib, "g_test_run_suite")
	core.PuregoSafeRegister(&xTestSetNonfatalAssertions, lib, "g_test_set_nonfatal_assertions")
	core.PuregoSafeRegister(&xTestSkip, lib, "g_test_skip")
	core.PuregoSafeRegister(&xTestSkipPrintf, lib, "g_test_skip_printf")
	core.PuregoSafeRegister(&xTestSubprocess, lib, "g_test_subprocess")
	core.PuregoSafeRegister(&xTestSummary, lib, "g_test_summary")
	core.PuregoSafeRegister(&xTestTimerElapsed, lib, "g_test_timer_elapsed")
	core.PuregoSafeRegister(&xTestTimerLast, lib, "g_test_timer_last")
	core.PuregoSafeRegister(&xTestTimerStart, lib, "g_test_timer_start")
	core.PuregoSafeRegister(&xTestTrapAssertions, lib, "g_test_trap_assertions")
	core.PuregoSafeRegister(&xTestTrapFork, lib, "g_test_trap_fork")
	core.PuregoSafeRegister(&xTestTrapHasPassed, lib, "g_test_trap_has_passed")
	core.PuregoSafeRegister(&xTestTrapReachedTimeout, lib, "g_test_trap_reached_timeout")
	core.PuregoSafeRegister(&xTestTrapSubprocess, lib, "g_test_trap_subprocess")

	core.PuregoSafeRegister(&xTestCaseFree, lib, "g_test_case_free")

	core.PuregoSafeRegister(&xTestLogBufferFree, lib, "g_test_log_buffer_free")
	core.PuregoSafeRegister(&xTestLogBufferPop, lib, "g_test_log_buffer_pop")
	core.PuregoSafeRegister(&xTestLogBufferPush, lib, "g_test_log_buffer_push")

	core.PuregoSafeRegister(&xTestLogMsgFree, lib, "g_test_log_msg_free")

	core.PuregoSafeRegister(&xTestSuiteAdd, lib, "g_test_suite_add")
	core.PuregoSafeRegister(&xTestSuiteAddSuite, lib, "g_test_suite_add_suite")
	core.PuregoSafeRegister(&xTestSuiteFree, lib, "g_test_suite_free")

}
