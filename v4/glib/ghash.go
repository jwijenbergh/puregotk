// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Specifies the type of the function passed to
// g_hash_table_foreach_remove(). It is called with each key/value
// pair, together with the @user_data parameter passed to
// g_hash_table_foreach_remove(). It should return %TRUE if the
// key/value pair should be removed from the #GHashTable.
type HRFunc func(uintptr, uintptr, uintptr) bool

// The #GHashTable struct is an opaque data structure to represent a
// [Hash Table][glib-Hash-Tables]. It should only be accessed via the
// following functions.
type HashTable struct {
}

var xHashTableGLibType func() types.GType

func HashTableGLibType() types.GType {
	return xHashTableGLibType()
}

func (x *HashTable) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A GHashTableIter structure represents an iterator that can be used
// to iterate over the elements of a #GHashTable. GHashTableIter
// structures are typically allocated on the stack and then initialized
// with g_hash_table_iter_init().
//
// The iteration order of a #GHashTableIter over the keys/values in a hash
// table is not defined.
type HashTableIter struct {
	Dummy1 uintptr

	Dummy2 uintptr

	Dummy3 uintptr

	Dummy4 int

	Dummy5 bool

	Dummy6 uintptr
}

func (x *HashTableIter) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xHashTableIterGetHashTable func(uintptr) *HashTable

// Returns the #GHashTable associated with @iter.
func (x *HashTableIter) GetHashTable() *HashTable {

	cret := xHashTableIterGetHashTable(x.GoPointer())
	return cret
}

var xHashTableIterInit func(uintptr, *HashTable)

// Initializes a key/value pair iterator and associates it with
// @hash_table. Modifying the hash table after calling this function
// invalidates the returned iterator.
//
// The iteration order of a #GHashTableIter over the keys/values in a hash
// table is not defined.
//
// |[&lt;!-- language="C" --&gt;
// GHashTableIter iter;
// gpointer key, value;
//
// g_hash_table_iter_init (&amp;iter, hash_table);
// while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
//
//	{
//	  // do something with key and value
//	}
//
// ]|
func (x *HashTableIter) Init(HashTableVar *HashTable) {

	xHashTableIterInit(x.GoPointer(), HashTableVar)

}

var xHashTableIterNext func(uintptr, uintptr, uintptr) bool

// Advances @iter and retrieves the key and/or value that are now
// pointed to as a result of this advancement. If %FALSE is returned,
// @key and @value are not set, and the iterator becomes invalid.
func (x *HashTableIter) Next(KeyVar uintptr, ValueVar uintptr) bool {

	cret := xHashTableIterNext(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xHashTableIterRemove func(uintptr)

// Removes the key/value pair currently pointed to by the iterator
// from its associated #GHashTable. Can only be called after
// g_hash_table_iter_next() returned %TRUE, and cannot be called
// more than once for the same key/value pair.
//
// If the #GHashTable was created using g_hash_table_new_full(),
// the key and value are freed using the supplied destroy functions,
// otherwise you have to make sure that any dynamically allocated
// values are freed yourself.
//
// It is safe to continue iterating the #GHashTable afterward:
// |[&lt;!-- language="C" --&gt;
// while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
//
//	{
//	  if (condition)
//	    g_hash_table_iter_remove (&amp;iter);
//	}
//
// ]|
func (x *HashTableIter) Remove() {

	xHashTableIterRemove(x.GoPointer())

}

var xHashTableIterReplace func(uintptr, uintptr)

// Replaces the value currently pointed to by the iterator
// from its associated #GHashTable. Can only be called after
// g_hash_table_iter_next() returned %TRUE.
//
// If you supplied a @value_destroy_func when creating the
// #GHashTable, the old value is freed using that function.
func (x *HashTableIter) Replace(ValueVar uintptr) {

	xHashTableIterReplace(x.GoPointer(), ValueVar)

}

var xHashTableIterSteal func(uintptr)

// Removes the key/value pair currently pointed to by the
// iterator from its associated #GHashTable, without calling
// the key and value destroy functions. Can only be called
// after g_hash_table_iter_next() returned %TRUE, and cannot
// be called more than once for the same key/value pair.
func (x *HashTableIter) Steal() {

	xHashTableIterSteal(x.GoPointer())

}

var xDirectEqual func(uintptr, uintptr) bool

// Compares two #gpointer arguments and returns %TRUE if they are equal.
// It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using opaque pointers compared by pointer value as
// keys in a #GHashTable.
//
// This equality function is also appropriate for keys that are integers
// stored in pointers, such as `GINT_TO_POINTER (n)`.
func DirectEqual(V1Var uintptr, V2Var uintptr) bool {

	cret := xDirectEqual(V1Var, V2Var)
	return cret
}

var xDirectHash func(uintptr) uint

// Converts a gpointer to a hash value.
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using opaque pointers compared by pointer value as keys in a
// #GHashTable.
//
// This hash function is also appropriate for keys that are integers
// stored in pointers, such as `GINT_TO_POINTER (n)`.
func DirectHash(VVar uintptr) uint {

	cret := xDirectHash(VVar)
	return cret
}

var xDoubleEqual func(uintptr, uintptr) bool

// Compares the two #gdouble values being pointed to and returns
// %TRUE if they are equal.
// It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-%NULL pointers to doubles as keys in a
// #GHashTable.
func DoubleEqual(V1Var uintptr, V2Var uintptr) bool {

	cret := xDoubleEqual(V1Var, V2Var)
	return cret
}

var xDoubleHash func(uintptr) uint

// Converts a pointer to a #gdouble to a hash value.
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using non-%NULL pointers to doubles as keys in a #GHashTable.
func DoubleHash(VVar uintptr) uint {

	cret := xDoubleHash(VVar)
	return cret
}

var xHashTableAdd func(*HashTable, uintptr) bool

// This is a convenience function for using a #GHashTable as a set.  It
// is equivalent to calling g_hash_table_replace() with @key as both the
// key and the value.
//
// In particular, this means that if @key already exists in the hash table, then
// the old copy of @key in the hash table is freed and @key replaces it in the
// table.
//
// When a hash table only ever contains keys that have themselves as the
// corresponding value it is able to be stored more efficiently.  See
// the discussion in the section description.
//
// Starting from GLib 2.40, this function returns a boolean value to
// indicate whether the newly added value was already in the hash table
// or not.
func HashTableAdd(HashTableVar *HashTable, KeyVar uintptr) bool {

	cret := xHashTableAdd(HashTableVar, KeyVar)
	return cret
}

var xHashTableContains func(*HashTable, uintptr) bool

// Checks if @key is in @hash_table.
func HashTableContains(HashTableVar *HashTable, KeyVar uintptr) bool {

	cret := xHashTableContains(HashTableVar, KeyVar)
	return cret
}

var xHashTableDestroy func(*HashTable)

// Destroys all keys and values in the #GHashTable and decrements its
// reference count by 1. If keys and/or values are dynamically allocated,
// you should either free them first or create the #GHashTable with destroy
// notifiers using g_hash_table_new_full(). In the latter case the destroy
// functions you supplied will be called on all keys and values during the
// destruction phase.
func HashTableDestroy(HashTableVar *HashTable) {

	xHashTableDestroy(HashTableVar)

}

var xHashTableInsert func(*HashTable, uintptr, uintptr) bool

// Inserts a new key and value into a #GHashTable.
//
// If the key already exists in the #GHashTable its current
// value is replaced with the new value. If you supplied a
// @value_destroy_func when creating the #GHashTable, the old
// value is freed using that function. If you supplied a
// @key_destroy_func when creating the #GHashTable, the passed
// key is freed using that function.
//
// Starting from GLib 2.40, this function returns a boolean value to
// indicate whether the newly added value was already in the hash table
// or not.
func HashTableInsert(HashTableVar *HashTable, KeyVar uintptr, ValueVar uintptr) bool {

	cret := xHashTableInsert(HashTableVar, KeyVar, ValueVar)
	return cret
}

var xHashTableLookup func(*HashTable, uintptr) uintptr

// Looks up a key in a #GHashTable. Note that this function cannot
// distinguish between a key that is not present and one which is present
// and has the value %NULL. If you need this distinction, use
// g_hash_table_lookup_extended().
func HashTableLookup(HashTableVar *HashTable, KeyVar uintptr) uintptr {

	cret := xHashTableLookup(HashTableVar, KeyVar)
	return cret
}

var xHashTableLookupExtended func(*HashTable, uintptr, uintptr, uintptr) bool

// Looks up a key in the #GHashTable, returning the original key and the
// associated value and a #gboolean which is %TRUE if the key was found. This
// is useful if you need to free the memory allocated for the original key,
// for example before calling g_hash_table_remove().
//
// You can actually pass %NULL for @lookup_key to test
// whether the %NULL key exists, provided the hash and equal functions
// of @hash_table are %NULL-safe.
func HashTableLookupExtended(HashTableVar *HashTable, LookupKeyVar uintptr, OrigKeyVar uintptr, ValueVar uintptr) bool {

	cret := xHashTableLookupExtended(HashTableVar, LookupKeyVar, OrigKeyVar, ValueVar)
	return cret
}

var xHashTableNewSimilar func(*HashTable) *HashTable

// Creates a new #GHashTable like g_hash_table_new_full() with a reference
// count of 1.
//
// It inherits the hash function, the key equal function, the key destroy function,
// as well as the value destroy function, from @other_hash_table.
//
// The returned hash table will be empty; it will not contain the keys
// or values from @other_hash_table.
func HashTableNewSimilar(OtherHashTableVar *HashTable) *HashTable {

	cret := xHashTableNewSimilar(OtherHashTableVar)
	return cret
}

var xHashTableRemove func(*HashTable, uintptr) bool

// Removes a key and its associated value from a #GHashTable.
//
// If the #GHashTable was created using g_hash_table_new_full(), the
// key and value are freed using the supplied destroy functions, otherwise
// you have to make sure that any dynamically allocated values are freed
// yourself.
func HashTableRemove(HashTableVar *HashTable, KeyVar uintptr) bool {

	cret := xHashTableRemove(HashTableVar, KeyVar)
	return cret
}

var xHashTableRemoveAll func(*HashTable)

// Removes all keys and their associated values from a #GHashTable.
//
// If the #GHashTable was created using g_hash_table_new_full(),
// the keys and values are freed using the supplied destroy functions,
// otherwise you have to make sure that any dynamically allocated
// values are freed yourself.
func HashTableRemoveAll(HashTableVar *HashTable) {

	xHashTableRemoveAll(HashTableVar)

}

var xHashTableReplace func(*HashTable, uintptr, uintptr) bool

// Inserts a new key and value into a #GHashTable similar to
// g_hash_table_insert(). The difference is that if the key
// already exists in the #GHashTable, it gets replaced by the
// new key. If you supplied a @value_destroy_func when creating
// the #GHashTable, the old value is freed using that function.
// If you supplied a @key_destroy_func when creating the
// #GHashTable, the old key is freed using that function.
//
// Starting from GLib 2.40, this function returns a boolean value to
// indicate whether the newly added value was already in the hash table
// or not.
func HashTableReplace(HashTableVar *HashTable, KeyVar uintptr, ValueVar uintptr) bool {

	cret := xHashTableReplace(HashTableVar, KeyVar, ValueVar)
	return cret
}

var xHashTableSize func(*HashTable) uint

// Returns the number of elements contained in the #GHashTable.
func HashTableSize(HashTableVar *HashTable) uint {

	cret := xHashTableSize(HashTableVar)
	return cret
}

var xHashTableSteal func(*HashTable, uintptr) bool

// Removes a key and its associated value from a #GHashTable without
// calling the key and value destroy functions.
func HashTableSteal(HashTableVar *HashTable, KeyVar uintptr) bool {

	cret := xHashTableSteal(HashTableVar, KeyVar)
	return cret
}

var xHashTableStealAll func(*HashTable)

// Removes all keys and their associated values from a #GHashTable
// without calling the key and value destroy functions.
func HashTableStealAll(HashTableVar *HashTable) {

	xHashTableStealAll(HashTableVar)

}

var xHashTableStealExtended func(*HashTable, uintptr, uintptr, uintptr) bool

// Looks up a key in the #GHashTable, stealing the original key and the
// associated value and returning %TRUE if the key was found. If the key was
// not found, %FALSE is returned.
//
// If found, the stolen key and value are removed from the hash table without
// calling the key and value destroy functions, and ownership is transferred to
// the caller of this method; as with g_hash_table_steal().
//
// You can pass %NULL for @lookup_key, provided the hash and equal functions
// of @hash_table are %NULL-safe.
func HashTableStealExtended(HashTableVar *HashTable, LookupKeyVar uintptr, StolenKeyVar uintptr, StolenValueVar uintptr) bool {

	cret := xHashTableStealExtended(HashTableVar, LookupKeyVar, StolenKeyVar, StolenValueVar)
	return cret
}

var xHashTableUnref func(*HashTable)

// Atomically decrements the reference count of @hash_table by one.
// If the reference count drops to 0, all keys and values will be
// destroyed, and all memory allocated by the hash table is released.
// This function is MT-safe and may be called from any thread.
func HashTableUnref(HashTableVar *HashTable) {

	xHashTableUnref(HashTableVar)

}

var xInt64Equal func(uintptr, uintptr) bool

// Compares the two #gint64 values being pointed to and returns
// %TRUE if they are equal.
// It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-%NULL pointers to 64-bit integers as keys in a
// #GHashTable.
func Int64Equal(V1Var uintptr, V2Var uintptr) bool {

	cret := xInt64Equal(V1Var, V2Var)
	return cret
}

var xInt64Hash func(uintptr) uint

// Converts a pointer to a #gint64 to a hash value.
//
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using non-%NULL pointers to 64-bit integer values as keys in a
// #GHashTable.
func Int64Hash(VVar uintptr) uint {

	cret := xInt64Hash(VVar)
	return cret
}

var xIntEqual func(uintptr, uintptr) bool

// Compares the two #gint values being pointed to and returns
// %TRUE if they are equal.
// It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-%NULL pointers to integers as keys in a
// #GHashTable.
//
// Note that this function acts on pointers to #gint, not on #gint
// directly: if your hash table's keys are of the form
// `GINT_TO_POINTER (n)`, use g_direct_equal() instead.
func IntEqual(V1Var uintptr, V2Var uintptr) bool {

	cret := xIntEqual(V1Var, V2Var)
	return cret
}

var xIntHash func(uintptr) uint

// Converts a pointer to a #gint to a hash value.
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using non-%NULL pointers to integer values as keys in a #GHashTable.
//
// Note that this function acts on pointers to #gint, not on #gint
// directly: if your hash table's keys are of the form
// `GINT_TO_POINTER (n)`, use g_direct_hash() instead.
func IntHash(VVar uintptr) uint {

	cret := xIntHash(VVar)
	return cret
}

var xStrEqual func(uintptr, uintptr) bool

// Compares two strings for byte-by-byte equality and returns %TRUE
// if they are equal. It can be passed to g_hash_table_new() as the
// @key_equal_func parameter, when using non-%NULL strings as keys in a
// #GHashTable.
//
// This function is typically used for hash table comparisons, but can be used
// for general purpose comparisons of non-%NULL strings. For a %NULL-safe string
// comparison function, see g_strcmp0().
func StrEqual(V1Var uintptr, V2Var uintptr) bool {

	cret := xStrEqual(V1Var, V2Var)
	return cret
}

var xStrHash func(uintptr) uint

// Converts a string to a hash value.
//
// This function implements the widely used "djb" hash apparently
// posted by Daniel Bernstein to comp.lang.c some time ago.  The 32
// bit unsigned hash value starts at 5381 and for each byte 'c' in
// the string, is updated: `hash = hash * 33 + c`. This function
// uses the signed value of each byte.
//
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using non-%NULL strings as keys in a #GHashTable.
//
// Note that this function may not be a perfect fit for all use cases.
// For example, it produces some hash collisions with strings as short
// as 2.
func StrHash(VVar uintptr) uint {

	cret := xStrHash(VVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xDirectEqual, lib, "g_direct_equal")
	core.PuregoSafeRegister(&xDirectHash, lib, "g_direct_hash")
	core.PuregoSafeRegister(&xDoubleEqual, lib, "g_double_equal")
	core.PuregoSafeRegister(&xDoubleHash, lib, "g_double_hash")
	core.PuregoSafeRegister(&xHashTableAdd, lib, "g_hash_table_add")
	core.PuregoSafeRegister(&xHashTableContains, lib, "g_hash_table_contains")
	core.PuregoSafeRegister(&xHashTableDestroy, lib, "g_hash_table_destroy")
	core.PuregoSafeRegister(&xHashTableInsert, lib, "g_hash_table_insert")
	core.PuregoSafeRegister(&xHashTableLookup, lib, "g_hash_table_lookup")
	core.PuregoSafeRegister(&xHashTableLookupExtended, lib, "g_hash_table_lookup_extended")
	core.PuregoSafeRegister(&xHashTableNewSimilar, lib, "g_hash_table_new_similar")
	core.PuregoSafeRegister(&xHashTableRemove, lib, "g_hash_table_remove")
	core.PuregoSafeRegister(&xHashTableRemoveAll, lib, "g_hash_table_remove_all")
	core.PuregoSafeRegister(&xHashTableReplace, lib, "g_hash_table_replace")
	core.PuregoSafeRegister(&xHashTableSize, lib, "g_hash_table_size")
	core.PuregoSafeRegister(&xHashTableSteal, lib, "g_hash_table_steal")
	core.PuregoSafeRegister(&xHashTableStealAll, lib, "g_hash_table_steal_all")
	core.PuregoSafeRegister(&xHashTableStealExtended, lib, "g_hash_table_steal_extended")
	core.PuregoSafeRegister(&xHashTableUnref, lib, "g_hash_table_unref")
	core.PuregoSafeRegister(&xInt64Equal, lib, "g_int64_equal")
	core.PuregoSafeRegister(&xInt64Hash, lib, "g_int64_hash")
	core.PuregoSafeRegister(&xIntEqual, lib, "g_int_equal")
	core.PuregoSafeRegister(&xIntHash, lib, "g_int_hash")
	core.PuregoSafeRegister(&xStrEqual, lib, "g_str_equal")
	core.PuregoSafeRegister(&xStrHash, lib, "g_str_hash")

	core.PuregoSafeRegister(&xHashTableGLibType, lib, "g_hash_table_get_type")

	core.PuregoSafeRegister(&xHashTableIterGetHashTable, lib, "g_hash_table_iter_get_hash_table")
	core.PuregoSafeRegister(&xHashTableIterInit, lib, "g_hash_table_iter_init")
	core.PuregoSafeRegister(&xHashTableIterNext, lib, "g_hash_table_iter_next")
	core.PuregoSafeRegister(&xHashTableIterRemove, lib, "g_hash_table_iter_remove")
	core.PuregoSafeRegister(&xHashTableIterReplace, lib, "g_hash_table_iter_replace")
	core.PuregoSafeRegister(&xHashTableIterSteal, lib, "g_hash_table_iter_steal")

}
