// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// Specifies the type of a comparison function used to compare two
// values.  The function should return a negative integer if the first
// value comes before the second, 0 if they are equal, or a positive
// integer if the first value comes after the second.
type CompareDataFunc func(uintptr, uintptr, uintptr) int

// Specifies the type of a comparison function used to compare two
// values.  The function should return a negative integer if the first
// value comes before the second, 0 if they are equal, or a positive
// integer if the first value comes after the second.
type CompareFunc func(uintptr, uintptr) int

// A function of this signature is used to copy the node data
// when doing a deep-copy of a tree.
type CopyFunc func(uintptr, uintptr) uintptr

// Specifies the type of function which is called when a data element
// is destroyed. It is passed the pointer to the data element and
// should free any memory and resources allocated for it.
type DestroyNotify func(uintptr)

// Specifies the type of a function used to test two values for
// equality. The function should return %TRUE if both values are equal
// and %FALSE otherwise.
type EqualFunc func(uintptr, uintptr) bool

// Declares a type of function which takes an arbitrary
// data pointer argument and has no return value. It is
// not currently used in GLib or GTK+.
type FreeFunc func(uintptr)

// Specifies the type of functions passed to g_list_foreach() and
// g_slist_foreach().
type Func func(uintptr, uintptr)

// Specifies the type of the function passed to g_hash_table_foreach().
// It is called with each key/value pair, together with the @user_data
// parameter which is passed to g_hash_table_foreach().
type HFunc func(uintptr, uintptr, uintptr)

// Specifies the type of the hash function which is passed to
// g_hash_table_new() when a #GHashTable is created.
//
// The function is passed a key and should return a #guint hash value.
// The functions g_direct_hash(), g_int_hash() and g_str_hash() provide
// hash functions which can be used when the key is a #gpointer, #gint*,
// and #gchar* respectively.
//
// g_direct_hash() is also the appropriate hash function for keys
// of the form `GINT_TO_POINTER (n)` (or similar macros).
//
// A good hash functions should produce
// hash values that are evenly distributed over a fairly large range.
// The modulus is taken with the hash table size (a prime number) to
// find the 'bucket' to place each key into. The function should also
// be very fast, since it is called for each key lookup.
//
// Note that the hash functions provided by GLib have these qualities,
// but are not particularly robust against manufactured keys that
// cause hash collisions. Therefore, you should consider choosing
// a more secure hash function when using a GHashTable with keys
// that originate in untrusted data (such as HTTP requests).
// Using g_str_hash() in that situation might make your application
// vulnerable to
// [Algorithmic Complexity Attacks](https://lwn.net/Articles/474912/).
//
// The key to choosing a good hash is unpredictability.  Even
// cryptographic hashes are very easy to find collisions for when the
// remainder is taken modulo a somewhat predictable prime number.  There
// must be an element of randomness that an attacker is unable to guess.
type HashFunc func(uintptr) uint

// The type of functions which are used to translate user-visible
// strings, for &lt;option&gt;--help&lt;/option&gt; output.
type TranslateFunc func(string, uintptr) string

// Represents a precise time, with seconds and microseconds.
//
// Similar to the struct timeval returned by the `gettimeofday()`
// UNIX system call.
//
// GLib is attempting to unify around the use of 64-bit integers to
// represent microsecond-precision time. As such, this type will be
// removed from a future version of GLib. A consequence of using `glong` for
// `tv_sec` is that on 32-bit systems `GTimeVal` is subject to the year 2038
// problem.
type TimeVal struct {
	_ structs.HostLayout

	TvSec int32

	TvUsec int32
}

func (x *TimeVal) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xTimeValAdd func(uintptr, int32)

// Adds the given number of microseconds to @time_. @microseconds can
// also be negative to decrease the value of @time_.
func (x *TimeVal) Add(MicrosecondsVar int32) {

	xTimeValAdd(x.GoPointer(), MicrosecondsVar)

}

var xTimeValToIso8601 func(uintptr) string

// Converts @time_ into an RFC 3339 encoded string, relative to the
// Coordinated Universal Time (UTC). This is one of the many formats
// allowed by ISO 8601.
//
// ISO 8601 allows a large number of date/time formats, with or without
// punctuation and optional elements. The format returned by this function
// is a complete date and time, with optional punctuation included, the
// UTC time zone represented as "Z", and the @tv_usec part included if
// and only if it is nonzero, i.e. either
// "YYYY-MM-DDTHH:MM:SSZ" or "YYYY-MM-DDTHH:MM:SS.fffffZ".
//
// This corresponds to the Internet date/time format defined by
// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt),
// and to either of the two most-precise formats defined by
// the W3C Note
// [Date and Time Formats](http://www.w3.org/TR/NOTE-datetime-19980827).
// Both of these documents are profiles of ISO 8601.
//
// Use g_date_time_format() or g_strdup_printf() if a different
// variation of ISO 8601 format is required.
//
// If @time_ represents a date which is too large to fit into a `struct tm`,
// %NULL will be returned. This is platform dependent. Note also that since
// `GTimeVal` stores the number of seconds as a `glong`, on 32-bit systems it
// is subject to the year 2038 problem. Accordingly, since GLib 2.62, this
// function has been deprecated. Equivalent functionality is available using:
// |[
// GDateTime *dt = g_date_time_new_from_unix_utc (time_val);
// iso8601_string = g_date_time_format_iso8601 (dt);
// g_date_time_unref (dt);
// ]|
//
// The return value of g_time_val_to_iso8601() has been nullable since GLib
// 2.54; before then, GLib would crash under the same conditions.
func (x *TimeVal) ToIso8601() string {

	cret := xTimeValToIso8601(x.GoPointer())
	return cret
}

// The #GFloatIEEE754 and #GDoubleIEEE754 unions are used to access the sign,
// mantissa and exponent of IEEE floats and doubles. These unions are defined
// as appropriate for a given platform. IEEE floats and doubles are supported
// (used for storage) by at least Intel, PPC and Sparc.
type DoubleIEEE754 = uintptr

// The #GFloatIEEE754 and #GDoubleIEEE754 unions are used to access the sign,
// mantissa and exponent of IEEE floats and doubles. These unions are defined
// as appropriate for a given platform. IEEE floats and doubles are supported
// (used for storage) by at least Intel, PPC and Sparc.
type FloatIEEE754 = uintptr

const (
	// Specifies one of the possible types of byte order.
	// See %G_BYTE_ORDER.
	BIG_ENDIAN int = 4321
	// The base of natural logarithms.
	E float64 = 2.718282
	// The bias by which exponents in double-precision floats are offset.
	IEEE754_DOUBLE_BIAS int = 1023
	// The bias by which exponents in single-precision floats are offset.
	IEEE754_FLOAT_BIAS int = 127
	// Specifies one of the possible types of byte order.
	// See %G_BYTE_ORDER.
	LITTLE_ENDIAN int = 1234
	// The natural logarithm of 10.
	LN10 float64 = 2.302585
	// The natural logarithm of 2.
	LN2 float64 = 0.693147
	// Multiplying the base 2 exponent by this number yields the base 10 exponent.
	LOG_2_BASE_10 float64 = 0.301030
	// The maximum value which can be held in a #gint16.
	MAXINT16 int16 = 32767
	// The maximum value which can be held in a #gint32.
	MAXINT32 int32 = 2147483647
	// The maximum value which can be held in a #gint64.
	MAXINT64 int64 = 9223372036854775807
	// The maximum value which can be held in a #gint8.
	MAXINT8 int8 = 127
	// The maximum value which can be held in a #guint16.
	MAXUINT16 uint16 = 65535
	// The maximum value which can be held in a #guint32.
	MAXUINT32 uint32 = 4294967295
	// The maximum value which can be held in a #guint64.
	MAXUINT64 uint64 = 18446744073709551615
	// The maximum value which can be held in a #guint8.
	MAXUINT8 byte = 255
	// The minimum value which can be held in a #gint16.
	MININT16 int16 = -32768
	// The minimum value which can be held in a #gint32.
	MININT32 int32 = -2147483648
	// The minimum value which can be held in a #gint64.
	MININT64 int64 = -9223372036854775808
	// The minimum value which can be held in a #gint8.
	MININT8 int8 = -128
	// Specifies one of the possible types of byte order
	// (currently unused). See %G_BYTE_ORDER.
	PDP_ENDIAN int = 3412
	// The value of pi (ratio of circle's circumference to its diameter).
	PI float64 = 3.141593
	// Pi divided by 2.
	PI_2 float64 = 1.570796
	// Pi divided by 4.
	PI_4 float64 = 0.785398
	// The square root of two.
	SQRT2 float64 = 1.414214
)

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xTimeValAdd, lib, "g_time_val_add")
	core.PuregoSafeRegister(&xTimeValToIso8601, lib, "g_time_val_to_iso8601")

}
