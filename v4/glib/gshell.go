// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// Error codes returned by shell functions.
type ShellError int

const (

	// Mismatched or otherwise mangled quoting.
	GShellErrorBadQuotingValue ShellError = 0
	// String to be parsed was empty.
	GShellErrorEmptyStringValue ShellError = 1
	// Some other error.
	GShellErrorFailedValue ShellError = 2
)

var xShellParseArgv func(string, int, []string, **Error) bool

// Parses a command line into an argument vector, in much the same way
// the shell would, but without many of the expansions the shell would
// perform (variable expansion, globs, operators, filename expansion,
// etc. are not supported).
//
// The results are defined to be the same as those you would get from
// a UNIX98 `/bin/sh`, as long as the input contains none of the
// unsupported shell expansions. If the input does contain such expansions,
// they are passed through literally.
//
// Possible errors are those from the %G_SHELL_ERROR domain.
//
// In particular, if @command_line is an empty string (or a string containing
// only whitespace), %G_SHELL_ERROR_EMPTY_STRING will be returned. It’s
// guaranteed that @argvp will be a non-empty array if this function returns
// successfully.
//
// Free the returned vector with g_strfreev().
func ShellParseArgv(CommandLineVar string, ArgcpVar int, ArgvpVar []string) (bool, error) {
	var cerr *Error

	cret := xShellParseArgv(CommandLineVar, ArgcpVar, ArgvpVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xShellQuote func(string) string

// Quotes a string so that the shell (/bin/sh) will interpret the
// quoted string to mean @unquoted_string.
//
// If you pass a filename to the shell, for example, you should first
// quote it with this function.
//
// The return value must be freed with g_free().
//
// The quoting style used is undefined (single or double quotes may be
// used).
func ShellQuote(UnquotedStringVar string) string {

	cret := xShellQuote(UnquotedStringVar)
	return cret
}

var xShellUnquote func(string, **Error) string

// Unquotes a string as the shell (/bin/sh) would.
//
// This function only handles quotes; if a string contains file globs,
// arithmetic operators, variables, backticks, redirections, or other
// special-to-the-shell features, the result will be different from the
// result a real shell would produce (the variables, backticks, etc.
// will be passed through literally instead of being expanded).
//
// This function is guaranteed to succeed if applied to the result of
// g_shell_quote(). If it fails, it returns %NULL and sets the
// error.
//
// The @quoted_string need not actually contain quoted or escaped text;
// g_shell_unquote() simply goes through the string and unquotes/unescapes
// anything that the shell would. Both single and double quotes are
// handled, as are escapes including escaped newlines.
//
// The return value must be freed with g_free().
//
// Possible errors are in the %G_SHELL_ERROR domain.
//
// Shell quoting rules are a bit strange. Single quotes preserve the
// literal string exactly. escape sequences are not allowed; not even
// `\'` - if you want a `'` in the quoted text, you have to do something
// like `'foo'\”bar'`. Double quotes allow `$`, ```, `"`, `\`, and
// newline to be escaped with backslash. Otherwise double quotes
// preserve things literally.
func ShellUnquote(QuotedStringVar string) (string, error) {
	var cerr *Error

	cret := xShellUnquote(QuotedStringVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xShellParseArgv, lib, "g_shell_parse_argv")
	core.PuregoSafeRegister(&xShellQuote, lib, "g_shell_quote")
	core.PuregoSafeRegister(&xShellUnquote, lib, "g_shell_unquote")

}
