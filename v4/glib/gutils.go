// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// Declares a type of function which takes no arguments
// and has no return value. It is used to specify the type
// function passed to g_atexit().
type VoidFunc func()

// Associates a string with a bit flag.
// Used in g_parse_debug_string().
type DebugKey struct {
	_ structs.HostLayout

	Key uintptr

	Value uint
}

func (x *DebugKey) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Flags to modify the format of the string returned by g_format_size_full().
type FormatSizeFlags int

const (

	// behave the same as g_format_size()
	GFormatSizeDefaultValue FormatSizeFlags = 0
	// include the exact number of bytes as part
	//     of the returned string.  For example, "45.6 kB (45,612 bytes)".
	GFormatSizeLongFormatValue FormatSizeFlags = 1
	// use IEC (base 1024) units with "KiB"-style
	//     suffixes. IEC units should only be used for reporting things with
	//     a strong "power of 2" basis, like RAM sizes or RAID stripe sizes.
	//     Network and storage sizes should be reported in the normal SI units.
	GFormatSizeIecUnitsValue FormatSizeFlags = 2
	// set the size as a quantity in bits, rather than
	//     bytes, and return units in bits. For example, ‘Mb’ rather than ‘MB’.
	GFormatSizeBitsValue FormatSizeFlags = 4
)

// These are logical ids for special directories which are defined
// depending on the platform used. You should use g_get_user_special_dir()
// to retrieve the full path associated to the logical id.
//
// The #GUserDirectory enumeration can be extended at later date. Not
// every platform has a directory for every logical id in this
// enumeration.
type UserDirectory int

const (

	// the user's Desktop directory
	GUserDirectoryDesktopValue UserDirectory = 0
	// the user's Documents directory
	GUserDirectoryDocumentsValue UserDirectory = 1
	// the user's Downloads directory
	GUserDirectoryDownloadValue UserDirectory = 2
	// the user's Music directory
	GUserDirectoryMusicValue UserDirectory = 3
	// the user's Pictures directory
	GUserDirectoryPicturesValue UserDirectory = 4
	// the user's shared directory
	GUserDirectoryPublicShareValue UserDirectory = 5
	// the user's Templates directory
	GUserDirectoryTemplatesValue UserDirectory = 6
	// the user's Movies directory
	GUserDirectoryVideosValue UserDirectory = 7
	// the number of enum values
	GUserNDirectoriesValue UserDirectory = 8
)

var xAtexit func(uintptr)

// Specifies a function to be called at normal program termination.
//
// Since GLib 2.8.2, on Windows g_atexit() actually is a preprocessor
// macro that maps to a call to the atexit() function in the C
// library. This means that in case the code that calls g_atexit(),
// i.e. atexit(), is in a DLL, the function will be called when the
// DLL is detached from the program. This typically makes more sense
// than that the function is called when the GLib DLL is detached,
// which happened earlier when g_atexit() was a function in the GLib
// DLL.
//
// The behaviour of atexit() in the context of dynamically loaded
// modules is not formally specified and varies wildly.
//
// On POSIX systems, calling g_atexit() (or atexit()) in a dynamically
// loaded module which is unloaded before the program terminates might
// well cause a crash at program exit.
//
// Some POSIX systems implement atexit() like Windows, and have each
// dynamically loaded module maintain an own atexit chain that is
// called when the module is unloaded.
//
// On other POSIX systems, before a dynamically loaded module is
// unloaded, the registered atexit functions (if any) residing in that
// module are called, regardless where the code that registered them
// resided. This is presumably the most robust approach.
//
// As can be seen from the above, for portability it's best to avoid
// calling g_atexit() (or atexit()) except in the main executable of a
// program.
func Atexit(FuncVar *VoidFunc) {

	xAtexit(NewCallback(FuncVar))

}

var xBitNthLsf func(uint32, int) int

// Find the position of the first bit set in @mask, searching
// from (but not including) @nth_bit upwards. Bits are numbered
// from 0 (least significant) to sizeof(#gulong) * 8 - 1 (31 or 63,
// usually). To start searching from the 0th bit, set @nth_bit to -1.
func BitNthLsf(MaskVar uint32, NthBitVar int) int {

	cret := xBitNthLsf(MaskVar, NthBitVar)
	return cret
}

var xBitNthMsf func(uint32, int) int

// Find the position of the first bit set in @mask, searching
// from (but not including) @nth_bit downwards. Bits are numbered
// from 0 (least significant) to sizeof(#gulong) * 8 - 1 (31 or 63,
// usually). To start searching from the last bit, set @nth_bit to
// -1 or GLIB_SIZEOF_LONG * 8.
func BitNthMsf(MaskVar uint32, NthBitVar int) int {

	cret := xBitNthMsf(MaskVar, NthBitVar)
	return cret
}

var xBitStorage func(uint32) uint

// Gets the number of bits used to hold @number,
// e.g. if @number is 4, 3 bits are needed.
func BitStorage(NumberVar uint32) uint {

	cret := xBitStorage(NumberVar)
	return cret
}

var xFindProgramInPath func(string) string

// Locates the first executable named @program in the user's path, in the
// same way that execvp() would locate it. Returns an allocated string
// with the absolute path name, or %NULL if the program is not found in
// the path. If @program is already an absolute path, returns a copy of
// @program if @program exists and is executable, and %NULL otherwise.
//
// On Windows, if @program does not have a file type suffix, tries
// with the suffixes .exe, .cmd, .bat and .com, and the suffixes in
// the `PATHEXT` environment variable.
//
// On Windows, it looks for the file in the same way as CreateProcess()
// would. This means first in the directory where the executing
// program was loaded from, then in the current directory, then in the
// Windows 32-bit system directory, then in the Windows directory, and
// finally in the directories in the `PATH` environment variable. If
// the program is found, the return value contains the full name
// including the type suffix.
func FindProgramInPath(ProgramVar string) string {

	cret := xFindProgramInPath(ProgramVar)
	return cret
}

var xFormatSize func(uint64) string

// Formats a size (for example the size of a file) into a human readable
// string.  Sizes are rounded to the nearest size prefix (kB, MB, GB)
// and are displayed rounded to the nearest tenth. E.g. the file size
// 3292528 bytes will be converted into the string "3.2 MB". The returned string
// is UTF-8, and may use a non-breaking space to separate the number and units,
// to ensure they aren’t separated when line wrapped.
//
// The prefix units base is 1000 (i.e. 1 kB is 1000 bytes).
//
// This string should be freed with g_free() when not needed any longer.
//
// See g_format_size_full() for more options about how the size might be
// formatted.
func FormatSize(SizeVar uint64) string {

	cret := xFormatSize(SizeVar)
	return cret
}

var xFormatSizeForDisplay func(int64) string

// Formats a size (for example the size of a file) into a human
// readable string. Sizes are rounded to the nearest size prefix
// (KB, MB, GB) and are displayed rounded to the nearest tenth.
// E.g. the file size 3292528 bytes will be converted into the
// string "3.1 MB".
//
// The prefix units base is 1024 (i.e. 1 KB is 1024 bytes).
//
// This string should be freed with g_free() when not needed any longer.
func FormatSizeForDisplay(SizeVar int64) string {

	cret := xFormatSizeForDisplay(SizeVar)
	return cret
}

var xFormatSizeFull func(uint64, FormatSizeFlags) string

// Formats a size.
//
// This function is similar to g_format_size() but allows for flags
// that modify the output. See #GFormatSizeFlags.
func FormatSizeFull(SizeVar uint64, FlagsVar FormatSizeFlags) string {

	cret := xFormatSizeFull(SizeVar, FlagsVar)
	return cret
}

var xGetApplicationName func() string

// Gets a human-readable name for the application, as set by
// g_set_application_name(). This name should be localized if
// possible, and is intended for display to the user.  Contrast with
// g_get_prgname(), which gets a non-localized name. If
// g_set_application_name() has not been called, returns the result of
// g_get_prgname() (which may be %NULL if g_set_prgname() has also not
// been called).
func GetApplicationName() string {

	cret := xGetApplicationName()
	return cret
}

var xGetHomeDir func() string

// Gets the current user's home directory.
//
// As with most UNIX tools, this function will return the value of the
// `HOME` environment variable if it is set to an existing absolute path
// name, falling back to the `passwd` file in the case that it is unset.
//
// If the path given in `HOME` is non-absolute, does not exist, or is
// not a directory, the result is undefined.
//
// Before version 2.36 this function would ignore the `HOME` environment
// variable, taking the value from the `passwd` database instead. This was
// changed to increase the compatibility of GLib with other programs (and
// the XDG basedir specification) and to increase testability of programs
// based on GLib (by making it easier to run them from test frameworks).
//
// If your program has a strong requirement for either the new or the
// old behaviour (and if you don't wish to increase your GLib
// dependency to ensure that the new behaviour is in effect) then you
// should either directly check the `HOME` environment variable yourself
// or unset it before calling any functions in GLib.
func GetHomeDir() string {

	cret := xGetHomeDir()
	return cret
}

var xGetHostName func() string

// Return a name for the machine.
//
// The returned name is not necessarily a fully-qualified domain name,
// or even present in DNS or some other name service at all. It need
// not even be unique on your local network or site, but usually it
// is. Callers should not rely on the return value having any specific
// properties like uniqueness for security purposes. Even if the name
// of the machine is changed while an application is running, the
// return value from this function does not change. The returned
// string is owned by GLib and should not be modified or freed. If no
// name can be determined, a default fixed string "localhost" is
// returned.
//
// The encoding of the returned string is UTF-8.
func GetHostName() string {

	cret := xGetHostName()
	return cret
}

var xGetOsInfo func(string) string

// Get information about the operating system.
//
// On Linux this comes from the `/etc/os-release` file. On other systems, it may
// come from a variety of sources. You can either use the standard key names
// like %G_OS_INFO_KEY_NAME or pass any UTF-8 string key name. For example,
// `/etc/os-release` provides a number of other less commonly used values that may
// be useful. No key is guaranteed to be provided, so the caller should always
// check if the result is %NULL.
func GetOsInfo(KeyNameVar string) string {

	cret := xGetOsInfo(KeyNameVar)
	return cret
}

var xGetPrgname func() string

// Gets the name of the program. This name should not be localized,
// in contrast to g_get_application_name().
//
// If you are using #GApplication the program name is set in
// g_application_run(). In case of GDK or GTK+ it is set in
// gdk_init(), which is called by gtk_init() and the
// #GtkApplication::startup handler. The program name is found by
// taking the last component of @argv[0].
func GetPrgname() string {

	cret := xGetPrgname()
	return cret
}

var xGetRealName func() string

// Gets the real name of the user. This usually comes from the user's
// entry in the `passwd` file. The encoding of the returned string is
// system-defined. (On Windows, it is, however, always UTF-8.) If the
// real user name cannot be determined, the string "Unknown" is
// returned.
func GetRealName() string {

	cret := xGetRealName()
	return cret
}

var xGetSystemConfigDirs func() []string

// Returns an ordered list of base directories in which to access
// system-wide configuration information.
//
// On UNIX platforms this is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
// In this case the list of directories retrieved will be `XDG_CONFIG_DIRS`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_DIRS` is defined.
// If `XDG_CONFIG_DIRS` is undefined, the directory that contains application
// data for all users is used instead. A typical path is
// `C:\Documents and Settings\All Users\Application Data`.
// This folder is used for application data
// that is not user specific. For example, an application can store
// a spell-check dictionary, a database of clip art, or a log file in the
// FOLDERID_ProgramData folder. This information will not roam and is available
// to anyone using the computer.
//
// The return value is cached and modifying it at runtime is not supported, as
// it’s not thread-safe to modify environment variables at runtime.
func GetSystemConfigDirs() []string {

	cret := xGetSystemConfigDirs()
	return cret
}

var xGetSystemDataDirs func() []string

// Returns an ordered list of base directories in which to access
// system-wide application data.
//
// On UNIX platforms this is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec)
// In this case the list of directories retrieved will be `XDG_DATA_DIRS`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_DATA_DIRS` is defined.
// If `XDG_DATA_DIRS` is undefined,
// the first elements in the list are the Application Data
// and Documents folders for All Users. (These can be determined only
// on Windows 2000 or later and are not present in the list on other
// Windows versions.) See documentation for FOLDERID_ProgramData and
// FOLDERID_PublicDocuments.
//
// Then follows the "share" subfolder in the installation folder for
// the package containing the DLL that calls this function, if it can
// be determined.
//
// Finally the list contains the "share" subfolder in the installation
// folder for GLib, and in the installation folder for the package the
// application's .exe file belongs to.
//
// The installation folders above are determined by looking up the
// folder where the module (DLL or EXE) in question is located. If the
// folder's name is "bin", its parent is used, otherwise the folder
// itself.
//
// Note that on Windows the returned list can vary depending on where
// this function is called.
//
// The return value is cached and modifying it at runtime is not supported, as
// it’s not thread-safe to modify environment variables at runtime.
func GetSystemDataDirs() []string {

	cret := xGetSystemDataDirs()
	return cret
}

var xGetTmpDir func() string

// Gets the directory to use for temporary files.
//
// On UNIX, this is taken from the `TMPDIR` environment variable.
// If the variable is not set, `P_tmpdir` is
// used, as defined by the system C library. Failing that, a
// hard-coded default of "/tmp" is returned.
//
// On Windows, the `TEMP` environment variable is used, with the
// root directory of the Windows installation (eg: "C:\") used
// as a default.
//
// The encoding of the returned string is system-defined. On Windows,
// it is always UTF-8. The return value is never %NULL or the empty
// string.
func GetTmpDir() string {

	cret := xGetTmpDir()
	return cret
}

var xGetUserCacheDir func() string

// Returns a base directory in which to store non-essential, cached
// data specific to particular user.
//
// On UNIX platforms this is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
// In this case the directory retrieved will be `XDG_CACHE_HOME`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_CACHE_HOME` is defined.
// If `XDG_CACHE_HOME` is undefined, the directory that serves as a common
// repository for temporary Internet files is used instead. A typical path is
// `C:\Documents and Settings\username\Local Settings\Temporary Internet Files`.
// See the [documentation for `FOLDERID_InternetCache`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
//
// The return value is cached and modifying it at runtime is not supported, as
// it’s not thread-safe to modify environment variables at runtime.
func GetUserCacheDir() string {

	cret := xGetUserCacheDir()
	return cret
}

var xGetUserConfigDir func() string

// Returns a base directory in which to store user-specific application
// configuration information such as user preferences and settings.
//
// On UNIX platforms this is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
// In this case the directory retrieved will be `XDG_CONFIG_HOME`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_HOME` is defined.
// If `XDG_CONFIG_HOME` is undefined, the folder to use for local (as opposed
// to roaming) application data is used instead. See the
// [documentation for `FOLDERID_LocalAppData`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
// Note that in this case on Windows it will be  the same
// as what g_get_user_data_dir() returns.
//
// The return value is cached and modifying it at runtime is not supported, as
// it’s not thread-safe to modify environment variables at runtime.
func GetUserConfigDir() string {

	cret := xGetUserConfigDir()
	return cret
}

var xGetUserDataDir func() string

// Returns a base directory in which to access application data such
// as icons that is customized for a particular user.
//
// On UNIX platforms this is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
// In this case the directory retrieved will be `XDG_DATA_HOME`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_DATA_HOME`
// is defined. If `XDG_DATA_HOME` is undefined, the folder to use for local (as
// opposed to roaming) application data is used instead. See the
// [documentation for `FOLDERID_LocalAppData`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
// Note that in this case on Windows it will be the same
// as what g_get_user_config_dir() returns.
//
// The return value is cached and modifying it at runtime is not supported, as
// it’s not thread-safe to modify environment variables at runtime.
func GetUserDataDir() string {

	cret := xGetUserDataDir()
	return cret
}

var xGetUserName func() string

// Gets the user name of the current user. The encoding of the returned
// string is system-defined. On UNIX, it might be the preferred file name
// encoding, or something else, and there is no guarantee that it is even
// consistent on a machine. On Windows, it is always UTF-8.
func GetUserName() string {

	cret := xGetUserName()
	return cret
}

var xGetUserRuntimeDir func() string

// Returns a directory that is unique to the current user on the local
// system.
//
// This is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
// This is the directory
// specified in the `XDG_RUNTIME_DIR` environment variable.
// In the case that this variable is not set, we return the value of
// g_get_user_cache_dir(), after verifying that it exists.
//
// The return value is cached and modifying it at runtime is not supported, as
// it’s not thread-safe to modify environment variables at runtime.
func GetUserRuntimeDir() string {

	cret := xGetUserRuntimeDir()
	return cret
}

var xGetUserSpecialDir func(UserDirectory) string

// Returns the full path of a special directory using its logical id.
//
// On UNIX this is done using the XDG special user directories.
// For compatibility with existing practise, %G_USER_DIRECTORY_DESKTOP
// falls back to `$HOME/Desktop` when XDG special user directories have
// not been set up.
//
// Depending on the platform, the user might be able to change the path
// of the special directory without requiring the session to restart; GLib
// will not reflect any change once the special directories are loaded.
func GetUserSpecialDir(DirectoryVar UserDirectory) string {

	cret := xGetUserSpecialDir(DirectoryVar)
	return cret
}

var xGetUserStateDir func() string

// Returns a base directory in which to store state files specific to
// particular user.
//
// On UNIX platforms this is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
// In this case the directory retrieved will be `XDG_STATE_HOME`.
//
// On Windows it follows XDG Base Directory Specification if `XDG_STATE_HOME` is defined.
// If `XDG_STATE_HOME` is undefined, the folder to use for local (as opposed
// to roaming) application data is used instead. See the
// [documentation for `FOLDERID_LocalAppData`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
// Note that in this case on Windows it will be the same
// as what g_get_user_data_dir() returns.
//
// The return value is cached and modifying it at runtime is not supported, as
// it’s not thread-safe to modify environment variables at runtime.
func GetUserStateDir() string {

	cret := xGetUserStateDir()
	return cret
}

var xNullifyPointer func(uintptr)

// Set the pointer at the specified location to %NULL.
func NullifyPointer(NullifyLocationVar uintptr) {

	xNullifyPointer(NullifyLocationVar)

}

var xParseDebugString func(string, []DebugKey, uint) uint

// Parses a string containing debugging options
// into a %guint containing bit flags. This is used
// within GDK and GTK+ to parse the debug options passed on the
// command line or through environment variables.
//
// If @string is equal to "all", all flags are set. Any flags
// specified along with "all" in @string are inverted; thus,
// "all,foo,bar" or "foo,bar,all" sets all flags except those
// corresponding to "foo" and "bar".
//
// If @string is equal to "help", all the available keys in @keys
// are printed out to standard error.
func ParseDebugString(StringVar string, KeysVar []DebugKey, NkeysVar uint) uint {

	cret := xParseDebugString(StringVar, KeysVar, NkeysVar)
	return cret
}

var xReloadUserSpecialDirsCache func()

// Resets the cache used for g_get_user_special_dir(), so
// that the latest on-disk version is used. Call this only
// if you just changed the data on disk yourself.
//
// Due to thread safety issues this may cause leaking of strings
// that were previously returned from g_get_user_special_dir()
// that can't be freed. We ensure to only leak the data for
// the directories that actually changed value though.
func ReloadUserSpecialDirsCache() {

	xReloadUserSpecialDirsCache()

}

var xSetApplicationName func(string)

// Sets a human-readable name for the application. This name should be
// localized if possible, and is intended for display to the user.
// Contrast with g_set_prgname(), which sets a non-localized name.
// g_set_prgname() will be called automatically by gtk_init(),
// but g_set_application_name() will not.
//
// Note that for thread safety reasons, this function can only
// be called once.
//
// The application name will be used in contexts such as error messages,
// or when displaying an application's name in the task list.
func SetApplicationName(ApplicationNameVar string) {

	xSetApplicationName(ApplicationNameVar)

}

var xSetPrgname func(string)

// Sets the name of the program. This name should not be localized,
// in contrast to g_set_application_name().
//
// If you are using #GApplication the program name is set in
// g_application_run(). In case of GDK or GTK+ it is set in
// gdk_init(), which is called by gtk_init() and the
// #GtkApplication::startup handler. The program name is found by
// taking the last component of @argv[0].
//
// Since GLib 2.72, this function can be called multiple times
// and is fully thread safe. Prior to GLib 2.72, this function
// could only be called once per process.
func SetPrgname(PrgnameVar string) {

	xSetPrgname(PrgnameVar)

}

var xSnprintf func(string, uint32, string, ...interface{}) int

// A safer form of the standard sprintf() function. The output is guaranteed
// to not exceed @n characters (including the terminating nul character), so
// it is easy to ensure that a buffer overflow cannot occur.
//
// See also g_strdup_printf().
//
// In versions of GLib prior to 1.2.3, this function may return -1 if the
// output was truncated, and the truncated string may not be nul-terminated.
// In versions prior to 1.3.12, this function returns the length of the output
// string.
//
// The return value of g_snprintf() conforms to the snprintf()
// function as standardized in ISO C99. Note that this is different from
// traditional snprintf(), which returns the length of the output string.
//
// The format string may contain positional parameters, as specified in
// the Single Unix Specification.
func Snprintf(StringVar string, NVar uint32, FormatVar string, varArgs ...interface{}) int {

	cret := xSnprintf(StringVar, NVar, FormatVar, varArgs...)
	return cret
}

var xVsnprintf func(string, uint32, string, []interface{}) int

// A safer form of the standard vsprintf() function. The output is guaranteed
// to not exceed @n characters (including the terminating nul character), so
// it is easy to ensure that a buffer overflow cannot occur.
//
// See also g_strdup_vprintf().
//
// In versions of GLib prior to 1.2.3, this function may return -1 if the
// output was truncated, and the truncated string may not be nul-terminated.
// In versions prior to 1.3.12, this function returns the length of the output
// string.
//
// The return value of g_vsnprintf() conforms to the vsnprintf() function
// as standardized in ISO C99. Note that this is different from traditional
// vsnprintf(), which returns the length of the output string.
//
// The format string may contain positional parameters, as specified in
// the Single Unix Specification.
func Vsnprintf(StringVar string, NVar uint32, FormatVar string, ArgsVar []interface{}) int {

	cret := xVsnprintf(StringVar, NVar, FormatVar, ArgsVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xAtexit, lib, "g_atexit")
	core.PuregoSafeRegister(&xBitNthLsf, lib, "g_bit_nth_lsf")
	core.PuregoSafeRegister(&xBitNthMsf, lib, "g_bit_nth_msf")
	core.PuregoSafeRegister(&xBitStorage, lib, "g_bit_storage")
	core.PuregoSafeRegister(&xFindProgramInPath, lib, "g_find_program_in_path")
	core.PuregoSafeRegister(&xFormatSize, lib, "g_format_size")
	core.PuregoSafeRegister(&xFormatSizeForDisplay, lib, "g_format_size_for_display")
	core.PuregoSafeRegister(&xFormatSizeFull, lib, "g_format_size_full")
	core.PuregoSafeRegister(&xGetApplicationName, lib, "g_get_application_name")
	core.PuregoSafeRegister(&xGetHomeDir, lib, "g_get_home_dir")
	core.PuregoSafeRegister(&xGetHostName, lib, "g_get_host_name")
	core.PuregoSafeRegister(&xGetOsInfo, lib, "g_get_os_info")
	core.PuregoSafeRegister(&xGetPrgname, lib, "g_get_prgname")
	core.PuregoSafeRegister(&xGetRealName, lib, "g_get_real_name")
	core.PuregoSafeRegister(&xGetSystemConfigDirs, lib, "g_get_system_config_dirs")
	core.PuregoSafeRegister(&xGetSystemDataDirs, lib, "g_get_system_data_dirs")
	core.PuregoSafeRegister(&xGetTmpDir, lib, "g_get_tmp_dir")
	core.PuregoSafeRegister(&xGetUserCacheDir, lib, "g_get_user_cache_dir")
	core.PuregoSafeRegister(&xGetUserConfigDir, lib, "g_get_user_config_dir")
	core.PuregoSafeRegister(&xGetUserDataDir, lib, "g_get_user_data_dir")
	core.PuregoSafeRegister(&xGetUserName, lib, "g_get_user_name")
	core.PuregoSafeRegister(&xGetUserRuntimeDir, lib, "g_get_user_runtime_dir")
	core.PuregoSafeRegister(&xGetUserSpecialDir, lib, "g_get_user_special_dir")
	core.PuregoSafeRegister(&xGetUserStateDir, lib, "g_get_user_state_dir")
	core.PuregoSafeRegister(&xNullifyPointer, lib, "g_nullify_pointer")
	core.PuregoSafeRegister(&xParseDebugString, lib, "g_parse_debug_string")
	core.PuregoSafeRegister(&xReloadUserSpecialDirsCache, lib, "g_reload_user_special_dirs_cache")
	core.PuregoSafeRegister(&xSetApplicationName, lib, "g_set_application_name")
	core.PuregoSafeRegister(&xSetPrgname, lib, "g_set_prgname")
	core.PuregoSafeRegister(&xSnprintf, lib, "g_snprintf")
	core.PuregoSafeRegister(&xVsnprintf, lib, "g_vsnprintf")

}
