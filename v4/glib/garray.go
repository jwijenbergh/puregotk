// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Contains the public fields of a GArray.
type Array struct {
	_ structs.HostLayout

	Data uintptr

	Len uint
}

var xArrayGLibType func() types.GType

func ArrayGLibType() types.GType {
	return xArrayGLibType()
}

func (x *Array) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Contains the public fields of a GByteArray.
type ByteArray struct {
	_ structs.HostLayout

	Data byte

	Len uint
}

var xByteArrayGLibType func() types.GType

func ByteArrayGLibType() types.GType {
	return xByteArrayGLibType()
}

func (x *ByteArray) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A simple refcounted data type representing an immutable sequence of zero or
// more bytes from an unspecified origin.
//
// The purpose of a #GBytes is to keep the memory region that it holds
// alive for as long as anyone holds a reference to the bytes.  When
// the last reference count is dropped, the memory is released. Multiple
// unrelated callers can use byte data in the #GBytes without coordinating
// their activities, resting assured that the byte data will not change or
// move while they hold a reference.
//
// A #GBytes can come from many different origins that may have
// different procedures for freeing the memory region.  Examples are
// memory from g_malloc(), from memory slices, from a #GMappedFile or
// memory from other allocators.
//
// #GBytes work well as keys in #GHashTable. Use g_bytes_equal() and
// g_bytes_hash() as parameters to g_hash_table_new() or g_hash_table_new_full().
// #GBytes can also be used as keys in a #GTree by passing the g_bytes_compare()
// function to g_tree_new().
//
// The data pointed to by this bytes must not be modified. For a mutable
// array of bytes see #GByteArray. Use g_bytes_unref_to_array() to create a
// mutable array for a #GBytes sequence. To create an immutable #GBytes from
// a mutable #GByteArray, use the g_byte_array_free_to_bytes() function.
type Bytes struct {
	_ structs.HostLayout
}

var xBytesGLibType func() types.GType

func BytesGLibType() types.GType {
	return xBytesGLibType()
}

func (x *Bytes) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewBytes func([]byte, uint) *Bytes

// Creates a new #GBytes from @data.
//
// @data is copied. If @size is 0, @data may be %NULL.
func NewBytes(DataVar []byte, SizeVar uint) *Bytes {

	cret := xNewBytes(DataVar, SizeVar)
	return cret
}

var xNewBytesStatic func([]byte, uint) *Bytes

// Creates a new #GBytes from static data.
//
// @data must be static (ie: never modified or freed). It may be %NULL if @size
// is 0.
func NewBytesStatic(DataVar []byte, SizeVar uint) *Bytes {

	cret := xNewBytesStatic(DataVar, SizeVar)
	return cret
}

var xNewBytesTake func(uintptr, uint) *Bytes

// Creates a new #GBytes from @data.
//
// After this call, @data belongs to the bytes and may no longer be
// modified by the caller.  g_free() will be called on @data when the
// bytes is no longer in use. Because of this @data must have been created by
// a call to g_malloc(), g_malloc0() or g_realloc() or by one of the many
// functions that wrap these calls (such as g_new(), g_strdup(), etc).
//
// For creating #GBytes with memory from other allocators, see
// g_bytes_new_with_free_func().
//
// @data may be %NULL if @size is 0.
func NewBytesTake(DataVar uintptr, SizeVar uint) *Bytes {

	cret := xNewBytesTake(DataVar, SizeVar)
	return cret
}

var xNewBytesWithFreeFunc func([]byte, uint, uintptr, uintptr) *Bytes

// Creates a #GBytes from @data.
//
// When the last reference is dropped, @free_func will be called with the
// @user_data argument.
//
// @data must not be modified after this call is made until @free_func has
// been called to indicate that the bytes is no longer in use.
//
// @data may be %NULL if @size is 0.
func NewBytesWithFreeFunc(DataVar []byte, SizeVar uint, FreeFuncVar *DestroyNotify, UserDataVar uintptr) *Bytes {

	cret := xNewBytesWithFreeFunc(DataVar, SizeVar, NewCallback(FreeFuncVar), UserDataVar)
	return cret
}

var xBytesCompare func(uintptr, uintptr) int

// Compares the two #GBytes values.
//
// This function can be used to sort GBytes instances in lexicographical order.
//
// If @bytes1 and @bytes2 have different length but the shorter one is a
// prefix of the longer one then the shorter one is considered to be less than
// the longer one. Otherwise the first byte where both differ is used for
// comparison. If @bytes1 has a smaller value at that position it is
// considered less, otherwise greater than @bytes2.
func (x *Bytes) Compare(Bytes2Var uintptr) int {

	cret := xBytesCompare(x.GoPointer(), Bytes2Var)
	return cret
}

var xBytesEqual func(uintptr, uintptr) bool

// Compares the two #GBytes values being pointed to and returns
// %TRUE if they are equal.
//
// This function can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-%NULL #GBytes pointers as keys in a #GHashTable.
func (x *Bytes) Equal(Bytes2Var uintptr) bool {

	cret := xBytesEqual(x.GoPointer(), Bytes2Var)
	return cret
}

var xBytesGetData func(uintptr, uint) []byte

// Get the byte data in the #GBytes. This data should not be modified.
//
// This function will always return the same pointer for a given #GBytes.
//
// %NULL may be returned if @size is 0. This is not guaranteed, as the #GBytes
// may represent an empty string with @data non-%NULL and @size as 0. %NULL will
// not be returned if @size is non-zero.
func (x *Bytes) GetData(SizeVar uint) []byte {

	cret := xBytesGetData(x.GoPointer(), SizeVar)
	return cret
}

var xBytesGetRegion func(uintptr, uint, uint, uint) uintptr

// Gets a pointer to a region in @bytes.
//
// The region starts at @offset many bytes from the start of the data
// and contains @n_elements many elements of @element_size size.
//
// @n_elements may be zero, but @element_size must always be non-zero.
// Ideally, @element_size is a static constant (eg: sizeof a struct).
//
// This function does careful bounds checking (including checking for
// arithmetic overflows) and returns a non-%NULL pointer if the
// specified region lies entirely within the @bytes. If the region is
// in some way out of range, or if an overflow has occurred, then %NULL
// is returned.
//
// Note: it is possible to have a valid zero-size region. In this case,
// the returned pointer will be equal to the base pointer of the data of
// @bytes, plus @offset.  This will be non-%NULL except for the case
// where @bytes itself was a zero-sized region.  Since it is unlikely
// that you will be using this function to check for a zero-sized region
// in a zero-sized @bytes, %NULL effectively always means "error".
func (x *Bytes) GetRegion(ElementSizeVar uint, OffsetVar uint, NElementsVar uint) uintptr {

	cret := xBytesGetRegion(x.GoPointer(), ElementSizeVar, OffsetVar, NElementsVar)
	return cret
}

var xBytesGetSize func(uintptr) uint

// Get the size of the byte data in the #GBytes.
//
// This function will always return the same value for a given #GBytes.
func (x *Bytes) GetSize() uint {

	cret := xBytesGetSize(x.GoPointer())
	return cret
}

var xBytesHash func(uintptr) uint

// Creates an integer hash code for the byte data in the #GBytes.
//
// This function can be passed to g_hash_table_new() as the @key_hash_func
// parameter, when using non-%NULL #GBytes pointers as keys in a #GHashTable.
func (x *Bytes) Hash() uint {

	cret := xBytesHash(x.GoPointer())
	return cret
}

var xBytesNewFromBytes func(uintptr, uint, uint) *Bytes

// Creates a #GBytes which is a subsection of another #GBytes. The @offset +
// @length may not be longer than the size of @bytes.
//
// A reference to @bytes will be held by the newly created #GBytes until
// the byte data is no longer needed.
//
// Since 2.56, if @offset is 0 and @length matches the size of @bytes, then
// @bytes will be returned with the reference count incremented by 1. If @bytes
// is a slice of another #GBytes, then the resulting #GBytes will reference
// the same #GBytes instead of @bytes. This allows consumers to simplify the
// usage of #GBytes when asynchronously writing to streams.
func (x *Bytes) NewFromBytes(OffsetVar uint, LengthVar uint) *Bytes {

	cret := xBytesNewFromBytes(x.GoPointer(), OffsetVar, LengthVar)
	return cret
}

var xBytesRef func(uintptr) *Bytes

// Increase the reference count on @bytes.
func (x *Bytes) Ref() *Bytes {

	cret := xBytesRef(x.GoPointer())
	return cret
}

var xBytesUnref func(uintptr)

// Releases a reference on @bytes.  This may result in the bytes being
// freed. If @bytes is %NULL, it will return immediately.
func (x *Bytes) Unref() {

	xBytesUnref(x.GoPointer())

}

var xBytesUnrefToArray func(uintptr) []byte

// Unreferences the bytes, and returns a new mutable #GByteArray containing
// the same byte data.
//
// As an optimization, the byte data is transferred to the array without copying
// if this was the last reference to bytes and bytes was created with
// g_bytes_new(), g_bytes_new_take() or g_byte_array_free_to_bytes(). In all
// other cases the data is copied.
//
// Do not use it if @bytes contains more than %G_MAXUINT
// bytes. #GByteArray stores the length of its data in #guint, which
// may be shorter than #gsize, that @bytes is using.
func (x *Bytes) UnrefToArray() []byte {

	cret := xBytesUnrefToArray(x.GoPointer())
	return cret
}

var xBytesUnrefToData func(uintptr, uint) uintptr

// Unreferences the bytes, and returns a pointer the same byte data
// contents.
//
// As an optimization, the byte data is returned without copying if this was
// the last reference to bytes and bytes was created with g_bytes_new(),
// g_bytes_new_take() or g_byte_array_free_to_bytes(). In all other cases the
// data is copied.
func (x *Bytes) UnrefToData(SizeVar uint) uintptr {

	cret := xBytesUnrefToData(x.GoPointer(), SizeVar)
	return cret
}

// Contains the public fields of a pointer array.
type PtrArray struct {
	_ structs.HostLayout

	Pdata uintptr

	Len uint
}

var xPtrArrayGLibType func() types.GType

func PtrArrayGLibType() types.GType {
	return xPtrArrayGLibType()
}

func (x *PtrArray) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xByteArrayFree func([]byte, bool) byte

// Frees the memory allocated by the #GByteArray. If @free_segment is
// %TRUE it frees the actual byte data. If the reference count of
// @array is greater than one, the #GByteArray wrapper is preserved but
// the size of @array will be set to zero.
func ByteArrayFree(ArrayVar []byte, FreeSegmentVar bool) byte {

	cret := xByteArrayFree(ArrayVar, FreeSegmentVar)
	return cret
}

var xByteArrayFreeToBytes func([]byte) *Bytes

// Transfers the data from the #GByteArray into a new immutable #GBytes.
//
// The #GByteArray is freed unless the reference count of @array is greater
// than one, the #GByteArray wrapper is preserved but the size of @array
// will be set to zero.
//
// This is identical to using g_bytes_new_take() and g_byte_array_free()
// together.
func ByteArrayFreeToBytes(ArrayVar []byte) *Bytes {

	cret := xByteArrayFreeToBytes(ArrayVar)
	return cret
}

var xByteArrayNew func() []byte

// Creates a new #GByteArray with a reference count of 1.
func ByteArrayNew() []byte {

	cret := xByteArrayNew()
	return cret
}

var xByteArrayNewTake func([]byte, uint) []byte

// Create byte array containing the data. The data will be owned by the array
// and will be freed with g_free(), i.e. it could be allocated using g_strdup().
//
// Do not use it if @len is greater than %G_MAXUINT. #GByteArray
// stores the length of its data in #guint, which may be shorter than
// #gsize.
func ByteArrayNewTake(DataVar []byte, LenVar uint) []byte {

	cret := xByteArrayNewTake(DataVar, LenVar)
	return cret
}

var xByteArraySteal func([]byte, uint) byte

// Frees the data in the array and resets the size to zero, while
// the underlying array is preserved for use elsewhere and returned
// to the caller.
func ByteArraySteal(ArrayVar []byte, LenVar uint) byte {

	cret := xByteArraySteal(ArrayVar, LenVar)
	return cret
}

var xByteArrayUnref func([]byte)

// Atomically decrements the reference count of @array by one. If the
// reference count drops to 0, all memory allocated by the array is
// released. This function is thread-safe and may be called from any
// thread.
func ByteArrayUnref(ArrayVar []byte) {

	xByteArrayUnref(ArrayVar)

}

var xPtrArrayFind func([]uintptr, uintptr, uint) bool

// Checks whether @needle exists in @haystack. If the element is found, %TRUE is
// returned and the element’s index is returned in @index_ (if non-%NULL).
// Otherwise, %FALSE is returned and @index_ is undefined. If @needle exists
// multiple times in @haystack, the index of the first instance is returned.
//
// This does pointer comparisons only. If you want to use more complex equality
// checks, such as string comparisons, use g_ptr_array_find_with_equal_func().
func PtrArrayFind(HaystackVar []uintptr, NeedleVar uintptr, IndexVar uint) bool {

	cret := xPtrArrayFind(HaystackVar, NeedleVar, IndexVar)
	return cret
}

var xPtrArrayFindWithEqualFunc func([]uintptr, uintptr, uintptr, uint) bool

// Checks whether @needle exists in @haystack, using the given @equal_func.
// If the element is found, %TRUE is returned and the element’s index is
// returned in @index_ (if non-%NULL). Otherwise, %FALSE is returned and @index_
// is undefined. If @needle exists multiple times in @haystack, the index of
// the first instance is returned.
//
// @equal_func is called with the element from the array as its first parameter,
// and @needle as its second parameter. If @equal_func is %NULL, pointer
// equality is used.
func PtrArrayFindWithEqualFunc(HaystackVar []uintptr, NeedleVar uintptr, EqualFuncVar *EqualFunc, IndexVar uint) bool {

	cret := xPtrArrayFindWithEqualFunc(HaystackVar, NeedleVar, NewCallback(EqualFuncVar), IndexVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xByteArrayFree, lib, "g_byte_array_free")
	core.PuregoSafeRegister(&xByteArrayFreeToBytes, lib, "g_byte_array_free_to_bytes")
	core.PuregoSafeRegister(&xByteArrayNew, lib, "g_byte_array_new")
	core.PuregoSafeRegister(&xByteArrayNewTake, lib, "g_byte_array_new_take")
	core.PuregoSafeRegister(&xByteArraySteal, lib, "g_byte_array_steal")
	core.PuregoSafeRegister(&xByteArrayUnref, lib, "g_byte_array_unref")
	core.PuregoSafeRegister(&xPtrArrayFind, lib, "g_ptr_array_find")
	core.PuregoSafeRegister(&xPtrArrayFindWithEqualFunc, lib, "g_ptr_array_find_with_equal_func")

	core.PuregoSafeRegister(&xArrayGLibType, lib, "g_array_get_type")

	core.PuregoSafeRegister(&xByteArrayGLibType, lib, "g_byte_array_get_type")

	core.PuregoSafeRegister(&xBytesGLibType, lib, "g_bytes_get_type")

	core.PuregoSafeRegister(&xNewBytes, lib, "g_bytes_new")
	core.PuregoSafeRegister(&xNewBytesStatic, lib, "g_bytes_new_static")
	core.PuregoSafeRegister(&xNewBytesTake, lib, "g_bytes_new_take")
	core.PuregoSafeRegister(&xNewBytesWithFreeFunc, lib, "g_bytes_new_with_free_func")

	core.PuregoSafeRegister(&xBytesCompare, lib, "g_bytes_compare")
	core.PuregoSafeRegister(&xBytesEqual, lib, "g_bytes_equal")
	core.PuregoSafeRegister(&xBytesGetData, lib, "g_bytes_get_data")
	core.PuregoSafeRegister(&xBytesGetRegion, lib, "g_bytes_get_region")
	core.PuregoSafeRegister(&xBytesGetSize, lib, "g_bytes_get_size")
	core.PuregoSafeRegister(&xBytesHash, lib, "g_bytes_hash")
	core.PuregoSafeRegister(&xBytesNewFromBytes, lib, "g_bytes_new_from_bytes")
	core.PuregoSafeRegister(&xBytesRef, lib, "g_bytes_ref")
	core.PuregoSafeRegister(&xBytesUnref, lib, "g_bytes_unref")
	core.PuregoSafeRegister(&xBytesUnrefToArray, lib, "g_bytes_unref_to_array")
	core.PuregoSafeRegister(&xBytesUnrefToData, lib, "g_bytes_unref_to_data")

	core.PuregoSafeRegister(&xPtrArrayGLibType, lib, "g_ptr_array_get_type")

}
