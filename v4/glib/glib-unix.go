// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// The type of functions to be called when a UNIX fd watch source
// triggers.
type UnixFDSourceFunc func(int, IOCondition, uintptr) bool

var xUnixFdAdd func(int, IOCondition, uintptr, uintptr) uint

// Sets a function to be called when the IO condition, as specified by
// @condition becomes true for @fd.
//
// @function will be called when the specified IO condition becomes
// %TRUE.  The function is expected to clear whatever event caused the
// IO condition to become true and return %TRUE in order to be notified
// when it happens again.  If @function returns %FALSE then the watch
// will be cancelled.
//
// The return value of this function can be passed to g_source_remove()
// to cancel the watch at any time that it exists.
//
// The source will never close the fd -- you must do it yourself.
func UnixFdAdd(FdVar int, ConditionVar IOCondition, FunctionVar *UnixFDSourceFunc, UserDataVar uintptr) uint {

	cret := xUnixFdAdd(FdVar, ConditionVar, NewCallback(FunctionVar), UserDataVar)
	return cret
}

var xUnixFdAddFull func(int, int, IOCondition, uintptr, uintptr, uintptr) uint

// Sets a function to be called when the IO condition, as specified by
// @condition becomes true for @fd.
//
// This is the same as g_unix_fd_add(), except that it allows you to
// specify a non-default priority and a provide a #GDestroyNotify for
// @user_data.
func UnixFdAddFull(PriorityVar int, FdVar int, ConditionVar IOCondition, FunctionVar *UnixFDSourceFunc, UserDataVar uintptr, NotifyVar *DestroyNotify) uint {

	cret := xUnixFdAddFull(PriorityVar, FdVar, ConditionVar, NewCallback(FunctionVar), UserDataVar, NewCallback(NotifyVar))
	return cret
}

var xUnixFdSourceNew func(int, IOCondition) *Source

// Creates a #GSource to watch for a particular IO condition on a file
// descriptor.
//
// The source will never close the fd -- you must do it yourself.
func UnixFdSourceNew(FdVar int, ConditionVar IOCondition) *Source {

	cret := xUnixFdSourceNew(FdVar, ConditionVar)
	return cret
}

var xUnixGetPasswdEntry func(string, **Error) uintptr

// Get the `passwd` file entry for the given @user_name using `getpwnam_r()`.
// This can fail if the given @user_name doesnâ€™t exist.
//
// The returned `struct passwd` has been allocated using g_malloc() and should
// be freed using g_free(). The strings referenced by the returned struct are
// included in the same allocation, so are valid until the `struct passwd` is
// freed.
//
// This function is safe to call from multiple threads concurrently.
//
// You will need to include `pwd.h` to get the definition of `struct passwd`.
func UnixGetPasswdEntry(UserNameVar string) (uintptr, error) {
	var cerr *Error

	cret := xUnixGetPasswdEntry(UserNameVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnixOpenPipe func(int, int, **Error) bool

// Similar to the UNIX pipe() call, but on modern systems like Linux
// uses the pipe2() system call, which atomically creates a pipe with
// the configured flags. The only supported flag currently is
// %FD_CLOEXEC. If for example you want to configure %O_NONBLOCK, that
// must still be done separately with fcntl().
//
// This function does not take %O_CLOEXEC, it takes %FD_CLOEXEC as if
// for fcntl(); these are different on Linux/glibc.
func UnixOpenPipe(FdsVar int, FlagsVar int) (bool, error) {
	var cerr *Error

	cret := xUnixOpenPipe(FdsVar, FlagsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnixSetFdNonblocking func(int, bool, **Error) bool

// Control the non-blocking state of the given file descriptor,
// according to @nonblock. On most systems this uses %O_NONBLOCK, but
// on some older ones may use %O_NDELAY.
func UnixSetFdNonblocking(FdVar int, NonblockVar bool) (bool, error) {
	var cerr *Error

	cret := xUnixSetFdNonblocking(FdVar, NonblockVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnixSignalAdd func(int, uintptr, uintptr) uint

// A convenience function for g_unix_signal_source_new(), which
// attaches to the default #GMainContext.  You can remove the watch
// using g_source_remove().
func UnixSignalAdd(SignumVar int, HandlerVar *SourceFunc, UserDataVar uintptr) uint {

	cret := xUnixSignalAdd(SignumVar, NewCallback(HandlerVar), UserDataVar)
	return cret
}

var xUnixSignalAddFull func(int, int, uintptr, uintptr, uintptr) uint

// A convenience function for g_unix_signal_source_new(), which
// attaches to the default #GMainContext.  You can remove the watch
// using g_source_remove().
func UnixSignalAddFull(PriorityVar int, SignumVar int, HandlerVar *SourceFunc, UserDataVar uintptr, NotifyVar *DestroyNotify) uint {

	cret := xUnixSignalAddFull(PriorityVar, SignumVar, NewCallback(HandlerVar), UserDataVar, NewCallback(NotifyVar))
	return cret
}

var xUnixSignalSourceNew func(int) *Source

// Create a #GSource that will be dispatched upon delivery of the UNIX
// signal @signum.  In GLib versions before 2.36, only `SIGHUP`, `SIGINT`,
// `SIGTERM` can be monitored.  In GLib 2.36, `SIGUSR1` and `SIGUSR2`
// were added. In GLib 2.54, `SIGWINCH` was added.
//
// Note that unlike the UNIX default, all sources which have created a
// watch will be dispatched, regardless of which underlying thread
// invoked g_unix_signal_source_new().
//
// For example, an effective use of this function is to handle `SIGTERM`
// cleanly; flushing any outstanding files, and then calling
// g_main_loop_quit ().  It is not safe to do any of this a regular
// UNIX signal handler; your handler may be invoked while malloc() or
// another library function is running, causing reentrancy if you
// attempt to use it from the handler.  None of the GLib/GObject API
// is safe against this kind of reentrancy.
//
// The interaction of this source when combined with native UNIX
// functions like sigprocmask() is not defined.
//
// The source will not initially be associated with any #GMainContext
// and must be added to one with g_source_attach() before it will be
// executed.
func UnixSignalSourceNew(SignumVar int) *Source {

	cret := xUnixSignalSourceNew(SignumVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xUnixFdAdd, lib, "g_unix_fd_add")
	core.PuregoSafeRegister(&xUnixFdAddFull, lib, "g_unix_fd_add_full")
	core.PuregoSafeRegister(&xUnixFdSourceNew, lib, "g_unix_fd_source_new")
	core.PuregoSafeRegister(&xUnixGetPasswdEntry, lib, "g_unix_get_passwd_entry")
	core.PuregoSafeRegister(&xUnixOpenPipe, lib, "g_unix_open_pipe")
	core.PuregoSafeRegister(&xUnixSetFdNonblocking, lib, "g_unix_set_fd_nonblocking")
	core.PuregoSafeRegister(&xUnixSignalAdd, lib, "g_unix_signal_add")
	core.PuregoSafeRegister(&xUnixSignalAddFull, lib, "g_unix_signal_add_full")
	core.PuregoSafeRegister(&xUnixSignalSourceNew, lib, "g_unix_signal_source_new")

}
