// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// Specifies the type of function passed to g_node_children_foreach().
// The function is called with each child node, together with the user
// data passed to g_node_children_foreach().
type NodeForeachFunc func(*Node, uintptr)

// Specifies the type of function passed to g_node_traverse(). The
// function is called with each of the nodes visited, together with the
// user data passed to g_node_traverse(). If the function returns
// %TRUE, then the traversal is stopped.
type NodeTraverseFunc func(*Node, uintptr) bool

// The #GNode struct represents one node in a [n-ary tree][glib-N-ary-Trees].
type Node struct {
	_ structs.HostLayout

	Data uintptr

	Next *Node

	Prev *Node

	Parent *Node

	Children *Node
}

func (x *Node) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNodeChildIndex func(uintptr, uintptr) int

// Gets the position of the first child of a #GNode
// which contains the given data.
func (x *Node) ChildIndex(DataVar uintptr) int {

	cret := xNodeChildIndex(x.GoPointer(), DataVar)
	return cret
}

var xNodeChildPosition func(uintptr, *Node) int

// Gets the position of a #GNode with respect to its siblings.
// @child must be a child of @node. The first child is numbered 0,
// the second 1, and so on.
func (x *Node) ChildPosition(ChildVar *Node) int {

	cret := xNodeChildPosition(x.GoPointer(), ChildVar)
	return cret
}

var xNodeChildrenForeach func(uintptr, TraverseFlags, uintptr, uintptr)

// Calls a function for each of the children of a #GNode. Note that it
// doesn't descend beneath the child nodes. @func must not do anything
// that would modify the structure of the tree.
func (x *Node) ChildrenForeach(FlagsVar TraverseFlags, FuncVar *NodeForeachFunc, DataVar uintptr) {

	xNodeChildrenForeach(x.GoPointer(), FlagsVar, NewCallback(FuncVar), DataVar)

}

var xNodeCopy func(uintptr) *Node

// Recursively copies a #GNode (but does not deep-copy the data inside the
// nodes, see g_node_copy_deep() if you need that).
func (x *Node) Copy() *Node {

	cret := xNodeCopy(x.GoPointer())
	return cret
}

var xNodeCopyDeep func(uintptr, uintptr, uintptr) *Node

// Recursively copies a #GNode and its data.
func (x *Node) CopyDeep(CopyFuncVar *CopyFunc, DataVar uintptr) *Node {

	cret := xNodeCopyDeep(x.GoPointer(), NewCallback(CopyFuncVar), DataVar)
	return cret
}

var xNodeDepth func(uintptr) uint

// Gets the depth of a #GNode.
//
// If @node is %NULL the depth is 0. The root node has a depth of 1.
// For the children of the root node the depth is 2. And so on.
func (x *Node) Depth() uint {

	cret := xNodeDepth(x.GoPointer())
	return cret
}

var xNodeDestroy func(uintptr)

// Removes @root and its children from the tree, freeing any memory
// allocated.
func (x *Node) Destroy() {

	xNodeDestroy(x.GoPointer())

}

var xNodeFind func(uintptr, TraverseType, TraverseFlags, uintptr) *Node

// Finds a #GNode in a tree.
func (x *Node) Find(OrderVar TraverseType, FlagsVar TraverseFlags, DataVar uintptr) *Node {

	cret := xNodeFind(x.GoPointer(), OrderVar, FlagsVar, DataVar)
	return cret
}

var xNodeFindChild func(uintptr, TraverseFlags, uintptr) *Node

// Finds the first child of a #GNode with the given data.
func (x *Node) FindChild(FlagsVar TraverseFlags, DataVar uintptr) *Node {

	cret := xNodeFindChild(x.GoPointer(), FlagsVar, DataVar)
	return cret
}

var xNodeFirstSibling func(uintptr) *Node

// Gets the first sibling of a #GNode.
// This could possibly be the node itself.
func (x *Node) FirstSibling() *Node {

	cret := xNodeFirstSibling(x.GoPointer())
	return cret
}

var xNodeGetRoot func(uintptr) *Node

// Gets the root of a tree.
func (x *Node) GetRoot() *Node {

	cret := xNodeGetRoot(x.GoPointer())
	return cret
}

var xNodeInsert func(uintptr, int, *Node) *Node

// Inserts a #GNode beneath the parent at the given position.
func (x *Node) Insert(PositionVar int, NodeVar *Node) *Node {

	cret := xNodeInsert(x.GoPointer(), PositionVar, NodeVar)
	return cret
}

var xNodeInsertAfter func(uintptr, *Node, *Node) *Node

// Inserts a #GNode beneath the parent after the given sibling.
func (x *Node) InsertAfter(SiblingVar *Node, NodeVar *Node) *Node {

	cret := xNodeInsertAfter(x.GoPointer(), SiblingVar, NodeVar)
	return cret
}

var xNodeInsertBefore func(uintptr, *Node, *Node) *Node

// Inserts a #GNode beneath the parent before the given sibling.
func (x *Node) InsertBefore(SiblingVar *Node, NodeVar *Node) *Node {

	cret := xNodeInsertBefore(x.GoPointer(), SiblingVar, NodeVar)
	return cret
}

var xNodeIsAncestor func(uintptr, *Node) bool

// Returns %TRUE if @node is an ancestor of @descendant.
// This is true if node is the parent of @descendant,
// or if node is the grandparent of @descendant etc.
func (x *Node) IsAncestor(DescendantVar *Node) bool {

	cret := xNodeIsAncestor(x.GoPointer(), DescendantVar)
	return cret
}

var xNodeLastChild func(uintptr) *Node

// Gets the last child of a #GNode.
func (x *Node) LastChild() *Node {

	cret := xNodeLastChild(x.GoPointer())
	return cret
}

var xNodeLastSibling func(uintptr) *Node

// Gets the last sibling of a #GNode.
// This could possibly be the node itself.
func (x *Node) LastSibling() *Node {

	cret := xNodeLastSibling(x.GoPointer())
	return cret
}

var xNodeMaxHeight func(uintptr) uint

// Gets the maximum height of all branches beneath a #GNode.
// This is the maximum distance from the #GNode to all leaf nodes.
//
// If @root is %NULL, 0 is returned. If @root has no children,
// 1 is returned. If @root has children, 2 is returned. And so on.
func (x *Node) MaxHeight() uint {

	cret := xNodeMaxHeight(x.GoPointer())
	return cret
}

var xNodeNChildren func(uintptr) uint

// Gets the number of children of a #GNode.
func (x *Node) NChildren() uint {

	cret := xNodeNChildren(x.GoPointer())
	return cret
}

var xNodeNNodes func(uintptr, TraverseFlags) uint

// Gets the number of nodes in a tree.
func (x *Node) NNodes(FlagsVar TraverseFlags) uint {

	cret := xNodeNNodes(x.GoPointer(), FlagsVar)
	return cret
}

var xNodeNthChild func(uintptr, uint) *Node

// Gets a child of a #GNode, using the given index.
// The first child is at index 0. If the index is
// too big, %NULL is returned.
func (x *Node) NthChild(NVar uint) *Node {

	cret := xNodeNthChild(x.GoPointer(), NVar)
	return cret
}

var xNodePrepend func(uintptr, *Node) *Node

// Inserts a #GNode as the first child of the given parent.
func (x *Node) Prepend(NodeVar *Node) *Node {

	cret := xNodePrepend(x.GoPointer(), NodeVar)
	return cret
}

var xNodeReverseChildren func(uintptr)

// Reverses the order of the children of a #GNode.
// (It doesn't change the order of the grandchildren.)
func (x *Node) ReverseChildren() {

	xNodeReverseChildren(x.GoPointer())

}

var xNodeTraverse func(uintptr, TraverseType, TraverseFlags, int, uintptr, uintptr)

// Traverses a tree starting at the given root #GNode.
// It calls the given function for each node visited.
// The traversal can be halted at any point by returning %TRUE from @func.
// @func must not do anything that would modify the structure of the tree.
func (x *Node) Traverse(OrderVar TraverseType, FlagsVar TraverseFlags, MaxDepthVar int, FuncVar *NodeTraverseFunc, DataVar uintptr) {

	xNodeTraverse(x.GoPointer(), OrderVar, FlagsVar, MaxDepthVar, NewCallback(FuncVar), DataVar)

}

var xNodeUnlink func(uintptr)

// Unlinks a #GNode from a tree, resulting in two separate trees.
func (x *Node) Unlink() {

	xNodeUnlink(x.GoPointer())

}

// Specifies which nodes are visited during several of the tree
// functions, including g_node_traverse() and g_node_find().
type TraverseFlags int

const (

	// only leaf nodes should be visited. This name has
	//                     been introduced in 2.6, for older version use
	//                     %G_TRAVERSE_LEAFS.
	GTraverseLeavesValue TraverseFlags = 1
	// only non-leaf nodes should be visited. This
	//                         name has been introduced in 2.6, for older
	//                         version use %G_TRAVERSE_NON_LEAFS.
	GTraverseNonLeavesValue TraverseFlags = 2
	// all nodes should be visited.
	GTraverseAllValue TraverseFlags = 3
	// a mask of all traverse flags.
	GTraverseMaskValue TraverseFlags = 3
	// identical to %G_TRAVERSE_LEAVES.
	GTraverseLeafsValue TraverseFlags = 1
	// identical to %G_TRAVERSE_NON_LEAVES.
	GTraverseNonLeafsValue TraverseFlags = 2
)

// Specifies the type of traversal performed by g_tree_traverse(),
// g_node_traverse() and g_node_find(). The different orders are
// illustrated here:
//   - In order: A, B, C, D, E, F, G, H, I
//     ![](Sorted_binary_tree_inorder.svg)
//   - Pre order: F, B, A, D, C, E, G, I, H
//     ![](Sorted_binary_tree_preorder.svg)
//   - Post order: A, C, E, D, B, H, I, G, F
//     ![](Sorted_binary_tree_postorder.svg)
//   - Level order: F, B, G, A, D, I, C, E, H
//     ![](Sorted_binary_tree_breadth-first_traversal.svg)
type TraverseType int

const (

	// vists a node's left child first, then the node itself,
	//              then its right child. This is the one to use if you
	//              want the output sorted according to the compare
	//              function.
	GInOrderValue TraverseType = 0
	// visits a node, then its children.
	GPreOrderValue TraverseType = 1
	// visits the node's children, then the node itself.
	GPostOrderValue TraverseType = 2
	// is not implemented for
	//              [balanced binary trees][glib-Balanced-Binary-Trees].
	//              For [n-ary trees][glib-N-ary-Trees], it
	//              vists the root node first, then its children, then
	//              its grandchildren, and so on. Note that this is less
	//              efficient than the other orders.
	GLevelOrderValue TraverseType = 3
)

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNodeChildIndex, lib, "g_node_child_index")
	core.PuregoSafeRegister(&xNodeChildPosition, lib, "g_node_child_position")
	core.PuregoSafeRegister(&xNodeChildrenForeach, lib, "g_node_children_foreach")
	core.PuregoSafeRegister(&xNodeCopy, lib, "g_node_copy")
	core.PuregoSafeRegister(&xNodeCopyDeep, lib, "g_node_copy_deep")
	core.PuregoSafeRegister(&xNodeDepth, lib, "g_node_depth")
	core.PuregoSafeRegister(&xNodeDestroy, lib, "g_node_destroy")
	core.PuregoSafeRegister(&xNodeFind, lib, "g_node_find")
	core.PuregoSafeRegister(&xNodeFindChild, lib, "g_node_find_child")
	core.PuregoSafeRegister(&xNodeFirstSibling, lib, "g_node_first_sibling")
	core.PuregoSafeRegister(&xNodeGetRoot, lib, "g_node_get_root")
	core.PuregoSafeRegister(&xNodeInsert, lib, "g_node_insert")
	core.PuregoSafeRegister(&xNodeInsertAfter, lib, "g_node_insert_after")
	core.PuregoSafeRegister(&xNodeInsertBefore, lib, "g_node_insert_before")
	core.PuregoSafeRegister(&xNodeIsAncestor, lib, "g_node_is_ancestor")
	core.PuregoSafeRegister(&xNodeLastChild, lib, "g_node_last_child")
	core.PuregoSafeRegister(&xNodeLastSibling, lib, "g_node_last_sibling")
	core.PuregoSafeRegister(&xNodeMaxHeight, lib, "g_node_max_height")
	core.PuregoSafeRegister(&xNodeNChildren, lib, "g_node_n_children")
	core.PuregoSafeRegister(&xNodeNNodes, lib, "g_node_n_nodes")
	core.PuregoSafeRegister(&xNodeNthChild, lib, "g_node_nth_child")
	core.PuregoSafeRegister(&xNodePrepend, lib, "g_node_prepend")
	core.PuregoSafeRegister(&xNodeReverseChildren, lib, "g_node_reverse_children")
	core.PuregoSafeRegister(&xNodeTraverse, lib, "g_node_traverse")
	core.PuregoSafeRegister(&xNodeUnlink, lib, "g_node_unlink")

}
