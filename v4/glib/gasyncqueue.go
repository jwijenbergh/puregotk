// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// An opaque data structure which represents an asynchronous queue.
//
// It should only be accessed through the `g_async_queue_*` functions.
type AsyncQueue struct {
	_ structs.HostLayout
}

func (x *AsyncQueue) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xAsyncQueueLength func(uintptr) int

// Returns the length of the queue.
//
// Actually this function returns the number of data items in
// the queue minus the number of waiting threads, so a negative
// value means waiting threads, and a positive value means available
// entries in the @queue. A return value of 0 could mean n entries
// in the queue and n threads waiting. This can happen due to locking
// of the queue or due to scheduling.
func (x *AsyncQueue) Length() int {

	cret := xAsyncQueueLength(x.GoPointer())
	return cret
}

var xAsyncQueueLengthUnlocked func(uintptr) int

// Returns the length of the queue.
//
// Actually this function returns the number of data items in
// the queue minus the number of waiting threads, so a negative
// value means waiting threads, and a positive value means available
// entries in the @queue. A return value of 0 could mean n entries
// in the queue and n threads waiting. This can happen due to locking
// of the queue or due to scheduling.
//
// This function must be called while holding the @queue's lock.
func (x *AsyncQueue) LengthUnlocked() int {

	cret := xAsyncQueueLengthUnlocked(x.GoPointer())
	return cret
}

var xAsyncQueueLock func(uintptr)

// Acquires the @queue's lock. If another thread is already
// holding the lock, this call will block until the lock
// becomes available.
//
// Call g_async_queue_unlock() to drop the lock again.
//
// While holding the lock, you can only call the
// g_async_queue_*_unlocked() functions on @queue. Otherwise,
// deadlock may occur.
func (x *AsyncQueue) Lock() {

	xAsyncQueueLock(x.GoPointer())

}

var xAsyncQueuePop func(uintptr) uintptr

// Pops data from the @queue. If @queue is empty, this function
// blocks until data becomes available.
func (x *AsyncQueue) Pop() uintptr {

	cret := xAsyncQueuePop(x.GoPointer())
	return cret
}

var xAsyncQueuePopUnlocked func(uintptr) uintptr

// Pops data from the @queue. If @queue is empty, this function
// blocks until data becomes available.
//
// This function must be called while holding the @queue's lock.
func (x *AsyncQueue) PopUnlocked() uintptr {

	cret := xAsyncQueuePopUnlocked(x.GoPointer())
	return cret
}

var xAsyncQueuePush func(uintptr, uintptr)

// Pushes the @data into the @queue. @data must not be %NULL.
func (x *AsyncQueue) Push(DataVar uintptr) {

	xAsyncQueuePush(x.GoPointer(), DataVar)

}

var xAsyncQueuePushFront func(uintptr, uintptr)

// Pushes the @item into the @queue. @item must not be %NULL.
// In contrast to g_async_queue_push(), this function
// pushes the new item ahead of the items already in the queue,
// so that it will be the next one to be popped off the queue.
func (x *AsyncQueue) PushFront(ItemVar uintptr) {

	xAsyncQueuePushFront(x.GoPointer(), ItemVar)

}

var xAsyncQueuePushFrontUnlocked func(uintptr, uintptr)

// Pushes the @item into the @queue. @item must not be %NULL.
// In contrast to g_async_queue_push_unlocked(), this function
// pushes the new item ahead of the items already in the queue,
// so that it will be the next one to be popped off the queue.
//
// This function must be called while holding the @queue's lock.
func (x *AsyncQueue) PushFrontUnlocked(ItemVar uintptr) {

	xAsyncQueuePushFrontUnlocked(x.GoPointer(), ItemVar)

}

var xAsyncQueuePushSorted func(uintptr, uintptr, uintptr, uintptr)

// Inserts @data into @queue using @func to determine the new
// position.
//
// This function requires that the @queue is sorted before pushing on
// new elements, see g_async_queue_sort().
//
// This function will lock @queue before it sorts the queue and unlock
// it when it is finished.
//
// For an example of @func see g_async_queue_sort().
func (x *AsyncQueue) PushSorted(DataVar uintptr, FuncVar *CompareDataFunc, UserDataVar uintptr) {

	xAsyncQueuePushSorted(x.GoPointer(), DataVar, NewCallback(FuncVar), UserDataVar)

}

var xAsyncQueuePushSortedUnlocked func(uintptr, uintptr, uintptr, uintptr)

// Inserts @data into @queue using @func to determine the new
// position.
//
// The sort function @func is passed two elements of the @queue.
// It should return 0 if they are equal, a negative value if the
// first element should be higher in the @queue or a positive value
// if the first element should be lower in the @queue than the second
// element.
//
// This function requires that the @queue is sorted before pushing on
// new elements, see g_async_queue_sort().
//
// This function must be called while holding the @queue's lock.
//
// For an example of @func see g_async_queue_sort().
func (x *AsyncQueue) PushSortedUnlocked(DataVar uintptr, FuncVar *CompareDataFunc, UserDataVar uintptr) {

	xAsyncQueuePushSortedUnlocked(x.GoPointer(), DataVar, NewCallback(FuncVar), UserDataVar)

}

var xAsyncQueuePushUnlocked func(uintptr, uintptr)

// Pushes the @data into the @queue. @data must not be %NULL.
//
// This function must be called while holding the @queue's lock.
func (x *AsyncQueue) PushUnlocked(DataVar uintptr) {

	xAsyncQueuePushUnlocked(x.GoPointer(), DataVar)

}

var xAsyncQueueRef func(uintptr) *AsyncQueue

// Increases the reference count of the asynchronous @queue by 1.
// You do not need to hold the lock to call this function.
func (x *AsyncQueue) Ref() *AsyncQueue {

	cret := xAsyncQueueRef(x.GoPointer())
	return cret
}

var xAsyncQueueRefUnlocked func(uintptr)

// Increases the reference count of the asynchronous @queue by 1.
func (x *AsyncQueue) RefUnlocked() {

	xAsyncQueueRefUnlocked(x.GoPointer())

}

var xAsyncQueueRemove func(uintptr, uintptr) bool

// Remove an item from the queue.
func (x *AsyncQueue) Remove(ItemVar uintptr) bool {

	cret := xAsyncQueueRemove(x.GoPointer(), ItemVar)
	return cret
}

var xAsyncQueueRemoveUnlocked func(uintptr, uintptr) bool

// Remove an item from the queue.
//
// This function must be called while holding the @queue's lock.
func (x *AsyncQueue) RemoveUnlocked(ItemVar uintptr) bool {

	cret := xAsyncQueueRemoveUnlocked(x.GoPointer(), ItemVar)
	return cret
}

var xAsyncQueueSort func(uintptr, uintptr, uintptr)

// Sorts @queue using @func.
//
// The sort function @func is passed two elements of the @queue.
// It should return 0 if they are equal, a negative value if the
// first element should be higher in the @queue or a positive value
// if the first element should be lower in the @queue than the second
// element.
//
// This function will lock @queue before it sorts the queue and unlock
// it when it is finished.
//
// If you were sorting a list of priority numbers to make sure the
// lowest priority would be at the top of the queue, you could use:
// |[&lt;!-- language="C" --&gt;
//
//	gint32 id1;
//	gint32 id2;
//
//	id1 = GPOINTER_TO_INT (element1);
//	id2 = GPOINTER_TO_INT (element2);
//
//	return (id1 &gt; id2 ? +1 : id1 == id2 ? 0 : -1);
//
// ]|
func (x *AsyncQueue) Sort(FuncVar *CompareDataFunc, UserDataVar uintptr) {

	xAsyncQueueSort(x.GoPointer(), NewCallback(FuncVar), UserDataVar)

}

var xAsyncQueueSortUnlocked func(uintptr, uintptr, uintptr)

// Sorts @queue using @func.
//
// The sort function @func is passed two elements of the @queue.
// It should return 0 if they are equal, a negative value if the
// first element should be higher in the @queue or a positive value
// if the first element should be lower in the @queue than the second
// element.
//
// This function must be called while holding the @queue's lock.
func (x *AsyncQueue) SortUnlocked(FuncVar *CompareDataFunc, UserDataVar uintptr) {

	xAsyncQueueSortUnlocked(x.GoPointer(), NewCallback(FuncVar), UserDataVar)

}

var xAsyncQueueTimedPop func(uintptr, *TimeVal) uintptr

// Pops data from the @queue. If the queue is empty, blocks until
// @end_time or until data becomes available.
//
// If no data is received before @end_time, %NULL is returned.
//
// To easily calculate @end_time, a combination of g_get_real_time()
// and g_time_val_add() can be used.
func (x *AsyncQueue) TimedPop(EndTimeVar *TimeVal) uintptr {

	cret := xAsyncQueueTimedPop(x.GoPointer(), EndTimeVar)
	return cret
}

var xAsyncQueueTimedPopUnlocked func(uintptr, *TimeVal) uintptr

// Pops data from the @queue. If the queue is empty, blocks until
// @end_time or until data becomes available.
//
// If no data is received before @end_time, %NULL is returned.
//
// To easily calculate @end_time, a combination of g_get_real_time()
// and g_time_val_add() can be used.
//
// This function must be called while holding the @queue's lock.
func (x *AsyncQueue) TimedPopUnlocked(EndTimeVar *TimeVal) uintptr {

	cret := xAsyncQueueTimedPopUnlocked(x.GoPointer(), EndTimeVar)
	return cret
}

var xAsyncQueueTimeoutPop func(uintptr, uint64) uintptr

// Pops data from the @queue. If the queue is empty, blocks for
// @timeout microseconds, or until data becomes available.
//
// If no data is received before the timeout, %NULL is returned.
func (x *AsyncQueue) TimeoutPop(TimeoutVar uint64) uintptr {

	cret := xAsyncQueueTimeoutPop(x.GoPointer(), TimeoutVar)
	return cret
}

var xAsyncQueueTimeoutPopUnlocked func(uintptr, uint64) uintptr

// Pops data from the @queue. If the queue is empty, blocks for
// @timeout microseconds, or until data becomes available.
//
// If no data is received before the timeout, %NULL is returned.
//
// This function must be called while holding the @queue's lock.
func (x *AsyncQueue) TimeoutPopUnlocked(TimeoutVar uint64) uintptr {

	cret := xAsyncQueueTimeoutPopUnlocked(x.GoPointer(), TimeoutVar)
	return cret
}

var xAsyncQueueTryPop func(uintptr) uintptr

// Tries to pop data from the @queue. If no data is available,
// %NULL is returned.
func (x *AsyncQueue) TryPop() uintptr {

	cret := xAsyncQueueTryPop(x.GoPointer())
	return cret
}

var xAsyncQueueTryPopUnlocked func(uintptr) uintptr

// Tries to pop data from the @queue. If no data is available,
// %NULL is returned.
//
// This function must be called while holding the @queue's lock.
func (x *AsyncQueue) TryPopUnlocked() uintptr {

	cret := xAsyncQueueTryPopUnlocked(x.GoPointer())
	return cret
}

var xAsyncQueueUnlock func(uintptr)

// Releases the queue's lock.
//
// Calling this function when you have not acquired
// the with g_async_queue_lock() leads to undefined
// behaviour.
func (x *AsyncQueue) Unlock() {

	xAsyncQueueUnlock(x.GoPointer())

}

var xAsyncQueueUnref func(uintptr)

// Decreases the reference count of the asynchronous @queue by 1.
//
// If the reference count went to 0, the @queue will be destroyed
// and the memory allocated will be freed. So you are not allowed
// to use the @queue afterwards, as it might have disappeared.
// You do not need to hold the lock to call this function.
func (x *AsyncQueue) Unref() {

	xAsyncQueueUnref(x.GoPointer())

}

var xAsyncQueueUnrefAndUnlock func(uintptr)

// Decreases the reference count of the asynchronous @queue by 1
// and releases the lock. This function must be called while holding
// the @queue's lock. If the reference count went to 0, the @queue
// will be destroyed and the memory allocated will be freed.
func (x *AsyncQueue) UnrefAndUnlock() {

	xAsyncQueueUnrefAndUnlock(x.GoPointer())

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xAsyncQueueLength, lib, "g_async_queue_length")
	core.PuregoSafeRegister(&xAsyncQueueLengthUnlocked, lib, "g_async_queue_length_unlocked")
	core.PuregoSafeRegister(&xAsyncQueueLock, lib, "g_async_queue_lock")
	core.PuregoSafeRegister(&xAsyncQueuePop, lib, "g_async_queue_pop")
	core.PuregoSafeRegister(&xAsyncQueuePopUnlocked, lib, "g_async_queue_pop_unlocked")
	core.PuregoSafeRegister(&xAsyncQueuePush, lib, "g_async_queue_push")
	core.PuregoSafeRegister(&xAsyncQueuePushFront, lib, "g_async_queue_push_front")
	core.PuregoSafeRegister(&xAsyncQueuePushFrontUnlocked, lib, "g_async_queue_push_front_unlocked")
	core.PuregoSafeRegister(&xAsyncQueuePushSorted, lib, "g_async_queue_push_sorted")
	core.PuregoSafeRegister(&xAsyncQueuePushSortedUnlocked, lib, "g_async_queue_push_sorted_unlocked")
	core.PuregoSafeRegister(&xAsyncQueuePushUnlocked, lib, "g_async_queue_push_unlocked")
	core.PuregoSafeRegister(&xAsyncQueueRef, lib, "g_async_queue_ref")
	core.PuregoSafeRegister(&xAsyncQueueRefUnlocked, lib, "g_async_queue_ref_unlocked")
	core.PuregoSafeRegister(&xAsyncQueueRemove, lib, "g_async_queue_remove")
	core.PuregoSafeRegister(&xAsyncQueueRemoveUnlocked, lib, "g_async_queue_remove_unlocked")
	core.PuregoSafeRegister(&xAsyncQueueSort, lib, "g_async_queue_sort")
	core.PuregoSafeRegister(&xAsyncQueueSortUnlocked, lib, "g_async_queue_sort_unlocked")
	core.PuregoSafeRegister(&xAsyncQueueTimedPop, lib, "g_async_queue_timed_pop")
	core.PuregoSafeRegister(&xAsyncQueueTimedPopUnlocked, lib, "g_async_queue_timed_pop_unlocked")
	core.PuregoSafeRegister(&xAsyncQueueTimeoutPop, lib, "g_async_queue_timeout_pop")
	core.PuregoSafeRegister(&xAsyncQueueTimeoutPopUnlocked, lib, "g_async_queue_timeout_pop_unlocked")
	core.PuregoSafeRegister(&xAsyncQueueTryPop, lib, "g_async_queue_try_pop")
	core.PuregoSafeRegister(&xAsyncQueueTryPopUnlocked, lib, "g_async_queue_try_pop_unlocked")
	core.PuregoSafeRegister(&xAsyncQueueUnlock, lib, "g_async_queue_unlock")
	core.PuregoSafeRegister(&xAsyncQueueUnref, lib, "g_async_queue_unref")
	core.PuregoSafeRegister(&xAsyncQueueUnrefAndUnlock, lib, "g_async_queue_unref_and_unlock")

}
