// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// A typedef alias for gchar**. This is mostly useful when used together with
// g_auto().
type Strv = string

const (
	// A good size for a buffer to be passed into g_ascii_dtostr().
	// It is guaranteed to be enough for all output of that function
	// on systems with 64bit IEEE-compatible doubles.
	//
	// The typical usage would be something like:
	// |[&lt;!-- language="C" --&gt;
	//   char buf[G_ASCII_DTOSTR_BUF_SIZE];
	//
	//   fprintf (out, "value=%s\n", g_ascii_dtostr (buf, sizeof (buf), value));
	// ]|
	ASCII_DTOSTR_BUF_SIZE int = 39
	// The standard delimiters, used in g_strdelimit().
	STR_DELIMITERS string = "_-|> <."
)

type AsciiType int

const (
	GAsciiAlnumValue AsciiType = 1

	GAsciiAlphaValue AsciiType = 2

	GAsciiCntrlValue AsciiType = 4

	GAsciiDigitValue AsciiType = 8

	GAsciiGraphValue AsciiType = 16

	GAsciiLowerValue AsciiType = 32

	GAsciiPrintValue AsciiType = 64

	GAsciiPunctValue AsciiType = 128

	GAsciiSpaceValue AsciiType = 256

	GAsciiUpperValue AsciiType = 512

	GAsciiXdigitValue AsciiType = 1024
)

// Error codes returned by functions converting a string to a number.
type NumberParserError int

const (

	// String was not a valid number.
	GNumberParserErrorInvalidValue NumberParserError = 0
	// String was a number, but out of bounds.
	GNumberParserErrorOutOfBoundsValue NumberParserError = 1
)

var xAsciiDigitValue func(byte) int

// Determines the numeric value of a character as a decimal digit.
// Differs from g_unichar_digit_value() because it takes a char, so
// there's no worry about sign extension if characters are signed.
func AsciiDigitValue(CVar byte) int {

	cret := xAsciiDigitValue(CVar)
	return cret
}

var xAsciiDtostr func(string, int, float64) string

// Converts a #gdouble to a string, using the '.' as
// decimal point.
//
// This function generates enough precision that converting
// the string back using g_ascii_strtod() gives the same machine-number
// (on machines with IEEE compatible 64bit doubles). It is
// guaranteed that the size of the resulting string will never
// be larger than %G_ASCII_DTOSTR_BUF_SIZE bytes, including the terminating
// nul character, which is always added.
func AsciiDtostr(BufferVar string, BufLenVar int, DVar float64) string {

	cret := xAsciiDtostr(BufferVar, BufLenVar, DVar)
	return cret
}

var xAsciiFormatd func(string, int, string, float64) string

// Converts a #gdouble to a string, using the '.' as
// decimal point. To format the number you pass in
// a printf()-style format string. Allowed conversion
// specifiers are 'e', 'E', 'f', 'F', 'g' and 'G'.
//
// The @format must just be a single format specifier
// starting with `%`, expecting a #gdouble argument.
//
// The returned buffer is guaranteed to be nul-terminated.
//
// If you just want to want to serialize the value into a
// string, use g_ascii_dtostr().
func AsciiFormatd(BufferVar string, BufLenVar int, FormatVar string, DVar float64) string {

	cret := xAsciiFormatd(BufferVar, BufLenVar, FormatVar, DVar)
	return cret
}

var xAsciiStrcasecmp func(string, string) int

// Compare two strings, ignoring the case of ASCII characters.
//
// Unlike the BSD strcasecmp() function, this only recognizes standard
// ASCII letters and ignores the locale, treating all non-ASCII
// bytes as if they are not letters.
//
// This function should be used only on strings that are known to be
// in encodings where the bytes corresponding to ASCII letters always
// represent themselves. This includes UTF-8 and the ISO-8859-*
// charsets, but not for instance double-byte encodings like the
// Windows Codepage 932, where the trailing bytes of double-byte
// characters include all ASCII letters. If you compare two CP932
// strings using this function, you will get false matches.
//
// Both @s1 and @s2 must be non-%NULL.
func AsciiStrcasecmp(S1Var string, S2Var string) int {

	cret := xAsciiStrcasecmp(S1Var, S2Var)
	return cret
}

var xAsciiStrdown func(string, int) string

// Converts all upper case ASCII letters to lower case ASCII letters.
func AsciiStrdown(StrVar string, LenVar int) string {

	cret := xAsciiStrdown(StrVar, LenVar)
	return cret
}

var xAsciiStringToSigned func(string, uint, int64, int64, int64, **Error) bool

// A convenience function for converting a string to a signed number.
//
// This function assumes that @str contains only a number of the given
// @base that is within inclusive bounds limited by @min and @max. If
// this is true, then the converted number is stored in @out_num. An
// empty string is not a valid input. A string with leading or
// trailing whitespace is also an invalid input.
//
// @base can be between 2 and 36 inclusive. Hexadecimal numbers must
// not be prefixed with "0x" or "0X". Such a problem does not exist
// for octal numbers, since they were usually prefixed with a zero
// which does not change the value of the parsed number.
//
// Parsing failures result in an error with the %G_NUMBER_PARSER_ERROR
// domain. If the input is invalid, the error code will be
// %G_NUMBER_PARSER_ERROR_INVALID. If the parsed number is out of
// bounds - %G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS.
//
// See g_ascii_strtoll() if you have more complex needs such as
// parsing a string which starts with a number, but then has other
// characters.
func AsciiStringToSigned(StrVar string, BaseVar uint, MinVar int64, MaxVar int64, OutNumVar int64) (bool, error) {
	var cerr *Error

	cret := xAsciiStringToSigned(StrVar, BaseVar, MinVar, MaxVar, OutNumVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xAsciiStringToUnsigned func(string, uint, uint64, uint64, uint64, **Error) bool

// A convenience function for converting a string to an unsigned number.
//
// This function assumes that @str contains only a number of the given
// @base that is within inclusive bounds limited by @min and @max. If
// this is true, then the converted number is stored in @out_num. An
// empty string is not a valid input. A string with leading or
// trailing whitespace is also an invalid input. A string with a leading sign
// (`-` or `+`) is not a valid input for the unsigned parser.
//
// @base can be between 2 and 36 inclusive. Hexadecimal numbers must
// not be prefixed with "0x" or "0X". Such a problem does not exist
// for octal numbers, since they were usually prefixed with a zero
// which does not change the value of the parsed number.
//
// Parsing failures result in an error with the %G_NUMBER_PARSER_ERROR
// domain. If the input is invalid, the error code will be
// %G_NUMBER_PARSER_ERROR_INVALID. If the parsed number is out of
// bounds - %G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS.
//
// See g_ascii_strtoull() if you have more complex needs such as
// parsing a string which starts with a number, but then has other
// characters.
func AsciiStringToUnsigned(StrVar string, BaseVar uint, MinVar uint64, MaxVar uint64, OutNumVar uint64) (bool, error) {
	var cerr *Error

	cret := xAsciiStringToUnsigned(StrVar, BaseVar, MinVar, MaxVar, OutNumVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xAsciiStrncasecmp func(string, string, uint) int

// Compare @s1 and @s2, ignoring the case of ASCII characters and any
// characters after the first @n in each string. If either string is
// less than @n bytes long, comparison will stop at the first nul byte
// encountered.
//
// Unlike the BSD strcasecmp() function, this only recognizes standard
// ASCII letters and ignores the locale, treating all non-ASCII
// characters as if they are not letters.
//
// The same warning as in g_ascii_strcasecmp() applies: Use this
// function only on strings known to be in encodings where bytes
// corresponding to ASCII letters always represent themselves.
func AsciiStrncasecmp(S1Var string, S2Var string, NVar uint) int {

	cret := xAsciiStrncasecmp(S1Var, S2Var, NVar)
	return cret
}

var xAsciiStrtod func(string, string) float64

// Converts a string to a #gdouble value.
//
// This function behaves like the standard strtod() function
// does in the C locale. It does this without actually changing
// the current locale, since that would not be thread-safe.
// A limitation of the implementation is that this function
// will still accept localized versions of infinities and NANs.
//
// This function is typically used when reading configuration
// files or other non-user input that should be locale independent.
// To handle input from the user you should normally use the
// locale-sensitive system strtod() function.
//
// To convert from a #gdouble to a string in a locale-insensitive
// way, use g_ascii_dtostr().
//
// If the correct value would cause overflow, plus or minus %HUGE_VAL
// is returned (according to the sign of the value), and %ERANGE is
// stored in %errno. If the correct value would cause underflow,
// zero is returned and %ERANGE is stored in %errno.
//
// This function resets %errno before calling strtod() so that
// you can reliably detect overflow and underflow.
func AsciiStrtod(NptrVar string, EndptrVar string) float64 {

	cret := xAsciiStrtod(NptrVar, EndptrVar)
	return cret
}

var xAsciiStrtoll func(string, string, uint) int64

// Converts a string to a #gint64 value.
// This function behaves like the standard strtoll() function
// does in the C locale. It does this without actually
// changing the current locale, since that would not be
// thread-safe.
//
// This function is typically used when reading configuration
// files or other non-user input that should be locale independent.
// To handle input from the user you should normally use the
// locale-sensitive system strtoll() function.
//
// If the correct value would cause overflow, %G_MAXINT64 or %G_MININT64
// is returned, and `ERANGE` is stored in `errno`.
// If the base is outside the valid range, zero is returned, and
// `EINVAL` is stored in `errno`. If the
// string conversion fails, zero is returned, and @endptr returns @nptr
// (if @endptr is non-%NULL).
func AsciiStrtoll(NptrVar string, EndptrVar string, BaseVar uint) int64 {

	cret := xAsciiStrtoll(NptrVar, EndptrVar, BaseVar)
	return cret
}

var xAsciiStrtoull func(string, string, uint) uint64

// Converts a string to a #guint64 value.
// This function behaves like the standard strtoull() function
// does in the C locale. It does this without actually
// changing the current locale, since that would not be
// thread-safe.
//
// Note that input with a leading minus sign (`-`) is accepted, and will return
// the negation of the parsed number, unless that would overflow a #guint64.
// Critically, this means you cannot assume that a short fixed length input will
// never result in a low return value, as the input could have a leading `-`.
//
// This function is typically used when reading configuration
// files or other non-user input that should be locale independent.
// To handle input from the user you should normally use the
// locale-sensitive system strtoull() function.
//
// If the correct value would cause overflow, %G_MAXUINT64
// is returned, and `ERANGE` is stored in `errno`.
// If the base is outside the valid range, zero is returned, and
// `EINVAL` is stored in `errno`.
// If the string conversion fails, zero is returned, and @endptr returns
// @nptr (if @endptr is non-%NULL).
func AsciiStrtoull(NptrVar string, EndptrVar string, BaseVar uint) uint64 {

	cret := xAsciiStrtoull(NptrVar, EndptrVar, BaseVar)
	return cret
}

var xAsciiStrup func(string, int) string

// Converts all lower case ASCII letters to upper case ASCII letters.
func AsciiStrup(StrVar string, LenVar int) string {

	cret := xAsciiStrup(StrVar, LenVar)
	return cret
}

var xAsciiTolower func(byte) byte

// Convert a character to ASCII lower case.
//
// Unlike the standard C library tolower() function, this only
// recognizes standard ASCII letters and ignores the locale, returning
// all non-ASCII characters unchanged, even if they are lower case
// letters in a particular character set. Also unlike the standard
// library function, this takes and returns a char, not an int, so
// don't call it on %EOF but no need to worry about casting to #guchar
// before passing a possibly non-ASCII character in.
func AsciiTolower(CVar byte) byte {

	cret := xAsciiTolower(CVar)
	return cret
}

var xAsciiToupper func(byte) byte

// Convert a character to ASCII upper case.
//
// Unlike the standard C library toupper() function, this only
// recognizes standard ASCII letters and ignores the locale, returning
// all non-ASCII characters unchanged, even if they are upper case
// letters in a particular character set. Also unlike the standard
// library function, this takes and returns a char, not an int, so
// don't call it on %EOF but no need to worry about casting to #guchar
// before passing a possibly non-ASCII character in.
func AsciiToupper(CVar byte) byte {

	cret := xAsciiToupper(CVar)
	return cret
}

var xAsciiXdigitValue func(byte) int

// Determines the numeric value of a character as a hexadecimal
// digit. Differs from g_unichar_xdigit_value() because it takes
// a char, so there's no worry about sign extension if characters
// are signed.
func AsciiXdigitValue(CVar byte) int {

	cret := xAsciiXdigitValue(CVar)
	return cret
}

var xMemdup func(uintptr, uint) uintptr

// Allocates @byte_size bytes of memory, and copies @byte_size bytes into it
// from @mem. If @mem is %NULL it returns %NULL.
func Memdup(MemVar uintptr, ByteSizeVar uint) uintptr {

	cret := xMemdup(MemVar, ByteSizeVar)
	return cret
}

var xMemdup2 func(uintptr, uint) uintptr

// Allocates @byte_size bytes of memory, and copies @byte_size bytes into it
// from @mem. If @mem is %NULL it returns %NULL.
//
// This replaces g_memdup(), which was prone to integer overflows when
// converting the argument from a #gsize to a #guint.
func Memdup2(MemVar uintptr, ByteSizeVar uint) uintptr {

	cret := xMemdup2(MemVar, ByteSizeVar)
	return cret
}

var xStpcpy func(string, string) string

// Copies a nul-terminated string into the dest buffer, include the
// trailing nul, and return a pointer to the trailing nul byte.
// This is useful for concatenating multiple strings together
// without having to repeatedly scan for the end.
func Stpcpy(DestVar string, SrcVar string) string {

	cret := xStpcpy(DestVar, SrcVar)
	return cret
}

var xStrHasPrefix func(string, string) bool

// Looks whether the string @str begins with @prefix.
func StrHasPrefix(StrVar string, PrefixVar string) bool {

	cret := xStrHasPrefix(StrVar, PrefixVar)
	return cret
}

var xStrHasSuffix func(string, string) bool

// Looks whether the string @str ends with @suffix.
func StrHasSuffix(StrVar string, SuffixVar string) bool {

	cret := xStrHasSuffix(StrVar, SuffixVar)
	return cret
}

var xStrIsAscii func(string) bool

// Determines if a string is pure ASCII. A string is pure ASCII if it
// contains no bytes with the high bit set.
func StrIsAscii(StrVar string) bool {

	cret := xStrIsAscii(StrVar)
	return cret
}

var xStrMatchString func(string, string, bool) bool

// Checks if a search conducted for @search_term should match
// @potential_hit.
//
// This function calls g_str_tokenize_and_fold() on both
// @search_term and @potential_hit.  ASCII alternates are never taken
// for @search_term but will be taken for @potential_hit according to
// the value of @accept_alternates.
//
// A hit occurs when each folded token in @search_term is a prefix of a
// folded token from @potential_hit.
//
// Depending on how you're performing the search, it will typically be
// faster to call g_str_tokenize_and_fold() on each string in
// your corpus and build an index on the returned folded tokens, then
// call g_str_tokenize_and_fold() on the search term and
// perform lookups into that index.
//
// As some examples, searching for ‘fred’ would match the potential hit
// ‘Smith, Fred’ and also ‘Frédéric’.  Searching for ‘Fréd’ would match
// ‘Frédéric’ but not ‘Frederic’ (due to the one-directional nature of
// accent matching).  Searching ‘fo’ would match ‘Foo’ and ‘Bar Foo
// Baz’, but not ‘SFO’ (because no word has ‘fo’ as a prefix).
func StrMatchString(SearchTermVar string, PotentialHitVar string, AcceptAlternatesVar bool) bool {

	cret := xStrMatchString(SearchTermVar, PotentialHitVar, AcceptAlternatesVar)
	return cret
}

var xStrToAscii func(string, string) string

// Transliterate @str to plain ASCII.
//
// For best results, @str should be in composed normalised form.
//
// This function performs a reasonably good set of character
// replacements.  The particular set of replacements that is done may
// change by version or even by runtime environment.
//
// If the source language of @str is known, it can used to improve the
// accuracy of the translation by passing it as @from_locale.  It should
// be a valid POSIX locale string (of the form
// `language[_territory][.codeset][@modifier]`).
//
// If @from_locale is %NULL then the current locale is used.
//
// If you want to do translation for no specific locale, and you want it
// to be done independently of the currently locale, specify `"C"` for
// @from_locale.
func StrToAscii(StrVar string, FromLocaleVar string) string {

	cret := xStrToAscii(StrVar, FromLocaleVar)
	return cret
}

var xStrTokenizeAndFold func(string, string, []string) []string

// Tokenises @string and performs folding on each token.
//
// A token is a non-empty sequence of alphanumeric characters in the
// source string, separated by non-alphanumeric characters.  An
// "alphanumeric" character for this purpose is one that matches
// g_unichar_isalnum() or g_unichar_ismark().
//
// Each token is then (Unicode) normalised and case-folded.  If
// @ascii_alternates is non-%NULL and some of the returned tokens
// contain non-ASCII characters, ASCII alternatives will be generated.
//
// The number of ASCII alternatives that are generated and the method
// for doing so is unspecified, but @translit_locale (if specified) may
// improve the transliteration if the language of the source string is
// known.
func StrTokenizeAndFold(StringVar string, TranslitLocaleVar string, AsciiAlternatesVar []string) []string {

	cret := xStrTokenizeAndFold(StringVar, TranslitLocaleVar, AsciiAlternatesVar)
	return cret
}

var xStrcanon func(string, string, byte) string

// For each character in @string, if the character is not in @valid_chars,
// replaces the character with @substitutor.
//
// Modifies @string in place, and return @string itself, not a copy. The
// return value is to allow nesting such as:
//
// |[&lt;!-- language="C" --&gt;
//
//	g_ascii_strup (g_strcanon (str, "abc", '?'))
//
// ]|
//
// In order to modify a copy, you may use g_strdup():
//
// |[&lt;!-- language="C" --&gt;
//
//	reformatted = g_strcanon (g_strdup (const_str), "abc", '?');
//	...
//	g_free (reformatted);
//
// ]|
func Strcanon(StringVar string, ValidCharsVar string, SubstitutorVar byte) string {

	cret := xStrcanon(StringVar, ValidCharsVar, SubstitutorVar)
	return cret
}

var xStrcasecmp func(string, string) int

// A case-insensitive string comparison, corresponding to the standard
// strcasecmp() function on platforms which support it.
func Strcasecmp(S1Var string, S2Var string) int {

	cret := xStrcasecmp(S1Var, S2Var)
	return cret
}

var xStrchomp func(string) string

// Removes trailing whitespace from a string.
//
// This function doesn't allocate or reallocate any memory;
// it modifies @string in place. Therefore, it cannot be used
// on statically allocated strings.
//
// The pointer to @string is returned to allow the nesting of functions.
//
// Also see g_strchug() and g_strstrip().
func Strchomp(StringVar string) string {

	cret := xStrchomp(StringVar)
	return cret
}

var xStrchug func(string) string

// Removes leading whitespace from a string, by moving the rest
// of the characters forward.
//
// This function doesn't allocate or reallocate any memory;
// it modifies @string in place. Therefore, it cannot be used on
// statically allocated strings.
//
// The pointer to @string is returned to allow the nesting of functions.
//
// Also see g_strchomp() and g_strstrip().
func Strchug(StringVar string) string {

	cret := xStrchug(StringVar)
	return cret
}

var xStrcompress func(string) string

// Replaces all escaped characters with their one byte equivalent.
//
// This function does the reverse conversion of g_strescape().
func Strcompress(SourceVar string) string {

	cret := xStrcompress(SourceVar)
	return cret
}

var xStrconcat func(string, ...interface{}) string

// Concatenates all of the given strings into one long string. The
// returned string should be freed with g_free() when no longer needed.
//
// The variable argument list must end with %NULL. If you forget the %NULL,
// g_strconcat() will start appending random memory junk to your string.
//
// Note that this function is usually not the right function to use to
// assemble a translated message from pieces, since proper translation
// often requires the pieces to be reordered.
func Strconcat(String1Var string, varArgs ...interface{}) string {

	cret := xStrconcat(String1Var, varArgs...)
	return cret
}

var xStrdelimit func(string, string, byte) string

// Converts any delimiter characters in @string to @new_delimiter.
//
// Any characters in @string which are found in @delimiters are
// changed to the @new_delimiter character. Modifies @string in place,
// and returns @string itself, not a copy.
//
// The return value is to allow nesting such as:
//
// |[&lt;!-- language="C" --&gt;
//
//	g_ascii_strup (g_strdelimit (str, "abc", '?'))
//
// ]|
//
// In order to modify a copy, you may use g_strdup():
//
// |[&lt;!-- language="C" --&gt;
//
//	reformatted = g_strdelimit (g_strdup (const_str), "abc", '?');
//	...
//	g_free (reformatted);
//
// ]|
func Strdelimit(StringVar string, DelimitersVar string, NewDelimiterVar byte) string {

	cret := xStrdelimit(StringVar, DelimitersVar, NewDelimiterVar)
	return cret
}

var xStrdown func(string) string

// Converts a string to lower case.
func Strdown(StringVar string) string {

	cret := xStrdown(StringVar)
	return cret
}

var xStrdup func(string) string

// Duplicates a string. If @str is %NULL it returns %NULL.
// The returned string should be freed with g_free()
// when no longer needed.
func Strdup(StrVar string) string {

	cret := xStrdup(StrVar)
	return cret
}

var xStrdupPrintf func(string, ...interface{}) string

// Similar to the standard C sprintf() function but safer, since it
// calculates the maximum space required and allocates memory to hold
// the result. The returned string should be freed with g_free() when no
// longer needed.
//
// The returned string is guaranteed to be non-NULL, unless @format
// contains `%lc` or `%ls` conversions, which can fail if no multibyte
// representation is available for the given character.
func StrdupPrintf(FormatVar string, varArgs ...interface{}) string {

	cret := xStrdupPrintf(FormatVar, varArgs...)
	return cret
}

var xStrdupVprintf func(string, []interface{}) string

// Similar to the standard C vsprintf() function but safer, since it
// calculates the maximum space required and allocates memory to hold
// the result. The returned string should be freed with g_free() when
// no longer needed.
//
// The returned string is guaranteed to be non-NULL, unless @format
// contains `%lc` or `%ls` conversions, which can fail if no multibyte
// representation is available for the given character.
//
// See also g_vasprintf(), which offers the same functionality, but
// additionally returns the length of the allocated string.
func StrdupVprintf(FormatVar string, ArgsVar []interface{}) string {

	cret := xStrdupVprintf(FormatVar, ArgsVar)
	return cret
}

var xStrdupv func(string) []string

// Copies %NULL-terminated array of strings. The copy is a deep copy;
// the new array should be freed by first freeing each string, then
// the array itself. g_strfreev() does this for you. If called
// on a %NULL value, g_strdupv() simply returns %NULL.
func Strdupv(StrArrayVar string) []string {

	cret := xStrdupv(StrArrayVar)
	return cret
}

var xStrerror func(int) string

// Returns a string corresponding to the given error code, e.g. "no
// such process". Unlike strerror(), this always returns a string in
// UTF-8 encoding, and the pointer is guaranteed to remain valid for
// the lifetime of the process.
//
// Note that the string may be translated according to the current locale.
//
// The value of %errno will not be changed by this function. However, it may
// be changed by intermediate function calls, so you should save its value
// as soon as the call returns:
// |[
//
//	int saved_errno;
//
//	ret = read (blah);
//	saved_errno = errno;
//
//	g_strerror (saved_errno);
//
// ]|
func Strerror(ErrnumVar int) string {

	cret := xStrerror(ErrnumVar)
	return cret
}

var xStrescape func(string, string) string

// Escapes the special characters '\b', '\f', '\n', '\r', '\t', '\v', '\'
// and '"' in the string @source by inserting a '\' before
// them. Additionally all characters in the range 0x01-0x1F (everything
// below SPACE) and in the range 0x7F-0xFF (all non-ASCII chars) are
// replaced with a '\' followed by their octal representation.
// Characters supplied in @exceptions are not escaped.
//
// g_strcompress() does the reverse conversion.
func Strescape(SourceVar string, ExceptionsVar string) string {

	cret := xStrescape(SourceVar, ExceptionsVar)
	return cret
}

var xStrfreev func(string)

// Frees a %NULL-terminated array of strings, as well as each
// string it contains.
//
// If @str_array is %NULL, this function simply returns.
func Strfreev(StrArrayVar string) {

	xStrfreev(StrArrayVar)

}

var xStrjoin func(string, ...interface{}) string

// Joins a number of strings together to form one long string, with the
// optional @separator inserted between each of them. The returned string
// should be freed with g_free().
func Strjoin(SeparatorVar string, varArgs ...interface{}) string {

	cret := xStrjoin(SeparatorVar, varArgs...)
	return cret
}

var xStrjoinv func(string, string) string

// Joins a number of strings together to form one long string, with the
// optional @separator inserted between each of them. The returned string
// should be freed with g_free().
//
// If @str_array has no items, the return value will be an
// empty string. If @str_array contains a single item, @separator will not
// appear in the resulting string.
func Strjoinv(SeparatorVar string, StrArrayVar string) string {

	cret := xStrjoinv(SeparatorVar, StrArrayVar)
	return cret
}

var xStrlcat func(string, string, uint) uint

// Portability wrapper that calls strlcat() on systems which have it,
// and emulates it otherwise. Appends nul-terminated @src string to @dest,
// guaranteeing nul-termination for @dest. The total size of @dest won't
// exceed @dest_size.
//
// At most @dest_size - 1 characters will be copied. Unlike strncat(),
// @dest_size is the full size of dest, not the space left over. This
// function does not allocate memory. It always nul-terminates (unless
// @dest_size == 0 or there were no nul characters in the @dest_size
// characters of dest to start with).
//
// Caveat: this is supposedly a more secure alternative to strcat() or
// strncat(), but for real security g_strconcat() is harder to mess up.
func Strlcat(DestVar string, SrcVar string, DestSizeVar uint) uint {

	cret := xStrlcat(DestVar, SrcVar, DestSizeVar)
	return cret
}

var xStrlcpy func(string, string, uint) uint

// Portability wrapper that calls strlcpy() on systems which have it,
// and emulates strlcpy() otherwise. Copies @src to @dest; @dest is
// guaranteed to be nul-terminated; @src must be nul-terminated;
// @dest_size is the buffer size, not the number of bytes to copy.
//
// At most @dest_size - 1 characters will be copied. Always nul-terminates
// (unless @dest_size is 0). This function does not allocate memory. Unlike
// strncpy(), this function doesn't pad @dest (so it's often faster). It
// returns the size of the attempted result, strlen (src), so if
// @retval &gt;= @dest_size, truncation occurred.
//
// Caveat: strlcpy() is supposedly more secure than strcpy() or strncpy(),
// but if you really want to avoid screwups, g_strdup() is an even better
// idea.
func Strlcpy(DestVar string, SrcVar string, DestSizeVar uint) uint {

	cret := xStrlcpy(DestVar, SrcVar, DestSizeVar)
	return cret
}

var xStrncasecmp func(string, string, uint) int

// A case-insensitive string comparison, corresponding to the standard
// strncasecmp() function on platforms which support it. It is similar
// to g_strcasecmp() except it only compares the first @n characters of
// the strings.
func Strncasecmp(S1Var string, S2Var string, NVar uint) int {

	cret := xStrncasecmp(S1Var, S2Var, NVar)
	return cret
}

var xStrndup func(string, uint) string

// Duplicates the first @n bytes of a string, returning a newly-allocated
// buffer @n + 1 bytes long which will always be nul-terminated. If @str
// is less than @n bytes long the buffer is padded with nuls. If @str is
// %NULL it returns %NULL. The returned value should be freed when no longer
// needed.
//
// To copy a number of characters from a UTF-8 encoded string,
// use g_utf8_strncpy() instead.
func Strndup(StrVar string, NVar uint) string {

	cret := xStrndup(StrVar, NVar)
	return cret
}

var xStrnfill func(uint, byte) string

// Creates a new string @length bytes long filled with @fill_char.
// The returned string should be freed when no longer needed.
func Strnfill(LengthVar uint, FillCharVar byte) string {

	cret := xStrnfill(LengthVar, FillCharVar)
	return cret
}

var xStrreverse func(string) string

// Reverses all of the bytes in a string. For example,
// `g_strreverse ("abcdef")` will result in "fedcba".
//
// Note that g_strreverse() doesn't work on UTF-8 strings
// containing multibyte characters. For that purpose, use
// g_utf8_strreverse().
func Strreverse(StringVar string) string {

	cret := xStrreverse(StringVar)
	return cret
}

var xStrrstr func(string, string) string

// Searches the string @haystack for the last occurrence
// of the string @needle.
func Strrstr(HaystackVar string, NeedleVar string) string {

	cret := xStrrstr(HaystackVar, NeedleVar)
	return cret
}

var xStrrstrLen func(string, int, string) string

// Searches the string @haystack for the last occurrence
// of the string @needle, limiting the length of the search
// to @haystack_len.
func StrrstrLen(HaystackVar string, HaystackLenVar int, NeedleVar string) string {

	cret := xStrrstrLen(HaystackVar, HaystackLenVar, NeedleVar)
	return cret
}

var xStrsignal func(int) string

// Returns a string describing the given signal, e.g. "Segmentation fault".
// You should use this function in preference to strsignal(), because it
// returns a string in UTF-8 encoding, and since not all platforms support
// the strsignal() function.
func Strsignal(SignumVar int) string {

	cret := xStrsignal(SignumVar)
	return cret
}

var xStrsplit func(string, string, int) []string

// Splits a string into a maximum of @max_tokens pieces, using the given
// @delimiter. If @max_tokens is reached, the remainder of @string is
// appended to the last token.
//
// As an example, the result of g_strsplit (":a:bc::d:", ":", -1) is a
// %NULL-terminated vector containing the six strings "", "a", "bc", "", "d"
// and "".
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this
// special case is that being able to represent an empty vector is typically
// more useful than consistent handling of empty elements. If you do need
// to represent empty elements, you'll need to check for the empty string
// before calling g_strsplit().
func Strsplit(StringVar string, DelimiterVar string, MaxTokensVar int) []string {

	cret := xStrsplit(StringVar, DelimiterVar, MaxTokensVar)
	return cret
}

var xStrsplitSet func(string, string, int) []string

// Splits @string into a number of tokens not containing any of the characters
// in @delimiter. A token is the (possibly empty) longest string that does not
// contain any of the characters in @delimiters. If @max_tokens is reached, the
// remainder is appended to the last token.
//
// For example the result of g_strsplit_set ("abc:def/ghi", ":/", -1) is a
// %NULL-terminated vector containing the three strings "abc", "def",
// and "ghi".
//
// The result of g_strsplit_set (":def/ghi:", ":/", -1) is a %NULL-terminated
// vector containing the four strings "", "def", "ghi", and "".
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this
// special case is that being able to represent an empty vector is typically
// more useful than consistent handling of empty elements. If you do need
// to represent empty elements, you'll need to check for the empty string
// before calling g_strsplit_set().
//
// Note that this function works on bytes not characters, so it can't be used
// to delimit UTF-8 strings for anything but ASCII characters.
func StrsplitSet(StringVar string, DelimitersVar string, MaxTokensVar int) []string {

	cret := xStrsplitSet(StringVar, DelimitersVar, MaxTokensVar)
	return cret
}

var xStrstrLen func(string, int, string) string

// Searches the string @haystack for the first occurrence
// of the string @needle, limiting the length of the search
// to @haystack_len.
func StrstrLen(HaystackVar string, HaystackLenVar int, NeedleVar string) string {

	cret := xStrstrLen(HaystackVar, HaystackLenVar, NeedleVar)
	return cret
}

var xStrtod func(string, string) float64

// Converts a string to a #gdouble value.
// It calls the standard strtod() function to handle the conversion, but
// if the string is not completely converted it attempts the conversion
// again with g_ascii_strtod(), and returns the best match.
//
// This function should seldom be used. The normal situation when reading
// numbers not for human consumption is to use g_ascii_strtod(). Only when
// you know that you must expect both locale formatted and C formatted numbers
// should you use this. Make sure that you don't pass strings such as comma
// separated lists of values, since the commas may be interpreted as a decimal
// point in some locales, causing unexpected results.
func Strtod(NptrVar string, EndptrVar string) float64 {

	cret := xStrtod(NptrVar, EndptrVar)
	return cret
}

var xStrup func(string) string

// Converts a string to upper case.
func Strup(StringVar string) string {

	cret := xStrup(StringVar)
	return cret
}

var xStrvContains func(string, string) bool

// Checks if @strv contains @str. @strv must not be %NULL.
func StrvContains(StrvVar string, StrVar string) bool {

	cret := xStrvContains(StrvVar, StrVar)
	return cret
}

var xStrvEqual func(string, string) bool

// Checks if @strv1 and @strv2 contain exactly the same elements in exactly the
// same order. Elements are compared using g_str_equal(). To match independently
// of order, sort the arrays first (using g_qsort_with_data() or similar).
//
// Two empty arrays are considered equal. Neither @strv1 not @strv2 may be
// %NULL.
func StrvEqual(Strv1Var string, Strv2Var string) bool {

	cret := xStrvEqual(Strv1Var, Strv2Var)
	return cret
}

var xStrvLength func(string) uint

// Returns the length of the given %NULL-terminated
// string array @str_array. @str_array must not be %NULL.
func StrvLength(StrArrayVar string) uint {

	cret := xStrvLength(StrArrayVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xAsciiDigitValue, lib, "g_ascii_digit_value")
	core.PuregoSafeRegister(&xAsciiDtostr, lib, "g_ascii_dtostr")
	core.PuregoSafeRegister(&xAsciiFormatd, lib, "g_ascii_formatd")
	core.PuregoSafeRegister(&xAsciiStrcasecmp, lib, "g_ascii_strcasecmp")
	core.PuregoSafeRegister(&xAsciiStrdown, lib, "g_ascii_strdown")
	core.PuregoSafeRegister(&xAsciiStringToSigned, lib, "g_ascii_string_to_signed")
	core.PuregoSafeRegister(&xAsciiStringToUnsigned, lib, "g_ascii_string_to_unsigned")
	core.PuregoSafeRegister(&xAsciiStrncasecmp, lib, "g_ascii_strncasecmp")
	core.PuregoSafeRegister(&xAsciiStrtod, lib, "g_ascii_strtod")
	core.PuregoSafeRegister(&xAsciiStrtoll, lib, "g_ascii_strtoll")
	core.PuregoSafeRegister(&xAsciiStrtoull, lib, "g_ascii_strtoull")
	core.PuregoSafeRegister(&xAsciiStrup, lib, "g_ascii_strup")
	core.PuregoSafeRegister(&xAsciiTolower, lib, "g_ascii_tolower")
	core.PuregoSafeRegister(&xAsciiToupper, lib, "g_ascii_toupper")
	core.PuregoSafeRegister(&xAsciiXdigitValue, lib, "g_ascii_xdigit_value")
	core.PuregoSafeRegister(&xMemdup, lib, "g_memdup")
	core.PuregoSafeRegister(&xMemdup2, lib, "g_memdup2")
	core.PuregoSafeRegister(&xStpcpy, lib, "g_stpcpy")
	core.PuregoSafeRegister(&xStrHasPrefix, lib, "g_str_has_prefix")
	core.PuregoSafeRegister(&xStrHasSuffix, lib, "g_str_has_suffix")
	core.PuregoSafeRegister(&xStrIsAscii, lib, "g_str_is_ascii")
	core.PuregoSafeRegister(&xStrMatchString, lib, "g_str_match_string")
	core.PuregoSafeRegister(&xStrToAscii, lib, "g_str_to_ascii")
	core.PuregoSafeRegister(&xStrTokenizeAndFold, lib, "g_str_tokenize_and_fold")
	core.PuregoSafeRegister(&xStrcanon, lib, "g_strcanon")
	core.PuregoSafeRegister(&xStrcasecmp, lib, "g_strcasecmp")
	core.PuregoSafeRegister(&xStrchomp, lib, "g_strchomp")
	core.PuregoSafeRegister(&xStrchug, lib, "g_strchug")
	core.PuregoSafeRegister(&xStrcompress, lib, "g_strcompress")
	core.PuregoSafeRegister(&xStrconcat, lib, "g_strconcat")
	core.PuregoSafeRegister(&xStrdelimit, lib, "g_strdelimit")
	core.PuregoSafeRegister(&xStrdown, lib, "g_strdown")
	core.PuregoSafeRegister(&xStrdup, lib, "g_strdup")
	core.PuregoSafeRegister(&xStrdupPrintf, lib, "g_strdup_printf")
	core.PuregoSafeRegister(&xStrdupVprintf, lib, "g_strdup_vprintf")
	core.PuregoSafeRegister(&xStrdupv, lib, "g_strdupv")
	core.PuregoSafeRegister(&xStrerror, lib, "g_strerror")
	core.PuregoSafeRegister(&xStrescape, lib, "g_strescape")
	core.PuregoSafeRegister(&xStrfreev, lib, "g_strfreev")
	core.PuregoSafeRegister(&xStrjoin, lib, "g_strjoin")
	core.PuregoSafeRegister(&xStrjoinv, lib, "g_strjoinv")
	core.PuregoSafeRegister(&xStrlcat, lib, "g_strlcat")
	core.PuregoSafeRegister(&xStrlcpy, lib, "g_strlcpy")
	core.PuregoSafeRegister(&xStrncasecmp, lib, "g_strncasecmp")
	core.PuregoSafeRegister(&xStrndup, lib, "g_strndup")
	core.PuregoSafeRegister(&xStrnfill, lib, "g_strnfill")
	core.PuregoSafeRegister(&xStrreverse, lib, "g_strreverse")
	core.PuregoSafeRegister(&xStrrstr, lib, "g_strrstr")
	core.PuregoSafeRegister(&xStrrstrLen, lib, "g_strrstr_len")
	core.PuregoSafeRegister(&xStrsignal, lib, "g_strsignal")
	core.PuregoSafeRegister(&xStrsplit, lib, "g_strsplit")
	core.PuregoSafeRegister(&xStrsplitSet, lib, "g_strsplit_set")
	core.PuregoSafeRegister(&xStrstrLen, lib, "g_strstr_len")
	core.PuregoSafeRegister(&xStrtod, lib, "g_strtod")
	core.PuregoSafeRegister(&xStrup, lib, "g_strup")
	core.PuregoSafeRegister(&xStrvContains, lib, "g_strv_contains")
	core.PuregoSafeRegister(&xStrvEqual, lib, "g_strv_equal")
	core.PuregoSafeRegister(&xStrvLength, lib, "g_strv_length")

}
