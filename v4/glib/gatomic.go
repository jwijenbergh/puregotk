// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

var xAtomicIntAdd func(int, int) int

// Atomically adds @val to the value of @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic += val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// Before version 2.30, this function did not return a value
// (but g_atomic_int_exchange_and_add() did, and had the same meaning).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntAdd(AtomicVar int, ValVar int) int {

	cret := xAtomicIntAdd(AtomicVar, ValVar)
	return cret
}

var xAtomicIntAnd func(uint, uint) uint

// Performs an atomic bitwise 'and' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// This call acts as a full compiler and hardware memory barrier.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic &amp;= val; return tmp; }`.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntAnd(AtomicVar uint, ValVar uint) uint {

	cret := xAtomicIntAnd(AtomicVar, ValVar)
	return cret
}

var xAtomicIntCompareAndExchange func(int, int, int) bool

// Compares @atomic to @oldval and, if equal, sets it to @newval.
// If @atomic was not equal to @oldval then no change occurs.
//
// This compare and exchange is done atomically.
//
// Think of this operation as an atomic version of
// `{ if (*atomic == oldval) { *atomic = newval; return TRUE; } else return FALSE; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntCompareAndExchange(AtomicVar int, OldvalVar int, NewvalVar int) bool {

	cret := xAtomicIntCompareAndExchange(AtomicVar, OldvalVar, NewvalVar)
	return cret
}

var xAtomicIntDecAndTest func(int) bool

// Decrements the value of @atomic by 1.
//
// Think of this operation as an atomic version of
// `{ *atomic -= 1; return (*atomic == 0); }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntDecAndTest(AtomicVar int) bool {

	cret := xAtomicIntDecAndTest(AtomicVar)
	return cret
}

var xAtomicIntExchangeAndAdd func(int, int) int

// This function existed before g_atomic_int_add() returned the prior
// value of the integer (which it now does).  It is retained only for
// compatibility reasons.  Don't use this function in new code.
func AtomicIntExchangeAndAdd(AtomicVar int, ValVar int) int {

	cret := xAtomicIntExchangeAndAdd(AtomicVar, ValVar)
	return cret
}

var xAtomicIntGet func(int) int

// Gets the current value of @atomic.
//
// This call acts as a full compiler and hardware
// memory barrier (before the get).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntGet(AtomicVar int) int {

	cret := xAtomicIntGet(AtomicVar)
	return cret
}

var xAtomicIntInc func(int)

// Increments the value of @atomic by 1.
//
// Think of this operation as an atomic version of `{ *atomic += 1; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntInc(AtomicVar int) {

	xAtomicIntInc(AtomicVar)

}

var xAtomicIntOr func(uint, uint) uint

// Performs an atomic bitwise 'or' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic |= val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntOr(AtomicVar uint, ValVar uint) uint {

	cret := xAtomicIntOr(AtomicVar, ValVar)
	return cret
}

var xAtomicIntSet func(int, int)

// Sets the value of @atomic to @newval.
//
// This call acts as a full compiler and hardware
// memory barrier (after the set).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntSet(AtomicVar int, NewvalVar int) {

	xAtomicIntSet(AtomicVar, NewvalVar)

}

var xAtomicIntXor func(uint, uint) uint

// Performs an atomic bitwise 'xor' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic ^= val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicIntXor(AtomicVar uint, ValVar uint) uint {

	cret := xAtomicIntXor(AtomicVar, ValVar)
	return cret
}

var xAtomicPointerAdd func(uintptr, int) int

// Atomically adds @val to the value of @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic += val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerAdd(AtomicVar uintptr, ValVar int) int {

	cret := xAtomicPointerAdd(AtomicVar, ValVar)
	return cret
}

var xAtomicPointerAnd func(uintptr, uint) uint

// Performs an atomic bitwise 'and' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic &amp;= val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerAnd(AtomicVar uintptr, ValVar uint) uint {

	cret := xAtomicPointerAnd(AtomicVar, ValVar)
	return cret
}

var xAtomicPointerCompareAndExchange func(uintptr, uintptr, uintptr) bool

// Compares @atomic to @oldval and, if equal, sets it to @newval.
// If @atomic was not equal to @oldval then no change occurs.
//
// This compare and exchange is done atomically.
//
// Think of this operation as an atomic version of
// `{ if (*atomic == oldval) { *atomic = newval; return TRUE; } else return FALSE; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerCompareAndExchange(AtomicVar uintptr, OldvalVar uintptr, NewvalVar uintptr) bool {

	cret := xAtomicPointerCompareAndExchange(AtomicVar, OldvalVar, NewvalVar)
	return cret
}

var xAtomicPointerGet func(uintptr) uintptr

// Gets the current value of @atomic.
//
// This call acts as a full compiler and hardware
// memory barrier (before the get).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerGet(AtomicVar uintptr) uintptr {

	cret := xAtomicPointerGet(AtomicVar)
	return cret
}

var xAtomicPointerOr func(uintptr, uint) uint

// Performs an atomic bitwise 'or' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic |= val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerOr(AtomicVar uintptr, ValVar uint) uint {

	cret := xAtomicPointerOr(AtomicVar, ValVar)
	return cret
}

var xAtomicPointerSet func(uintptr, uintptr)

// Sets the value of @atomic to @newval.
//
// This call acts as a full compiler and hardware
// memory barrier (after the set).
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerSet(AtomicVar uintptr, NewvalVar uintptr) {

	xAtomicPointerSet(AtomicVar, NewvalVar)

}

var xAtomicPointerXor func(uintptr, uint) uint

// Performs an atomic bitwise 'xor' of the value of @atomic and @val,
// storing the result back in @atomic.
//
// Think of this operation as an atomic version of
// `{ tmp = *atomic; *atomic ^= val; return tmp; }`.
//
// This call acts as a full compiler and hardware memory barrier.
//
// While @atomic has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func AtomicPointerXor(AtomicVar uintptr, ValVar uint) uint {

	cret := xAtomicPointerXor(AtomicVar, ValVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xAtomicIntAdd, lib, "g_atomic_int_add")
	core.PuregoSafeRegister(&xAtomicIntAnd, lib, "g_atomic_int_and")
	core.PuregoSafeRegister(&xAtomicIntCompareAndExchange, lib, "g_atomic_int_compare_and_exchange")
	core.PuregoSafeRegister(&xAtomicIntDecAndTest, lib, "g_atomic_int_dec_and_test")
	core.PuregoSafeRegister(&xAtomicIntExchangeAndAdd, lib, "g_atomic_int_exchange_and_add")
	core.PuregoSafeRegister(&xAtomicIntGet, lib, "g_atomic_int_get")
	core.PuregoSafeRegister(&xAtomicIntInc, lib, "g_atomic_int_inc")
	core.PuregoSafeRegister(&xAtomicIntOr, lib, "g_atomic_int_or")
	core.PuregoSafeRegister(&xAtomicIntSet, lib, "g_atomic_int_set")
	core.PuregoSafeRegister(&xAtomicIntXor, lib, "g_atomic_int_xor")
	core.PuregoSafeRegister(&xAtomicPointerAdd, lib, "g_atomic_pointer_add")
	core.PuregoSafeRegister(&xAtomicPointerAnd, lib, "g_atomic_pointer_and")
	core.PuregoSafeRegister(&xAtomicPointerCompareAndExchange, lib, "g_atomic_pointer_compare_and_exchange")
	core.PuregoSafeRegister(&xAtomicPointerGet, lib, "g_atomic_pointer_get")
	core.PuregoSafeRegister(&xAtomicPointerOr, lib, "g_atomic_pointer_or")
	core.PuregoSafeRegister(&xAtomicPointerSet, lib, "g_atomic_pointer_set")
	core.PuregoSafeRegister(&xAtomicPointerXor, lib, "g_atomic_pointer_xor")

}
