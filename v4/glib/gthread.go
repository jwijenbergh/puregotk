// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Specifies the type of the @func functions passed to g_thread_new()
// or g_thread_try_new().
type ThreadFunc func(uintptr) uintptr

// The #GCond struct is an opaque data structure that represents a
// condition. Threads can block on a #GCond if they find a certain
// condition to be false. If other threads change the state of this
// condition they signal the #GCond, and that causes the waiting
// threads to be woken up.
//
// Consider the following example of a shared variable.  One or more
// threads can wait for data to be published to the variable and when
// another thread publishes the data, it can signal one of the waiting
// threads to wake up to collect the data.
//
// Here is an example for using GCond to block a thread until a condition
// is satisfied:
// |[&lt;!-- language="C" --&gt;
//
//	gpointer current_data = NULL;
//	GMutex data_mutex;
//	GCond data_cond;
//
//	void
//	push_data (gpointer data)
//	{
//	  g_mutex_lock (&amp;data_mutex);
//	  current_data = data;
//	  g_cond_signal (&amp;data_cond);
//	  g_mutex_unlock (&amp;data_mutex);
//	}
//
//	gpointer
//	pop_data (void)
//	{
//	  gpointer data;
//
//	  g_mutex_lock (&amp;data_mutex);
//	  while (!current_data)
//	    g_cond_wait (&amp;data_cond, &amp;data_mutex);
//	  data = current_data;
//	  current_data = NULL;
//	  g_mutex_unlock (&amp;data_mutex);
//
//	  return data;
//	}
//
// ]|
// Whenever a thread calls pop_data() now, it will wait until
// current_data is non-%NULL, i.e. until some other thread
// has called push_data().
//
// The example shows that use of a condition variable must always be
// paired with a mutex.  Without the use of a mutex, there would be a
// race between the check of @current_data by the while loop in
// pop_data() and waiting. Specifically, another thread could set
// @current_data after the check, and signal the cond (with nobody
// waiting on it) before the first thread goes to sleep. #GCond is
// specifically useful for its ability to release the mutex and go
// to sleep atomically.
//
// It is also important to use the g_cond_wait() and g_cond_wait_until()
// functions only inside a loop which checks for the condition to be
// true.  See g_cond_wait() for an explanation of why the condition may
// not be true even after it returns.
//
// If a #GCond is allocated in static storage then it can be used
// without initialisation.  Otherwise, you should call g_cond_init()
// on it and g_cond_clear() when done.
//
// A #GCond should only be accessed via the g_cond_ functions.
type Cond struct {
	_ structs.HostLayout

	P uintptr

	I [2]uint
}

func (x *Cond) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xCondBroadcast func(uintptr)

// If threads are waiting for @cond, all of them are unblocked.
// If no threads are waiting for @cond, this function has no effect.
// It is good practice to lock the same mutex as the waiting threads
// while calling this function, though not required.
func (x *Cond) Broadcast() {

	xCondBroadcast(x.GoPointer())

}

var xCondClear func(uintptr)

// Frees the resources allocated to a #GCond with g_cond_init().
//
// This function should not be used with a #GCond that has been
// statically allocated.
//
// Calling g_cond_clear() for a #GCond on which threads are
// blocking leads to undefined behaviour.
func (x *Cond) Clear() {

	xCondClear(x.GoPointer())

}

var xCondInit func(uintptr)

// Initialises a #GCond so that it can be used.
//
// This function is useful to initialise a #GCond that has been
// allocated as part of a larger structure.  It is not necessary to
// initialise a #GCond that has been statically allocated.
//
// To undo the effect of g_cond_init() when a #GCond is no longer
// needed, use g_cond_clear().
//
// Calling g_cond_init() on an already-initialised #GCond leads
// to undefined behaviour.
func (x *Cond) Init() {

	xCondInit(x.GoPointer())

}

var xCondSignal func(uintptr)

// If threads are waiting for @cond, at least one of them is unblocked.
// If no threads are waiting for @cond, this function has no effect.
// It is good practice to hold the same lock as the waiting thread
// while calling this function, though not required.
func (x *Cond) Signal() {

	xCondSignal(x.GoPointer())

}

var xCondWait func(uintptr, *Mutex)

// Atomically releases @mutex and waits until @cond is signalled.
// When this function returns, @mutex is locked again and owned by the
// calling thread.
//
// When using condition variables, it is possible that a spurious wakeup
// may occur (ie: g_cond_wait() returns even though g_cond_signal() was
// not called).  It's also possible that a stolen wakeup may occur.
// This is when g_cond_signal() is called, but another thread acquires
// @mutex before this thread and modifies the state of the program in
// such a way that when g_cond_wait() is able to return, the expected
// condition is no longer met.
//
// For this reason, g_cond_wait() must always be used in a loop.  See
// the documentation for #GCond for a complete example.
func (x *Cond) Wait(MutexVar *Mutex) {

	xCondWait(x.GoPointer(), MutexVar)

}

var xCondWaitUntil func(uintptr, *Mutex, int64) bool

// Waits until either @cond is signalled or @end_time has passed.
//
// As with g_cond_wait() it is possible that a spurious or stolen wakeup
// could occur.  For that reason, waiting on a condition variable should
// always be in a loop, based on an explicitly-checked predicate.
//
// %TRUE is returned if the condition variable was signalled (or in the
// case of a spurious wakeup).  %FALSE is returned if @end_time has
// passed.
//
// The following code shows how to correctly perform a timed wait on a
// condition variable (extending the example presented in the
// documentation for #GCond):
//
// |[&lt;!-- language="C" --&gt;
// gpointer
// pop_data_timed (void)
//
//	{
//	  gint64 end_time;
//	  gpointer data;
//
//	  g_mutex_lock (&amp;data_mutex);
//
//	  end_time = g_get_monotonic_time () + 5 * G_TIME_SPAN_SECOND;
//	  while (!current_data)
//	    if (!g_cond_wait_until (&amp;data_cond, &amp;data_mutex, end_time))
//	      {
//	        // timeout has passed.
//	        g_mutex_unlock (&amp;data_mutex);
//	        return NULL;
//	      }
//
//	  // there is data for us
//	  data = current_data;
//	  current_data = NULL;
//
//	  g_mutex_unlock (&amp;data_mutex);
//
//	  return data;
//	}
//
// ]|
//
// Notice that the end time is calculated once, before entering the
// loop and reused.  This is the motivation behind the use of absolute
// time on this API -- if a relative time of 5 seconds were passed
// directly to the call and a spurious wakeup occurred, the program would
// have to start over waiting again (which would lead to a total wait
// time of more than 5 seconds).
func (x *Cond) WaitUntil(MutexVar *Mutex, EndTimeVar int64) bool {

	cret := xCondWaitUntil(x.GoPointer(), MutexVar, EndTimeVar)
	return cret
}

// A #GOnce struct controls a one-time initialization function. Any
// one-time initialization function must have its own unique #GOnce
// struct.
type Once struct {
	_ structs.HostLayout

	Status OnceStatus

	Retval uintptr
}

func (x *Once) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xOnceImpl func(uintptr, uintptr, uintptr) uintptr

func (x *Once) Impl(FuncVar *ThreadFunc, ArgVar uintptr) uintptr {

	cret := xOnceImpl(x.GoPointer(), NewCallback(FuncVar), ArgVar)
	return cret
}

// The #GPrivate struct is an opaque data structure to represent a
// thread-local data key. It is approximately equivalent to the
// pthread_setspecific()/pthread_getspecific() APIs on POSIX and to
// TlsSetValue()/TlsGetValue() on Windows.
//
// If you don't already know why you might want this functionality,
// then you probably don't need it.
//
// #GPrivate is a very limited resource (as far as 128 per program,
// shared between all libraries). It is also not possible to destroy a
// #GPrivate after it has been used. As such, it is only ever acceptable
// to use #GPrivate in static scope, and even then sparingly so.
//
// See G_PRIVATE_INIT() for a couple of examples.
//
// The #GPrivate structure should be considered opaque.  It should only
// be accessed via the g_private_ functions.
type Private struct {
	_ structs.HostLayout

	P uintptr

	Notify DestroyNotify

	Future [2]uintptr
}

func (x *Private) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xPrivateGet func(uintptr) uintptr

// Returns the current value of the thread local variable @key.
//
// If the value has not yet been set in this thread, %NULL is returned.
// Values are never copied between threads (when a new thread is
// created, for example).
func (x *Private) Get() uintptr {

	cret := xPrivateGet(x.GoPointer())
	return cret
}

var xPrivateReplace func(uintptr, uintptr)

// Sets the thread local variable @key to have the value @value in the
// current thread.
//
// This function differs from g_private_set() in the following way: if
// the previous value was non-%NULL then the #GDestroyNotify handler for
// @key is run on it.
func (x *Private) Replace(ValueVar uintptr) {

	xPrivateReplace(x.GoPointer(), ValueVar)

}

var xPrivateSet func(uintptr, uintptr)

// Sets the thread local variable @key to have the value @value in the
// current thread.
//
// This function differs from g_private_replace() in the following way:
// the #GDestroyNotify for @key is not called on the old value.
func (x *Private) Set(ValueVar uintptr) {

	xPrivateSet(x.GoPointer(), ValueVar)

}

// The GRWLock struct is an opaque data structure to represent a
// reader-writer lock. It is similar to a #GMutex in that it allows
// multiple threads to coordinate access to a shared resource.
//
// The difference to a mutex is that a reader-writer lock discriminates
// between read-only ('reader') and full ('writer') access. While only
// one thread at a time is allowed write access (by holding the 'writer'
// lock via g_rw_lock_writer_lock()), multiple threads can gain
// simultaneous read-only access (by holding the 'reader' lock via
// g_rw_lock_reader_lock()).
//
// It is unspecified whether readers or writers have priority in acquiring the
// lock when a reader already holds the lock and a writer is queued to acquire
// it.
//
// Here is an example for an array with access functions:
// |[&lt;!-- language="C" --&gt;
//
//	 GRWLock lock;
//	 GPtrArray *array;
//
//	 gpointer
//	 my_array_get (guint index)
//	 {
//	   gpointer retval = NULL;
//
//	   if (!array)
//	     return NULL;
//
//	   g_rw_lock_reader_lock (&amp;lock);
//	   if (index &lt; array-&gt;len)
//	     retval = g_ptr_array_index (array, index);
//	   g_rw_lock_reader_unlock (&amp;lock);
//
//	   return retval;
//	 }
//
//	 void
//	 my_array_set (guint index, gpointer data)
//	 {
//	   g_rw_lock_writer_lock (&amp;lock);
//
//	   if (!array)
//	     array = g_ptr_array_new ();
//
//	   if (index &gt;= array-&gt;len)
//	     g_ptr_array_set_size (array, index+1);
//	   g_ptr_array_index (array, index) = data;
//
//	   g_rw_lock_writer_unlock (&amp;lock);
//	 }
//	]|
//
// This example shows an array which can be accessed by many readers
// (the my_array_get() function) simultaneously, whereas the writers
// (the my_array_set() function) will only be allowed one at a time
// and only if no readers currently access the array. This is because
// of the potentially dangerous resizing of the array. Using these
// functions is fully multi-thread safe now.
//
// If a #GRWLock is allocated in static storage then it can be used
// without initialisation.  Otherwise, you should call
// g_rw_lock_init() on it and g_rw_lock_clear() when done.
//
// A GRWLock should only be accessed with the g_rw_lock_ functions.
type RWLock struct {
	_ structs.HostLayout

	P uintptr

	I [2]uint
}

func (x *RWLock) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xRWLockClear func(uintptr)

// Frees the resources allocated to a lock with g_rw_lock_init().
//
// This function should not be used with a #GRWLock that has been
// statically allocated.
//
// Calling g_rw_lock_clear() when any thread holds the lock
// leads to undefined behaviour.
//
// Sine: 2.32
func (x *RWLock) Clear() {

	xRWLockClear(x.GoPointer())

}

var xRWLockInit func(uintptr)

// Initializes a #GRWLock so that it can be used.
//
// This function is useful to initialize a lock that has been
// allocated on the stack, or as part of a larger structure.  It is not
// necessary to initialise a reader-writer lock that has been statically
// allocated.
//
// |[&lt;!-- language="C" --&gt;
//
//	typedef struct {
//	  GRWLock l;
//	  ...
//	} Blob;
//
// Blob *b;
//
// b = g_new (Blob, 1);
// g_rw_lock_init (&amp;b-&gt;l);
// ]|
//
// To undo the effect of g_rw_lock_init() when a lock is no longer
// needed, use g_rw_lock_clear().
//
// Calling g_rw_lock_init() on an already initialized #GRWLock leads
// to undefined behaviour.
func (x *RWLock) Init() {

	xRWLockInit(x.GoPointer())

}

var xRWLockReaderLock func(uintptr)

// Obtain a read lock on @rw_lock. If another thread currently holds
// the write lock on @rw_lock, the current thread will block until the
// write lock was (held and) released. If another thread does not hold
// the write lock, but is waiting for it, it is implementation defined
// whether the reader or writer will block. Read locks can be taken
// recursively.
//
// Calling g_rw_lock_reader_lock() while the current thread already
// owns a write lock leads to undefined behaviour. Read locks however
// can be taken recursively, in which case you need to make sure to
// call g_rw_lock_reader_unlock() the same amount of times.
//
// It is implementation-defined how many read locks are allowed to be
// held on the same lock simultaneously. If the limit is hit,
// or if a deadlock is detected, a critical warning will be emitted.
func (x *RWLock) ReaderLock() {

	xRWLockReaderLock(x.GoPointer())

}

var xRWLockReaderTrylock func(uintptr) bool

// Tries to obtain a read lock on @rw_lock and returns %TRUE if
// the read lock was successfully obtained. Otherwise it
// returns %FALSE.
func (x *RWLock) ReaderTrylock() bool {

	cret := xRWLockReaderTrylock(x.GoPointer())
	return cret
}

var xRWLockReaderUnlock func(uintptr)

// Release a read lock on @rw_lock.
//
// Calling g_rw_lock_reader_unlock() on a lock that is not held
// by the current thread leads to undefined behaviour.
func (x *RWLock) ReaderUnlock() {

	xRWLockReaderUnlock(x.GoPointer())

}

var xRWLockWriterLock func(uintptr)

// Obtain a write lock on @rw_lock. If another thread currently holds
// a read or write lock on @rw_lock, the current thread will block
// until all other threads have dropped their locks on @rw_lock.
//
// Calling g_rw_lock_writer_lock() while the current thread already
// owns a read or write lock on @rw_lock leads to undefined behaviour.
func (x *RWLock) WriterLock() {

	xRWLockWriterLock(x.GoPointer())

}

var xRWLockWriterTrylock func(uintptr) bool

// Tries to obtain a write lock on @rw_lock. If another thread
// currently holds a read or write lock on @rw_lock, it immediately
// returns %FALSE.
// Otherwise it locks @rw_lock and returns %TRUE.
func (x *RWLock) WriterTrylock() bool {

	cret := xRWLockWriterTrylock(x.GoPointer())
	return cret
}

var xRWLockWriterUnlock func(uintptr)

// Release a write lock on @rw_lock.
//
// Calling g_rw_lock_writer_unlock() on a lock that is not held
// by the current thread leads to undefined behaviour.
func (x *RWLock) WriterUnlock() {

	xRWLockWriterUnlock(x.GoPointer())

}

// The GRecMutex struct is an opaque data structure to represent a
// recursive mutex. It is similar to a #GMutex with the difference
// that it is possible to lock a GRecMutex multiple times in the same
// thread without deadlock. When doing so, care has to be taken to
// unlock the recursive mutex as often as it has been locked.
//
// If a #GRecMutex is allocated in static storage then it can be used
// without initialisation.  Otherwise, you should call
// g_rec_mutex_init() on it and g_rec_mutex_clear() when done.
//
// A GRecMutex should only be accessed with the
// g_rec_mutex_ functions.
type RecMutex struct {
	_ structs.HostLayout

	P uintptr

	I [2]uint
}

func (x *RecMutex) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xRecMutexClear func(uintptr)

// Frees the resources allocated to a recursive mutex with
// g_rec_mutex_init().
//
// This function should not be used with a #GRecMutex that has been
// statically allocated.
//
// Calling g_rec_mutex_clear() on a locked recursive mutex leads
// to undefined behaviour.
//
// Sine: 2.32
func (x *RecMutex) Clear() {

	xRecMutexClear(x.GoPointer())

}

var xRecMutexInit func(uintptr)

// Initializes a #GRecMutex so that it can be used.
//
// This function is useful to initialize a recursive mutex
// that has been allocated on the stack, or as part of a larger
// structure.
//
// It is not necessary to initialise a recursive mutex that has been
// statically allocated.
//
// |[&lt;!-- language="C" --&gt;
//
//	typedef struct {
//	  GRecMutex m;
//	  ...
//	} Blob;
//
// Blob *b;
//
// b = g_new (Blob, 1);
// g_rec_mutex_init (&amp;b-&gt;m);
// ]|
//
// Calling g_rec_mutex_init() on an already initialized #GRecMutex
// leads to undefined behaviour.
//
// To undo the effect of g_rec_mutex_init() when a recursive mutex
// is no longer needed, use g_rec_mutex_clear().
func (x *RecMutex) Init() {

	xRecMutexInit(x.GoPointer())

}

var xRecMutexLock func(uintptr)

// Locks @rec_mutex. If @rec_mutex is already locked by another
// thread, the current thread will block until @rec_mutex is
// unlocked by the other thread. If @rec_mutex is already locked
// by the current thread, the 'lock count' of @rec_mutex is increased.
// The mutex will only become available again when it is unlocked
// as many times as it has been locked.
func (x *RecMutex) Lock() {

	xRecMutexLock(x.GoPointer())

}

var xRecMutexTrylock func(uintptr) bool

// Tries to lock @rec_mutex. If @rec_mutex is already locked
// by another thread, it immediately returns %FALSE. Otherwise
// it locks @rec_mutex and returns %TRUE.
func (x *RecMutex) Trylock() bool {

	cret := xRecMutexTrylock(x.GoPointer())
	return cret
}

var xRecMutexUnlock func(uintptr)

// Unlocks @rec_mutex. If another thread is blocked in a
// g_rec_mutex_lock() call for @rec_mutex, it will become unblocked
// and can lock @rec_mutex itself.
//
// Calling g_rec_mutex_unlock() on a recursive mutex that is not
// locked by the current thread leads to undefined behaviour.
func (x *RecMutex) Unlock() {

	xRecMutexUnlock(x.GoPointer())

}

// The #GThread struct represents a running thread. This struct
// is returned by g_thread_new() or g_thread_try_new(). You can
// obtain the #GThread struct representing the current thread by
// calling g_thread_self().
//
// GThread is refcounted, see g_thread_ref() and g_thread_unref().
// The thread represented by it holds a reference while it is running,
// and g_thread_join() consumes the reference that it is given, so
// it is normally not necessary to manage GThread references
// explicitly.
//
// The structure is opaque -- none of its fields may be directly
// accessed.
type Thread struct {
	_ structs.HostLayout
}

var xThreadGLibType func() types.GType

func ThreadGLibType() types.GType {
	return xThreadGLibType()
}

func (x *Thread) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewThread func(string, uintptr, uintptr) *Thread

// This function creates a new thread. The new thread starts by invoking
// @func with the argument data. The thread will run until @func returns
// or until g_thread_exit() is called from the new thread. The return value
// of @func becomes the return value of the thread, which can be obtained
// with g_thread_join().
//
// The @name can be useful for discriminating threads in a debugger.
// It is not used for other purposes and does not have to be unique.
// Some systems restrict the length of @name to 16 bytes.
//
// If the thread can not be created the program aborts. See
// g_thread_try_new() if you want to attempt to deal with failures.
//
// If you are using threads to offload (potentially many) short-lived tasks,
// #GThreadPool may be more appropriate than manually spawning and tracking
// multiple #GThreads.
//
// To free the struct returned by this function, use g_thread_unref().
// Note that g_thread_join() implicitly unrefs the #GThread as well.
//
// New threads by default inherit their scheduler policy (POSIX) or thread
// priority (Windows) of the thread creating the new thread.
//
// This behaviour changed in GLib 2.64: before threads on Windows were not
// inheriting the thread priority but were spawned with the default priority.
// Starting with GLib 2.64 the behaviour is now consistent between Windows and
// POSIX and all threads inherit their parent thread's priority.
func NewThread(NameVar string, FuncVar *ThreadFunc, DataVar uintptr) *Thread {

	cret := xNewThread(NameVar, NewCallback(FuncVar), DataVar)
	return cret
}

var xThreadTryNew func(string, uintptr, uintptr, **Error) *Thread

// This function is the same as g_thread_new() except that
// it allows for the possibility of failure.
//
// If a thread can not be created (due to resource limits),
// @error is set and %NULL is returned.
func ThreadTryNew(NameVar string, FuncVar *ThreadFunc, DataVar uintptr) (*Thread, error) {
	var cerr *Error

	cret := xThreadTryNew(NameVar, NewCallback(FuncVar), DataVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xThreadJoin func(uintptr) uintptr

// Waits until @thread finishes, i.e. the function @func, as
// given to g_thread_new(), returns or g_thread_exit() is called.
// If @thread has already terminated, then g_thread_join()
// returns immediately.
//
// Any thread can wait for any other thread by calling g_thread_join(),
// not just its 'creator'. Calling g_thread_join() from multiple threads
// for the same @thread leads to undefined behaviour.
//
// The value returned by @func or given to g_thread_exit() is
// returned by this function.
//
// g_thread_join() consumes the reference to the passed-in @thread.
// This will usually cause the #GThread struct and associated resources
// to be freed. Use g_thread_ref() to obtain an extra reference if you
// want to keep the GThread alive beyond the g_thread_join() call.
func (x *Thread) Join() uintptr {

	cret := xThreadJoin(x.GoPointer())
	return cret
}

var xThreadRef func(uintptr) *Thread

// Increase the reference count on @thread.
func (x *Thread) Ref() *Thread {

	cret := xThreadRef(x.GoPointer())
	return cret
}

var xThreadUnref func(uintptr)

// Decrease the reference count on @thread, possibly freeing all
// resources associated with it.
//
// Note that each thread holds a reference to its #GThread while
// it is running, so it is safe to drop your own reference to it
// if you don't need it anymore.
func (x *Thread) Unref() {

	xThreadUnref(x.GoPointer())

}

// The #GMutex struct is an opaque data structure to represent a mutex
// (mutual exclusion). It can be used to protect data against shared
// access.
//
// Take for example the following function:
// |[&lt;!-- language="C" --&gt;
//
//	int
//	give_me_next_number (void)
//	{
//	  static int current_number = 0;
//
//	  // now do a very complicated calculation to calculate the new
//	  // number, this might for example be a random number generator
//	  current_number = calc_next_number (current_number);
//
//	  return current_number;
//	}
//
// ]|
// It is easy to see that this won't work in a multi-threaded
// application. There current_number must be protected against shared
// access. A #GMutex can be used as a solution to this problem:
// |[&lt;!-- language="C" --&gt;
//
//	int
//	give_me_next_number (void)
//	{
//	  static GMutex mutex;
//	  static int current_number = 0;
//	  int ret_val;
//
//	  g_mutex_lock (&amp;mutex);
//	  ret_val = current_number = calc_next_number (current_number);
//	  g_mutex_unlock (&amp;mutex);
//
//	  return ret_val;
//	}
//
// ]|
// Notice that the #GMutex is not initialised to any particular value.
// Its placement in static storage ensures that it will be initialised
// to all-zeros, which is appropriate.
//
// If a #GMutex is placed in other contexts (eg: embedded in a struct)
// then it must be explicitly initialised using g_mutex_init().
//
// A #GMutex should only be accessed via g_mutex_ functions.
type Mutex = uintptr

// Opaque type. See g_mutex_locker_new() for details.
type MutexLocker = uintptr

// Opaque type. See g_rw_lock_reader_locker_new() for details.
type RWLockReaderLocker = uintptr

// Opaque type. See g_rw_lock_writer_locker_new() for details.
type RWLockWriterLocker = uintptr

// Opaque type. See g_rec_mutex_locker_new() for details.
type RecMutexLocker = uintptr

// The possible statuses of a one-time initialization function
// controlled by a #GOnce struct.
type OnceStatus int

const (

	// the function has not been called yet.
	GOnceStatusNotcalledValue OnceStatus = 0
	// the function call is currently in progress.
	GOnceStatusProgressValue OnceStatus = 1
	// the function has been called.
	GOnceStatusReadyValue OnceStatus = 2
)

// Possible errors of thread related functions.
type ThreadError int

const (

	// a thread couldn't be created due to resource
	//                        shortage. Try again later.
	GThreadErrorAgainValue ThreadError = 0
)

var xGetNumProcessors func() uint

// Determine the approximate number of threads that the system will
// schedule simultaneously for this process.  This is intended to be
// used as a parameter to g_thread_pool_new() for CPU bound tasks and
// similar cases.
func GetNumProcessors() uint {

	cret := xGetNumProcessors()
	return cret
}

var xOnceInitEnter func(uintptr) bool

// Function to be called when starting a critical initialization
// section. The argument @location must point to a static
// 0-initialized variable that will be set to a value other than 0 at
// the end of the initialization section. In combination with
// g_once_init_leave() and the unique address @value_location, it can
// be ensured that an initialization section will be executed only once
// during a program's life time, and that concurrent threads are
// blocked until initialization completed. To be used in constructs
// like this:
//
// |[&lt;!-- language="C" --&gt;
//
//	static gsize initialization_value = 0;
//
//	if (g_once_init_enter (&amp;initialization_value))
//	  {
//	    gsize setup_value = 42; // initialization code here
//
//	    g_once_init_leave (&amp;initialization_value, setup_value);
//	  }
//
//	// use initialization_value here
//
// ]|
//
// While @location has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func OnceInitEnter(LocationVar uintptr) bool {

	cret := xOnceInitEnter(LocationVar)
	return cret
}

var xOnceInitLeave func(uintptr, uint)

// Counterpart to g_once_init_enter(). Expects a location of a static
// 0-initialized initialization variable, and an initialization value
// other than 0. Sets the variable to the initialization value, and
// releases concurrent threads blocking in g_once_init_enter() on this
// initialization variable.
//
// While @location has a `volatile` qualifier, this is a historical artifact and
// the pointer passed to it should not be `volatile`.
func OnceInitLeave(LocationVar uintptr, ResultVar uint) {

	xOnceInitLeave(LocationVar, ResultVar)

}

var xThreadExit func(uintptr)

// Terminates the current thread.
//
// If another thread is waiting for us using g_thread_join() then the
// waiting thread will be woken up and get @retval as the return value
// of g_thread_join().
//
// Calling g_thread_exit() with a parameter @retval is equivalent to
// returning @retval from the function @func, as given to g_thread_new().
//
// You must only call g_thread_exit() from a thread that you created
// yourself with g_thread_new() or related APIs. You must not call
// this function from a thread created with another threading library
// or or from within a #GThreadPool.
func ThreadExit(RetvalVar uintptr) {

	xThreadExit(RetvalVar)

}

var xThreadSelf func() *Thread

// This function returns the #GThread corresponding to the
// current thread. Note that this function does not increase
// the reference count of the returned struct.
//
// This function will return a #GThread even for threads that
// were not created by GLib (i.e. those created by other threading
// APIs). This may be useful for thread identification purposes
// (i.e. comparisons) but you must not use GLib functions (such
// as g_thread_join()) on these threads.
func ThreadSelf() *Thread {

	cret := xThreadSelf()
	return cret
}

var xThreadYield func()

// Causes the calling thread to voluntarily relinquish the CPU, so
// that other threads can run.
//
// This function is often used as a method to make busy wait less evil.
func ThreadYield() {

	xThreadYield()

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xGetNumProcessors, lib, "g_get_num_processors")
	core.PuregoSafeRegister(&xOnceInitEnter, lib, "g_once_init_enter")
	core.PuregoSafeRegister(&xOnceInitLeave, lib, "g_once_init_leave")
	core.PuregoSafeRegister(&xThreadExit, lib, "g_thread_exit")
	core.PuregoSafeRegister(&xThreadSelf, lib, "g_thread_self")
	core.PuregoSafeRegister(&xThreadYield, lib, "g_thread_yield")

	core.PuregoSafeRegister(&xCondBroadcast, lib, "g_cond_broadcast")
	core.PuregoSafeRegister(&xCondClear, lib, "g_cond_clear")
	core.PuregoSafeRegister(&xCondInit, lib, "g_cond_init")
	core.PuregoSafeRegister(&xCondSignal, lib, "g_cond_signal")
	core.PuregoSafeRegister(&xCondWait, lib, "g_cond_wait")
	core.PuregoSafeRegister(&xCondWaitUntil, lib, "g_cond_wait_until")

	core.PuregoSafeRegister(&xOnceImpl, lib, "g_once_impl")

	core.PuregoSafeRegister(&xPrivateGet, lib, "g_private_get")
	core.PuregoSafeRegister(&xPrivateReplace, lib, "g_private_replace")
	core.PuregoSafeRegister(&xPrivateSet, lib, "g_private_set")

	core.PuregoSafeRegister(&xRWLockClear, lib, "g_rw_lock_clear")
	core.PuregoSafeRegister(&xRWLockInit, lib, "g_rw_lock_init")
	core.PuregoSafeRegister(&xRWLockReaderLock, lib, "g_rw_lock_reader_lock")
	core.PuregoSafeRegister(&xRWLockReaderTrylock, lib, "g_rw_lock_reader_trylock")
	core.PuregoSafeRegister(&xRWLockReaderUnlock, lib, "g_rw_lock_reader_unlock")
	core.PuregoSafeRegister(&xRWLockWriterLock, lib, "g_rw_lock_writer_lock")
	core.PuregoSafeRegister(&xRWLockWriterTrylock, lib, "g_rw_lock_writer_trylock")
	core.PuregoSafeRegister(&xRWLockWriterUnlock, lib, "g_rw_lock_writer_unlock")

	core.PuregoSafeRegister(&xRecMutexClear, lib, "g_rec_mutex_clear")
	core.PuregoSafeRegister(&xRecMutexInit, lib, "g_rec_mutex_init")
	core.PuregoSafeRegister(&xRecMutexLock, lib, "g_rec_mutex_lock")
	core.PuregoSafeRegister(&xRecMutexTrylock, lib, "g_rec_mutex_trylock")
	core.PuregoSafeRegister(&xRecMutexUnlock, lib, "g_rec_mutex_unlock")

	core.PuregoSafeRegister(&xThreadGLibType, lib, "g_thread_get_type")

	core.PuregoSafeRegister(&xNewThread, lib, "g_thread_new")
	core.PuregoSafeRegister(&xThreadTryNew, lib, "g_thread_try_new")

	core.PuregoSafeRegister(&xThreadJoin, lib, "g_thread_join")
	core.PuregoSafeRegister(&xThreadRef, lib, "g_thread_ref")
	core.PuregoSafeRegister(&xThreadUnref, lib, "g_thread_unref")

}
