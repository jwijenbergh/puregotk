// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// Specifies the type of the setup function passed to g_spawn_async(),
// g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very
// limited ways, be used to affect the child's execution.
//
// On POSIX platforms, the function is called in the child after GLib
// has performed all the setup it plans to perform, but before calling
// exec(). Actions taken in this function will only affect the child,
// not the parent.
//
// On Windows, the function is called in the parent. Its usefulness on
// Windows is thus questionable. In many cases executing the child setup
// function in the parent can have ill effects, and you should be very
// careful when porting software to Windows that uses child setup
// functions.
//
// However, even on POSIX, you are extremely limited in what you can
// safely do from a #GSpawnChildSetupFunc, because any mutexes that were
// held by other threads in the parent process at the time of the fork()
// will still be locked in the child process, and they will never be
// unlocked (since the threads that held them don't exist in the child).
// POSIX allows only async-signal-safe functions (see signal(7)) to be
// called in the child between fork() and exec(), which drastically limits
// the usefulness of child setup functions.
//
// In particular, it is not safe to call any function which may
// call malloc(), which includes POSIX functions such as setenv().
// If you need to set up the child environment differently from
// the parent, you should use g_get_environ(), g_environ_setenv(),
// and g_environ_unsetenv(), and then pass the complete environment
// list to the `g_spawn...` function.
type SpawnChildSetupFunc func(uintptr)

// Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes().
type SpawnFlags int

const (

	// no flags, default behaviour
	GSpawnDefaultValue SpawnFlags = 0
	// the parent's open file descriptors will
	//     be inherited by the child; otherwise all descriptors except stdin,
	//     stdout and stderr will be closed before calling exec() in the child.
	GSpawnLeaveDescriptorsOpenValue SpawnFlags = 1
	// the child will not be automatically reaped;
	//     you must use g_child_watch_add() yourself (or call waitpid() or handle
	//     `SIGCHLD` yourself), or the child will become a zombie.
	GSpawnDoNotReapChildValue SpawnFlags = 2
	// `argv[0]` need not be an absolute path, it will be
	//     looked for in the user's `PATH`.
	GSpawnSearchPathValue SpawnFlags = 4
	// the child's standard output will be discarded,
	//     instead of going to the same location as the parent's standard output.
	GSpawnStdoutToDevNullValue SpawnFlags = 8
	// the child's standard error will be discarded.
	GSpawnStderrToDevNullValue SpawnFlags = 16
	// the child will inherit the parent's standard
	//     input (by default, the child's standard input is attached to `/dev/null`).
	GSpawnChildInheritsStdinValue SpawnFlags = 32
	// the first element of `argv` is the file to
	//     execute, while the remaining elements are the actual argument vector
	//     to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`
	//     as the file to execute, and passes all of `argv` to the child.
	GSpawnFileAndArgvZeroValue SpawnFlags = 64
	// if `argv[0]` is not an absolute path,
	//     it will be looked for in the `PATH` from the passed child environment.
	//     Since: 2.34
	GSpawnSearchPathFromEnvpValue SpawnFlags = 128
	// create all pipes with the `O_CLOEXEC` flag set.
	//     Since: 2.40
	GSpawnCloexecPipesValue SpawnFlags = 256
)

// Error codes returned by spawning processes.
type SpawnError int

const (

	// Fork failed due to lack of memory.
	GSpawnErrorForkValue SpawnError = 0
	// Read or select on pipes failed.
	GSpawnErrorReadValue SpawnError = 1
	// Changing to working directory failed.
	GSpawnErrorChdirValue SpawnError = 2
	// execv() returned `EACCES`
	GSpawnErrorAccesValue SpawnError = 3
	// execv() returned `EPERM`
	GSpawnErrorPermValue SpawnError = 4
	// execv() returned `E2BIG`
	GSpawnErrorTooBigValue SpawnError = 5
	// deprecated alias for %G_SPAWN_ERROR_TOO_BIG (deprecated since GLib 2.32)
	GSpawnError2bigValue SpawnError = 5
	// execv() returned `ENOEXEC`
	GSpawnErrorNoexecValue SpawnError = 6
	// execv() returned `ENAMETOOLONG`
	GSpawnErrorNametoolongValue SpawnError = 7
	// execv() returned `ENOENT`
	GSpawnErrorNoentValue SpawnError = 8
	// execv() returned `ENOMEM`
	GSpawnErrorNomemValue SpawnError = 9
	// execv() returned `ENOTDIR`
	GSpawnErrorNotdirValue SpawnError = 10
	// execv() returned `ELOOP`
	GSpawnErrorLoopValue SpawnError = 11
	// execv() returned `ETXTBUSY`
	GSpawnErrorTxtbusyValue SpawnError = 12
	// execv() returned `EIO`
	GSpawnErrorIoValue SpawnError = 13
	// execv() returned `ENFILE`
	GSpawnErrorNfileValue SpawnError = 14
	// execv() returned `EMFILE`
	GSpawnErrorMfileValue SpawnError = 15
	// execv() returned `EINVAL`
	GSpawnErrorInvalValue SpawnError = 16
	// execv() returned `EISDIR`
	GSpawnErrorIsdirValue SpawnError = 17
	// execv() returned `ELIBBAD`
	GSpawnErrorLibbadValue SpawnError = 18
	// Some other fatal failure,
	//   `error-&gt;message` should explain.
	GSpawnErrorFailedValue SpawnError = 19
)

var xSpawnAsync func(string, []string, []string, SpawnFlags, uintptr, uintptr, *Pid, **Error) bool

// Executes a child program asynchronously.
//
// See g_spawn_async_with_pipes() for a full description; this function
// simply calls the g_spawn_async_with_pipes() without any pipes.
//
// You should call g_spawn_close_pid() on the returned child process
// reference when you don't need it any more.
//
// If you are writing a GTK application, and the program you are spawning is a
// graphical application too, then to ensure that the spawned program opens its
// windows on the right screen, you may want to use #GdkAppLaunchContext,
// #GAppLaunchContext, or set the %DISPLAY environment variable.
//
// Note that the returned @child_pid on Windows is a handle to the child
// process and not its identifier. Process handles and process identifiers
// are different concepts on Windows.
func SpawnAsync(WorkingDirectoryVar string, ArgvVar []string, EnvpVar []string, FlagsVar SpawnFlags, ChildSetupVar *SpawnChildSetupFunc, UserDataVar uintptr, ChildPidVar *Pid) (bool, error) {
	var cerr *Error

	cret := xSpawnAsync(WorkingDirectoryVar, ArgvVar, EnvpVar, FlagsVar, NewCallback(ChildSetupVar), UserDataVar, ChildPidVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSpawnAsyncWithFds func(string, []string, []string, SpawnFlags, uintptr, uintptr, *Pid, int, int, int, **Error) bool

// Executes a child program asynchronously.
//
// Identical to g_spawn_async_with_pipes_and_fds() but with `n_fds` set to zero,
// so no FD assignments are used.
func SpawnAsyncWithFds(WorkingDirectoryVar string, ArgvVar []string, EnvpVar []string, FlagsVar SpawnFlags, ChildSetupVar *SpawnChildSetupFunc, UserDataVar uintptr, ChildPidVar *Pid, StdinFdVar int, StdoutFdVar int, StderrFdVar int) (bool, error) {
	var cerr *Error

	cret := xSpawnAsyncWithFds(WorkingDirectoryVar, ArgvVar, EnvpVar, FlagsVar, NewCallback(ChildSetupVar), UserDataVar, ChildPidVar, StdinFdVar, StdoutFdVar, StderrFdVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSpawnAsyncWithPipes func(string, []string, []string, SpawnFlags, uintptr, uintptr, *Pid, int, int, int, **Error) bool

// Identical to g_spawn_async_with_pipes_and_fds() but with `n_fds` set to zero,
// so no FD assignments are used.
func SpawnAsyncWithPipes(WorkingDirectoryVar string, ArgvVar []string, EnvpVar []string, FlagsVar SpawnFlags, ChildSetupVar *SpawnChildSetupFunc, UserDataVar uintptr, ChildPidVar *Pid, StandardInputVar int, StandardOutputVar int, StandardErrorVar int) (bool, error) {
	var cerr *Error

	cret := xSpawnAsyncWithPipes(WorkingDirectoryVar, ArgvVar, EnvpVar, FlagsVar, NewCallback(ChildSetupVar), UserDataVar, ChildPidVar, StandardInputVar, StandardOutputVar, StandardErrorVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSpawnAsyncWithPipesAndFds func(string, []string, []string, SpawnFlags, uintptr, uintptr, int, int, int, []int, []int, uint, *Pid, int, int, int, **Error) bool

// Executes a child program asynchronously (your program will not
// block waiting for the child to exit).
//
// The child program is specified by the only argument that must be
// provided, @argv. @argv should be a %NULL-terminated array of strings,
// to be passed as the argument vector for the child. The first string
// in @argv is of course the name of the program to execute. By default,
// the name of the program must be a full path. If @flags contains the
// %G_SPAWN_SEARCH_PATH flag, the `PATH` environment variable is used to
// search for the executable. If @flags contains the
// %G_SPAWN_SEARCH_PATH_FROM_ENVP flag, the `PATH` variable from @envp
// is used to search for the executable. If both the
// %G_SPAWN_SEARCH_PATH and %G_SPAWN_SEARCH_PATH_FROM_ENVP flags are
// set, the `PATH` variable from @envp takes precedence over the
// environment variable.
//
// If the program name is not a full path and %G_SPAWN_SEARCH_PATH flag
// is not used, then the program will be run from the current directory
// (or @working_directory, if specified); this might be unexpected or even
// dangerous in some cases when the current directory is world-writable.
//
// On Windows, note that all the string or string vector arguments to
// this function and the other `g_spawn*()` functions are in UTF-8, the
// GLib file name encoding. Unicode characters that are not part of
// the system codepage passed in these arguments will be correctly
// available in the spawned program only if it uses wide character API
// to retrieve its command line. For C programs built with Microsoft's
// tools it is enough to make the program have a `wmain()` instead of
// `main()`. `wmain()` has a wide character argument vector as parameter.
//
// At least currently, mingw doesn't support `wmain()`, so if you use
// mingw to develop the spawned program, it should call
// g_win32_get_command_line() to get arguments in UTF-8.
//
// On Windows the low-level child process creation API `CreateProcess()`
// doesn't use argument vectors, but a command line. The C runtime
// library's `spawn*()` family of functions (which g_spawn_async_with_pipes()
// eventually calls) paste the argument vector elements together into
// a command line, and the C runtime startup code does a corresponding
// reconstruction of an argument vector from the command line, to be
// passed to `main()`. Complications arise when you have argument vector
// elements that contain spaces or double quotes. The `spawn*()` functions
// don't do any quoting or escaping, but on the other hand the startup
// code does do unquoting and unescaping in order to enable receiving
// arguments with embedded spaces or double quotes. To work around this
// asymmetry, g_spawn_async_with_pipes() will do quoting and escaping on
// argument vector elements that need it before calling the C runtime
// `spawn()` function.
//
// The returned @child_pid on Windows is a handle to the child
// process, not its identifier. Process handles and process
// identifiers are different concepts on Windows.
//
// @envp is a %NULL-terminated array of strings, where each string
// has the form `KEY=VALUE`. This will become the child's environment.
// If @envp is %NULL, the child inherits its parent's environment.
//
// @flags should be the bitwise OR of any flags you want to affect the
// function's behaviour. The %G_SPAWN_DO_NOT_REAP_CHILD means that the
// child will not automatically be reaped; you must use a child watch
// (g_child_watch_add()) to be notified about the death of the child process,
// otherwise it will stay around as a zombie process until this process exits.
// Eventually you must call g_spawn_close_pid() on the @child_pid, in order to
// free resources which may be associated with the child process. (On Unix,
// using a child watch is equivalent to calling waitpid() or handling
// the `SIGCHLD` signal manually. On Windows, calling g_spawn_close_pid()
// is equivalent to calling `CloseHandle()` on the process handle returned
// in @child_pid). See g_child_watch_add().
//
// Open UNIX file descriptors marked as `FD_CLOEXEC` will be automatically
// closed in the child process. %G_SPAWN_LEAVE_DESCRIPTORS_OPEN means that
// other open file descriptors will be inherited by the child; otherwise all
// descriptors except stdin/stdout/stderr will be closed before calling `exec()`
// in the child. %G_SPAWN_SEARCH_PATH means that @argv[0] need not be an
// absolute path, it will be looked for in the `PATH` environment
// variable. %G_SPAWN_SEARCH_PATH_FROM_ENVP means need not be an
// absolute path, it will be looked for in the `PATH` variable from
// @envp. If both %G_SPAWN_SEARCH_PATH and %G_SPAWN_SEARCH_PATH_FROM_ENVP
// are used, the value from @envp takes precedence over the environment.
//
// %G_SPAWN_STDOUT_TO_DEV_NULL means that the child's standard output
// will be discarded, instead of going to the same location as the parent's
// standard output. If you use this flag, @stdout_pipe_out must be %NULL.
//
// %G_SPAWN_STDERR_TO_DEV_NULL means that the child's standard error
// will be discarded, instead of going to the same location as the parent's
// standard error. If you use this flag, @stderr_pipe_out must be %NULL.
//
// %G_SPAWN_CHILD_INHERITS_STDIN means that the child will inherit the parent's
// standard input (by default, the child's standard input is attached to
// `/dev/null`). If you use this flag, @stdin_pipe_out must be %NULL.
//
// It is valid to pass the same FD in multiple parameters (e.g. you can pass
// a single FD for both @stdout_fd and @stderr_fd, and include it in
// @source_fds too).
//
// @source_fds and @target_fds allow zero or more FDs from this process to be
// remapped to different FDs in the spawned process. If @n_fds is greater than
// zero, @source_fds and @target_fds must both be non-%NULL and the same length.
// Each FD in @source_fds is remapped to the FD number at the same index in
// @target_fds. The source and target FD may be equal to simply propagate an FD
// to the spawned process. FD remappings are processed after standard FDs, so
// any target FDs which equal @stdin_fd, @stdout_fd or @stderr_fd will overwrite
// them in the spawned process.
//
// @source_fds is supported on Windows since 2.72.
//
// %G_SPAWN_FILE_AND_ARGV_ZERO means that the first element of @argv is
// the file to execute, while the remaining elements are the actual
// argument vector to pass to the file. Normally g_spawn_async_with_pipes()
// uses @argv[0] as the file to execute, and passes all of @argv to the child.
//
// @child_setup and @user_data are a function and user data. On POSIX
// platforms, the function is called in the child after GLib has
// performed all the setup it plans to perform (including creating
// pipes, closing file descriptors, etc.) but before calling `exec()`.
// That is, @child_setup is called just before calling `exec()` in the
// child. Obviously actions taken in this function will only affect
// the child, not the parent.
//
// On Windows, there is no separate `fork()` and `exec()` functionality.
// Child processes are created and run with a single API call,
// `CreateProcess()`. There is no sensible thing @child_setup
// could be used for on Windows so it is ignored and not called.
//
// If non-%NULL, @child_pid will on Unix be filled with the child's
// process ID. You can use the process ID to send signals to the child,
// or to use g_child_watch_add() (or `waitpid()`) if you specified the
// %G_SPAWN_DO_NOT_REAP_CHILD flag. On Windows, @child_pid will be
// filled with a handle to the child process only if you specified the
// %G_SPAWN_DO_NOT_REAP_CHILD flag. You can then access the child
// process using the Win32 API, for example wait for its termination
// with the `WaitFor*()` functions, or examine its exit code with
// `GetExitCodeProcess()`. You should close the handle with `CloseHandle()`
// or g_spawn_close_pid() when you no longer need it.
//
// If non-%NULL, the @stdin_pipe_out, @stdout_pipe_out, @stderr_pipe_out
// locations will be filled with file descriptors for writing to the child's
// standard input or reading from its standard output or standard error.
// The caller of g_spawn_async_with_pipes() must close these file descriptors
// when they are no longer in use. If these parameters are %NULL, the
// corresponding pipe won't be created.
//
// If @stdin_pipe_out is %NULL, the child's standard input is attached to
// `/dev/null` unless %G_SPAWN_CHILD_INHERITS_STDIN is set.
//
// If @stderr_pipe_out is NULL, the child's standard error goes to the same
// location as the parent's standard error unless %G_SPAWN_STDERR_TO_DEV_NULL
// is set.
//
// If @stdout_pipe_out is NULL, the child's standard output goes to the same
// location as the parent's standard output unless %G_SPAWN_STDOUT_TO_DEV_NULL
// is set.
//
// @error can be %NULL to ignore errors, or non-%NULL to report errors.
// If an error is set, the function returns %FALSE. Errors are reported
// even if they occur in the child (for example if the executable in
// `@argv[0]` is not found). Typically the `message` field of returned
// errors should be displayed to users. Possible errors are those from
// the %G_SPAWN_ERROR domain.
//
// If an error occurs, @child_pid, @stdin_pipe_out, @stdout_pipe_out,
// and @stderr_pipe_out will not be filled with valid values.
//
// If @child_pid is not %NULL and an error does not occur then the returned
// process reference must be closed using g_spawn_close_pid().
//
// On modern UNIX platforms, GLib can use an efficient process launching
// codepath driven internally by `posix_spawn()`. This has the advantage of
// avoiding the fork-time performance costs of cloning the parent process
// address space, and avoiding associated memory overcommit checks that are
// not relevant in the context of immediately executing a distinct process.
// This optimized codepath will be used provided that the following conditions
// are met:
//
//  1. %G_SPAWN_DO_NOT_REAP_CHILD is set
//  2. %G_SPAWN_LEAVE_DESCRIPTORS_OPEN is set
//  3. %G_SPAWN_SEARCH_PATH_FROM_ENVP is not set
//  4. @working_directory is %NULL
//  5. @child_setup is %NULL
//  6. The program is of a recognised binary format, or has a shebang.
//     Otherwise, GLib will have to execute the program through the
//     shell, which is not done using the optimized codepath.
//
// If you are writing a GTK application, and the program you are spawning is a
// graphical application too, then to ensure that the spawned program opens its
// windows on the right screen, you may want to use #GdkAppLaunchContext,
// #GAppLaunchContext, or set the `DISPLAY` environment variable.
func SpawnAsyncWithPipesAndFds(WorkingDirectoryVar string, ArgvVar []string, EnvpVar []string, FlagsVar SpawnFlags, ChildSetupVar *SpawnChildSetupFunc, UserDataVar uintptr, StdinFdVar int, StdoutFdVar int, StderrFdVar int, SourceFdsVar []int, TargetFdsVar []int, NFdsVar uint, ChildPidOutVar *Pid, StdinPipeOutVar int, StdoutPipeOutVar int, StderrPipeOutVar int) (bool, error) {
	var cerr *Error

	cret := xSpawnAsyncWithPipesAndFds(WorkingDirectoryVar, ArgvVar, EnvpVar, FlagsVar, NewCallback(ChildSetupVar), UserDataVar, StdinFdVar, StdoutFdVar, StderrFdVar, SourceFdsVar, TargetFdsVar, NFdsVar, ChildPidOutVar, StdinPipeOutVar, StdoutPipeOutVar, StderrPipeOutVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSpawnCheckExitStatus func(int, **Error) bool

// An old name for g_spawn_check_wait_status(), deprecated because its
// name is misleading.
//
// Despite the name of the function, @wait_status must be the wait status
// as returned by g_spawn_sync(), g_subprocess_get_status(), `waitpid()`,
// etc. On Unix platforms, it is incorrect for it to be the exit status
// as passed to `exit()` or returned by g_subprocess_get_exit_status() or
// `WEXITSTATUS()`.
func SpawnCheckExitStatus(WaitStatusVar int) (bool, error) {
	var cerr *Error

	cret := xSpawnCheckExitStatus(WaitStatusVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSpawnCheckWaitStatus func(int, **Error) bool

// Set @error if @wait_status indicates the child exited abnormally
// (e.g. with a nonzero exit code, or via a fatal signal).
//
// The g_spawn_sync() and g_child_watch_add() family of APIs return the
// status of subprocesses encoded in a platform-specific way.
// On Unix, this is guaranteed to be in the same format waitpid() returns,
// and on Windows it is guaranteed to be the result of GetExitCodeProcess().
//
// Prior to the introduction of this function in GLib 2.34, interpreting
// @wait_status required use of platform-specific APIs, which is problematic
// for software using GLib as a cross-platform layer.
//
// Additionally, many programs simply want to determine whether or not
// the child exited successfully, and either propagate a #GError or
// print a message to standard error. In that common case, this function
// can be used. Note that the error message in @error will contain
// human-readable information about the wait status.
//
// The @domain and @code of @error have special semantics in the case
// where the process has an "exit code", as opposed to being killed by
// a signal. On Unix, this happens if WIFEXITED() would be true of
// @wait_status. On Windows, it is always the case.
//
// The special semantics are that the actual exit code will be the
// code set in @error, and the domain will be %G_SPAWN_EXIT_ERROR.
// This allows you to differentiate between different exit codes.
//
// If the process was terminated by some means other than an exit
// status (for example if it was killed by a signal), the domain will be
// %G_SPAWN_ERROR and the code will be %G_SPAWN_ERROR_FAILED.
//
// This function just offers convenience; you can of course also check
// the available platform via a macro such as %G_OS_UNIX, and use
// WIFEXITED() and WEXITSTATUS() on @wait_status directly. Do not attempt
// to scan or parse the error message string; it may be translated and/or
// change in future versions of GLib.
//
// Prior to version 2.70, g_spawn_check_exit_status() provides the same
// functionality, although under a misleading name.
func SpawnCheckWaitStatus(WaitStatusVar int) (bool, error) {
	var cerr *Error

	cret := xSpawnCheckWaitStatus(WaitStatusVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSpawnClosePid func(Pid)

// On some platforms, notably Windows, the #GPid type represents a resource
// which must be closed to prevent resource leaking. g_spawn_close_pid()
// is provided for this purpose. It should be used on all platforms, even
// though it doesn't do anything under UNIX.
func SpawnClosePid(PidVar Pid) {

	xSpawnClosePid(PidVar)

}

var xSpawnCommandLineAsync func(string, **Error) bool

// A simple version of g_spawn_async() that parses a command line with
// g_shell_parse_argv() and passes it to g_spawn_async().
//
// Runs a command line in the background. Unlike g_spawn_async(), the
// %G_SPAWN_SEARCH_PATH flag is enabled, other flags are not. Note
// that %G_SPAWN_SEARCH_PATH can have security implications, so
// consider using g_spawn_async() directly if appropriate. Possible
// errors are those from g_shell_parse_argv() and g_spawn_async().
//
// The same concerns on Windows apply as for g_spawn_command_line_sync().
func SpawnCommandLineAsync(CommandLineVar string) (bool, error) {
	var cerr *Error

	cret := xSpawnCommandLineAsync(CommandLineVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSpawnCommandLineSync func(string, []byte, []byte, int, **Error) bool

// A simple version of g_spawn_sync() with little-used parameters
// removed, taking a command line instead of an argument vector.
//
// See g_spawn_sync() for full details.
//
// The @command_line argument will be parsed by g_shell_parse_argv().
//
// Unlike g_spawn_sync(), the %G_SPAWN_SEARCH_PATH flag is enabled.
// Note that %G_SPAWN_SEARCH_PATH can have security implications, so
// consider using g_spawn_sync() directly if appropriate.
//
// Possible errors are those from g_spawn_sync() and those
// from g_shell_parse_argv().
//
// If @wait_status is non-%NULL, the platform-specific status of
// the child is stored there; see the documentation of
// g_spawn_check_wait_status() for how to use and interpret this.
// On Unix platforms, note that it is usually not equal
// to the integer passed to `exit()` or returned from `main()`.
//
// On Windows, please note the implications of g_shell_parse_argv()
// parsing @command_line. Parsing is done according to Unix shell rules, not
// Windows command interpreter rules.
// Space is a separator, and backslashes are
// special. Thus you cannot simply pass a @command_line containing
// canonical Windows paths, like "c:\\program files\\app\\app.exe", as
// the backslashes will be eaten, and the space will act as a
// separator. You need to enclose such paths with single quotes, like
// "'c:\\program files\\app\\app.exe' 'e:\\folder\\argument.txt'".
func SpawnCommandLineSync(CommandLineVar string, StandardOutputVar []byte, StandardErrorVar []byte, WaitStatusVar int) (bool, error) {
	var cerr *Error

	cret := xSpawnCommandLineSync(CommandLineVar, StandardOutputVar, StandardErrorVar, WaitStatusVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSpawnSync func(string, []string, []string, SpawnFlags, uintptr, uintptr, []byte, []byte, int, **Error) bool

// Executes a child synchronously (waits for the child to exit before returning).
//
// All output from the child is stored in @standard_output and @standard_error,
// if those parameters are non-%NULL. Note that you must set the
// %G_SPAWN_STDOUT_TO_DEV_NULL and %G_SPAWN_STDERR_TO_DEV_NULL flags when
// passing %NULL for @standard_output and @standard_error.
//
// If @wait_status is non-%NULL, the platform-specific status of
// the child is stored there; see the documentation of
// g_spawn_check_wait_status() for how to use and interpret this.
// On Unix platforms, note that it is usually not equal
// to the integer passed to `exit()` or returned from `main()`.
//
// Note that it is invalid to pass %G_SPAWN_DO_NOT_REAP_CHILD in
// @flags, and on POSIX platforms, the same restrictions as for
// g_child_watch_source_new() apply.
//
// If an error occurs, no data is returned in @standard_output,
// @standard_error, or @wait_status.
//
// This function calls g_spawn_async_with_pipes() internally; see that
// function for full details on the other parameters and details on
// how these functions work on Windows.
func SpawnSync(WorkingDirectoryVar string, ArgvVar []string, EnvpVar []string, FlagsVar SpawnFlags, ChildSetupVar *SpawnChildSetupFunc, UserDataVar uintptr, StandardOutputVar []byte, StandardErrorVar []byte, WaitStatusVar int) (bool, error) {
	var cerr *Error

	cret := xSpawnSync(WorkingDirectoryVar, ArgvVar, EnvpVar, FlagsVar, NewCallback(ChildSetupVar), UserDataVar, StandardOutputVar, StandardErrorVar, WaitStatusVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xSpawnAsync, lib, "g_spawn_async")
	core.PuregoSafeRegister(&xSpawnAsyncWithFds, lib, "g_spawn_async_with_fds")
	core.PuregoSafeRegister(&xSpawnAsyncWithPipes, lib, "g_spawn_async_with_pipes")
	core.PuregoSafeRegister(&xSpawnAsyncWithPipesAndFds, lib, "g_spawn_async_with_pipes_and_fds")
	core.PuregoSafeRegister(&xSpawnCheckExitStatus, lib, "g_spawn_check_exit_status")
	core.PuregoSafeRegister(&xSpawnCheckWaitStatus, lib, "g_spawn_check_wait_status")
	core.PuregoSafeRegister(&xSpawnClosePid, lib, "g_spawn_close_pid")
	core.PuregoSafeRegister(&xSpawnCommandLineAsync, lib, "g_spawn_command_line_async")
	core.PuregoSafeRegister(&xSpawnCommandLineSync, lib, "g_spawn_command_line_sync")
	core.PuregoSafeRegister(&xSpawnSync, lib, "g_spawn_sync")

}
