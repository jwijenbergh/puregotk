// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// Specifies the type of function passed to g_main_context_set_poll_func().
// The semantics of the function should match those of the poll() system call.
type PollFunc func(*PollFD, uint, int) int

// Represents a file descriptor, which events to poll for, and which events
// occurred.
type PollFD struct {
	Fd int32

	Events uint16

	Revents uint16
}

func (x *PollFD) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xPoll func(*PollFD, uint, int) int

// Polls @fds, as with the poll() system call, but portably. (On
// systems that don't have poll(), it is emulated using select().)
// This is used internally by #GMainContext, but it can be called
// directly if you need to block until a file descriptor is ready, but
// don't want to run the full main loop.
//
// Each element of @fds is a #GPollFD describing a single file
// descriptor to poll. The @fd field indicates the file descriptor,
// and the @events field indicates the events to poll for. On return,
// the @revents fields will be filled with the events that actually
// occurred.
//
// On POSIX systems, the file descriptors in @fds can be any sort of
// file descriptor, but the situation is much more complicated on
// Windows. If you need to use g_poll() in code that has to run on
// Windows, the easiest solution is to construct all of your
// #GPollFDs with g_io_channel_win32_make_pollfd().
func Poll(FdsVar *PollFD, NfdsVar uint, TimeoutVar int) int {

	cret := xPoll(FdsVar, NfdsVar, TimeoutVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xPoll, lib, "g_poll")

}
