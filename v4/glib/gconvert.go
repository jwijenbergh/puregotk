// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// The GIConv struct wraps an iconv() conversion descriptor. It contains
// private data and should only be accessed using the following functions.
type IConv struct {
}

func (x *IConv) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xIConvGIconv func(uintptr, string, uint, string, uint) uint

// Same as the standard UNIX routine iconv(), but
// may be implemented via libiconv on UNIX flavors that lack
// a native implementation.
//
// GLib provides g_convert() and g_locale_to_utf8() which are likely
// more convenient than the raw iconv wrappers.
//
// Note that the behaviour of iconv() for characters which are valid in the
// input character set, but which have no representation in the output character
// set, is implementation defined. This function may return success (with a
// positive number of non-reversible conversions as replacement characters were
// used), or it may return -1 and set an error such as %EILSEQ, in such a
// situation.
func (x *IConv) GIconv(InbufVar string, InbytesLeftVar uint, OutbufVar string, OutbytesLeftVar uint) uint {

	cret := xIConvGIconv(x.GoPointer(), InbufVar, InbytesLeftVar, OutbufVar, OutbytesLeftVar)
	return cret
}

var xIConvClose func(uintptr) int

// Same as the standard UNIX routine iconv_close(), but
// may be implemented via libiconv on UNIX flavors that lack
// a native implementation. Should be called to clean up
// the conversion descriptor from g_iconv_open() when
// you are done converting things.
//
// GLib provides g_convert() and g_locale_to_utf8() which are likely
// more convenient than the raw iconv wrappers.
func (x *IConv) Close() int {

	cret := xIConvClose(x.GoPointer())
	return cret
}

// Error codes returned by character set conversion routines.
type ConvertError int

const (

	// Conversion between the requested character
	//     sets is not supported.
	GConvertErrorNoConversionValue ConvertError = 0
	// Invalid byte sequence in conversion input;
	//    or the character sequence could not be represented in the target
	//    character set.
	GConvertErrorIllegalSequenceValue ConvertError = 1
	// Conversion failed for some reason.
	GConvertErrorFailedValue ConvertError = 2
	// Partial character sequence at end of input.
	GConvertErrorPartialInputValue ConvertError = 3
	// URI is invalid.
	GConvertErrorBadUriValue ConvertError = 4
	// Pathname is not an absolute path.
	GConvertErrorNotAbsolutePathValue ConvertError = 5
	// No memory available. Since: 2.40
	GConvertErrorNoMemoryValue ConvertError = 6
	// An embedded NUL character is present in
	//     conversion output where a NUL-terminated string is expected.
	//     Since: 2.56
	GConvertErrorEmbeddedNulValue ConvertError = 7
)

var xConvert func([]byte, int, string, string, uint, uint, **Error) []byte

// Converts a string from one character set to another.
//
// Note that you should use g_iconv() for streaming conversions.
// Despite the fact that @bytes_read can return information about partial
// characters, the g_convert_... functions are not generally suitable
// for streaming. If the underlying converter maintains internal state,
// then this won't be preserved across successive calls to g_convert(),
// g_convert_with_iconv() or g_convert_with_fallback(). (An example of
// this is the GNU C converter for CP1255 which does not emit a base
// character until it knows that the next character is not a mark that
// could combine with the base character.)
//
// Using extensions such as "//TRANSLIT" may not work (or may not work
// well) on many platforms.  Consider using g_str_to_ascii() instead.
func Convert(StrVar []byte, LenVar int, ToCodesetVar string, FromCodesetVar string, BytesReadVar uint, BytesWrittenVar uint) ([]byte, error) {
	var cerr *Error

	cret := xConvert(StrVar, LenVar, ToCodesetVar, FromCodesetVar, BytesReadVar, BytesWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xConvertWithFallback func([]byte, int, string, string, string, uint, uint, **Error) []byte

// Converts a string from one character set to another, possibly
// including fallback sequences for characters not representable
// in the output. Note that it is not guaranteed that the specification
// for the fallback sequences in @fallback will be honored. Some
// systems may do an approximate conversion from @from_codeset
// to @to_codeset in their iconv() functions,
// in which case GLib will simply return that approximate conversion.
//
// Note that you should use g_iconv() for streaming conversions.
// Despite the fact that @bytes_read can return information about partial
// characters, the g_convert_... functions are not generally suitable
// for streaming. If the underlying converter maintains internal state,
// then this won't be preserved across successive calls to g_convert(),
// g_convert_with_iconv() or g_convert_with_fallback(). (An example of
// this is the GNU C converter for CP1255 which does not emit a base
// character until it knows that the next character is not a mark that
// could combine with the base character.)
func ConvertWithFallback(StrVar []byte, LenVar int, ToCodesetVar string, FromCodesetVar string, FallbackVar string, BytesReadVar uint, BytesWrittenVar uint) ([]byte, error) {
	var cerr *Error

	cret := xConvertWithFallback(StrVar, LenVar, ToCodesetVar, FromCodesetVar, FallbackVar, BytesReadVar, BytesWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xConvertWithIconv func([]byte, int, uintptr, uint, uint, **Error) []byte

// Converts a string from one character set to another.
//
// Note that you should use g_iconv() for streaming conversions.
// Despite the fact that @bytes_read can return information about partial
// characters, the g_convert_... functions are not generally suitable
// for streaming. If the underlying converter maintains internal state,
// then this won't be preserved across successive calls to g_convert(),
// g_convert_with_iconv() or g_convert_with_fallback(). (An example of
// this is the GNU C converter for CP1255 which does not emit a base
// character until it knows that the next character is not a mark that
// could combine with the base character.)
//
// Characters which are valid in the input character set, but which have no
// representation in the output character set will result in a
// %G_CONVERT_ERROR_ILLEGAL_SEQUENCE error. This is in contrast to the iconv()
// specification, which leaves this behaviour implementation defined. Note that
// this is the same error code as is returned for an invalid byte sequence in
// the input character set. To get defined behaviour for conversion of
// unrepresentable characters, use g_convert_with_fallback().
func ConvertWithIconv(StrVar []byte, LenVar int, ConverterVar uintptr, BytesReadVar uint, BytesWrittenVar uint) ([]byte, error) {
	var cerr *Error

	cret := xConvertWithIconv(StrVar, LenVar, ConverterVar, BytesReadVar, BytesWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFilenameDisplayBasename func(string) string

// Returns the display basename for the particular filename, guaranteed
// to be valid UTF-8. The display name might not be identical to the filename,
// for instance there might be problems converting it to UTF-8, and some files
// can be translated in the display.
//
// If GLib cannot make sense of the encoding of @filename, as a last resort it
// replaces unknown characters with U+FFFD, the Unicode replacement character.
// You can search the result for the UTF-8 encoding of this character (which is
// "\357\277\275" in octal notation) to find out if @filename was in an invalid
// encoding.
//
// You must pass the whole absolute pathname to this functions so that
// translation of well known locations can be done.
//
// This function is preferred over g_filename_display_name() if you know the
// whole path, as it allows translation.
func FilenameDisplayBasename(FilenameVar string) string {

	cret := xFilenameDisplayBasename(FilenameVar)
	return cret
}

var xFilenameDisplayName func(string) string

// Converts a filename into a valid UTF-8 string. The conversion is
// not necessarily reversible, so you should keep the original around
// and use the return value of this function only for display purposes.
// Unlike g_filename_to_utf8(), the result is guaranteed to be non-%NULL
// even if the filename actually isn't in the GLib file name encoding.
//
// If GLib cannot make sense of the encoding of @filename, as a last resort it
// replaces unknown characters with U+FFFD, the Unicode replacement character.
// You can search the result for the UTF-8 encoding of this character (which is
// "\357\277\275" in octal notation) to find out if @filename was in an invalid
// encoding.
//
// If you know the whole pathname of the file you should use
// g_filename_display_basename(), since that allows location-based
// translation of filenames.
func FilenameDisplayName(FilenameVar string) string {

	cret := xFilenameDisplayName(FilenameVar)
	return cret
}

var xFilenameFromUri func(string, string, **Error) string

// Converts an escaped ASCII-encoded URI to a local filename in the
// encoding used for filenames.
func FilenameFromUri(UriVar string, HostnameVar string) (string, error) {
	var cerr *Error

	cret := xFilenameFromUri(UriVar, HostnameVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFilenameFromUtf8 func(string, int, uint, uint, **Error) string

// Converts a string from UTF-8 to the encoding GLib uses for
// filenames. Note that on Windows GLib uses UTF-8 for filenames;
// on other platforms, this function indirectly depends on the
// [current locale][setlocale].
//
// The input string shall not contain nul characters even if the @len
// argument is positive. A nul character found inside the string will result
// in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the filename encoding is
// not UTF-8 and the conversion output contains a nul character, the error
// %G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns %NULL.
func FilenameFromUtf8(Utf8stringVar string, LenVar int, BytesReadVar uint, BytesWrittenVar uint) (string, error) {
	var cerr *Error

	cret := xFilenameFromUtf8(Utf8stringVar, LenVar, BytesReadVar, BytesWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFilenameToUri func(string, string, **Error) string

// Converts an absolute filename to an escaped ASCII-encoded URI, with the path
// component following Section 3.3. of RFC 2396.
func FilenameToUri(FilenameVar string, HostnameVar string) (string, error) {
	var cerr *Error

	cret := xFilenameToUri(FilenameVar, HostnameVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xFilenameToUtf8 func(string, int, uint, uint, **Error) string

// Converts a string which is in the encoding used by GLib for
// filenames into a UTF-8 string. Note that on Windows GLib uses UTF-8
// for filenames; on other platforms, this function indirectly depends on
// the [current locale][setlocale].
//
// The input string shall not contain nul characters even if the @len
// argument is positive. A nul character found inside the string will result
// in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
// If the source encoding is not UTF-8 and the conversion output contains a
// nul character, the error %G_CONVERT_ERROR_EMBEDDED_NUL is set and the
// function returns %NULL. Use g_convert() to produce output that
// may contain embedded nul characters.
func FilenameToUtf8(OpsysstringVar string, LenVar int, BytesReadVar uint, BytesWrittenVar uint) (string, error) {
	var cerr *Error

	cret := xFilenameToUtf8(OpsysstringVar, LenVar, BytesReadVar, BytesWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xGetFilenameCharsets func([]string) bool

// Determines the preferred character sets used for filenames.
// The first character set from the @charsets is the filename encoding, the
// subsequent character sets are used when trying to generate a displayable
// representation of a filename, see g_filename_display_name().
//
// On Unix, the character sets are determined by consulting the
// environment variables `G_FILENAME_ENCODING` and `G_BROKEN_FILENAMES`.
// On Windows, the character set used in the GLib API is always UTF-8
// and said environment variables have no effect.
//
// `G_FILENAME_ENCODING` may be set to a comma-separated list of
// character set names. The special token "\@locale" is taken
// to  mean the character set for the [current locale][setlocale].
// If `G_FILENAME_ENCODING` is not set, but `G_BROKEN_FILENAMES` is,
// the character set of the current locale is taken as the filename
// encoding. If neither environment variable  is set, UTF-8 is taken
// as the filename encoding, but the character set of the current locale
// is also put in the list of encodings.
//
// The returned @charsets belong to GLib and must not be freed.
//
// Note that on Unix, regardless of the locale character set or
// `G_FILENAME_ENCODING` value, the actual file names present
// on a system might be in any random encoding or just gibberish.
func GetFilenameCharsets(FilenameCharsetsVar []string) bool {

	cret := xGetFilenameCharsets(FilenameCharsetsVar)
	return cret
}

var xIconv func(uintptr, string, uint, string, uint) uint

// Same as the standard UNIX routine iconv(), but
// may be implemented via libiconv on UNIX flavors that lack
// a native implementation.
//
// GLib provides g_convert() and g_locale_to_utf8() which are likely
// more convenient than the raw iconv wrappers.
//
// Note that the behaviour of iconv() for characters which are valid in the
// input character set, but which have no representation in the output character
// set, is implementation defined. This function may return success (with a
// positive number of non-reversible conversions as replacement characters were
// used), or it may return -1 and set an error such as %EILSEQ, in such a
// situation.
func Iconv(ConverterVar uintptr, InbufVar string, InbytesLeftVar uint, OutbufVar string, OutbytesLeftVar uint) uint {

	cret := xIconv(ConverterVar, InbufVar, InbytesLeftVar, OutbufVar, OutbytesLeftVar)
	return cret
}

var xIconvOpen func(string, string) uintptr

// Same as the standard UNIX routine iconv_open(), but
// may be implemented via libiconv on UNIX flavors that lack
// a native implementation.
//
// GLib provides g_convert() and g_locale_to_utf8() which are likely
// more convenient than the raw iconv wrappers.
func IconvOpen(ToCodesetVar string, FromCodesetVar string) uintptr {

	cret := xIconvOpen(ToCodesetVar, FromCodesetVar)
	return cret
}

var xLocaleFromUtf8 func(string, int, uint, uint, **Error) []byte

// Converts a string from UTF-8 to the encoding used for strings by
// the C runtime (usually the same as that used by the operating
// system) in the [current locale][setlocale]. On Windows this means
// the system codepage.
//
// The input string shall not contain nul characters even if the @len
// argument is positive. A nul character found inside the string will result
// in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE. Use g_convert() to convert
// input that may contain embedded nul characters.
func LocaleFromUtf8(Utf8stringVar string, LenVar int, BytesReadVar uint, BytesWrittenVar uint) ([]byte, error) {
	var cerr *Error

	cret := xLocaleFromUtf8(Utf8stringVar, LenVar, BytesReadVar, BytesWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xLocaleToUtf8 func([]byte, int, uint, uint, **Error) string

// Converts a string which is in the encoding used for strings by
// the C runtime (usually the same as that used by the operating
// system) in the [current locale][setlocale] into a UTF-8 string.
//
// If the source encoding is not UTF-8 and the conversion output contains a
// nul character, the error %G_CONVERT_ERROR_EMBEDDED_NUL is set and the
// function returns %NULL.
// If the source encoding is UTF-8, an embedded nul character is treated with
// the %G_CONVERT_ERROR_ILLEGAL_SEQUENCE error for backward compatibility with
// earlier versions of this library. Use g_convert() to produce output that
// may contain embedded nul characters.
func LocaleToUtf8(OpsysstringVar []byte, LenVar int, BytesReadVar uint, BytesWrittenVar uint) (string, error) {
	var cerr *Error

	cret := xLocaleToUtf8(OpsysstringVar, LenVar, BytesReadVar, BytesWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUriListExtractUris func(string) []string

// Splits an URI list conforming to the text/uri-list
// mime type defined in RFC 2483 into individual URIs,
// discarding any comments. The URIs are not validated.
func UriListExtractUris(UriListVar string) []string {

	cret := xUriListExtractUris(UriListVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xConvert, lib, "g_convert")
	core.PuregoSafeRegister(&xConvertWithFallback, lib, "g_convert_with_fallback")
	core.PuregoSafeRegister(&xConvertWithIconv, lib, "g_convert_with_iconv")
	core.PuregoSafeRegister(&xFilenameDisplayBasename, lib, "g_filename_display_basename")
	core.PuregoSafeRegister(&xFilenameDisplayName, lib, "g_filename_display_name")
	core.PuregoSafeRegister(&xFilenameFromUri, lib, "g_filename_from_uri")
	core.PuregoSafeRegister(&xFilenameFromUtf8, lib, "g_filename_from_utf8")
	core.PuregoSafeRegister(&xFilenameToUri, lib, "g_filename_to_uri")
	core.PuregoSafeRegister(&xFilenameToUtf8, lib, "g_filename_to_utf8")
	core.PuregoSafeRegister(&xGetFilenameCharsets, lib, "g_get_filename_charsets")
	core.PuregoSafeRegister(&xIconv, lib, "g_iconv")
	core.PuregoSafeRegister(&xIconvOpen, lib, "g_iconv_open")
	core.PuregoSafeRegister(&xLocaleFromUtf8, lib, "g_locale_from_utf8")
	core.PuregoSafeRegister(&xLocaleToUtf8, lib, "g_locale_to_utf8")
	core.PuregoSafeRegister(&xUriListExtractUris, lib, "g_uri_list_extract_uris")

	core.PuregoSafeRegister(&xIConvGIconv, lib, "g_iconv")
	core.PuregoSafeRegister(&xIConvClose, lib, "g_iconv_close")

}
