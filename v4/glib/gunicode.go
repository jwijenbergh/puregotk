// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

const (
	// The maximum length (in codepoints) of a compatibility or canonical
	// decomposition of a single Unicode character.
	//
	// This is as defined by Unicode 6.1.
	UNICHAR_MAX_DECOMPOSITION_LENGTH int = 18
)

// Defines how a Unicode string is transformed in a canonical
// form, standardizing such issues as whether a character with
// an accent is represented as a base character and combining
// accent or as a single precomposed character. Unicode strings
// should generally be normalized before comparing them.
type NormalizeMode int

const (

	// standardize differences that do not affect the
	//     text content, such as the above-mentioned accent representation
	GNormalizeDefaultValue NormalizeMode = 0
	// another name for %G_NORMALIZE_DEFAULT
	GNormalizeNfdValue NormalizeMode = 0
	// like %G_NORMALIZE_DEFAULT, but with
	//     composed forms rather than a maximally decomposed form
	GNormalizeDefaultComposeValue NormalizeMode = 1
	// another name for %G_NORMALIZE_DEFAULT_COMPOSE
	GNormalizeNfcValue NormalizeMode = 1
	// beyond %G_NORMALIZE_DEFAULT also standardize the
	//     "compatibility" characters in Unicode, such as SUPERSCRIPT THREE
	//     to the standard forms (in this case DIGIT THREE). Formatting
	//     information may be lost but for most text operations such
	//     characters should be considered the same
	GNormalizeAllValue NormalizeMode = 2
	// another name for %G_NORMALIZE_ALL
	GNormalizeNfkdValue NormalizeMode = 2
	// like %G_NORMALIZE_ALL, but with composed
	//     forms rather than a maximally decomposed form
	GNormalizeAllComposeValue NormalizeMode = 3
	// another name for %G_NORMALIZE_ALL_COMPOSE
	GNormalizeNfkcValue NormalizeMode = 3
)

// These are the possible line break classifications.
//
// Since new unicode versions may add new types here, applications should be ready
// to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN.
//
// See [Unicode Line Breaking Algorithm](http://www.unicode.org/unicode/reports/tr14/).
type UnicodeBreakType int

const (

	// Mandatory Break (BK)
	GUnicodeBreakMandatoryValue UnicodeBreakType = 0
	// Carriage Return (CR)
	GUnicodeBreakCarriageReturnValue UnicodeBreakType = 1
	// Line Feed (LF)
	GUnicodeBreakLineFeedValue UnicodeBreakType = 2
	// Attached Characters and Combining Marks (CM)
	GUnicodeBreakCombiningMarkValue UnicodeBreakType = 3
	// Surrogates (SG)
	GUnicodeBreakSurrogateValue UnicodeBreakType = 4
	// Zero Width Space (ZW)
	GUnicodeBreakZeroWidthSpaceValue UnicodeBreakType = 5
	// Inseparable (IN)
	GUnicodeBreakInseparableValue UnicodeBreakType = 6
	// Non-breaking ("Glue") (GL)
	GUnicodeBreakNonBreakingGlueValue UnicodeBreakType = 7
	// Contingent Break Opportunity (CB)
	GUnicodeBreakContingentValue UnicodeBreakType = 8
	// Space (SP)
	GUnicodeBreakSpaceValue UnicodeBreakType = 9
	// Break Opportunity After (BA)
	GUnicodeBreakAfterValue UnicodeBreakType = 10
	// Break Opportunity Before (BB)
	GUnicodeBreakBeforeValue UnicodeBreakType = 11
	// Break Opportunity Before and After (B2)
	GUnicodeBreakBeforeAndAfterValue UnicodeBreakType = 12
	// Hyphen (HY)
	GUnicodeBreakHyphenValue UnicodeBreakType = 13
	// Nonstarter (NS)
	GUnicodeBreakNonStarterValue UnicodeBreakType = 14
	// Opening Punctuation (OP)
	GUnicodeBreakOpenPunctuationValue UnicodeBreakType = 15
	// Closing Punctuation (CL)
	GUnicodeBreakClosePunctuationValue UnicodeBreakType = 16
	// Ambiguous Quotation (QU)
	GUnicodeBreakQuotationValue UnicodeBreakType = 17
	// Exclamation/Interrogation (EX)
	GUnicodeBreakExclamationValue UnicodeBreakType = 18
	// Ideographic (ID)
	GUnicodeBreakIdeographicValue UnicodeBreakType = 19
	// Numeric (NU)
	GUnicodeBreakNumericValue UnicodeBreakType = 20
	// Infix Separator (Numeric) (IS)
	GUnicodeBreakInfixSeparatorValue UnicodeBreakType = 21
	// Symbols Allowing Break After (SY)
	GUnicodeBreakSymbolValue UnicodeBreakType = 22
	// Ordinary Alphabetic and Symbol Characters (AL)
	GUnicodeBreakAlphabeticValue UnicodeBreakType = 23
	// Prefix (Numeric) (PR)
	GUnicodeBreakPrefixValue UnicodeBreakType = 24
	// Postfix (Numeric) (PO)
	GUnicodeBreakPostfixValue UnicodeBreakType = 25
	// Complex Content Dependent (South East Asian) (SA)
	GUnicodeBreakComplexContextValue UnicodeBreakType = 26
	// Ambiguous (Alphabetic or Ideographic) (AI)
	GUnicodeBreakAmbiguousValue UnicodeBreakType = 27
	// Unknown (XX)
	GUnicodeBreakUnknownValue UnicodeBreakType = 28
	// Next Line (NL)
	GUnicodeBreakNextLineValue UnicodeBreakType = 29
	// Word Joiner (WJ)
	GUnicodeBreakWordJoinerValue UnicodeBreakType = 30
	// Hangul L Jamo (JL)
	GUnicodeBreakHangulLJamoValue UnicodeBreakType = 31
	// Hangul V Jamo (JV)
	GUnicodeBreakHangulVJamoValue UnicodeBreakType = 32
	// Hangul T Jamo (JT)
	GUnicodeBreakHangulTJamoValue UnicodeBreakType = 33
	// Hangul LV Syllable (H2)
	GUnicodeBreakHangulLvSyllableValue UnicodeBreakType = 34
	// Hangul LVT Syllable (H3)
	GUnicodeBreakHangulLvtSyllableValue UnicodeBreakType = 35
	// Closing Parenthesis (CP). Since 2.28. Deprecated: 2.70: Use %G_UNICODE_BREAK_CLOSE_PARENTHESIS instead.
	GUnicodeBreakCloseParanthesisValue UnicodeBreakType = 36
	// Closing Parenthesis (CP). Since 2.70
	GUnicodeBreakCloseParenthesisValue UnicodeBreakType = 36
	// Conditional Japanese Starter (CJ). Since: 2.32
	GUnicodeBreakConditionalJapaneseStarterValue UnicodeBreakType = 37
	// Hebrew Letter (HL). Since: 2.32
	GUnicodeBreakHebrewLetterValue UnicodeBreakType = 38
	// Regional Indicator (RI). Since: 2.36
	GUnicodeBreakRegionalIndicatorValue UnicodeBreakType = 39
	// Emoji Base (EB). Since: 2.50
	GUnicodeBreakEmojiBaseValue UnicodeBreakType = 40
	// Emoji Modifier (EM). Since: 2.50
	GUnicodeBreakEmojiModifierValue UnicodeBreakType = 41
	// Zero Width Joiner (ZWJ). Since: 2.50
	GUnicodeBreakZeroWidthJoinerValue UnicodeBreakType = 42
)

// The #GUnicodeScript enumeration identifies different writing
// systems. The values correspond to the names as defined in the
// Unicode standard. The enumeration has been added in GLib 2.14,
// and is interchangeable with #PangoScript.
//
// Note that new types may be added in the future. Applications
// should be ready to handle unknown values.
// See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/).
type UnicodeScript int

const (

	// a value never returned from g_unichar_get_script()
	GUnicodeScriptInvalidCodeValue UnicodeScript = -1
	// a character used by multiple different scripts
	GUnicodeScriptCommonValue UnicodeScript = 0
	// a mark glyph that takes its script from the
	//                               base glyph to which it is attached
	GUnicodeScriptInheritedValue UnicodeScript = 1
	// Arabic
	GUnicodeScriptArabicValue UnicodeScript = 2
	// Armenian
	GUnicodeScriptArmenianValue UnicodeScript = 3
	// Bengali
	GUnicodeScriptBengaliValue UnicodeScript = 4
	// Bopomofo
	GUnicodeScriptBopomofoValue UnicodeScript = 5
	// Cherokee
	GUnicodeScriptCherokeeValue UnicodeScript = 6
	// Coptic
	GUnicodeScriptCopticValue UnicodeScript = 7
	// Cyrillic
	GUnicodeScriptCyrillicValue UnicodeScript = 8
	// Deseret
	GUnicodeScriptDeseretValue UnicodeScript = 9
	// Devanagari
	GUnicodeScriptDevanagariValue UnicodeScript = 10
	// Ethiopic
	GUnicodeScriptEthiopicValue UnicodeScript = 11
	// Georgian
	GUnicodeScriptGeorgianValue UnicodeScript = 12
	// Gothic
	GUnicodeScriptGothicValue UnicodeScript = 13
	// Greek
	GUnicodeScriptGreekValue UnicodeScript = 14
	// Gujarati
	GUnicodeScriptGujaratiValue UnicodeScript = 15
	// Gurmukhi
	GUnicodeScriptGurmukhiValue UnicodeScript = 16
	// Han
	GUnicodeScriptHanValue UnicodeScript = 17
	// Hangul
	GUnicodeScriptHangulValue UnicodeScript = 18
	// Hebrew
	GUnicodeScriptHebrewValue UnicodeScript = 19
	// Hiragana
	GUnicodeScriptHiraganaValue UnicodeScript = 20
	// Kannada
	GUnicodeScriptKannadaValue UnicodeScript = 21
	// Katakana
	GUnicodeScriptKatakanaValue UnicodeScript = 22
	// Khmer
	GUnicodeScriptKhmerValue UnicodeScript = 23
	// Lao
	GUnicodeScriptLaoValue UnicodeScript = 24
	// Latin
	GUnicodeScriptLatinValue UnicodeScript = 25
	// Malayalam
	GUnicodeScriptMalayalamValue UnicodeScript = 26
	// Mongolian
	GUnicodeScriptMongolianValue UnicodeScript = 27
	// Myanmar
	GUnicodeScriptMyanmarValue UnicodeScript = 28
	// Ogham
	GUnicodeScriptOghamValue UnicodeScript = 29
	// Old Italic
	GUnicodeScriptOldItalicValue UnicodeScript = 30
	// Oriya
	GUnicodeScriptOriyaValue UnicodeScript = 31
	// Runic
	GUnicodeScriptRunicValue UnicodeScript = 32
	// Sinhala
	GUnicodeScriptSinhalaValue UnicodeScript = 33
	// Syriac
	GUnicodeScriptSyriacValue UnicodeScript = 34
	// Tamil
	GUnicodeScriptTamilValue UnicodeScript = 35
	// Telugu
	GUnicodeScriptTeluguValue UnicodeScript = 36
	// Thaana
	GUnicodeScriptThaanaValue UnicodeScript = 37
	// Thai
	GUnicodeScriptThaiValue UnicodeScript = 38
	// Tibetan
	GUnicodeScriptTibetanValue UnicodeScript = 39
	// Canadian Aboriginal
	GUnicodeScriptCanadianAboriginalValue UnicodeScript = 40
	// Yi
	GUnicodeScriptYiValue UnicodeScript = 41
	// Tagalog
	GUnicodeScriptTagalogValue UnicodeScript = 42
	// Hanunoo
	GUnicodeScriptHanunooValue UnicodeScript = 43
	// Buhid
	GUnicodeScriptBuhidValue UnicodeScript = 44
	// Tagbanwa
	GUnicodeScriptTagbanwaValue UnicodeScript = 45
	// Braille
	GUnicodeScriptBrailleValue UnicodeScript = 46
	// Cypriot
	GUnicodeScriptCypriotValue UnicodeScript = 47
	// Limbu
	GUnicodeScriptLimbuValue UnicodeScript = 48
	// Osmanya
	GUnicodeScriptOsmanyaValue UnicodeScript = 49
	// Shavian
	GUnicodeScriptShavianValue UnicodeScript = 50
	// Linear B
	GUnicodeScriptLinearBValue UnicodeScript = 51
	// Tai Le
	GUnicodeScriptTaiLeValue UnicodeScript = 52
	// Ugaritic
	GUnicodeScriptUgariticValue UnicodeScript = 53
	// New Tai Lue
	GUnicodeScriptNewTaiLueValue UnicodeScript = 54
	// Buginese
	GUnicodeScriptBugineseValue UnicodeScript = 55
	// Glagolitic
	GUnicodeScriptGlagoliticValue UnicodeScript = 56
	// Tifinagh
	GUnicodeScriptTifinaghValue UnicodeScript = 57
	// Syloti Nagri
	GUnicodeScriptSylotiNagriValue UnicodeScript = 58
	// Old Persian
	GUnicodeScriptOldPersianValue UnicodeScript = 59
	// Kharoshthi
	GUnicodeScriptKharoshthiValue UnicodeScript = 60
	// an unassigned code point
	GUnicodeScriptUnknownValue UnicodeScript = 61
	// Balinese
	GUnicodeScriptBalineseValue UnicodeScript = 62
	// Cuneiform
	GUnicodeScriptCuneiformValue UnicodeScript = 63
	// Phoenician
	GUnicodeScriptPhoenicianValue UnicodeScript = 64
	// Phags-pa
	GUnicodeScriptPhagsPaValue UnicodeScript = 65
	// N'Ko
	GUnicodeScriptNkoValue UnicodeScript = 66
	// Kayah Li. Since 2.16.3
	GUnicodeScriptKayahLiValue UnicodeScript = 67
	// Lepcha. Since 2.16.3
	GUnicodeScriptLepchaValue UnicodeScript = 68
	// Rejang. Since 2.16.3
	GUnicodeScriptRejangValue UnicodeScript = 69
	// Sundanese. Since 2.16.3
	GUnicodeScriptSundaneseValue UnicodeScript = 70
	// Saurashtra. Since 2.16.3
	GUnicodeScriptSaurashtraValue UnicodeScript = 71
	// Cham. Since 2.16.3
	GUnicodeScriptChamValue UnicodeScript = 72
	// Ol Chiki. Since 2.16.3
	GUnicodeScriptOlChikiValue UnicodeScript = 73
	// Vai. Since 2.16.3
	GUnicodeScriptVaiValue UnicodeScript = 74
	// Carian. Since 2.16.3
	GUnicodeScriptCarianValue UnicodeScript = 75
	// Lycian. Since 2.16.3
	GUnicodeScriptLycianValue UnicodeScript = 76
	// Lydian. Since 2.16.3
	GUnicodeScriptLydianValue UnicodeScript = 77
	// Avestan. Since 2.26
	GUnicodeScriptAvestanValue UnicodeScript = 78
	// Bamum. Since 2.26
	GUnicodeScriptBamumValue UnicodeScript = 79
	// Egyptian Hieroglpyhs. Since 2.26
	GUnicodeScriptEgyptianHieroglyphsValue UnicodeScript = 80
	// Imperial Aramaic. Since 2.26
	GUnicodeScriptImperialAramaicValue UnicodeScript = 81
	// Inscriptional Pahlavi. Since 2.26
	GUnicodeScriptInscriptionalPahlaviValue UnicodeScript = 82
	// Inscriptional Parthian. Since 2.26
	GUnicodeScriptInscriptionalParthianValue UnicodeScript = 83
	// Javanese. Since 2.26
	GUnicodeScriptJavaneseValue UnicodeScript = 84
	// Kaithi. Since 2.26
	GUnicodeScriptKaithiValue UnicodeScript = 85
	// Lisu. Since 2.26
	GUnicodeScriptLisuValue UnicodeScript = 86
	// Meetei Mayek. Since 2.26
	GUnicodeScriptMeeteiMayekValue UnicodeScript = 87
	// Old South Arabian. Since 2.26
	GUnicodeScriptOldSouthArabianValue UnicodeScript = 88
	// Old Turkic. Since 2.28
	GUnicodeScriptOldTurkicValue UnicodeScript = 89
	// Samaritan. Since 2.26
	GUnicodeScriptSamaritanValue UnicodeScript = 90
	// Tai Tham. Since 2.26
	GUnicodeScriptTaiThamValue UnicodeScript = 91
	// Tai Viet. Since 2.26
	GUnicodeScriptTaiVietValue UnicodeScript = 92
	// Batak. Since 2.28
	GUnicodeScriptBatakValue UnicodeScript = 93
	// Brahmi. Since 2.28
	GUnicodeScriptBrahmiValue UnicodeScript = 94
	// Mandaic. Since 2.28
	GUnicodeScriptMandaicValue UnicodeScript = 95
	// Chakma. Since: 2.32
	GUnicodeScriptChakmaValue UnicodeScript = 96
	// Meroitic Cursive. Since: 2.32
	GUnicodeScriptMeroiticCursiveValue UnicodeScript = 97
	// Meroitic Hieroglyphs. Since: 2.32
	GUnicodeScriptMeroiticHieroglyphsValue UnicodeScript = 98
	// Miao. Since: 2.32
	GUnicodeScriptMiaoValue UnicodeScript = 99
	// Sharada. Since: 2.32
	GUnicodeScriptSharadaValue UnicodeScript = 100
	// Sora Sompeng. Since: 2.32
	GUnicodeScriptSoraSompengValue UnicodeScript = 101
	// Takri. Since: 2.32
	GUnicodeScriptTakriValue UnicodeScript = 102
	// Bassa. Since: 2.42
	GUnicodeScriptBassaVahValue UnicodeScript = 103
	// Caucasian Albanian. Since: 2.42
	GUnicodeScriptCaucasianAlbanianValue UnicodeScript = 104
	// Duployan. Since: 2.42
	GUnicodeScriptDuployanValue UnicodeScript = 105
	// Elbasan. Since: 2.42
	GUnicodeScriptElbasanValue UnicodeScript = 106
	// Grantha. Since: 2.42
	GUnicodeScriptGranthaValue UnicodeScript = 107
	// Kjohki. Since: 2.42
	GUnicodeScriptKhojkiValue UnicodeScript = 108
	// Khudawadi, Sindhi. Since: 2.42
	GUnicodeScriptKhudawadiValue UnicodeScript = 109
	// Linear A. Since: 2.42
	GUnicodeScriptLinearAValue UnicodeScript = 110
	// Mahajani. Since: 2.42
	GUnicodeScriptMahajaniValue UnicodeScript = 111
	// Manichaean. Since: 2.42
	GUnicodeScriptManichaeanValue UnicodeScript = 112
	// Mende Kikakui. Since: 2.42
	GUnicodeScriptMendeKikakuiValue UnicodeScript = 113
	// Modi. Since: 2.42
	GUnicodeScriptModiValue UnicodeScript = 114
	// Mro. Since: 2.42
	GUnicodeScriptMroValue UnicodeScript = 115
	// Nabataean. Since: 2.42
	GUnicodeScriptNabataeanValue UnicodeScript = 116
	// Old North Arabian. Since: 2.42
	GUnicodeScriptOldNorthArabianValue UnicodeScript = 117
	// Old Permic. Since: 2.42
	GUnicodeScriptOldPermicValue UnicodeScript = 118
	// Pahawh Hmong. Since: 2.42
	GUnicodeScriptPahawhHmongValue UnicodeScript = 119
	// Palmyrene. Since: 2.42
	GUnicodeScriptPalmyreneValue UnicodeScript = 120
	// Pau Cin Hau. Since: 2.42
	GUnicodeScriptPauCinHauValue UnicodeScript = 121
	// Psalter Pahlavi. Since: 2.42
	GUnicodeScriptPsalterPahlaviValue UnicodeScript = 122
	// Siddham. Since: 2.42
	GUnicodeScriptSiddhamValue UnicodeScript = 123
	// Tirhuta. Since: 2.42
	GUnicodeScriptTirhutaValue UnicodeScript = 124
	// Warang Citi. Since: 2.42
	GUnicodeScriptWarangCitiValue UnicodeScript = 125
	// Ahom. Since: 2.48
	GUnicodeScriptAhomValue UnicodeScript = 126
	// Anatolian Hieroglyphs. Since: 2.48
	GUnicodeScriptAnatolianHieroglyphsValue UnicodeScript = 127
	// Hatran. Since: 2.48
	GUnicodeScriptHatranValue UnicodeScript = 128
	// Multani. Since: 2.48
	GUnicodeScriptMultaniValue UnicodeScript = 129
	// Old Hungarian. Since: 2.48
	GUnicodeScriptOldHungarianValue UnicodeScript = 130
	// Signwriting. Since: 2.48
	GUnicodeScriptSignwritingValue UnicodeScript = 131
	// Adlam. Since: 2.50
	GUnicodeScriptAdlamValue UnicodeScript = 132
	// Bhaiksuki. Since: 2.50
	GUnicodeScriptBhaiksukiValue UnicodeScript = 133
	// Marchen. Since: 2.50
	GUnicodeScriptMarchenValue UnicodeScript = 134
	// Newa. Since: 2.50
	GUnicodeScriptNewaValue UnicodeScript = 135
	// Osage. Since: 2.50
	GUnicodeScriptOsageValue UnicodeScript = 136
	// Tangut. Since: 2.50
	GUnicodeScriptTangutValue UnicodeScript = 137
	// Masaram Gondi. Since: 2.54
	GUnicodeScriptMasaramGondiValue UnicodeScript = 138
	// Nushu. Since: 2.54
	GUnicodeScriptNushuValue UnicodeScript = 139
	// Soyombo. Since: 2.54
	GUnicodeScriptSoyomboValue UnicodeScript = 140
	// Zanabazar Square. Since: 2.54
	GUnicodeScriptZanabazarSquareValue UnicodeScript = 141
	// Dogra. Since: 2.58
	GUnicodeScriptDograValue UnicodeScript = 142
	// Gunjala Gondi. Since: 2.58
	GUnicodeScriptGunjalaGondiValue UnicodeScript = 143
	// Hanifi Rohingya. Since: 2.58
	GUnicodeScriptHanifiRohingyaValue UnicodeScript = 144
	// Makasar. Since: 2.58
	GUnicodeScriptMakasarValue UnicodeScript = 145
	// Medefaidrin. Since: 2.58
	GUnicodeScriptMedefaidrinValue UnicodeScript = 146
	// Old Sogdian. Since: 2.58
	GUnicodeScriptOldSogdianValue UnicodeScript = 147
	// Sogdian. Since: 2.58
	GUnicodeScriptSogdianValue UnicodeScript = 148
	// Elym. Since: 2.62
	GUnicodeScriptElymaicValue UnicodeScript = 149
	// Nand. Since: 2.62
	GUnicodeScriptNandinagariValue UnicodeScript = 150
	// Rohg. Since: 2.62
	GUnicodeScriptNyiakengPuachueHmongValue UnicodeScript = 151
	// Wcho. Since: 2.62
	GUnicodeScriptWanchoValue UnicodeScript = 152
	// Chorasmian. Since: 2.66
	GUnicodeScriptChorasmianValue UnicodeScript = 153
	// Dives Akuru. Since: 2.66
	GUnicodeScriptDivesAkuruValue UnicodeScript = 154
	// Khitan small script. Since: 2.66
	GUnicodeScriptKhitanSmallScriptValue UnicodeScript = 155
	// Yezidi. Since: 2.66
	GUnicodeScriptYezidiValue UnicodeScript = 156
	// Cypro-Minoan. Since: 2.72
	GUnicodeScriptCyproMinoanValue UnicodeScript = 157
	// Old Uyghur. Since: 2.72
	GUnicodeScriptOldUyghurValue UnicodeScript = 158
	// Tangsa. Since: 2.72
	GUnicodeScriptTangsaValue UnicodeScript = 159
	// Toto. Since: 2.72
	GUnicodeScriptTotoValue UnicodeScript = 160
	// Vithkuqi. Since: 2.72
	GUnicodeScriptVithkuqiValue UnicodeScript = 161
	// Mathematical notation. Since: 2.72
	GUnicodeScriptMathValue UnicodeScript = 162
)

// These are the possible character classifications from the
// Unicode specification.
// See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values).
type UnicodeType int

const (

	// General category "Other, Control" (Cc)
	GUnicodeControlValue UnicodeType = 0
	// General category "Other, Format" (Cf)
	GUnicodeFormatValue UnicodeType = 1
	// General category "Other, Not Assigned" (Cn)
	GUnicodeUnassignedValue UnicodeType = 2
	// General category "Other, Private Use" (Co)
	GUnicodePrivateUseValue UnicodeType = 3
	// General category "Other, Surrogate" (Cs)
	GUnicodeSurrogateValue UnicodeType = 4
	// General category "Letter, Lowercase" (Ll)
	GUnicodeLowercaseLetterValue UnicodeType = 5
	// General category "Letter, Modifier" (Lm)
	GUnicodeModifierLetterValue UnicodeType = 6
	// General category "Letter, Other" (Lo)
	GUnicodeOtherLetterValue UnicodeType = 7
	// General category "Letter, Titlecase" (Lt)
	GUnicodeTitlecaseLetterValue UnicodeType = 8
	// General category "Letter, Uppercase" (Lu)
	GUnicodeUppercaseLetterValue UnicodeType = 9
	// General category "Mark, Spacing" (Mc)
	GUnicodeSpacingMarkValue UnicodeType = 10
	// General category "Mark, Enclosing" (Me)
	GUnicodeEnclosingMarkValue UnicodeType = 11
	// General category "Mark, Nonspacing" (Mn)
	GUnicodeNonSpacingMarkValue UnicodeType = 12
	// General category "Number, Decimal Digit" (Nd)
	GUnicodeDecimalNumberValue UnicodeType = 13
	// General category "Number, Letter" (Nl)
	GUnicodeLetterNumberValue UnicodeType = 14
	// General category "Number, Other" (No)
	GUnicodeOtherNumberValue UnicodeType = 15
	// General category "Punctuation, Connector" (Pc)
	GUnicodeConnectPunctuationValue UnicodeType = 16
	// General category "Punctuation, Dash" (Pd)
	GUnicodeDashPunctuationValue UnicodeType = 17
	// General category "Punctuation, Close" (Pe)
	GUnicodeClosePunctuationValue UnicodeType = 18
	// General category "Punctuation, Final quote" (Pf)
	GUnicodeFinalPunctuationValue UnicodeType = 19
	// General category "Punctuation, Initial quote" (Pi)
	GUnicodeInitialPunctuationValue UnicodeType = 20
	// General category "Punctuation, Other" (Po)
	GUnicodeOtherPunctuationValue UnicodeType = 21
	// General category "Punctuation, Open" (Ps)
	GUnicodeOpenPunctuationValue UnicodeType = 22
	// General category "Symbol, Currency" (Sc)
	GUnicodeCurrencySymbolValue UnicodeType = 23
	// General category "Symbol, Modifier" (Sk)
	GUnicodeModifierSymbolValue UnicodeType = 24
	// General category "Symbol, Math" (Sm)
	GUnicodeMathSymbolValue UnicodeType = 25
	// General category "Symbol, Other" (So)
	GUnicodeOtherSymbolValue UnicodeType = 26
	// General category "Separator, Line" (Zl)
	GUnicodeLineSeparatorValue UnicodeType = 27
	// General category "Separator, Paragraph" (Zp)
	GUnicodeParagraphSeparatorValue UnicodeType = 28
	// General category "Separator, Space" (Zs)
	GUnicodeSpaceSeparatorValue UnicodeType = 29
)

var xUcs4ToUtf16 func(uint32, int32, int32, int32, **Error) uint16

// Convert a string from UCS-4 to UTF-16. A 0 character will be
// added to the result after the converted text.
func Ucs4ToUtf16(StrVar uint32, LenVar int32, ItemsReadVar int32, ItemsWrittenVar int32) (uint16, error) {
	var cerr *Error

	cret := xUcs4ToUtf16(StrVar, LenVar, ItemsReadVar, ItemsWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUcs4ToUtf8 func(uint32, int32, int32, int32, **Error) string

// Convert a string from a 32-bit fixed width representation as UCS-4.
// to UTF-8. The result will be terminated with a 0 byte.
func Ucs4ToUtf8(StrVar uint32, LenVar int32, ItemsReadVar int32, ItemsWrittenVar int32) (string, error) {
	var cerr *Error

	cret := xUcs4ToUtf8(StrVar, LenVar, ItemsReadVar, ItemsWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUnicharBreakType func(uint32) UnicodeBreakType

// Determines the break type of @c. @c should be a Unicode character
// (to derive a character from UTF-8 encoded text, use
// g_utf8_get_char()). The break type is used to find word and line
// breaks ("text boundaries"), Pango implements the Unicode boundary
// resolution algorithms and normally you would use a function such
// as pango_break() instead of caring about break types yourself.
func UnicharBreakType(CVar uint32) UnicodeBreakType {

	cret := xUnicharBreakType(CVar)
	return cret
}

var xUnicharCombiningClass func(uint32) int

// Determines the canonical combining class of a Unicode character.
func UnicharCombiningClass(UcVar uint32) int {

	cret := xUnicharCombiningClass(UcVar)
	return cret
}

var xUnicharCompose func(uint32, uint32, uint32) bool

// Performs a single composition step of the
// Unicode canonical composition algorithm.
//
// This function includes algorithmic Hangul Jamo composition,
// but it is not exactly the inverse of g_unichar_decompose().
// No composition can have either of @a or @b equal to zero.
// To be precise, this function composes if and only if
// there exists a Primary Composite P which is canonically
// equivalent to the sequence &lt;@a,@b&gt;.  See the Unicode
// Standard for the definition of Primary Composite.
//
// If @a and @b do not compose a new character, @ch is set to zero.
//
// See
// [UAX#15](http://unicode.org/reports/tr15/)
// for details.
func UnicharCompose(AVar uint32, BVar uint32, ChVar uint32) bool {

	cret := xUnicharCompose(AVar, BVar, ChVar)
	return cret
}

var xUnicharDecompose func(uint32, uint32, uint32) bool

// Performs a single decomposition step of the
// Unicode canonical decomposition algorithm.
//
// This function does not include compatibility
// decompositions. It does, however, include algorithmic
// Hangul Jamo decomposition, as well as 'singleton'
// decompositions which replace a character by a single
// other character. In the case of singletons *@b will
// be set to zero.
//
// If @ch is not decomposable, *@a is set to @ch and *@b
// is set to zero.
//
// Note that the way Unicode decomposition pairs are
// defined, it is guaranteed that @b would not decompose
// further, but @a may itself decompose.  To get the full
// canonical decomposition for @ch, one would need to
// recursively call this function on @a.  Or use
// g_unichar_fully_decompose().
//
// See
// [UAX#15](http://unicode.org/reports/tr15/)
// for details.
func UnicharDecompose(ChVar uint32, AVar uint32, BVar uint32) bool {

	cret := xUnicharDecompose(ChVar, AVar, BVar)
	return cret
}

var xUnicharDigitValue func(uint32) int

// Determines the numeric value of a character as a decimal
// digit.
func UnicharDigitValue(CVar uint32) int {

	cret := xUnicharDigitValue(CVar)
	return cret
}

var xUnicharFullyDecompose func(uint32, bool, uint32, uint) uint

// Computes the canonical or compatibility decomposition of a
// Unicode character.  For compatibility decomposition,
// pass %TRUE for @compat; for canonical decomposition
// pass %FALSE for @compat.
//
// The decomposed sequence is placed in @result.  Only up to
// @result_len characters are written into @result.  The length
// of the full decomposition (irrespective of @result_len) is
// returned by the function.  For canonical decomposition,
// currently all decompositions are of length at most 4, but
// this may change in the future (very unlikely though).
// At any rate, Unicode does guarantee that a buffer of length
// 18 is always enough for both compatibility and canonical
// decompositions, so that is the size recommended. This is provided
// as %G_UNICHAR_MAX_DECOMPOSITION_LENGTH.
//
// See
// [UAX#15](http://unicode.org/reports/tr15/)
// for details.
func UnicharFullyDecompose(ChVar uint32, CompatVar bool, ResultVar uint32, ResultLenVar uint) uint {

	cret := xUnicharFullyDecompose(ChVar, CompatVar, ResultVar, ResultLenVar)
	return cret
}

var xUnicharGetMirrorChar func(uint32, uint32) bool

// In Unicode, some characters are "mirrored". This means that their
// images are mirrored horizontally in text that is laid out from right
// to left. For instance, "(" would become its mirror image, ")", in
// right-to-left text.
//
// If @ch has the Unicode mirrored property and there is another unicode
// character that typically has a glyph that is the mirror image of @ch's
// glyph and @mirrored_ch is set, it puts that character in the address
// pointed to by @mirrored_ch.  Otherwise the original character is put.
func UnicharGetMirrorChar(ChVar uint32, MirroredChVar uint32) bool {

	cret := xUnicharGetMirrorChar(ChVar, MirroredChVar)
	return cret
}

var xUnicharGetScript func(uint32) UnicodeScript

// Looks up the #GUnicodeScript for a particular character (as defined
// by Unicode Standard Annex \#24). No check is made for @ch being a
// valid Unicode character; if you pass in invalid character, the
// result is undefined.
//
// This function is equivalent to pango_script_for_unichar() and the
// two are interchangeable.
func UnicharGetScript(ChVar uint32) UnicodeScript {

	cret := xUnicharGetScript(ChVar)
	return cret
}

var xUnicharIsalnum func(uint32) bool

// Determines whether a character is alphanumeric.
// Given some UTF-8 text, obtain a character value
// with g_utf8_get_char().
func UnicharIsalnum(CVar uint32) bool {

	cret := xUnicharIsalnum(CVar)
	return cret
}

var xUnicharIsalpha func(uint32) bool

// Determines whether a character is alphabetic (i.e. a letter).
// Given some UTF-8 text, obtain a character value with
// g_utf8_get_char().
func UnicharIsalpha(CVar uint32) bool {

	cret := xUnicharIsalpha(CVar)
	return cret
}

var xUnicharIscntrl func(uint32) bool

// Determines whether a character is a control character.
// Given some UTF-8 text, obtain a character value with
// g_utf8_get_char().
func UnicharIscntrl(CVar uint32) bool {

	cret := xUnicharIscntrl(CVar)
	return cret
}

var xUnicharIsdefined func(uint32) bool

// Determines if a given character is assigned in the Unicode
// standard.
func UnicharIsdefined(CVar uint32) bool {

	cret := xUnicharIsdefined(CVar)
	return cret
}

var xUnicharIsdigit func(uint32) bool

// Determines whether a character is numeric (i.e. a digit).  This
// covers ASCII 0-9 and also digits in other languages/scripts.  Given
// some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIsdigit(CVar uint32) bool {

	cret := xUnicharIsdigit(CVar)
	return cret
}

var xUnicharIsgraph func(uint32) bool

// Determines whether a character is printable and not a space
// (returns %FALSE for control characters, format characters, and
// spaces). g_unichar_isprint() is similar, but returns %TRUE for
// spaces. Given some UTF-8 text, obtain a character value with
// g_utf8_get_char().
func UnicharIsgraph(CVar uint32) bool {

	cret := xUnicharIsgraph(CVar)
	return cret
}

var xUnicharIslower func(uint32) bool

// Determines whether a character is a lowercase letter.
// Given some UTF-8 text, obtain a character value with
// g_utf8_get_char().
func UnicharIslower(CVar uint32) bool {

	cret := xUnicharIslower(CVar)
	return cret
}

var xUnicharIsmark func(uint32) bool

// Determines whether a character is a mark (non-spacing mark,
// combining mark, or enclosing mark in Unicode speak).
// Given some UTF-8 text, obtain a character value
// with g_utf8_get_char().
//
// Note: in most cases where isalpha characters are allowed,
// ismark characters should be allowed to as they are essential
// for writing most European languages as well as many non-Latin
// scripts.
func UnicharIsmark(CVar uint32) bool {

	cret := xUnicharIsmark(CVar)
	return cret
}

var xUnicharIsprint func(uint32) bool

// Determines whether a character is printable.
// Unlike g_unichar_isgraph(), returns %TRUE for spaces.
// Given some UTF-8 text, obtain a character value with
// g_utf8_get_char().
func UnicharIsprint(CVar uint32) bool {

	cret := xUnicharIsprint(CVar)
	return cret
}

var xUnicharIspunct func(uint32) bool

// Determines whether a character is punctuation or a symbol.
// Given some UTF-8 text, obtain a character value with
// g_utf8_get_char().
func UnicharIspunct(CVar uint32) bool {

	cret := xUnicharIspunct(CVar)
	return cret
}

var xUnicharIsspace func(uint32) bool

// Determines whether a character is a space, tab, or line separator
// (newline, carriage return, etc.).  Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
//
// (Note: don't use this to do word breaking; you have to use
// Pango or equivalent to get word breaking right, the algorithm
// is fairly complex.)
func UnicharIsspace(CVar uint32) bool {

	cret := xUnicharIsspace(CVar)
	return cret
}

var xUnicharIstitle func(uint32) bool

// Determines if a character is titlecase. Some characters in
// Unicode which are composites, such as the DZ digraph
// have three case variants instead of just two. The titlecase
// form is used at the beginning of a word where only the
// first letter is capitalized. The titlecase form of the DZ
// digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.
func UnicharIstitle(CVar uint32) bool {

	cret := xUnicharIstitle(CVar)
	return cret
}

var xUnicharIsupper func(uint32) bool

// Determines if a character is uppercase.
func UnicharIsupper(CVar uint32) bool {

	cret := xUnicharIsupper(CVar)
	return cret
}

var xUnicharIswide func(uint32) bool

// Determines if a character is typically rendered in a double-width
// cell.
func UnicharIswide(CVar uint32) bool {

	cret := xUnicharIswide(CVar)
	return cret
}

var xUnicharIswideCjk func(uint32) bool

// Determines if a character is typically rendered in a double-width
// cell under legacy East Asian locales.  If a character is wide according to
// g_unichar_iswide(), then it is also reported wide with this function, but
// the converse is not necessarily true. See the
// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)
// for details.
//
// If a character passes the g_unichar_iswide() test then it will also pass
// this test, but not the other way around.  Note that some characters may
// pass both this test and g_unichar_iszerowidth().
func UnicharIswideCjk(CVar uint32) bool {

	cret := xUnicharIswideCjk(CVar)
	return cret
}

var xUnicharIsxdigit func(uint32) bool

// Determines if a character is a hexadecimal digit.
func UnicharIsxdigit(CVar uint32) bool {

	cret := xUnicharIsxdigit(CVar)
	return cret
}

var xUnicharIszerowidth func(uint32) bool

// Determines if a given character typically takes zero width when rendered.
// The return value is %TRUE for all non-spacing and enclosing marks
// (e.g., combining accents), format characters, zero-width
// space, but not U+00AD SOFT HYPHEN.
//
// A typical use of this function is with one of g_unichar_iswide() or
// g_unichar_iswide_cjk() to determine the number of cells a string occupies
// when displayed on a grid display (terminals).  However, note that not all
// terminals support zero-width rendering of zero-width marks.
func UnicharIszerowidth(CVar uint32) bool {

	cret := xUnicharIszerowidth(CVar)
	return cret
}

var xUnicharToUtf8 func(uint32, string) int

// Converts a single character to UTF-8.
func UnicharToUtf8(CVar uint32, OutbufVar string) int {

	cret := xUnicharToUtf8(CVar, OutbufVar)
	return cret
}

var xUnicharTolower func(uint32) uint32

// Converts a character to lower case.
func UnicharTolower(CVar uint32) uint32 {

	cret := xUnicharTolower(CVar)
	return cret
}

var xUnicharTotitle func(uint32) uint32

// Converts a character to the titlecase.
func UnicharTotitle(CVar uint32) uint32 {

	cret := xUnicharTotitle(CVar)
	return cret
}

var xUnicharToupper func(uint32) uint32

// Converts a character to uppercase.
func UnicharToupper(CVar uint32) uint32 {

	cret := xUnicharToupper(CVar)
	return cret
}

var xUnicharType func(uint32) UnicodeType

// Classifies a Unicode character by type.
func UnicharType(CVar uint32) UnicodeType {

	cret := xUnicharType(CVar)
	return cret
}

var xUnicharValidate func(uint32) bool

// Checks whether @ch is a valid Unicode character. Some possible
// integer values of @ch will not be valid. 0 is considered a valid
// character, though it's normally a string terminator.
func UnicharValidate(ChVar uint32) bool {

	cret := xUnicharValidate(ChVar)
	return cret
}

var xUnicharXdigitValue func(uint32) int

// Determines the numeric value of a character as a hexadecimal
// digit.
func UnicharXdigitValue(CVar uint32) int {

	cret := xUnicharXdigitValue(CVar)
	return cret
}

var xUnicodeCanonicalDecomposition func(uint32, uint) uint32

// Computes the canonical decomposition of a Unicode character.
func UnicodeCanonicalDecomposition(ChVar uint32, ResultLenVar uint) uint32 {

	cret := xUnicodeCanonicalDecomposition(ChVar, ResultLenVar)
	return cret
}

var xUnicodeCanonicalOrdering func(uint32, uint)

// Computes the canonical ordering of a string in-place.
// This rearranges decomposed characters in the string
// according to their combining classes.  See the Unicode
// manual for more information.
func UnicodeCanonicalOrdering(StringVar uint32, LenVar uint) {

	xUnicodeCanonicalOrdering(StringVar, LenVar)

}

var xUnicodeScriptFromIso15924 func(uint32) UnicodeScript

// Looks up the Unicode script for @iso15924.  ISO 15924 assigns four-letter
// codes to scripts.  For example, the code for Arabic is 'Arab'.
// This function accepts four letter codes encoded as a @guint32 in a
// big-endian fashion.  That is, the code expected for Arabic is
// 0x41726162 (0x41 is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See
// [Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
// for details.
func UnicodeScriptFromIso15924(Iso15924Var uint32) UnicodeScript {

	cret := xUnicodeScriptFromIso15924(Iso15924Var)
	return cret
}

var xUnicodeScriptToIso15924 func(UnicodeScript) uint32

// Looks up the ISO 15924 code for @script.  ISO 15924 assigns four-letter
// codes to scripts.  For example, the code for Arabic is 'Arab'.  The
// four letter codes are encoded as a @guint32 by this function in a
// big-endian fashion.  That is, the code returned for Arabic is
// 0x41726162 (0x41 is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See
// [Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
// for details.
func UnicodeScriptToIso15924(ScriptVar UnicodeScript) uint32 {

	cret := xUnicodeScriptToIso15924(ScriptVar)
	return cret
}

var xUtf16ToUcs4 func(uint16, int32, int32, int32, **Error) uint32

// Convert a string from UTF-16 to UCS-4. The result will be
// nul-terminated.
func Utf16ToUcs4(StrVar uint16, LenVar int32, ItemsReadVar int32, ItemsWrittenVar int32) (uint32, error) {
	var cerr *Error

	cret := xUtf16ToUcs4(StrVar, LenVar, ItemsReadVar, ItemsWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUtf16ToUtf8 func(uint16, int32, int32, int32, **Error) string

// Convert a string from UTF-16 to UTF-8. The result will be
// terminated with a 0 byte.
//
// Note that the input is expected to be already in native endianness,
// an initial byte-order-mark character is not handled specially.
// g_convert() can be used to convert a byte buffer of UTF-16 data of
// ambiguous endianness.
//
// Further note that this function does not validate the result
// string; it may e.g. include embedded NUL characters. The only
// validation done by this function is to ensure that the input can
// be correctly interpreted as UTF-16, i.e. it doesn't contain
// unpaired surrogates or partial character sequences.
func Utf16ToUtf8(StrVar uint16, LenVar int32, ItemsReadVar int32, ItemsWrittenVar int32) (string, error) {
	var cerr *Error

	cret := xUtf16ToUtf8(StrVar, LenVar, ItemsReadVar, ItemsWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUtf8Casefold func(string, int) string

// Converts a string into a form that is independent of case. The
// result will not correspond to any particular case, but can be
// compared for equality or ordered with the results of calling
// g_utf8_casefold() on other strings.
//
// Note that calling g_utf8_casefold() followed by g_utf8_collate() is
// only an approximation to the correct linguistic case insensitive
// ordering, though it is a fairly good one. Getting this exactly
// right would require a more sophisticated collation function that
// takes case sensitivity into account. GLib does not currently
// provide such a function.
func Utf8Casefold(StrVar string, LenVar int) string {

	cret := xUtf8Casefold(StrVar, LenVar)
	return cret
}

var xUtf8Collate func(string, string) int

// Compares two strings for ordering using the linguistically
// correct rules for the [current locale][setlocale].
// When sorting a large number of strings, it will be significantly
// faster to obtain collation keys with g_utf8_collate_key() and
// compare the keys with strcmp() when sorting instead of sorting
// the original strings.
//
// If the two strings are not comparable due to being in different collation
// sequences, the result is undefined. This can happen if the strings are in
// different language scripts, for example.
func Utf8Collate(Str1Var string, Str2Var string) int {

	cret := xUtf8Collate(Str1Var, Str2Var)
	return cret
}

var xUtf8CollateKey func(string, int) string

// Converts a string into a collation key that can be compared
// with other collation keys produced by the same function using
// strcmp().
//
// The results of comparing the collation keys of two strings
// with strcmp() will always be the same as comparing the two
// original keys with g_utf8_collate().
//
// Note that this function depends on the [current locale][setlocale].
func Utf8CollateKey(StrVar string, LenVar int) string {

	cret := xUtf8CollateKey(StrVar, LenVar)
	return cret
}

var xUtf8CollateKeyForFilename func(string, int) string

// Converts a string into a collation key that can be compared
// with other collation keys produced by the same function using strcmp().
//
// In order to sort filenames correctly, this function treats the dot '.'
// as a special case. Most dictionary orderings seem to consider it
// insignificant, thus producing the ordering "event.c" "eventgenerator.c"
// "event.h" instead of "event.c" "event.h" "eventgenerator.c". Also, we
// would like to treat numbers intelligently so that "file1" "file10" "file5"
// is sorted as "file1" "file5" "file10".
//
// Note that this function depends on the [current locale][setlocale].
func Utf8CollateKeyForFilename(StrVar string, LenVar int) string {

	cret := xUtf8CollateKeyForFilename(StrVar, LenVar)
	return cret
}

var xUtf8FindNextChar func(string, string) string

// Finds the start of the next UTF-8 character in the string after @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check
// is made to see if the character found is actually valid other than
// it starts with an appropriate byte.
//
// If @end is %NULL, the return value will never be %NULL: if the end of the
// string is reached, a pointer to the terminating nul byte is returned. If
// @end is non-%NULL, the return value will be %NULL if the end of the string
// is reached.
func Utf8FindNextChar(PVar string, EndVar string) string {

	cret := xUtf8FindNextChar(PVar, EndVar)
	return cret
}

var xUtf8FindPrevChar func(string, string) string

// Given a position @p with a UTF-8 encoded string @str, find the start
// of the previous UTF-8 character starting before @p. Returns %NULL if no
// UTF-8 characters are present in @str before @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check
// is made to see if the character found is actually valid other than
// it starts with an appropriate byte.
func Utf8FindPrevChar(StrVar string, PVar string) string {

	cret := xUtf8FindPrevChar(StrVar, PVar)
	return cret
}

var xUtf8GetChar func(string) uint32

// Converts a sequence of bytes encoded as UTF-8 to a Unicode character.
//
// If @p does not point to a valid UTF-8 encoded character, results
// are undefined. If you are not sure that the bytes are complete
// valid Unicode characters, you should use g_utf8_get_char_validated()
// instead.
func Utf8GetChar(PVar string) uint32 {

	cret := xUtf8GetChar(PVar)
	return cret
}

var xUtf8GetCharValidated func(string, int) uint32

// Convert a sequence of bytes encoded as UTF-8 to a Unicode character.
// This function checks for incomplete characters, for invalid characters
// such as characters that are out of the range of Unicode, and for
// overlong encodings of valid characters.
//
// Note that g_utf8_get_char_validated() returns (gunichar)-2 if
// @max_len is positive and any of the bytes in the first UTF-8 character
// sequence are nul.
func Utf8GetCharValidated(PVar string, MaxLenVar int) uint32 {

	cret := xUtf8GetCharValidated(PVar, MaxLenVar)
	return cret
}

var xUtf8MakeValid func(string, int) string

// If the provided string is valid UTF-8, return a copy of it. If not,
// return a copy in which bytes that could not be interpreted as valid Unicode
// are replaced with the Unicode replacement character (U+FFFD).
//
// For example, this is an appropriate function to use if you have received
// a string that was incorrectly declared to be UTF-8, and you need a valid
// UTF-8 version of it that can be logged or displayed to the user, with the
// assumption that it is close enough to ASCII or UTF-8 to be mostly
// readable as-is.
func Utf8MakeValid(StrVar string, LenVar int) string {

	cret := xUtf8MakeValid(StrVar, LenVar)
	return cret
}

var xUtf8Normalize func(string, int, NormalizeMode) string

// Converts a string into canonical form, standardizing
// such issues as whether a character with an accent
// is represented as a base character and combining
// accent or as a single precomposed character. The
// string has to be valid UTF-8, otherwise %NULL is
// returned. You should generally call g_utf8_normalize()
// before comparing two Unicode strings.
//
// The normalization mode %G_NORMALIZE_DEFAULT only
// standardizes differences that do not affect the
// text content, such as the above-mentioned accent
// representation. %G_NORMALIZE_ALL also standardizes
// the "compatibility" characters in Unicode, such
// as SUPERSCRIPT THREE to the standard forms
// (in this case DIGIT THREE). Formatting information
// may be lost but for most text operations such
// characters should be considered the same.
//
// %G_NORMALIZE_DEFAULT_COMPOSE and %G_NORMALIZE_ALL_COMPOSE
// are like %G_NORMALIZE_DEFAULT and %G_NORMALIZE_ALL,
// but returned a result with composed forms rather
// than a maximally decomposed form. This is often
// useful if you intend to convert the string to
// a legacy encoding or pass it to a system with
// less capable Unicode handling.
func Utf8Normalize(StrVar string, LenVar int, ModeVar NormalizeMode) string {

	cret := xUtf8Normalize(StrVar, LenVar, ModeVar)
	return cret
}

var xUtf8OffsetToPointer func(string, int32) string

// Converts from an integer character offset to a pointer to a position
// within the string.
//
// Since 2.10, this function allows to pass a negative @offset to
// step backwards. It is usually worth stepping backwards from the end
// instead of forwards if @offset is in the last fourth of the string,
// since moving forward is about 3 times faster than moving backward.
//
// Note that this function doesn't abort when reaching the end of @str.
// Therefore you should be sure that @offset is within string boundaries
// before calling that function. Call g_utf8_strlen() when unsure.
// This limitation exists as this function is called frequently during
// text rendering and therefore has to be as fast as possible.
func Utf8OffsetToPointer(StrVar string, OffsetVar int32) string {

	cret := xUtf8OffsetToPointer(StrVar, OffsetVar)
	return cret
}

var xUtf8PointerToOffset func(string, string) int32

// Converts from a pointer to position within a string to an integer
// character offset.
//
// Since 2.10, this function allows @pos to be before @str, and returns
// a negative offset in this case.
func Utf8PointerToOffset(StrVar string, PosVar string) int32 {

	cret := xUtf8PointerToOffset(StrVar, PosVar)
	return cret
}

var xUtf8PrevChar func(string) string

// Finds the previous UTF-8 character in the string before @p.
//
// @p does not have to be at the beginning of a UTF-8 character. No check
// is made to see if the character found is actually valid other than
// it starts with an appropriate byte. If @p might be the first
// character of the string, you must use g_utf8_find_prev_char() instead.
func Utf8PrevChar(PVar string) string {

	cret := xUtf8PrevChar(PVar)
	return cret
}

var xUtf8Strchr func(string, int, uint32) string

// Finds the leftmost occurrence of the given Unicode character
// in a UTF-8 encoded string, while limiting the search to @len bytes.
// If @len is -1, allow unbounded search.
func Utf8Strchr(PVar string, LenVar int, CVar uint32) string {

	cret := xUtf8Strchr(PVar, LenVar, CVar)
	return cret
}

var xUtf8Strdown func(string, int) string

// Converts all Unicode characters in the string that have a case
// to lowercase. The exact manner that this is done depends
// on the current locale, and may result in the number of
// characters in the string changing.
func Utf8Strdown(StrVar string, LenVar int) string {

	cret := xUtf8Strdown(StrVar, LenVar)
	return cret
}

var xUtf8Strlen func(string, int) int32

// Computes the length of the string in characters, not including
// the terminating nul character. If the @max'th byte falls in the
// middle of a character, the last (partial) character is not counted.
func Utf8Strlen(PVar string, MaxVar int) int32 {

	cret := xUtf8Strlen(PVar, MaxVar)
	return cret
}

var xUtf8Strncpy func(string, string, uint) string

// Like the standard C strncpy() function, but copies a given number
// of characters instead of a given number of bytes. The @src string
// must be valid UTF-8 encoded text. (Use g_utf8_validate() on all
// text before trying to use UTF-8 utility functions with it.)
//
// Note you must ensure @dest is at least 4 * @n to fit the
// largest possible UTF-8 characters
func Utf8Strncpy(DestVar string, SrcVar string, NVar uint) string {

	cret := xUtf8Strncpy(DestVar, SrcVar, NVar)
	return cret
}

var xUtf8Strrchr func(string, int, uint32) string

// Find the rightmost occurrence of the given Unicode character
// in a UTF-8 encoded string, while limiting the search to @len bytes.
// If @len is -1, allow unbounded search.
func Utf8Strrchr(PVar string, LenVar int, CVar uint32) string {

	cret := xUtf8Strrchr(PVar, LenVar, CVar)
	return cret
}

var xUtf8Strreverse func(string, int) string

// Reverses a UTF-8 string. @str must be valid UTF-8 encoded text.
// (Use g_utf8_validate() on all text before trying to use UTF-8
// utility functions with it.)
//
// This function is intended for programmatic uses of reversed strings.
// It pays no attention to decomposed characters, combining marks, byte
// order marks, directional indicators (LRM, LRO, etc) and similar
// characters which might need special handling when reversing a string
// for display purposes.
//
// Note that unlike g_strreverse(), this function returns
// newly-allocated memory, which should be freed with g_free() when
// no longer needed.
func Utf8Strreverse(StrVar string, LenVar int) string {

	cret := xUtf8Strreverse(StrVar, LenVar)
	return cret
}

var xUtf8Strup func(string, int) string

// Converts all Unicode characters in the string that have a case
// to uppercase. The exact manner that this is done depends
// on the current locale, and may result in the number of
// characters in the string increasing. (For instance, the
// German ess-zet will be changed to SS.)
func Utf8Strup(StrVar string, LenVar int) string {

	cret := xUtf8Strup(StrVar, LenVar)
	return cret
}

var xUtf8Substring func(string, int32, int32) string

// Copies a substring out of a UTF-8 encoded string.
// The substring will contain @end_pos - @start_pos characters.
//
// Since GLib 2.72, `-1` can be passed to @end_pos to indicate the
// end of the string.
func Utf8Substring(StrVar string, StartPosVar int32, EndPosVar int32) string {

	cret := xUtf8Substring(StrVar, StartPosVar, EndPosVar)
	return cret
}

var xUtf8ToUcs4 func(string, int32, int32, int32, **Error) uint32

// Convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4. A trailing 0 character will be added to the
// string after the converted text.
func Utf8ToUcs4(StrVar string, LenVar int32, ItemsReadVar int32, ItemsWrittenVar int32) (uint32, error) {
	var cerr *Error

	cret := xUtf8ToUcs4(StrVar, LenVar, ItemsReadVar, ItemsWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUtf8ToUcs4Fast func(string, int32, int32) uint32

// Convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4, assuming valid UTF-8 input.
// This function is roughly twice as fast as g_utf8_to_ucs4()
// but does no error checking on the input. A trailing 0 character
// will be added to the string after the converted text.
func Utf8ToUcs4Fast(StrVar string, LenVar int32, ItemsWrittenVar int32) uint32 {

	cret := xUtf8ToUcs4Fast(StrVar, LenVar, ItemsWrittenVar)
	return cret
}

var xUtf8ToUtf16 func(string, int32, int32, int32, **Error) uint16

// Convert a string from UTF-8 to UTF-16. A 0 character will be
// added to the result after the converted text.
func Utf8ToUtf16(StrVar string, LenVar int32, ItemsReadVar int32, ItemsWrittenVar int32) (uint16, error) {
	var cerr *Error

	cret := xUtf8ToUtf16(StrVar, LenVar, ItemsReadVar, ItemsWrittenVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUtf8Validate func([]byte, int, string) bool

// Validates UTF-8 encoded text. @str is the text to validate;
// if @str is nul-terminated, then @max_len can be -1, otherwise
// @max_len should be the number of bytes to validate.
// If @end is non-%NULL, then the end of the valid range
// will be stored there (i.e. the start of the first invalid
// character if some bytes were invalid, or the end of the text
// being validated otherwise).
//
// Note that g_utf8_validate() returns %FALSE if @max_len is
// positive and any of the @max_len bytes are nul.
//
// Returns %TRUE if all of @str was valid. Many GLib and GTK+
// routines require valid UTF-8 as input; so data read from a file
// or the network should be checked with g_utf8_validate() before
// doing anything else with it.
func Utf8Validate(StrVar []byte, MaxLenVar int, EndVar string) bool {

	cret := xUtf8Validate(StrVar, MaxLenVar, EndVar)
	return cret
}

var xUtf8ValidateLen func([]byte, uint, string) bool

// Validates UTF-8 encoded text.
//
// As with g_utf8_validate(), but @max_len must be set, and hence this function
// will always return %FALSE if any of the bytes of @str are nul.
func Utf8ValidateLen(StrVar []byte, MaxLenVar uint, EndVar string) bool {

	cret := xUtf8ValidateLen(StrVar, MaxLenVar, EndVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xUcs4ToUtf16, lib, "g_ucs4_to_utf16")
	core.PuregoSafeRegister(&xUcs4ToUtf8, lib, "g_ucs4_to_utf8")
	core.PuregoSafeRegister(&xUnicharBreakType, lib, "g_unichar_break_type")
	core.PuregoSafeRegister(&xUnicharCombiningClass, lib, "g_unichar_combining_class")
	core.PuregoSafeRegister(&xUnicharCompose, lib, "g_unichar_compose")
	core.PuregoSafeRegister(&xUnicharDecompose, lib, "g_unichar_decompose")
	core.PuregoSafeRegister(&xUnicharDigitValue, lib, "g_unichar_digit_value")
	core.PuregoSafeRegister(&xUnicharFullyDecompose, lib, "g_unichar_fully_decompose")
	core.PuregoSafeRegister(&xUnicharGetMirrorChar, lib, "g_unichar_get_mirror_char")
	core.PuregoSafeRegister(&xUnicharGetScript, lib, "g_unichar_get_script")
	core.PuregoSafeRegister(&xUnicharIsalnum, lib, "g_unichar_isalnum")
	core.PuregoSafeRegister(&xUnicharIsalpha, lib, "g_unichar_isalpha")
	core.PuregoSafeRegister(&xUnicharIscntrl, lib, "g_unichar_iscntrl")
	core.PuregoSafeRegister(&xUnicharIsdefined, lib, "g_unichar_isdefined")
	core.PuregoSafeRegister(&xUnicharIsdigit, lib, "g_unichar_isdigit")
	core.PuregoSafeRegister(&xUnicharIsgraph, lib, "g_unichar_isgraph")
	core.PuregoSafeRegister(&xUnicharIslower, lib, "g_unichar_islower")
	core.PuregoSafeRegister(&xUnicharIsmark, lib, "g_unichar_ismark")
	core.PuregoSafeRegister(&xUnicharIsprint, lib, "g_unichar_isprint")
	core.PuregoSafeRegister(&xUnicharIspunct, lib, "g_unichar_ispunct")
	core.PuregoSafeRegister(&xUnicharIsspace, lib, "g_unichar_isspace")
	core.PuregoSafeRegister(&xUnicharIstitle, lib, "g_unichar_istitle")
	core.PuregoSafeRegister(&xUnicharIsupper, lib, "g_unichar_isupper")
	core.PuregoSafeRegister(&xUnicharIswide, lib, "g_unichar_iswide")
	core.PuregoSafeRegister(&xUnicharIswideCjk, lib, "g_unichar_iswide_cjk")
	core.PuregoSafeRegister(&xUnicharIsxdigit, lib, "g_unichar_isxdigit")
	core.PuregoSafeRegister(&xUnicharIszerowidth, lib, "g_unichar_iszerowidth")
	core.PuregoSafeRegister(&xUnicharToUtf8, lib, "g_unichar_to_utf8")
	core.PuregoSafeRegister(&xUnicharTolower, lib, "g_unichar_tolower")
	core.PuregoSafeRegister(&xUnicharTotitle, lib, "g_unichar_totitle")
	core.PuregoSafeRegister(&xUnicharToupper, lib, "g_unichar_toupper")
	core.PuregoSafeRegister(&xUnicharType, lib, "g_unichar_type")
	core.PuregoSafeRegister(&xUnicharValidate, lib, "g_unichar_validate")
	core.PuregoSafeRegister(&xUnicharXdigitValue, lib, "g_unichar_xdigit_value")
	core.PuregoSafeRegister(&xUnicodeCanonicalDecomposition, lib, "g_unicode_canonical_decomposition")
	core.PuregoSafeRegister(&xUnicodeCanonicalOrdering, lib, "g_unicode_canonical_ordering")
	core.PuregoSafeRegister(&xUnicodeScriptFromIso15924, lib, "g_unicode_script_from_iso15924")
	core.PuregoSafeRegister(&xUnicodeScriptToIso15924, lib, "g_unicode_script_to_iso15924")
	core.PuregoSafeRegister(&xUtf16ToUcs4, lib, "g_utf16_to_ucs4")
	core.PuregoSafeRegister(&xUtf16ToUtf8, lib, "g_utf16_to_utf8")
	core.PuregoSafeRegister(&xUtf8Casefold, lib, "g_utf8_casefold")
	core.PuregoSafeRegister(&xUtf8Collate, lib, "g_utf8_collate")
	core.PuregoSafeRegister(&xUtf8CollateKey, lib, "g_utf8_collate_key")
	core.PuregoSafeRegister(&xUtf8CollateKeyForFilename, lib, "g_utf8_collate_key_for_filename")
	core.PuregoSafeRegister(&xUtf8FindNextChar, lib, "g_utf8_find_next_char")
	core.PuregoSafeRegister(&xUtf8FindPrevChar, lib, "g_utf8_find_prev_char")
	core.PuregoSafeRegister(&xUtf8GetChar, lib, "g_utf8_get_char")
	core.PuregoSafeRegister(&xUtf8GetCharValidated, lib, "g_utf8_get_char_validated")
	core.PuregoSafeRegister(&xUtf8MakeValid, lib, "g_utf8_make_valid")
	core.PuregoSafeRegister(&xUtf8Normalize, lib, "g_utf8_normalize")
	core.PuregoSafeRegister(&xUtf8OffsetToPointer, lib, "g_utf8_offset_to_pointer")
	core.PuregoSafeRegister(&xUtf8PointerToOffset, lib, "g_utf8_pointer_to_offset")
	core.PuregoSafeRegister(&xUtf8PrevChar, lib, "g_utf8_prev_char")
	core.PuregoSafeRegister(&xUtf8Strchr, lib, "g_utf8_strchr")
	core.PuregoSafeRegister(&xUtf8Strdown, lib, "g_utf8_strdown")
	core.PuregoSafeRegister(&xUtf8Strlen, lib, "g_utf8_strlen")
	core.PuregoSafeRegister(&xUtf8Strncpy, lib, "g_utf8_strncpy")
	core.PuregoSafeRegister(&xUtf8Strrchr, lib, "g_utf8_strrchr")
	core.PuregoSafeRegister(&xUtf8Strreverse, lib, "g_utf8_strreverse")
	core.PuregoSafeRegister(&xUtf8Strup, lib, "g_utf8_strup")
	core.PuregoSafeRegister(&xUtf8Substring, lib, "g_utf8_substring")
	core.PuregoSafeRegister(&xUtf8ToUcs4, lib, "g_utf8_to_ucs4")
	core.PuregoSafeRegister(&xUtf8ToUcs4Fast, lib, "g_utf8_to_ucs4_fast")
	core.PuregoSafeRegister(&xUtf8ToUtf16, lib, "g_utf8_to_utf16")
	core.PuregoSafeRegister(&xUtf8Validate, lib, "g_utf8_validate")
	core.PuregoSafeRegister(&xUtf8ValidateLen, lib, "g_utf8_validate_len")

}
