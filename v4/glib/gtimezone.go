// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// #GTimeZone is an opaque structure whose members cannot be accessed
// directly.
type TimeZone struct {
	_ structs.HostLayout
}

var xTimeZoneGLibType func() types.GType

func TimeZoneGLibType() types.GType {
	return xTimeZoneGLibType()
}

func (x *TimeZone) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewTimeZone func(string) *TimeZone

// A version of g_time_zone_new_identifier() which returns the UTC time zone
// if @identifier could not be parsed or loaded.
//
// If you need to check whether @identifier was loaded successfully, use
// g_time_zone_new_identifier().
func NewTimeZone(IdentifierVar string) *TimeZone {

	cret := xNewTimeZone(IdentifierVar)
	return cret
}

var xNewTimeZoneIdentifier func(string) *TimeZone

// Creates a #GTimeZone corresponding to @identifier. If @identifier cannot be
// parsed or loaded, %NULL is returned.
//
// @identifier can either be an RFC3339/ISO 8601 time offset or
// something that would pass as a valid value for the `TZ` environment
// variable (including %NULL).
//
// In Windows, @identifier can also be the unlocalized name of a time
// zone for standard time, for example "Pacific Standard Time".
//
// Valid RFC3339 time offsets are `"Z"` (for UTC) or
// `"±hh:mm"`.  ISO 8601 additionally specifies
// `"±hhmm"` and `"±hh"`.  Offsets are
// time values to be added to Coordinated Universal Time (UTC) to get
// the local time.
//
// In UNIX, the `TZ` environment variable typically corresponds
// to the name of a file in the zoneinfo database, an absolute path to a file
// somewhere else, or a string in
// "std offset [dst [offset],start[/time],end[/time]]" (POSIX) format.
// There  are  no spaces in the specification. The name of standard
// and daylight savings time zone must be three or more alphabetic
// characters. Offsets are time values to be added to local time to
// get Coordinated Universal Time (UTC) and should be
// `"[±]hh[[:]mm[:ss]]"`.  Dates are either
// `"Jn"` (Julian day with n between 1 and 365, leap
// years not counted), `"n"` (zero-based Julian day
// with n between 0 and 365) or `"Mm.w.d"` (day d
// (0 &lt;= d &lt;= 6) of week w (1 &lt;= w &lt;= 5) of month m (1 &lt;= m &lt;= 12), day
// 0 is a Sunday).  Times are in local wall clock time, the default is
// 02:00:00.
//
// In Windows, the "tzn[+|–]hh[:mm[:ss]][dzn]" format is used, but also
// accepts POSIX format.  The Windows format uses US rules for all time
// zones; daylight savings time is 60 minutes behind the standard time
// with date and time of change taken from Pacific Standard Time.
// Offsets are time values to be added to the local time to get
// Coordinated Universal Time (UTC).
//
// g_time_zone_new_local() calls this function with the value of the
// `TZ` environment variable. This function itself is independent of
// the value of `TZ`, but if @identifier is %NULL then `/etc/localtime`
// will be consulted to discover the correct time zone on UNIX and the
// registry will be consulted or GetTimeZoneInformation() will be used
// to get the local time zone on Windows.
//
// If intervals are not available, only time zone rules from `TZ`
// environment variable or other means, then they will be computed
// from year 1900 to 2037.  If the maximum year for the rules is
// available and it is greater than 2037, then it will followed
// instead.
//
// See
// [RFC3339 §5.6](http://tools.ietf.org/html/rfc3339#section-5.6)
// for a precise definition of valid RFC3339 time offsets
// (the `time-offset` expansion) and ISO 8601 for the
// full list of valid time offsets.  See
// [The GNU C Library manual](http://www.gnu.org/s/libc/manual/html_node/TZ-Variable.html)
// for an explanation of the possible
// values of the `TZ` environment variable. See
// [Microsoft Time Zone Index Values](http://msdn.microsoft.com/en-us/library/ms912391%28v=winembedded.11%29.aspx)
// for the list of time zones on Windows.
//
// You should release the return value by calling g_time_zone_unref()
// when you are done with it.
func NewTimeZoneIdentifier(IdentifierVar string) *TimeZone {

	cret := xNewTimeZoneIdentifier(IdentifierVar)
	return cret
}

var xNewTimeZoneLocal func() *TimeZone

// Creates a #GTimeZone corresponding to local time.  The local time
// zone may change between invocations to this function; for example,
// if the system administrator changes it.
//
// This is equivalent to calling g_time_zone_new() with the value of
// the `TZ` environment variable (including the possibility of %NULL).
//
// You should release the return value by calling g_time_zone_unref()
// when you are done with it.
func NewTimeZoneLocal() *TimeZone {

	cret := xNewTimeZoneLocal()
	return cret
}

var xNewTimeZoneOffset func(int32) *TimeZone

// Creates a #GTimeZone corresponding to the given constant offset from UTC,
// in seconds.
//
// This is equivalent to calling g_time_zone_new() with a string in the form
// `[+|-]hh[:mm[:ss]]`.
func NewTimeZoneOffset(SecondsVar int32) *TimeZone {

	cret := xNewTimeZoneOffset(SecondsVar)
	return cret
}

var xNewTimeZoneUtc func() *TimeZone

// Creates a #GTimeZone corresponding to UTC.
//
// This is equivalent to calling g_time_zone_new() with a value like
// "Z", "UTC", "+00", etc.
//
// You should release the return value by calling g_time_zone_unref()
// when you are done with it.
func NewTimeZoneUtc() *TimeZone {

	cret := xNewTimeZoneUtc()
	return cret
}

var xTimeZoneAdjustTime func(uintptr, TimeType, int64) int

// Finds an interval within @tz that corresponds to the given @time_,
// possibly adjusting @time_ if required to fit into an interval.
// The meaning of @time_ depends on @type.
//
// This function is similar to g_time_zone_find_interval(), with the
// difference that it always succeeds (by making the adjustments
// described below).
//
// In any of the cases where g_time_zone_find_interval() succeeds then
// this function returns the same value, without modifying @time_.
//
// This function may, however, modify @time_ in order to deal with
// non-existent times.  If the non-existent local @time_ of 02:30 were
// requested on March 14th 2010 in Toronto then this function would
// adjust @time_ to be 03:00 and return the interval containing the
// adjusted time.
func (x *TimeZone) AdjustTime(TypeVar TimeType, TimeVar int64) int {

	cret := xTimeZoneAdjustTime(x.GoPointer(), TypeVar, TimeVar)
	return cret
}

var xTimeZoneFindInterval func(uintptr, TimeType, int64) int

// Finds an interval within @tz that corresponds to the given @time_.
// The meaning of @time_ depends on @type.
//
// If @type is %G_TIME_TYPE_UNIVERSAL then this function will always
// succeed (since universal time is monotonic and continuous).
//
// Otherwise @time_ is treated as local time.  The distinction between
// %G_TIME_TYPE_STANDARD and %G_TIME_TYPE_DAYLIGHT is ignored except in
// the case that the given @time_ is ambiguous.  In Toronto, for example,
// 01:30 on November 7th 2010 occurred twice (once inside of daylight
// savings time and the next, an hour later, outside of daylight savings
// time).  In this case, the different value of @type would result in a
// different interval being returned.
//
// It is still possible for this function to fail.  In Toronto, for
// example, 02:00 on March 14th 2010 does not exist (due to the leap
// forward to begin daylight savings time).  -1 is returned in that
// case.
func (x *TimeZone) FindInterval(TypeVar TimeType, TimeVar int64) int {

	cret := xTimeZoneFindInterval(x.GoPointer(), TypeVar, TimeVar)
	return cret
}

var xTimeZoneGetAbbreviation func(uintptr, int) string

// Determines the time zone abbreviation to be used during a particular
// @interval of time in the time zone @tz.
//
// For example, in Toronto this is currently "EST" during the winter
// months and "EDT" during the summer months when daylight savings time
// is in effect.
func (x *TimeZone) GetAbbreviation(IntervalVar int) string {

	cret := xTimeZoneGetAbbreviation(x.GoPointer(), IntervalVar)
	return cret
}

var xTimeZoneGetIdentifier func(uintptr) string

// Get the identifier of this #GTimeZone, as passed to g_time_zone_new().
// If the identifier passed at construction time was not recognised, `UTC` will
// be returned. If it was %NULL, the identifier of the local timezone at
// construction time will be returned.
//
// The identifier will be returned in the same format as provided at
// construction time: if provided as a time offset, that will be returned by
// this function.
func (x *TimeZone) GetIdentifier() string {

	cret := xTimeZoneGetIdentifier(x.GoPointer())
	return cret
}

var xTimeZoneGetOffset func(uintptr, int) int32

// Determines the offset to UTC in effect during a particular @interval
// of time in the time zone @tz.
//
// The offset is the number of seconds that you add to UTC time to
// arrive at local time for @tz (ie: negative numbers for time zones
// west of GMT, positive numbers for east).
func (x *TimeZone) GetOffset(IntervalVar int) int32 {

	cret := xTimeZoneGetOffset(x.GoPointer(), IntervalVar)
	return cret
}

var xTimeZoneIsDst func(uintptr, int) bool

// Determines if daylight savings time is in effect during a particular
// @interval of time in the time zone @tz.
func (x *TimeZone) IsDst(IntervalVar int) bool {

	cret := xTimeZoneIsDst(x.GoPointer(), IntervalVar)
	return cret
}

var xTimeZoneRef func(uintptr) *TimeZone

// Increases the reference count on @tz.
func (x *TimeZone) Ref() *TimeZone {

	cret := xTimeZoneRef(x.GoPointer())
	return cret
}

var xTimeZoneUnref func(uintptr)

// Decreases the reference count on @tz.
func (x *TimeZone) Unref() {

	xTimeZoneUnref(x.GoPointer())

}

// Disambiguates a given time in two ways.
//
// First, specifies if the given time is in universal or local time.
//
// Second, if the time is in local time, specifies if it is local
// standard time or local daylight time.  This is important for the case
// where the same local time occurs twice (during daylight savings time
// transitions, for example).
type TimeType int

const (

	// the time is in local standard time
	GTimeTypeStandardValue TimeType = 0
	// the time is in local daylight time
	GTimeTypeDaylightValue TimeType = 1
	// the time is in UTC
	GTimeTypeUniversalValue TimeType = 2
)

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xTimeZoneGLibType, lib, "g_time_zone_get_type")

	core.PuregoSafeRegister(&xNewTimeZone, lib, "g_time_zone_new")
	core.PuregoSafeRegister(&xNewTimeZoneIdentifier, lib, "g_time_zone_new_identifier")
	core.PuregoSafeRegister(&xNewTimeZoneLocal, lib, "g_time_zone_new_local")
	core.PuregoSafeRegister(&xNewTimeZoneOffset, lib, "g_time_zone_new_offset")
	core.PuregoSafeRegister(&xNewTimeZoneUtc, lib, "g_time_zone_new_utc")

	core.PuregoSafeRegister(&xTimeZoneAdjustTime, lib, "g_time_zone_adjust_time")
	core.PuregoSafeRegister(&xTimeZoneFindInterval, lib, "g_time_zone_find_interval")
	core.PuregoSafeRegister(&xTimeZoneGetAbbreviation, lib, "g_time_zone_get_abbreviation")
	core.PuregoSafeRegister(&xTimeZoneGetIdentifier, lib, "g_time_zone_get_identifier")
	core.PuregoSafeRegister(&xTimeZoneGetOffset, lib, "g_time_zone_get_offset")
	core.PuregoSafeRegister(&xTimeZoneIsDst, lib, "g_time_zone_is_dst")
	core.PuregoSafeRegister(&xTimeZoneRef, lib, "g_time_zone_ref")
	core.PuregoSafeRegister(&xTimeZoneUnref, lib, "g_time_zone_unref")

}
