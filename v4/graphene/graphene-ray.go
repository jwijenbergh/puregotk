// Package graphene was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package graphene

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// A ray emitted from an origin in a given direction.
//
// The contents of the `graphene_ray_t` structure are private, and should not
// be modified directly.
type Ray struct {
	Origin uintptr

	Direction uintptr
}

func (x *Ray) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xRayAlloc func() *Ray

// Allocates a new #graphene_ray_t structure.
//
// The contents of the returned structure are undefined.
func RayAlloc() *Ray {

	cret := xRayAlloc()
	return cret
}

var xRayEqual func(uintptr, *Ray) bool

// Checks whether the two given #graphene_ray_t are equal.
func (x *Ray) Equal(BVar *Ray) bool {

	cret := xRayEqual(x.GoPointer(), BVar)
	return cret
}

var xRayFree func(uintptr)

// Frees the resources allocated by graphene_ray_alloc().
func (x *Ray) Free() {

	xRayFree(x.GoPointer())

}

var xRayGetClosestPointToPoint func(uintptr, *Point3D, *Point3D)

// Computes the point on the given #graphene_ray_t that is closest to the
// given point @p.
func (x *Ray) GetClosestPointToPoint(PVar *Point3D, ResVar *Point3D) {

	xRayGetClosestPointToPoint(x.GoPointer(), PVar, ResVar)

}

var xRayGetDirection func(uintptr, *Vec3)

// Retrieves the direction of the given #graphene_ray_t.
func (x *Ray) GetDirection(DirectionVar *Vec3) {

	xRayGetDirection(x.GoPointer(), DirectionVar)

}

var xRayGetDistanceToPlane func(uintptr, *Plane) float32

// Computes the distance of the origin of the given #graphene_ray_t from the
// given plane.
//
// If the ray does not intersect the plane, this function returns `INFINITY`.
func (x *Ray) GetDistanceToPlane(PVar *Plane) float32 {

	cret := xRayGetDistanceToPlane(x.GoPointer(), PVar)
	return cret
}

var xRayGetDistanceToPoint func(uintptr, *Point3D) float32

// Computes the distance of the closest approach between the
// given #graphene_ray_t @r and the point @p.
//
// The closest approach to a ray from a point is the distance
// between the point and the projection of the point on the
// ray itself.
func (x *Ray) GetDistanceToPoint(PVar *Point3D) float32 {

	cret := xRayGetDistanceToPoint(x.GoPointer(), PVar)
	return cret
}

var xRayGetOrigin func(uintptr, *Point3D)

// Retrieves the origin of the given #graphene_ray_t.
func (x *Ray) GetOrigin(OriginVar *Point3D) {

	xRayGetOrigin(x.GoPointer(), OriginVar)

}

var xRayGetPositionAt func(uintptr, float32, *Point3D)

// Retrieves the coordinates of a point at the distance @t along the
// given #graphene_ray_t.
func (x *Ray) GetPositionAt(TVar float32, PositionVar *Point3D) {

	xRayGetPositionAt(x.GoPointer(), TVar, PositionVar)

}

var xRayInit func(uintptr, *Point3D, *Vec3) *Ray

// Initializes the given #graphene_ray_t using the given @origin
// and @direction values.
func (x *Ray) Init(OriginVar *Point3D, DirectionVar *Vec3) *Ray {

	cret := xRayInit(x.GoPointer(), OriginVar, DirectionVar)
	return cret
}

var xRayInitFromRay func(uintptr, *Ray) *Ray

// Initializes the given #graphene_ray_t using the origin and direction
// values of another #graphene_ray_t.
func (x *Ray) InitFromRay(SrcVar *Ray) *Ray {

	cret := xRayInitFromRay(x.GoPointer(), SrcVar)
	return cret
}

var xRayInitFromVec3 func(uintptr, *Vec3, *Vec3) *Ray

// Initializes the given #graphene_ray_t using the given vectors.
func (x *Ray) InitFromVec3(OriginVar *Vec3, DirectionVar *Vec3) *Ray {

	cret := xRayInitFromVec3(x.GoPointer(), OriginVar, DirectionVar)
	return cret
}

var xRayIntersectBox func(uintptr, *Box, float32) RayIntersectionKind

// Intersects the given #graphene_ray_t @r with the given
// #graphene_box_t @b.
func (x *Ray) IntersectBox(BVar *Box, TOutVar float32) RayIntersectionKind {

	cret := xRayIntersectBox(x.GoPointer(), BVar, TOutVar)
	return cret
}

var xRayIntersectSphere func(uintptr, *Sphere, float32) RayIntersectionKind

// Intersects the given #graphene_ray_t @r with the given
// #graphene_sphere_t @s.
func (x *Ray) IntersectSphere(SVar *Sphere, TOutVar float32) RayIntersectionKind {

	cret := xRayIntersectSphere(x.GoPointer(), SVar, TOutVar)
	return cret
}

var xRayIntersectTriangle func(uintptr, *Triangle, float32) RayIntersectionKind

// Intersects the given #graphene_ray_t @r with the given
// #graphene_triangle_t @t.
func (x *Ray) IntersectTriangle(TVar *Triangle, TOutVar float32) RayIntersectionKind {

	cret := xRayIntersectTriangle(x.GoPointer(), TVar, TOutVar)
	return cret
}

var xRayIntersectsBox func(uintptr, *Box) bool

// Checks whether the given #graphene_ray_t @r intersects the
// given #graphene_box_t @b.
//
// See also: graphene_ray_intersect_box()
func (x *Ray) IntersectsBox(BVar *Box) bool {

	cret := xRayIntersectsBox(x.GoPointer(), BVar)
	return cret
}

var xRayIntersectsSphere func(uintptr, *Sphere) bool

// Checks if the given #graphene_ray_t @r intersects the
// given #graphene_sphere_t @s.
//
// See also: graphene_ray_intersect_sphere()
func (x *Ray) IntersectsSphere(SVar *Sphere) bool {

	cret := xRayIntersectsSphere(x.GoPointer(), SVar)
	return cret
}

var xRayIntersectsTriangle func(uintptr, *Triangle) bool

// Checks whether the given #graphene_ray_t @r intersects the
// given #graphene_triangle_t @b.
//
// See also: graphene_ray_intersect_triangle()
func (x *Ray) IntersectsTriangle(TVar *Triangle) bool {

	cret := xRayIntersectsTriangle(x.GoPointer(), TVar)
	return cret
}

// The type of intersection.
type RayIntersectionKind int

const (

	// No intersection
	RayIntersectionKindNoneValue RayIntersectionKind = 0
	// The ray is entering the intersected
	//   object
	RayIntersectionKindEnterValue RayIntersectionKind = 1
	// The ray is leaving the intersected
	//   object
	RayIntersectionKindLeaveValue RayIntersectionKind = 2
)

func init() {
	lib, err := purego.Dlopen(core.GetPath("GRAPHENE"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xRayAlloc, lib, "graphene_ray_alloc")

	core.PuregoSafeRegister(&xRayEqual, lib, "graphene_ray_equal")
	core.PuregoSafeRegister(&xRayFree, lib, "graphene_ray_free")
	core.PuregoSafeRegister(&xRayGetClosestPointToPoint, lib, "graphene_ray_get_closest_point_to_point")
	core.PuregoSafeRegister(&xRayGetDirection, lib, "graphene_ray_get_direction")
	core.PuregoSafeRegister(&xRayGetDistanceToPlane, lib, "graphene_ray_get_distance_to_plane")
	core.PuregoSafeRegister(&xRayGetDistanceToPoint, lib, "graphene_ray_get_distance_to_point")
	core.PuregoSafeRegister(&xRayGetOrigin, lib, "graphene_ray_get_origin")
	core.PuregoSafeRegister(&xRayGetPositionAt, lib, "graphene_ray_get_position_at")
	core.PuregoSafeRegister(&xRayInit, lib, "graphene_ray_init")
	core.PuregoSafeRegister(&xRayInitFromRay, lib, "graphene_ray_init_from_ray")
	core.PuregoSafeRegister(&xRayInitFromVec3, lib, "graphene_ray_init_from_vec3")
	core.PuregoSafeRegister(&xRayIntersectBox, lib, "graphene_ray_intersect_box")
	core.PuregoSafeRegister(&xRayIntersectSphere, lib, "graphene_ray_intersect_sphere")
	core.PuregoSafeRegister(&xRayIntersectTriangle, lib, "graphene_ray_intersect_triangle")
	core.PuregoSafeRegister(&xRayIntersectsBox, lib, "graphene_ray_intersects_box")
	core.PuregoSafeRegister(&xRayIntersectsSphere, lib, "graphene_ray_intersects_sphere")
	core.PuregoSafeRegister(&xRayIntersectsTriangle, lib, "graphene_ray_intersects_triangle")

}
