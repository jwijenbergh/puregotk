// Package graphene was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package graphene

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// A structure capable of holding a 4x4 matrix.
//
// The contents of the #graphene_matrix_t structure are private and
// should never be accessed directly.
type Matrix struct {
	Value uintptr
}

func (x *Matrix) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xMatrixAlloc func() *Matrix

// Allocates a new #graphene_matrix_t.
func MatrixAlloc() *Matrix {

	cret := xMatrixAlloc()
	return cret
}

var xMatrixDecompose func(uintptr, *Vec3, *Vec3, *Quaternion, *Vec3, *Vec4) bool

// Decomposes a transformation matrix into its component transformations.
//
// The algorithm for decomposing a matrix is taken from the
// [CSS3 Transforms specification](http://dev.w3.org/csswg/css-transforms/);
// specifically, the decomposition code is based on the equivalent code
// published in "Graphics Gems II", edited by Jim Arvo, and
// [available online](http://web.archive.org/web/20150512160205/http://tog.acm.org/resources/GraphicsGems/gemsii/unmatrix.c).
func (x *Matrix) Decompose(TranslateVar *Vec3, ScaleVar *Vec3, RotateVar *Quaternion, ShearVar *Vec3, PerspectiveVar *Vec4) bool {

	cret := xMatrixDecompose(x.GoPointer(), TranslateVar, ScaleVar, RotateVar, ShearVar, PerspectiveVar)
	return cret
}

var xMatrixDeterminant func(uintptr) float32

// Computes the determinant of the given matrix.
func (x *Matrix) Determinant() float32 {

	cret := xMatrixDeterminant(x.GoPointer())
	return cret
}

var xMatrixEqual func(uintptr, *Matrix) bool

// Checks whether the two given #graphene_matrix_t matrices are equal.
func (x *Matrix) Equal(BVar *Matrix) bool {

	cret := xMatrixEqual(x.GoPointer(), BVar)
	return cret
}

var xMatrixEqualFast func(uintptr, *Matrix) bool

// Checks whether the two given #graphene_matrix_t matrices are
// byte-by-byte equal.
//
// While this function is faster than graphene_matrix_equal(), it
// can also return false negatives, so it should be used in
// conjuction with either graphene_matrix_equal() or
// graphene_matrix_near(). For instance:
//
// |[&lt;!-- language="C" --&gt;
//
//	if (graphene_matrix_equal_fast (a, b))
//	  {
//	    // matrices are definitely the same
//	  }
//	else
//	  {
//	    if (graphene_matrix_equal (a, b))
//	      // matrices contain the same values within an epsilon of FLT_EPSILON
//	    else if (graphene_matrix_near (a, b, 0.0001))
//	      // matrices contain the same values within an epsilon of 0.0001
//	    else
//	      // matrices are not equal
//	  }
//
// ]|
func (x *Matrix) EqualFast(BVar *Matrix) bool {

	cret := xMatrixEqualFast(x.GoPointer(), BVar)
	return cret
}

var xMatrixFree func(uintptr)

// Frees the resources allocated by graphene_matrix_alloc().
func (x *Matrix) Free() {

	xMatrixFree(x.GoPointer())

}

var xMatrixGetRow func(uintptr, uint, *Vec4)

// Retrieves the given row vector at @index_ inside a matrix.
func (x *Matrix) GetRow(IndexVar uint, ResVar *Vec4) {

	xMatrixGetRow(x.GoPointer(), IndexVar, ResVar)

}

var xMatrixGetValue func(uintptr, uint, uint) float32

// Retrieves the value at the given @row and @col index.
func (x *Matrix) GetValue(RowVar uint, ColVar uint) float32 {

	cret := xMatrixGetValue(x.GoPointer(), RowVar, ColVar)
	return cret
}

var xMatrixGetXScale func(uintptr) float32

// Retrieves the scaling factor on the X axis in @m.
func (x *Matrix) GetXScale() float32 {

	cret := xMatrixGetXScale(x.GoPointer())
	return cret
}

var xMatrixGetXTranslation func(uintptr) float32

// Retrieves the translation component on the X axis from @m.
func (x *Matrix) GetXTranslation() float32 {

	cret := xMatrixGetXTranslation(x.GoPointer())
	return cret
}

var xMatrixGetYScale func(uintptr) float32

// Retrieves the scaling factor on the Y axis in @m.
func (x *Matrix) GetYScale() float32 {

	cret := xMatrixGetYScale(x.GoPointer())
	return cret
}

var xMatrixGetYTranslation func(uintptr) float32

// Retrieves the translation component on the Y axis from @m.
func (x *Matrix) GetYTranslation() float32 {

	cret := xMatrixGetYTranslation(x.GoPointer())
	return cret
}

var xMatrixGetZScale func(uintptr) float32

// Retrieves the scaling factor on the Z axis in @m.
func (x *Matrix) GetZScale() float32 {

	cret := xMatrixGetZScale(x.GoPointer())
	return cret
}

var xMatrixGetZTranslation func(uintptr) float32

// Retrieves the translation component on the Z axis from @m.
func (x *Matrix) GetZTranslation() float32 {

	cret := xMatrixGetZTranslation(x.GoPointer())
	return cret
}

var xMatrixInitFrom2d func(uintptr, float64, float64, float64, float64, float64, float64) *Matrix

// Initializes a #graphene_matrix_t from the values of an affine
// transformation matrix.
//
// The arguments map to the following matrix layout:
//
// |[&lt;!-- language="plain" --&gt;
//
//	⎛ xx  yx ⎞   ⎛  a   b  0 ⎞
//	⎜ xy  yy ⎟ = ⎜  c   d  0 ⎟
//	⎝ x0  y0 ⎠   ⎝ tx  ty  1 ⎠
//
// ]|
//
// This function can be used to convert between an affine matrix type
// from other libraries and a #graphene_matrix_t.
func (x *Matrix) InitFrom2d(XxVar float64, YxVar float64, XyVar float64, YyVar float64, X0Var float64, Y0Var float64) *Matrix {

	cret := xMatrixInitFrom2d(x.GoPointer(), XxVar, YxVar, XyVar, YyVar, X0Var, Y0Var)
	return cret
}

var xMatrixInitFromFloat func(uintptr, uintptr) *Matrix

// Initializes a #graphene_matrix_t with the given array of floating
// point values.
func (x *Matrix) InitFromFloat(VVar uintptr) *Matrix {

	cret := xMatrixInitFromFloat(x.GoPointer(), VVar)
	return cret
}

var xMatrixInitFromMatrix func(uintptr, *Matrix) *Matrix

// Initializes a #graphene_matrix_t using the values of the
// given matrix.
func (x *Matrix) InitFromMatrix(SrcVar *Matrix) *Matrix {

	cret := xMatrixInitFromMatrix(x.GoPointer(), SrcVar)
	return cret
}

var xMatrixInitFromVec4 func(uintptr, *Vec4, *Vec4, *Vec4, *Vec4) *Matrix

// Initializes a #graphene_matrix_t with the given four row
// vectors.
func (x *Matrix) InitFromVec4(V0Var *Vec4, V1Var *Vec4, V2Var *Vec4, V3Var *Vec4) *Matrix {

	cret := xMatrixInitFromVec4(x.GoPointer(), V0Var, V1Var, V2Var, V3Var)
	return cret
}

var xMatrixInitFrustum func(uintptr, float32, float32, float32, float32, float32, float32) *Matrix

// Initializes a #graphene_matrix_t compatible with #graphene_frustum_t.
//
// See also: graphene_frustum_init_from_matrix()
func (x *Matrix) InitFrustum(LeftVar float32, RightVar float32, BottomVar float32, TopVar float32, ZNearVar float32, ZFarVar float32) *Matrix {

	cret := xMatrixInitFrustum(x.GoPointer(), LeftVar, RightVar, BottomVar, TopVar, ZNearVar, ZFarVar)
	return cret
}

var xMatrixInitIdentity func(uintptr) *Matrix

// Initializes a #graphene_matrix_t with the identity matrix.
func (x *Matrix) InitIdentity() *Matrix {

	cret := xMatrixInitIdentity(x.GoPointer())
	return cret
}

var xMatrixInitLookAt func(uintptr, *Vec3, *Vec3, *Vec3) *Matrix

// Initializes a #graphene_matrix_t so that it positions the "camera"
// at the given @eye coordinates towards an object at the @center
// coordinates. The top of the camera is aligned to the direction
// of the @up vector.
//
// Before the transform, the camera is assumed to be placed at the
// origin, looking towards the negative Z axis, with the top side of
// the camera facing in the direction of the Y axis and the right
// side in the direction of the X axis.
//
// In theory, one could use @m to transform a model of such a camera
// into world-space. However, it is more common to use the inverse of
// @m to transform another object from world coordinates to the view
// coordinates of the camera. Typically you would then apply the
// camera projection transform to get from view to screen
// coordinates.
func (x *Matrix) InitLookAt(EyeVar *Vec3, CenterVar *Vec3, UpVar *Vec3) *Matrix {

	cret := xMatrixInitLookAt(x.GoPointer(), EyeVar, CenterVar, UpVar)
	return cret
}

var xMatrixInitOrtho func(uintptr, float32, float32, float32, float32, float32, float32) *Matrix

// Initializes a #graphene_matrix_t with an orthographic projection.
func (x *Matrix) InitOrtho(LeftVar float32, RightVar float32, TopVar float32, BottomVar float32, ZNearVar float32, ZFarVar float32) *Matrix {

	cret := xMatrixInitOrtho(x.GoPointer(), LeftVar, RightVar, TopVar, BottomVar, ZNearVar, ZFarVar)
	return cret
}

var xMatrixInitPerspective func(uintptr, float32, float32, float32, float32) *Matrix

// Initializes a #graphene_matrix_t with a perspective projection.
func (x *Matrix) InitPerspective(FovyVar float32, AspectVar float32, ZNearVar float32, ZFarVar float32) *Matrix {

	cret := xMatrixInitPerspective(x.GoPointer(), FovyVar, AspectVar, ZNearVar, ZFarVar)
	return cret
}

var xMatrixInitRotate func(uintptr, float32, *Vec3) *Matrix

// Initializes @m to represent a rotation of @angle degrees on
// the axis represented by the @axis vector.
func (x *Matrix) InitRotate(AngleVar float32, AxisVar *Vec3) *Matrix {

	cret := xMatrixInitRotate(x.GoPointer(), AngleVar, AxisVar)
	return cret
}

var xMatrixInitScale func(uintptr, float32, float32, float32) *Matrix

// Initializes a #graphene_matrix_t with the given scaling factors.
func (x *Matrix) InitScale(XVar float32, YVar float32, ZVar float32) *Matrix {

	cret := xMatrixInitScale(x.GoPointer(), XVar, YVar, ZVar)
	return cret
}

var xMatrixInitSkew func(uintptr, float32, float32) *Matrix

// Initializes a #graphene_matrix_t with a skew transformation
// with the given factors.
func (x *Matrix) InitSkew(XSkewVar float32, YSkewVar float32) *Matrix {

	cret := xMatrixInitSkew(x.GoPointer(), XSkewVar, YSkewVar)
	return cret
}

var xMatrixInitTranslate func(uintptr, *Point3D) *Matrix

// Initializes a #graphene_matrix_t with a translation to the
// given coordinates.
func (x *Matrix) InitTranslate(PVar *Point3D) *Matrix {

	cret := xMatrixInitTranslate(x.GoPointer(), PVar)
	return cret
}

var xMatrixInterpolate func(uintptr, *Matrix, float64, *Matrix)

// Linearly interpolates the two given #graphene_matrix_t by
// interpolating the decomposed transformations separately.
//
// If either matrix cannot be reduced to their transformations
// then the interpolation cannot be performed, and this function
// will return an identity matrix.
func (x *Matrix) Interpolate(BVar *Matrix, FactorVar float64, ResVar *Matrix) {

	xMatrixInterpolate(x.GoPointer(), BVar, FactorVar, ResVar)

}

var xMatrixInverse func(uintptr, *Matrix) bool

// Inverts the given matrix.
func (x *Matrix) Inverse(ResVar *Matrix) bool {

	cret := xMatrixInverse(x.GoPointer(), ResVar)
	return cret
}

var xMatrixIs2d func(uintptr) bool

// Checks whether the given #graphene_matrix_t is compatible with an
// a 2D affine transformation matrix.
func (x *Matrix) Is2d() bool {

	cret := xMatrixIs2d(x.GoPointer())
	return cret
}

var xMatrixIsBackfaceVisible func(uintptr) bool

// Checks whether a #graphene_matrix_t has a visible back face.
func (x *Matrix) IsBackfaceVisible() bool {

	cret := xMatrixIsBackfaceVisible(x.GoPointer())
	return cret
}

var xMatrixIsIdentity func(uintptr) bool

// Checks whether the given #graphene_matrix_t is the identity matrix.
func (x *Matrix) IsIdentity() bool {

	cret := xMatrixIsIdentity(x.GoPointer())
	return cret
}

var xMatrixIsSingular func(uintptr) bool

// Checks whether a matrix is singular.
func (x *Matrix) IsSingular() bool {

	cret := xMatrixIsSingular(x.GoPointer())
	return cret
}

var xMatrixMultiply func(uintptr, *Matrix, *Matrix)

// Multiplies two #graphene_matrix_t.
//
// Matrix multiplication is not commutative in general; the order of the factors matters.
// The product of this multiplication is (@a × @b)
func (x *Matrix) Multiply(BVar *Matrix, ResVar *Matrix) {

	xMatrixMultiply(x.GoPointer(), BVar, ResVar)

}

var xMatrixNear func(uintptr, *Matrix, float32) bool

// Compares the two given #graphene_matrix_t matrices and checks
// whether their values are within the given @epsilon of each
// other.
func (x *Matrix) Near(BVar *Matrix, EpsilonVar float32) bool {

	cret := xMatrixNear(x.GoPointer(), BVar, EpsilonVar)
	return cret
}

var xMatrixNormalize func(uintptr, *Matrix)

// Normalizes the given #graphene_matrix_t.
func (x *Matrix) Normalize(ResVar *Matrix) {

	xMatrixNormalize(x.GoPointer(), ResVar)

}

var xMatrixPerspective func(uintptr, float32, *Matrix)

// Applies a perspective of @depth to the matrix.
func (x *Matrix) Perspective(DepthVar float32, ResVar *Matrix) {

	xMatrixPerspective(x.GoPointer(), DepthVar, ResVar)

}

var xMatrixPrint func(uintptr)

// Prints the contents of a matrix to the standard error stream.
//
// This function is only useful for debugging; there are no guarantees
// made on the format of the output.
func (x *Matrix) Print() {

	xMatrixPrint(x.GoPointer())

}

var xMatrixProjectPoint func(uintptr, *Point, *Point)

// Projects a #graphene_point_t using the matrix @m.
func (x *Matrix) ProjectPoint(PVar *Point, ResVar *Point) {

	xMatrixProjectPoint(x.GoPointer(), PVar, ResVar)

}

var xMatrixProjectRect func(uintptr, *Rect, *Quad)

// Projects all corners of a #graphene_rect_t using the given matrix.
//
// See also: graphene_matrix_project_point()
func (x *Matrix) ProjectRect(RVar *Rect, ResVar *Quad) {

	xMatrixProjectRect(x.GoPointer(), RVar, ResVar)

}

var xMatrixProjectRectBounds func(uintptr, *Rect, *Rect)

// Projects a #graphene_rect_t using the given matrix.
//
// The resulting rectangle is the axis aligned bounding rectangle capable
// of fully containing the projected rectangle.
func (x *Matrix) ProjectRectBounds(RVar *Rect, ResVar *Rect) {

	xMatrixProjectRectBounds(x.GoPointer(), RVar, ResVar)

}

var xMatrixRotate func(uintptr, float32, *Vec3)

// Adds a rotation transformation to @m, using the given @angle
// and @axis vector.
//
// This is the equivalent of calling graphene_matrix_init_rotate() and
// then multiplying the matrix @m with the rotation matrix.
func (x *Matrix) Rotate(AngleVar float32, AxisVar *Vec3) {

	xMatrixRotate(x.GoPointer(), AngleVar, AxisVar)

}

var xMatrixRotateEuler func(uintptr, *Euler)

// Adds a rotation transformation to @m, using the given
// #graphene_euler_t.
func (x *Matrix) RotateEuler(EVar *Euler) {

	xMatrixRotateEuler(x.GoPointer(), EVar)

}

var xMatrixRotateQuaternion func(uintptr, *Quaternion)

// Adds a rotation transformation to @m, using the given
// #graphene_quaternion_t.
//
// This is the equivalent of calling graphene_quaternion_to_matrix() and
// then multiplying @m with the rotation matrix.
func (x *Matrix) RotateQuaternion(QVar *Quaternion) {

	xMatrixRotateQuaternion(x.GoPointer(), QVar)

}

var xMatrixRotateX func(uintptr, float32)

// Adds a rotation transformation around the X axis to @m, using
// the given @angle.
//
// See also: graphene_matrix_rotate()
func (x *Matrix) RotateX(AngleVar float32) {

	xMatrixRotateX(x.GoPointer(), AngleVar)

}

var xMatrixRotateY func(uintptr, float32)

// Adds a rotation transformation around the Y axis to @m, using
// the given @angle.
//
// See also: graphene_matrix_rotate()
func (x *Matrix) RotateY(AngleVar float32) {

	xMatrixRotateY(x.GoPointer(), AngleVar)

}

var xMatrixRotateZ func(uintptr, float32)

// Adds a rotation transformation around the Z axis to @m, using
// the given @angle.
//
// See also: graphene_matrix_rotate()
func (x *Matrix) RotateZ(AngleVar float32) {

	xMatrixRotateZ(x.GoPointer(), AngleVar)

}

var xMatrixScale func(uintptr, float32, float32, float32)

// Adds a scaling transformation to @m, using the three
// given factors.
//
// This is the equivalent of calling graphene_matrix_init_scale() and then
// multiplying the matrix @m with the scale matrix.
func (x *Matrix) Scale(FactorXVar float32, FactorYVar float32, FactorZVar float32) {

	xMatrixScale(x.GoPointer(), FactorXVar, FactorYVar, FactorZVar)

}

var xMatrixSkewXy func(uintptr, float32)

// Adds a skew of @factor on the X and Y axis to the given matrix.
func (x *Matrix) SkewXy(FactorVar float32) {

	xMatrixSkewXy(x.GoPointer(), FactorVar)

}

var xMatrixSkewXz func(uintptr, float32)

// Adds a skew of @factor on the X and Z axis to the given matrix.
func (x *Matrix) SkewXz(FactorVar float32) {

	xMatrixSkewXz(x.GoPointer(), FactorVar)

}

var xMatrixSkewYz func(uintptr, float32)

// Adds a skew of @factor on the Y and Z axis to the given matrix.
func (x *Matrix) SkewYz(FactorVar float32) {

	xMatrixSkewYz(x.GoPointer(), FactorVar)

}

var xMatrixTo2d func(uintptr, float64, float64, float64, float64, float64, float64) bool

// Converts a #graphene_matrix_t to an affine transformation
// matrix, if the given matrix is compatible.
//
// The returned values have the following layout:
//
// |[&lt;!-- language="plain" --&gt;
//
//	⎛ xx  yx ⎞   ⎛  a   b  0 ⎞
//	⎜ xy  yy ⎟ = ⎜  c   d  0 ⎟
//	⎝ x0  y0 ⎠   ⎝ tx  ty  1 ⎠
//
// ]|
//
// This function can be used to convert between a #graphene_matrix_t
// and an affine matrix type from other libraries.
func (x *Matrix) To2d(XxVar float64, YxVar float64, XyVar float64, YyVar float64, X0Var float64, Y0Var float64) bool {

	cret := xMatrixTo2d(x.GoPointer(), XxVar, YxVar, XyVar, YyVar, X0Var, Y0Var)
	return cret
}

var xMatrixToFloat func(uintptr, uintptr)

// Converts a #graphene_matrix_t to an array of floating point
// values.
func (x *Matrix) ToFloat(VVar uintptr) {

	xMatrixToFloat(x.GoPointer(), VVar)

}

var xMatrixTransformBounds func(uintptr, *Rect, *Rect)

// Transforms each corner of a #graphene_rect_t using the given matrix @m.
//
// The result is the axis aligned bounding rectangle containing the coplanar
// quadrilateral.
//
// See also: graphene_matrix_transform_point()
func (x *Matrix) TransformBounds(RVar *Rect, ResVar *Rect) {

	xMatrixTransformBounds(x.GoPointer(), RVar, ResVar)

}

var xMatrixTransformBox func(uintptr, *Box, *Box)

// Transforms the vertices of a #graphene_box_t using the given matrix @m.
//
// The result is the axis aligned bounding box containing the transformed
// vertices.
func (x *Matrix) TransformBox(BVar *Box, ResVar *Box) {

	xMatrixTransformBox(x.GoPointer(), BVar, ResVar)

}

var xMatrixTransformPoint func(uintptr, *Point, *Point)

// Transforms the given #graphene_point_t using the matrix @m.
//
// Unlike graphene_matrix_transform_vec3(), this function will take into
// account the fourth row vector of the #graphene_matrix_t when computing
// the dot product of each row vector of the matrix.
//
// See also: graphene_simd4x4f_point3_mul()
func (x *Matrix) TransformPoint(PVar *Point, ResVar *Point) {

	xMatrixTransformPoint(x.GoPointer(), PVar, ResVar)

}

var xMatrixTransformPoint3d func(uintptr, *Point3D, *Point3D)

// Transforms the given #graphene_point3d_t using the matrix @m.
//
// Unlike graphene_matrix_transform_vec3(), this function will take into
// account the fourth row vector of the #graphene_matrix_t when computing
// the dot product of each row vector of the matrix.
//
// See also: graphene_simd4x4f_point3_mul()
func (x *Matrix) TransformPoint3d(PVar *Point3D, ResVar *Point3D) {

	xMatrixTransformPoint3d(x.GoPointer(), PVar, ResVar)

}

var xMatrixTransformRay func(uintptr, *Ray, *Ray)

// Transform a #graphene_ray_t using the given matrix @m.
func (x *Matrix) TransformRay(RVar *Ray, ResVar *Ray) {

	xMatrixTransformRay(x.GoPointer(), RVar, ResVar)

}

var xMatrixTransformRect func(uintptr, *Rect, *Quad)

// Transforms each corner of a #graphene_rect_t using the given matrix @m.
//
// The result is a coplanar quadrilateral.
//
// See also: graphene_matrix_transform_point()
func (x *Matrix) TransformRect(RVar *Rect, ResVar *Quad) {

	xMatrixTransformRect(x.GoPointer(), RVar, ResVar)

}

var xMatrixTransformSphere func(uintptr, *Sphere, *Sphere)

// Transforms a #graphene_sphere_t using the given matrix @m. The
// result is the bounding sphere containing the transformed sphere.
func (x *Matrix) TransformSphere(SVar *Sphere, ResVar *Sphere) {

	xMatrixTransformSphere(x.GoPointer(), SVar, ResVar)

}

var xMatrixTransformVec3 func(uintptr, *Vec3, *Vec3)

// Transforms the given #graphene_vec3_t using the matrix @m.
//
// This function will multiply the X, Y, and Z row vectors of the matrix @m
// with the corresponding components of the vector @v. The W row vector will
// be ignored.
//
// See also: graphene_simd4x4f_vec3_mul()
func (x *Matrix) TransformVec3(VVar *Vec3, ResVar *Vec3) {

	xMatrixTransformVec3(x.GoPointer(), VVar, ResVar)

}

var xMatrixTransformVec4 func(uintptr, *Vec4, *Vec4)

// Transforms the given #graphene_vec4_t using the matrix @m.
//
// See also: graphene_simd4x4f_vec4_mul()
func (x *Matrix) TransformVec4(VVar *Vec4, ResVar *Vec4) {

	xMatrixTransformVec4(x.GoPointer(), VVar, ResVar)

}

var xMatrixTranslate func(uintptr, *Point3D)

// Adds a translation transformation to @m using the coordinates
// of the given #graphene_point3d_t.
//
// This is the equivalent of calling graphene_matrix_init_translate() and
// then multiplying @m with the translation matrix.
func (x *Matrix) Translate(PosVar *Point3D) {

	xMatrixTranslate(x.GoPointer(), PosVar)

}

var xMatrixTranspose func(uintptr, *Matrix)

// Transposes the given matrix.
func (x *Matrix) Transpose(ResVar *Matrix) {

	xMatrixTranspose(x.GoPointer(), ResVar)

}

var xMatrixUnprojectPoint3d func(uintptr, *Matrix, *Point3D, *Point3D)

// Unprojects the given @point using the @projection matrix and
// a @modelview matrix.
func (x *Matrix) UnprojectPoint3d(ModelviewVar *Matrix, PointVar *Point3D, ResVar *Point3D) {

	xMatrixUnprojectPoint3d(x.GoPointer(), ModelviewVar, PointVar, ResVar)

}

var xMatrixUntransformBounds func(uintptr, *Rect, *Rect, *Rect)

// Undoes the transformation on the corners of a #graphene_rect_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (x *Matrix) UntransformBounds(RVar *Rect, BoundsVar *Rect, ResVar *Rect) {

	xMatrixUntransformBounds(x.GoPointer(), RVar, BoundsVar, ResVar)

}

var xMatrixUntransformPoint func(uintptr, *Point, *Rect, *Point) bool

// Undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (x *Matrix) UntransformPoint(PVar *Point, BoundsVar *Rect, ResVar *Point) bool {

	cret := xMatrixUntransformPoint(x.GoPointer(), PVar, BoundsVar, ResVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GRAPHENE"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xMatrixAlloc, lib, "graphene_matrix_alloc")

	core.PuregoSafeRegister(&xMatrixDecompose, lib, "graphene_matrix_decompose")
	core.PuregoSafeRegister(&xMatrixDeterminant, lib, "graphene_matrix_determinant")
	core.PuregoSafeRegister(&xMatrixEqual, lib, "graphene_matrix_equal")
	core.PuregoSafeRegister(&xMatrixEqualFast, lib, "graphene_matrix_equal_fast")
	core.PuregoSafeRegister(&xMatrixFree, lib, "graphene_matrix_free")
	core.PuregoSafeRegister(&xMatrixGetRow, lib, "graphene_matrix_get_row")
	core.PuregoSafeRegister(&xMatrixGetValue, lib, "graphene_matrix_get_value")
	core.PuregoSafeRegister(&xMatrixGetXScale, lib, "graphene_matrix_get_x_scale")
	core.PuregoSafeRegister(&xMatrixGetXTranslation, lib, "graphene_matrix_get_x_translation")
	core.PuregoSafeRegister(&xMatrixGetYScale, lib, "graphene_matrix_get_y_scale")
	core.PuregoSafeRegister(&xMatrixGetYTranslation, lib, "graphene_matrix_get_y_translation")
	core.PuregoSafeRegister(&xMatrixGetZScale, lib, "graphene_matrix_get_z_scale")
	core.PuregoSafeRegister(&xMatrixGetZTranslation, lib, "graphene_matrix_get_z_translation")
	core.PuregoSafeRegister(&xMatrixInitFrom2d, lib, "graphene_matrix_init_from_2d")
	core.PuregoSafeRegister(&xMatrixInitFromFloat, lib, "graphene_matrix_init_from_float")
	core.PuregoSafeRegister(&xMatrixInitFromMatrix, lib, "graphene_matrix_init_from_matrix")
	core.PuregoSafeRegister(&xMatrixInitFromVec4, lib, "graphene_matrix_init_from_vec4")
	core.PuregoSafeRegister(&xMatrixInitFrustum, lib, "graphene_matrix_init_frustum")
	core.PuregoSafeRegister(&xMatrixInitIdentity, lib, "graphene_matrix_init_identity")
	core.PuregoSafeRegister(&xMatrixInitLookAt, lib, "graphene_matrix_init_look_at")
	core.PuregoSafeRegister(&xMatrixInitOrtho, lib, "graphene_matrix_init_ortho")
	core.PuregoSafeRegister(&xMatrixInitPerspective, lib, "graphene_matrix_init_perspective")
	core.PuregoSafeRegister(&xMatrixInitRotate, lib, "graphene_matrix_init_rotate")
	core.PuregoSafeRegister(&xMatrixInitScale, lib, "graphene_matrix_init_scale")
	core.PuregoSafeRegister(&xMatrixInitSkew, lib, "graphene_matrix_init_skew")
	core.PuregoSafeRegister(&xMatrixInitTranslate, lib, "graphene_matrix_init_translate")
	core.PuregoSafeRegister(&xMatrixInterpolate, lib, "graphene_matrix_interpolate")
	core.PuregoSafeRegister(&xMatrixInverse, lib, "graphene_matrix_inverse")
	core.PuregoSafeRegister(&xMatrixIs2d, lib, "graphene_matrix_is_2d")
	core.PuregoSafeRegister(&xMatrixIsBackfaceVisible, lib, "graphene_matrix_is_backface_visible")
	core.PuregoSafeRegister(&xMatrixIsIdentity, lib, "graphene_matrix_is_identity")
	core.PuregoSafeRegister(&xMatrixIsSingular, lib, "graphene_matrix_is_singular")
	core.PuregoSafeRegister(&xMatrixMultiply, lib, "graphene_matrix_multiply")
	core.PuregoSafeRegister(&xMatrixNear, lib, "graphene_matrix_near")
	core.PuregoSafeRegister(&xMatrixNormalize, lib, "graphene_matrix_normalize")
	core.PuregoSafeRegister(&xMatrixPerspective, lib, "graphene_matrix_perspective")
	core.PuregoSafeRegister(&xMatrixPrint, lib, "graphene_matrix_print")
	core.PuregoSafeRegister(&xMatrixProjectPoint, lib, "graphene_matrix_project_point")
	core.PuregoSafeRegister(&xMatrixProjectRect, lib, "graphene_matrix_project_rect")
	core.PuregoSafeRegister(&xMatrixProjectRectBounds, lib, "graphene_matrix_project_rect_bounds")
	core.PuregoSafeRegister(&xMatrixRotate, lib, "graphene_matrix_rotate")
	core.PuregoSafeRegister(&xMatrixRotateEuler, lib, "graphene_matrix_rotate_euler")
	core.PuregoSafeRegister(&xMatrixRotateQuaternion, lib, "graphene_matrix_rotate_quaternion")
	core.PuregoSafeRegister(&xMatrixRotateX, lib, "graphene_matrix_rotate_x")
	core.PuregoSafeRegister(&xMatrixRotateY, lib, "graphene_matrix_rotate_y")
	core.PuregoSafeRegister(&xMatrixRotateZ, lib, "graphene_matrix_rotate_z")
	core.PuregoSafeRegister(&xMatrixScale, lib, "graphene_matrix_scale")
	core.PuregoSafeRegister(&xMatrixSkewXy, lib, "graphene_matrix_skew_xy")
	core.PuregoSafeRegister(&xMatrixSkewXz, lib, "graphene_matrix_skew_xz")
	core.PuregoSafeRegister(&xMatrixSkewYz, lib, "graphene_matrix_skew_yz")
	core.PuregoSafeRegister(&xMatrixTo2d, lib, "graphene_matrix_to_2d")
	core.PuregoSafeRegister(&xMatrixToFloat, lib, "graphene_matrix_to_float")
	core.PuregoSafeRegister(&xMatrixTransformBounds, lib, "graphene_matrix_transform_bounds")
	core.PuregoSafeRegister(&xMatrixTransformBox, lib, "graphene_matrix_transform_box")
	core.PuregoSafeRegister(&xMatrixTransformPoint, lib, "graphene_matrix_transform_point")
	core.PuregoSafeRegister(&xMatrixTransformPoint3d, lib, "graphene_matrix_transform_point3d")
	core.PuregoSafeRegister(&xMatrixTransformRay, lib, "graphene_matrix_transform_ray")
	core.PuregoSafeRegister(&xMatrixTransformRect, lib, "graphene_matrix_transform_rect")
	core.PuregoSafeRegister(&xMatrixTransformSphere, lib, "graphene_matrix_transform_sphere")
	core.PuregoSafeRegister(&xMatrixTransformVec3, lib, "graphene_matrix_transform_vec3")
	core.PuregoSafeRegister(&xMatrixTransformVec4, lib, "graphene_matrix_transform_vec4")
	core.PuregoSafeRegister(&xMatrixTranslate, lib, "graphene_matrix_translate")
	core.PuregoSafeRegister(&xMatrixTranspose, lib, "graphene_matrix_transpose")
	core.PuregoSafeRegister(&xMatrixUnprojectPoint3d, lib, "graphene_matrix_unproject_point3d")
	core.PuregoSafeRegister(&xMatrixUntransformBounds, lib, "graphene_matrix_untransform_bounds")
	core.PuregoSafeRegister(&xMatrixUntransformPoint, lib, "graphene_matrix_untransform_point")

}
