// Package graphene was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package graphene

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// A 2D plane that extends infinitely in a 3D volume.
//
// The contents of the `graphene_plane_t` are private, and should not be
// modified directly.
type Plane struct {
	Normal uintptr

	Constant float32
}

func (x *Plane) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xPlaneAlloc func() *Plane

// Allocates a new #graphene_plane_t structure.
//
// The contents of the returned structure are undefined.
func PlaneAlloc() *Plane {

	cret := xPlaneAlloc()
	return cret
}

var xPlaneDistance func(uintptr, *Point3D) float32

// Computes the distance of @point from a #graphene_plane_t.
func (x *Plane) Distance(PointVar *Point3D) float32 {

	cret := xPlaneDistance(x.GoPointer(), PointVar)
	return cret
}

var xPlaneEqual func(uintptr, *Plane) bool

// Checks whether the two given #graphene_plane_t are equal.
func (x *Plane) Equal(BVar *Plane) bool {

	cret := xPlaneEqual(x.GoPointer(), BVar)
	return cret
}

var xPlaneFree func(uintptr)

// Frees the resources allocated by graphene_plane_alloc().
func (x *Plane) Free() {

	xPlaneFree(x.GoPointer())

}

var xPlaneGetConstant func(uintptr) float32

// Retrieves the distance along the normal vector of the
// given #graphene_plane_t from the origin.
func (x *Plane) GetConstant() float32 {

	cret := xPlaneGetConstant(x.GoPointer())
	return cret
}

var xPlaneGetNormal func(uintptr, *Vec3)

// Retrieves the normal vector pointing towards the origin of the
// given #graphene_plane_t.
func (x *Plane) GetNormal(NormalVar *Vec3) {

	xPlaneGetNormal(x.GoPointer(), NormalVar)

}

var xPlaneInit func(uintptr, *Vec3, float32) *Plane

// Initializes the given #graphene_plane_t using the given @normal vector
// and @constant values.
func (x *Plane) Init(NormalVar *Vec3, ConstantVar float32) *Plane {

	cret := xPlaneInit(x.GoPointer(), NormalVar, ConstantVar)
	return cret
}

var xPlaneInitFromPlane func(uintptr, *Plane) *Plane

// Initializes the given #graphene_plane_t using the normal
// vector and constant of another #graphene_plane_t.
func (x *Plane) InitFromPlane(SrcVar *Plane) *Plane {

	cret := xPlaneInitFromPlane(x.GoPointer(), SrcVar)
	return cret
}

var xPlaneInitFromPoint func(uintptr, *Vec3, *Point3D) *Plane

// Initializes the given #graphene_plane_t using the given normal vector
// and an arbitrary co-planar point.
func (x *Plane) InitFromPoint(NormalVar *Vec3, PointVar *Point3D) *Plane {

	cret := xPlaneInitFromPoint(x.GoPointer(), NormalVar, PointVar)
	return cret
}

var xPlaneInitFromPoints func(uintptr, *Point3D, *Point3D, *Point3D) *Plane

// Initializes the given #graphene_plane_t using the 3 provided co-planar
// points.
//
// The winding order is counter-clockwise, and determines which direction
// the normal vector will point.
func (x *Plane) InitFromPoints(AVar *Point3D, BVar *Point3D, CVar *Point3D) *Plane {

	cret := xPlaneInitFromPoints(x.GoPointer(), AVar, BVar, CVar)
	return cret
}

var xPlaneInitFromVec4 func(uintptr, *Vec4) *Plane

// Initializes the given #graphene_plane_t using the components of
// the given #graphene_vec4_t vector.
func (x *Plane) InitFromVec4(SrcVar *Vec4) *Plane {

	cret := xPlaneInitFromVec4(x.GoPointer(), SrcVar)
	return cret
}

var xPlaneNegate func(uintptr, *Plane)

// Negates the normal vector and constant of a #graphene_plane_t, effectively
// mirroring the plane across the origin.
func (x *Plane) Negate(ResVar *Plane) {

	xPlaneNegate(x.GoPointer(), ResVar)

}

var xPlaneNormalize func(uintptr, *Plane)

// Normalizes the vector of the given #graphene_plane_t,
// and adjusts the constant accordingly.
func (x *Plane) Normalize(ResVar *Plane) {

	xPlaneNormalize(x.GoPointer(), ResVar)

}

var xPlaneTransform func(uintptr, *Matrix, *Matrix, *Plane)

// Transforms a #graphene_plane_t @p using the given @matrix
// and @normal_matrix.
//
// If @normal_matrix is %NULL, a transformation matrix for the plane
// normal will be computed from @matrix. If you are transforming
// multiple planes using the same @matrix it's recommended to compute
// the normal matrix beforehand to avoid incurring in the cost of
// recomputing it every time.
func (x *Plane) Transform(MatrixVar *Matrix, NormalMatrixVar *Matrix, ResVar *Plane) {

	xPlaneTransform(x.GoPointer(), MatrixVar, NormalMatrixVar, ResVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GRAPHENE"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xPlaneAlloc, lib, "graphene_plane_alloc")

	core.PuregoSafeRegister(&xPlaneDistance, lib, "graphene_plane_distance")
	core.PuregoSafeRegister(&xPlaneEqual, lib, "graphene_plane_equal")
	core.PuregoSafeRegister(&xPlaneFree, lib, "graphene_plane_free")
	core.PuregoSafeRegister(&xPlaneGetConstant, lib, "graphene_plane_get_constant")
	core.PuregoSafeRegister(&xPlaneGetNormal, lib, "graphene_plane_get_normal")
	core.PuregoSafeRegister(&xPlaneInit, lib, "graphene_plane_init")
	core.PuregoSafeRegister(&xPlaneInitFromPlane, lib, "graphene_plane_init_from_plane")
	core.PuregoSafeRegister(&xPlaneInitFromPoint, lib, "graphene_plane_init_from_point")
	core.PuregoSafeRegister(&xPlaneInitFromPoints, lib, "graphene_plane_init_from_points")
	core.PuregoSafeRegister(&xPlaneInitFromVec4, lib, "graphene_plane_init_from_vec4")
	core.PuregoSafeRegister(&xPlaneNegate, lib, "graphene_plane_negate")
	core.PuregoSafeRegister(&xPlaneNormalize, lib, "graphene_plane_normalize")
	core.PuregoSafeRegister(&xPlaneTransform, lib, "graphene_plane_transform")

}
