// Package graphene was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package graphene

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// A structure capable of holding a vector with four dimensions: x, y, z, and w.
//
// The contents of the #graphene_vec4_t structure are private and should
// never be accessed directly.
type Vec4 struct {
	Value uintptr
}

func (x *Vec4) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xVec4Alloc func() *Vec4

// Allocates a new #graphene_vec4_t structure.
//
// The contents of the returned structure are undefined.
//
// Use graphene_vec4_init() to initialize the vector.
func Vec4Alloc() *Vec4 {

	cret := xVec4Alloc()
	return cret
}

var xVec4Add func(uintptr, *Vec4, *Vec4)

// Adds each component of the two given vectors.
func (x *Vec4) Add(BVar *Vec4, ResVar *Vec4) {

	xVec4Add(x.GoPointer(), BVar, ResVar)

}

var xVec4Divide func(uintptr, *Vec4, *Vec4)

// Divides each component of the first operand @a by the corresponding
// component of the second operand @b, and places the results into the
// vector @res.
func (x *Vec4) Divide(BVar *Vec4, ResVar *Vec4) {

	xVec4Divide(x.GoPointer(), BVar, ResVar)

}

var xVec4Dot func(uintptr, *Vec4) float32

// Computes the dot product of the two given vectors.
func (x *Vec4) Dot(BVar *Vec4) float32 {

	cret := xVec4Dot(x.GoPointer(), BVar)
	return cret
}

var xVec4Equal func(uintptr, *Vec4) bool

// Checks whether the two given #graphene_vec4_t are equal.
func (x *Vec4) Equal(V2Var *Vec4) bool {

	cret := xVec4Equal(x.GoPointer(), V2Var)
	return cret
}

var xVec4Free func(uintptr)

// Frees the resources allocated by @v
func (x *Vec4) Free() {

	xVec4Free(x.GoPointer())

}

var xVec4GetW func(uintptr) float32

// Retrieves the value of the fourth component of the given #graphene_vec4_t.
func (x *Vec4) GetW() float32 {

	cret := xVec4GetW(x.GoPointer())
	return cret
}

var xVec4GetX func(uintptr) float32

// Retrieves the value of the first component of the given #graphene_vec4_t.
func (x *Vec4) GetX() float32 {

	cret := xVec4GetX(x.GoPointer())
	return cret
}

var xVec4GetXy func(uintptr, *Vec2)

// Creates a #graphene_vec2_t that contains the first two components
// of the given #graphene_vec4_t.
func (x *Vec4) GetXy(ResVar *Vec2) {

	xVec4GetXy(x.GoPointer(), ResVar)

}

var xVec4GetXyz func(uintptr, *Vec3)

// Creates a #graphene_vec3_t that contains the first three components
// of the given #graphene_vec4_t.
func (x *Vec4) GetXyz(ResVar *Vec3) {

	xVec4GetXyz(x.GoPointer(), ResVar)

}

var xVec4GetY func(uintptr) float32

// Retrieves the value of the second component of the given #graphene_vec4_t.
func (x *Vec4) GetY() float32 {

	cret := xVec4GetY(x.GoPointer())
	return cret
}

var xVec4GetZ func(uintptr) float32

// Retrieves the value of the third component of the given #graphene_vec4_t.
func (x *Vec4) GetZ() float32 {

	cret := xVec4GetZ(x.GoPointer())
	return cret
}

var xVec4Init func(uintptr, float32, float32, float32, float32) *Vec4

// Initializes a #graphene_vec4_t using the given values.
//
// This function can be called multiple times.
func (x *Vec4) Init(XVar float32, YVar float32, ZVar float32, WVar float32) *Vec4 {

	cret := xVec4Init(x.GoPointer(), XVar, YVar, ZVar, WVar)
	return cret
}

var xVec4InitFromFloat func(uintptr, uintptr) *Vec4

// Initializes a #graphene_vec4_t with the values inside the given array.
func (x *Vec4) InitFromFloat(SrcVar uintptr) *Vec4 {

	cret := xVec4InitFromFloat(x.GoPointer(), SrcVar)
	return cret
}

var xVec4InitFromVec2 func(uintptr, *Vec2, float32, float32) *Vec4

// Initializes a #graphene_vec4_t using the components of a
// #graphene_vec2_t and the values of @z and @w.
func (x *Vec4) InitFromVec2(SrcVar *Vec2, ZVar float32, WVar float32) *Vec4 {

	cret := xVec4InitFromVec2(x.GoPointer(), SrcVar, ZVar, WVar)
	return cret
}

var xVec4InitFromVec3 func(uintptr, *Vec3, float32) *Vec4

// Initializes a #graphene_vec4_t using the components of a
// #graphene_vec3_t and the value of @w.
func (x *Vec4) InitFromVec3(SrcVar *Vec3, WVar float32) *Vec4 {

	cret := xVec4InitFromVec3(x.GoPointer(), SrcVar, WVar)
	return cret
}

var xVec4InitFromVec4 func(uintptr, *Vec4) *Vec4

// Initializes a #graphene_vec4_t using the components of
// another #graphene_vec4_t.
func (x *Vec4) InitFromVec4(SrcVar *Vec4) *Vec4 {

	cret := xVec4InitFromVec4(x.GoPointer(), SrcVar)
	return cret
}

var xVec4Interpolate func(uintptr, *Vec4, float64, *Vec4)

// Linearly interpolates @v1 and @v2 using the given @factor.
func (x *Vec4) Interpolate(V2Var *Vec4, FactorVar float64, ResVar *Vec4) {

	xVec4Interpolate(x.GoPointer(), V2Var, FactorVar, ResVar)

}

var xVec4Length func(uintptr) float32

// Computes the length of the given #graphene_vec4_t.
func (x *Vec4) Length() float32 {

	cret := xVec4Length(x.GoPointer())
	return cret
}

var xVec4Max func(uintptr, *Vec4, *Vec4)

// Compares each component of the two given vectors and creates a
// vector that contains the maximum values.
func (x *Vec4) Max(BVar *Vec4, ResVar *Vec4) {

	xVec4Max(x.GoPointer(), BVar, ResVar)

}

var xVec4Min func(uintptr, *Vec4, *Vec4)

// Compares each component of the two given vectors and creates a
// vector that contains the minimum values.
func (x *Vec4) Min(BVar *Vec4, ResVar *Vec4) {

	xVec4Min(x.GoPointer(), BVar, ResVar)

}

var xVec4Multiply func(uintptr, *Vec4, *Vec4)

// Multiplies each component of the two given vectors.
func (x *Vec4) Multiply(BVar *Vec4, ResVar *Vec4) {

	xVec4Multiply(x.GoPointer(), BVar, ResVar)

}

var xVec4Near func(uintptr, *Vec4, float32) bool

// Compares the two given #graphene_vec4_t vectors and checks
// whether their values are within the given @epsilon.
func (x *Vec4) Near(V2Var *Vec4, EpsilonVar float32) bool {

	cret := xVec4Near(x.GoPointer(), V2Var, EpsilonVar)
	return cret
}

var xVec4Negate func(uintptr, *Vec4)

// Negates the given #graphene_vec4_t.
func (x *Vec4) Negate(ResVar *Vec4) {

	xVec4Negate(x.GoPointer(), ResVar)

}

var xVec4Normalize func(uintptr, *Vec4)

// Normalizes the given #graphene_vec4_t.
func (x *Vec4) Normalize(ResVar *Vec4) {

	xVec4Normalize(x.GoPointer(), ResVar)

}

var xVec4Scale func(uintptr, float32, *Vec4)

// Multiplies all components of the given vector with the given scalar @factor.
func (x *Vec4) Scale(FactorVar float32, ResVar *Vec4) {

	xVec4Scale(x.GoPointer(), FactorVar, ResVar)

}

var xVec4Subtract func(uintptr, *Vec4, *Vec4)

// Subtracts from each component of the first operand @a the
// corresponding component of the second operand @b and places
// each result into the components of @res.
func (x *Vec4) Subtract(BVar *Vec4, ResVar *Vec4) {

	xVec4Subtract(x.GoPointer(), BVar, ResVar)

}

var xVec4ToFloat func(uintptr, uintptr)

// Stores the components of the given #graphene_vec4_t into an array
// of floating point values.
func (x *Vec4) ToFloat(DestVar uintptr) {

	xVec4ToFloat(x.GoPointer(), DestVar)

}

var xVec4One func() *Vec4

// Retrieves a pointer to a #graphene_vec4_t with all its
// components set to 1.
func Vec4One() *Vec4 {

	cret := xVec4One()
	return cret
}

var xVec4WAxis func() *Vec4

// Retrieves a pointer to a #graphene_vec4_t with its
// components set to (0, 0, 0, 1).
func Vec4WAxis() *Vec4 {

	cret := xVec4WAxis()
	return cret
}

var xVec4XAxis func() *Vec4

// Retrieves a pointer to a #graphene_vec4_t with its
// components set to (1, 0, 0, 0).
func Vec4XAxis() *Vec4 {

	cret := xVec4XAxis()
	return cret
}

var xVec4YAxis func() *Vec4

// Retrieves a pointer to a #graphene_vec4_t with its
// components set to (0, 1, 0, 0).
func Vec4YAxis() *Vec4 {

	cret := xVec4YAxis()
	return cret
}

var xVec4ZAxis func() *Vec4

// Retrieves a pointer to a #graphene_vec4_t with its
// components set to (0, 0, 1, 0).
func Vec4ZAxis() *Vec4 {

	cret := xVec4ZAxis()
	return cret
}

var xVec4Zero func() *Vec4

// Retrieves a pointer to a #graphene_vec4_t with all its
// components set to 0.
func Vec4Zero() *Vec4 {

	cret := xVec4Zero()
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GRAPHENE"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xVec4One, lib, "graphene_vec4_one")
	core.PuregoSafeRegister(&xVec4WAxis, lib, "graphene_vec4_w_axis")
	core.PuregoSafeRegister(&xVec4XAxis, lib, "graphene_vec4_x_axis")
	core.PuregoSafeRegister(&xVec4YAxis, lib, "graphene_vec4_y_axis")
	core.PuregoSafeRegister(&xVec4ZAxis, lib, "graphene_vec4_z_axis")
	core.PuregoSafeRegister(&xVec4Zero, lib, "graphene_vec4_zero")

	core.PuregoSafeRegister(&xVec4Alloc, lib, "graphene_vec4_alloc")

	core.PuregoSafeRegister(&xVec4Add, lib, "graphene_vec4_add")
	core.PuregoSafeRegister(&xVec4Divide, lib, "graphene_vec4_divide")
	core.PuregoSafeRegister(&xVec4Dot, lib, "graphene_vec4_dot")
	core.PuregoSafeRegister(&xVec4Equal, lib, "graphene_vec4_equal")
	core.PuregoSafeRegister(&xVec4Free, lib, "graphene_vec4_free")
	core.PuregoSafeRegister(&xVec4GetW, lib, "graphene_vec4_get_w")
	core.PuregoSafeRegister(&xVec4GetX, lib, "graphene_vec4_get_x")
	core.PuregoSafeRegister(&xVec4GetXy, lib, "graphene_vec4_get_xy")
	core.PuregoSafeRegister(&xVec4GetXyz, lib, "graphene_vec4_get_xyz")
	core.PuregoSafeRegister(&xVec4GetY, lib, "graphene_vec4_get_y")
	core.PuregoSafeRegister(&xVec4GetZ, lib, "graphene_vec4_get_z")
	core.PuregoSafeRegister(&xVec4Init, lib, "graphene_vec4_init")
	core.PuregoSafeRegister(&xVec4InitFromFloat, lib, "graphene_vec4_init_from_float")
	core.PuregoSafeRegister(&xVec4InitFromVec2, lib, "graphene_vec4_init_from_vec2")
	core.PuregoSafeRegister(&xVec4InitFromVec3, lib, "graphene_vec4_init_from_vec3")
	core.PuregoSafeRegister(&xVec4InitFromVec4, lib, "graphene_vec4_init_from_vec4")
	core.PuregoSafeRegister(&xVec4Interpolate, lib, "graphene_vec4_interpolate")
	core.PuregoSafeRegister(&xVec4Length, lib, "graphene_vec4_length")
	core.PuregoSafeRegister(&xVec4Max, lib, "graphene_vec4_max")
	core.PuregoSafeRegister(&xVec4Min, lib, "graphene_vec4_min")
	core.PuregoSafeRegister(&xVec4Multiply, lib, "graphene_vec4_multiply")
	core.PuregoSafeRegister(&xVec4Near, lib, "graphene_vec4_near")
	core.PuregoSafeRegister(&xVec4Negate, lib, "graphene_vec4_negate")
	core.PuregoSafeRegister(&xVec4Normalize, lib, "graphene_vec4_normalize")
	core.PuregoSafeRegister(&xVec4Scale, lib, "graphene_vec4_scale")
	core.PuregoSafeRegister(&xVec4Subtract, lib, "graphene_vec4_subtract")
	core.PuregoSafeRegister(&xVec4ToFloat, lib, "graphene_vec4_to_float")

}
