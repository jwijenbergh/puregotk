// Package graphene was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package graphene

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// A structure capable of holding a vector with two dimensions, x and y.
//
// The contents of the #graphene_vec2_t structure are private and should
// never be accessed directly.
type Vec2 struct {
	Value uintptr
}

func (x *Vec2) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xVec2Alloc func() *Vec2

// Allocates a new #graphene_vec2_t structure.
//
// The contents of the returned structure are undefined.
//
// Use graphene_vec2_init() to initialize the vector.
func Vec2Alloc() *Vec2 {

	cret := xVec2Alloc()
	return cret
}

var xVec2Add func(uintptr, *Vec2, *Vec2)

// Adds each component of the two passed vectors and places
// each result into the components of @res.
func (x *Vec2) Add(BVar *Vec2, ResVar *Vec2) {

	xVec2Add(x.GoPointer(), BVar, ResVar)

}

var xVec2Divide func(uintptr, *Vec2, *Vec2)

// Divides each component of the first operand @a by the corresponding
// component of the second operand @b, and places the results into the
// vector @res.
func (x *Vec2) Divide(BVar *Vec2, ResVar *Vec2) {

	xVec2Divide(x.GoPointer(), BVar, ResVar)

}

var xVec2Dot func(uintptr, *Vec2) float32

// Computes the dot product of the two given vectors.
func (x *Vec2) Dot(BVar *Vec2) float32 {

	cret := xVec2Dot(x.GoPointer(), BVar)
	return cret
}

var xVec2Equal func(uintptr, *Vec2) bool

// Checks whether the two given #graphene_vec2_t are equal.
func (x *Vec2) Equal(V2Var *Vec2) bool {

	cret := xVec2Equal(x.GoPointer(), V2Var)
	return cret
}

var xVec2Free func(uintptr)

// Frees the resources allocated by @v
func (x *Vec2) Free() {

	xVec2Free(x.GoPointer())

}

var xVec2GetX func(uintptr) float32

// Retrieves the X component of the #graphene_vec2_t.
func (x *Vec2) GetX() float32 {

	cret := xVec2GetX(x.GoPointer())
	return cret
}

var xVec2GetY func(uintptr) float32

// Retrieves the Y component of the #graphene_vec2_t.
func (x *Vec2) GetY() float32 {

	cret := xVec2GetY(x.GoPointer())
	return cret
}

var xVec2Init func(uintptr, float32, float32) *Vec2

// Initializes a #graphene_vec2_t using the given values.
//
// This function can be called multiple times.
func (x *Vec2) Init(XVar float32, YVar float32) *Vec2 {

	cret := xVec2Init(x.GoPointer(), XVar, YVar)
	return cret
}

var xVec2InitFromFloat func(uintptr, uintptr) *Vec2

// Initializes @v with the contents of the given array.
func (x *Vec2) InitFromFloat(SrcVar uintptr) *Vec2 {

	cret := xVec2InitFromFloat(x.GoPointer(), SrcVar)
	return cret
}

var xVec2InitFromVec2 func(uintptr, *Vec2) *Vec2

// Copies the contents of @src into @v.
func (x *Vec2) InitFromVec2(SrcVar *Vec2) *Vec2 {

	cret := xVec2InitFromVec2(x.GoPointer(), SrcVar)
	return cret
}

var xVec2Interpolate func(uintptr, *Vec2, float64, *Vec2)

// Linearly interpolates @v1 and @v2 using the given @factor.
func (x *Vec2) Interpolate(V2Var *Vec2, FactorVar float64, ResVar *Vec2) {

	xVec2Interpolate(x.GoPointer(), V2Var, FactorVar, ResVar)

}

var xVec2Length func(uintptr) float32

// Computes the length of the given vector.
func (x *Vec2) Length() float32 {

	cret := xVec2Length(x.GoPointer())
	return cret
}

var xVec2Max func(uintptr, *Vec2, *Vec2)

// Compares the two given vectors and places the maximum
// values of each component into @res.
func (x *Vec2) Max(BVar *Vec2, ResVar *Vec2) {

	xVec2Max(x.GoPointer(), BVar, ResVar)

}

var xVec2Min func(uintptr, *Vec2, *Vec2)

// Compares the two given vectors and places the minimum
// values of each component into @res.
func (x *Vec2) Min(BVar *Vec2, ResVar *Vec2) {

	xVec2Min(x.GoPointer(), BVar, ResVar)

}

var xVec2Multiply func(uintptr, *Vec2, *Vec2)

// Multiplies each component of the two passed vectors and places
// each result into the components of @res.
func (x *Vec2) Multiply(BVar *Vec2, ResVar *Vec2) {

	xVec2Multiply(x.GoPointer(), BVar, ResVar)

}

var xVec2Near func(uintptr, *Vec2, float32) bool

// Compares the two given #graphene_vec2_t vectors and checks
// whether their values are within the given @epsilon.
func (x *Vec2) Near(V2Var *Vec2, EpsilonVar float32) bool {

	cret := xVec2Near(x.GoPointer(), V2Var, EpsilonVar)
	return cret
}

var xVec2Negate func(uintptr, *Vec2)

// Negates the given #graphene_vec2_t.
func (x *Vec2) Negate(ResVar *Vec2) {

	xVec2Negate(x.GoPointer(), ResVar)

}

var xVec2Normalize func(uintptr, *Vec2)

// Computes the normalized vector for the given vector @v.
func (x *Vec2) Normalize(ResVar *Vec2) {

	xVec2Normalize(x.GoPointer(), ResVar)

}

var xVec2Scale func(uintptr, float32, *Vec2)

// Multiplies all components of the given vector with the given scalar @factor.
func (x *Vec2) Scale(FactorVar float32, ResVar *Vec2) {

	xVec2Scale(x.GoPointer(), FactorVar, ResVar)

}

var xVec2Subtract func(uintptr, *Vec2, *Vec2)

// Subtracts from each component of the first operand @a the
// corresponding component of the second operand @b and places
// each result into the components of @res.
func (x *Vec2) Subtract(BVar *Vec2, ResVar *Vec2) {

	xVec2Subtract(x.GoPointer(), BVar, ResVar)

}

var xVec2ToFloat func(uintptr, uintptr)

// Stores the components of @v into an array.
func (x *Vec2) ToFloat(DestVar uintptr) {

	xVec2ToFloat(x.GoPointer(), DestVar)

}

var xVec2One func() *Vec2

// Retrieves a constant vector with (1, 1) components.
func Vec2One() *Vec2 {

	cret := xVec2One()
	return cret
}

var xVec2XAxis func() *Vec2

// Retrieves a constant vector with (1, 0) components.
func Vec2XAxis() *Vec2 {

	cret := xVec2XAxis()
	return cret
}

var xVec2YAxis func() *Vec2

// Retrieves a constant vector with (0, 1) components.
func Vec2YAxis() *Vec2 {

	cret := xVec2YAxis()
	return cret
}

var xVec2Zero func() *Vec2

// Retrieves a constant vector with (0, 0) components.
func Vec2Zero() *Vec2 {

	cret := xVec2Zero()
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GRAPHENE"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xVec2One, lib, "graphene_vec2_one")
	core.PuregoSafeRegister(&xVec2XAxis, lib, "graphene_vec2_x_axis")
	core.PuregoSafeRegister(&xVec2YAxis, lib, "graphene_vec2_y_axis")
	core.PuregoSafeRegister(&xVec2Zero, lib, "graphene_vec2_zero")

	core.PuregoSafeRegister(&xVec2Alloc, lib, "graphene_vec2_alloc")

	core.PuregoSafeRegister(&xVec2Add, lib, "graphene_vec2_add")
	core.PuregoSafeRegister(&xVec2Divide, lib, "graphene_vec2_divide")
	core.PuregoSafeRegister(&xVec2Dot, lib, "graphene_vec2_dot")
	core.PuregoSafeRegister(&xVec2Equal, lib, "graphene_vec2_equal")
	core.PuregoSafeRegister(&xVec2Free, lib, "graphene_vec2_free")
	core.PuregoSafeRegister(&xVec2GetX, lib, "graphene_vec2_get_x")
	core.PuregoSafeRegister(&xVec2GetY, lib, "graphene_vec2_get_y")
	core.PuregoSafeRegister(&xVec2Init, lib, "graphene_vec2_init")
	core.PuregoSafeRegister(&xVec2InitFromFloat, lib, "graphene_vec2_init_from_float")
	core.PuregoSafeRegister(&xVec2InitFromVec2, lib, "graphene_vec2_init_from_vec2")
	core.PuregoSafeRegister(&xVec2Interpolate, lib, "graphene_vec2_interpolate")
	core.PuregoSafeRegister(&xVec2Length, lib, "graphene_vec2_length")
	core.PuregoSafeRegister(&xVec2Max, lib, "graphene_vec2_max")
	core.PuregoSafeRegister(&xVec2Min, lib, "graphene_vec2_min")
	core.PuregoSafeRegister(&xVec2Multiply, lib, "graphene_vec2_multiply")
	core.PuregoSafeRegister(&xVec2Near, lib, "graphene_vec2_near")
	core.PuregoSafeRegister(&xVec2Negate, lib, "graphene_vec2_negate")
	core.PuregoSafeRegister(&xVec2Normalize, lib, "graphene_vec2_normalize")
	core.PuregoSafeRegister(&xVec2Scale, lib, "graphene_vec2_scale")
	core.PuregoSafeRegister(&xVec2Subtract, lib, "graphene_vec2_subtract")
	core.PuregoSafeRegister(&xVec2ToFloat, lib, "graphene_vec2_to_float")

}
