// Package gdkpixbuf was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gdkpixbuf

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// A pixel buffer.
//
// `GdkPixbuf` contains information about an image's pixel data,
// its color space, bits per sample, width and height, and the
// rowstride (the number of bytes between the start of one row
// and the start of the next).
//
// ## Creating new `GdkPixbuf`
//
// The most basic way to create a pixbuf is to wrap an existing pixel
// buffer with a [class@GdkPixbuf.Pixbuf] instance. You can use the
// [`ctor@GdkPixbuf.Pixbuf.new_from_data`] function to do this.
//
// Every time you create a new `GdkPixbuf` instance for some data, you
// will need to specify the destroy notification function that will be
// called when the data buffer needs to be freed; this will happen when
// a `GdkPixbuf` is finalized by the reference counting functions. If
// you have a chunk of static data compiled into your application, you
// can pass in `NULL` as the destroy notification function so that the
// data will not be freed.
//
// The [`ctor@GdkPixbuf.Pixbuf.new`] constructor function can be used
// as a convenience to create a pixbuf with an empty buffer; this is
// equivalent to allocating a data buffer using `malloc()` and then
// wrapping it with `gdk_pixbuf_new_from_data()`. The `gdk_pixbuf_new()`
// function will compute an optimal rowstride so that rendering can be
// performed with an efficient algorithm.
//
// As a special case, you can use the [`ctor@GdkPixbuf.Pixbuf.new_from_xpm_data`]
// function to create a pixbuf from inline XPM image data.
//
// You can also copy an existing pixbuf with the [method@Pixbuf.copy]
// function. This is not the same as just acquiring a reference to
// the old pixbuf instance: the copy function will actually duplicate
// the pixel data in memory and create a new [class@Pixbuf] instance
// for it.
//
// ## Reference counting
//
// `GdkPixbuf` structures are reference counted. This means that an
// application can share a single pixbuf among many parts of the
// code. When a piece of the program needs to use a pixbuf, it should
// acquire a reference to it by calling `g_object_ref()`; when it no
// longer needs the pixbuf, it should release the reference it acquired
// by calling `g_object_unref()`. The resources associated with a
// `GdkPixbuf` will be freed when its reference count drops to zero.
// Newly-created `GdkPixbuf` instances start with a reference count
// of one.
//
// ## Image Data
//
// Image data in a pixbuf is stored in memory in an uncompressed,
// packed format. Rows in the image are stored top to bottom, and
// in each row pixels are stored from left to right.
//
// There may be padding at the end of a row.
//
// The "rowstride" value of a pixbuf, as returned by [`method@GdkPixbuf.Pixbuf.get_rowstride`],
// indicates the number of bytes between rows.
//
// **NOTE**: If you are copying raw pixbuf data with `memcpy()` note that the
// last row in the pixbuf may not be as wide as the full rowstride, but rather
// just as wide as the pixel data needs to be; that is: it is unsafe to do
// `memcpy (dest, pixels, rowstride * height)` to copy a whole pixbuf. Use
// [method@GdkPixbuf.Pixbuf.copy] instead, or compute the width in bytes of the
// last row as:
//
// ```c
// last_row = width * ((n_channels * bits_per_sample + 7) / 8);
// ```
//
// The same rule applies when iterating over each row of a `GdkPixbuf` pixels
// array.
//
// The following code illustrates a simple `put_pixel()`
// function for RGB pixbufs with 8 bits per channel with an alpha
// channel.
//
// ```c
// static void
// put_pixel (GdkPixbuf *pixbuf,
//
//	           int x,
//		   int y,
//		   guchar red,
//		   guchar green,
//		   guchar blue,
//		   guchar alpha)
//
//	{
//	  int n_channels = gdk_pixbuf_get_n_channels (pixbuf);
//
//	  // Ensure that the pixbuf is valid
//	  g_assert (gdk_pixbuf_get_colorspace (pixbuf) == GDK_COLORSPACE_RGB);
//	  g_assert (gdk_pixbuf_get_bits_per_sample (pixbuf) == 8);
//	  g_assert (gdk_pixbuf_get_has_alpha (pixbuf));
//	  g_assert (n_channels == 4);
//
//	  int width = gdk_pixbuf_get_width (pixbuf);
//	  int height = gdk_pixbuf_get_height (pixbuf);
//
//	  // Ensure that the coordinates are in a valid range
//	  g_assert (x &gt;= 0 &amp;&amp; x &lt; width);
//	  g_assert (y &gt;= 0 &amp;&amp; y &lt; height);
//
//	  int rowstride = gdk_pixbuf_get_rowstride (pixbuf);
//
//	  // The pixel buffer in the GdkPixbuf instance
//	  guchar *pixels = gdk_pixbuf_get_pixels (pixbuf);
//
//	  // The pixel we wish to modify
//	  guchar *p = pixels + y * rowstride + x * n_channels;
//	  p[0] = red;
//	  p[1] = green;
//	  p[2] = blue;
//	  p[3] = alpha;
//	}
//
// ```
//
// ## Loading images
//
// The `GdkPixBuf` class provides a simple mechanism for loading
// an image from a file in synchronous and asynchronous fashion.
//
// For GUI applications, it is recommended to use the asynchronous
// stream API to avoid blocking the control flow of the application.
//
// Additionally, `GdkPixbuf` provides the [class@GdkPixbuf.PixbufLoader`]
// API for progressive image loading.
//
// ## Saving images
//
// The `GdkPixbuf` class provides methods for saving image data in
// a number of file formats. The formatted data can be written to a
// file or to a memory buffer. `GdkPixbuf` can also call a user-defined
// callback on the data, which allows to e.g. write the image
// to a socket or store it in a database.
type Pixbuf struct {
	gobject.Object
}

func PixbufNewFromInternalPtr(ptr uintptr) *Pixbuf {
	cls := &Pixbuf{}
	cls.Ptr = ptr
	return cls
}

var xNewPixbuf func(Colorspace, bool, int, int, int) uintptr

// Creates a new `GdkPixbuf` structure and allocates a buffer for it.
//
// If the allocation of the buffer failed, this function will return `NULL`.
//
// The buffer has an optimal rowstride. Note that the buffer is not cleared;
// you will have to fill it completely yourself.
func NewPixbuf(ColorspaceVar Colorspace, HasAlphaVar bool, BitsPerSampleVar int, WidthVar int, HeightVar int) *Pixbuf {
	var cls *Pixbuf

	cret := xNewPixbuf(ColorspaceVar, HasAlphaVar, BitsPerSampleVar, WidthVar, HeightVar)

	if cret == 0 {
		return nil
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xNewPixbufFromBytes func(*glib.Bytes, Colorspace, bool, int, int, int, int) uintptr

// Creates a new #GdkPixbuf out of in-memory readonly image data.
//
// Currently only RGB images with 8 bits per sample are supported.
//
// This is the `GBytes` variant of gdk_pixbuf_new_from_data(), useful
// for language bindings.
func NewPixbufFromBytes(DataVar *glib.Bytes, ColorspaceVar Colorspace, HasAlphaVar bool, BitsPerSampleVar int, WidthVar int, HeightVar int, RowstrideVar int) *Pixbuf {
	var cls *Pixbuf

	cret := xNewPixbufFromBytes(DataVar, ColorspaceVar, HasAlphaVar, BitsPerSampleVar, WidthVar, HeightVar, RowstrideVar)

	if cret == 0 {
		return nil
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xNewPixbufFromData func(uintptr, Colorspace, bool, int, int, int, int, uintptr, uintptr) uintptr

// Creates a new #GdkPixbuf out of in-memory image data.
//
// Currently only RGB images with 8 bits per sample are supported.
//
// Since you are providing a pre-allocated pixel buffer, you must also
// specify a way to free that data.  This is done with a function of
// type `GdkPixbufDestroyNotify`.  When a pixbuf created with is
// finalized, your destroy notification function will be called, and
// it is its responsibility to free the pixel array.
//
// See also: [ctor@GdkPixbuf.Pixbuf.new_from_bytes]
func NewPixbufFromData(DataVar uintptr, ColorspaceVar Colorspace, HasAlphaVar bool, BitsPerSampleVar int, WidthVar int, HeightVar int, RowstrideVar int, DestroyFnVar *PixbufDestroyNotify, DestroyFnDataVar uintptr) *Pixbuf {
	var cls *Pixbuf

	cret := xNewPixbufFromData(DataVar, ColorspaceVar, HasAlphaVar, BitsPerSampleVar, WidthVar, HeightVar, RowstrideVar, glib.NewCallback(DestroyFnVar), DestroyFnDataVar)

	if cret == 0 {
		return nil
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xNewPixbufFromFile func(string, **glib.Error) uintptr

// Creates a new pixbuf by loading an image from a file.
//
// The file format is detected automatically.
//
// If `NULL` is returned, then @error will be set. Possible errors are:
//
//   - the file could not be opened
//   - there is no loader for the file's format
//   - there is not enough memory to allocate the image buffer
//   - the image buffer contains invalid data
//
// The error domains are `GDK_PIXBUF_ERROR` and `G_FILE_ERROR`.
func NewPixbufFromFile(FilenameVar string) (*Pixbuf, error) {
	var cls *Pixbuf
	var cerr *glib.Error

	cret := xNewPixbufFromFile(FilenameVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewPixbufFromFileAtScale func(string, int, int, bool, **glib.Error) uintptr

// Creates a new pixbuf by loading an image from a file.
//
// The file format is detected automatically.
//
// If `NULL` is returned, then @error will be set. Possible errors are:
//
//   - the file could not be opened
//   - there is no loader for the file's format
//   - there is not enough memory to allocate the image buffer
//   - the image buffer contains invalid data
//
// The error domains are `GDK_PIXBUF_ERROR` and `G_FILE_ERROR`.
//
// The image will be scaled to fit in the requested size, optionally preserving
// the image's aspect ratio.
//
// When preserving the aspect ratio, a `width` of -1 will cause the image
// to be scaled to the exact given height, and a `height` of -1 will cause
// the image to be scaled to the exact given width. When not preserving
// aspect ratio, a `width` or `height` of -1 means to not scale the image
// at all in that dimension. Negative values for `width` and `height` are
// allowed since 2.8.
func NewPixbufFromFileAtScale(FilenameVar string, WidthVar int, HeightVar int, PreserveAspectRatioVar bool) (*Pixbuf, error) {
	var cls *Pixbuf
	var cerr *glib.Error

	cret := xNewPixbufFromFileAtScale(FilenameVar, WidthVar, HeightVar, PreserveAspectRatioVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewPixbufFromFileAtSize func(string, int, int, **glib.Error) uintptr

// Creates a new pixbuf by loading an image from a file.
//
// The file format is detected automatically.
//
// If `NULL` is returned, then @error will be set. Possible errors are:
//
//   - the file could not be opened
//   - there is no loader for the file's format
//   - there is not enough memory to allocate the image buffer
//   - the image buffer contains invalid data
//
// The error domains are `GDK_PIXBUF_ERROR` and `G_FILE_ERROR`.
//
// The image will be scaled to fit in the requested size, preserving
// the image's aspect ratio. Note that the returned pixbuf may be smaller
// than `width` x `height`, if the aspect ratio requires it. To load
// and image at the requested size, regardless of aspect ratio, use
// [ctor@GdkPixbuf.Pixbuf.new_from_file_at_scale].
func NewPixbufFromFileAtSize(FilenameVar string, WidthVar int, HeightVar int) (*Pixbuf, error) {
	var cls *Pixbuf
	var cerr *glib.Error

	cret := xNewPixbufFromFileAtSize(FilenameVar, WidthVar, HeightVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewPixbufFromInline func(int, uintptr, bool, **glib.Error) uintptr

// Creates a `GdkPixbuf` from a flat representation that is suitable for
// storing as inline data in a program.
//
// This is useful if you want to ship a program with images, but don't want
// to depend on any external files.
//
// GdkPixbuf ships with a program called `gdk-pixbuf-csource`, which allows
// for conversion of `GdkPixbuf`s into such a inline representation.
//
// In almost all cases, you should pass the `--raw` option to
// `gdk-pixbuf-csource`. A sample invocation would be:
//
// ```
// gdk-pixbuf-csource --raw --name=myimage_inline myimage.png
// ```
//
// For the typical case where the inline pixbuf is read-only static data,
// you don't need to copy the pixel data unless you intend to write to
// it, so you can pass `FALSE` for `copy_pixels`. If you pass `--rle` to
// `gdk-pixbuf-csource`, a copy will be made even if `copy_pixels` is `FALSE`,
// so using this option is generally a bad idea.
//
// If you create a pixbuf from const inline data compiled into your
// program, it's probably safe to ignore errors and disable length checks,
// since things will always succeed:
//
// ```c
// pixbuf = gdk_pixbuf_new_from_inline (-1, myimage_inline, FALSE, NULL);
// ```
//
// For non-const inline data, you could get out of memory. For untrusted
// inline data located at runtime, you could have corrupt inline data in
// addition.
func NewPixbufFromInline(DataLengthVar int, DataVar uintptr, CopyPixelsVar bool) (*Pixbuf, error) {
	var cls *Pixbuf
	var cerr *glib.Error

	cret := xNewPixbufFromInline(DataLengthVar, DataVar, CopyPixelsVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewPixbufFromResource func(string, **glib.Error) uintptr

// Creates a new pixbuf by loading an image from an resource.
//
// The file format is detected automatically. If `NULL` is returned, then
// @error will be set.
func NewPixbufFromResource(ResourcePathVar string) (*Pixbuf, error) {
	var cls *Pixbuf
	var cerr *glib.Error

	cret := xNewPixbufFromResource(ResourcePathVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewPixbufFromResourceAtScale func(string, int, int, bool, **glib.Error) uintptr

// Creates a new pixbuf by loading an image from an resource.
//
// The file format is detected automatically. If `NULL` is returned, then
// @error will be set.
//
// The image will be scaled to fit in the requested size, optionally
// preserving the image's aspect ratio. When preserving the aspect ratio,
// a @width of -1 will cause the image to be scaled to the exact given
// height, and a @height of -1 will cause the image to be scaled to the
// exact given width. When not preserving aspect ratio, a @width or
// @height of -1 means to not scale the image at all in that dimension.
//
// The stream is not closed.
func NewPixbufFromResourceAtScale(ResourcePathVar string, WidthVar int, HeightVar int, PreserveAspectRatioVar bool) (*Pixbuf, error) {
	var cls *Pixbuf
	var cerr *glib.Error

	cret := xNewPixbufFromResourceAtScale(ResourcePathVar, WidthVar, HeightVar, PreserveAspectRatioVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewPixbufFromStream func(uintptr, uintptr, **glib.Error) uintptr

// Creates a new pixbuf by loading an image from an input stream.
//
// The file format is detected automatically.
//
// If `NULL` is returned, then `error` will be set.
//
// The `cancellable` can be used to abort the operation from another thread.
// If the operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
// returned. Other possible errors are in the `GDK_PIXBUF_ERROR` and
// `G_IO_ERROR` domains.
//
// The stream is not closed.
func NewPixbufFromStream(StreamVar *gio.InputStream, CancellableVar *gio.Cancellable) (*Pixbuf, error) {
	var cls *Pixbuf
	var cerr *glib.Error

	cret := xNewPixbufFromStream(StreamVar.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewPixbufFromStreamAtScale func(uintptr, int, int, bool, uintptr, **glib.Error) uintptr

// Creates a new pixbuf by loading an image from an input stream.
//
// The file format is detected automatically. If `NULL` is returned, then
// @error will be set. The @cancellable can be used to abort the operation
// from another thread. If the operation was cancelled, the error
// `G_IO_ERROR_CANCELLED` will be returned. Other possible errors are in
// the `GDK_PIXBUF_ERROR` and `G_IO_ERROR` domains.
//
// The image will be scaled to fit in the requested size, optionally
// preserving the image's aspect ratio.
//
// When preserving the aspect ratio, a `width` of -1 will cause the image to be
// scaled to the exact given height, and a `height` of -1 will cause the image
// to be scaled to the exact given width. If both `width` and `height` are
// given, this function will behave as if the smaller of the two values
// is passed as -1.
//
// When not preserving aspect ratio, a `width` or `height` of -1 means to not
// scale the image at all in that dimension.
//
// The stream is not closed.
func NewPixbufFromStreamAtScale(StreamVar *gio.InputStream, WidthVar int, HeightVar int, PreserveAspectRatioVar bool, CancellableVar *gio.Cancellable) (*Pixbuf, error) {
	var cls *Pixbuf
	var cerr *glib.Error

	cret := xNewPixbufFromStreamAtScale(StreamVar.GoPointer(), WidthVar, HeightVar, PreserveAspectRatioVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewPixbufFromStreamFinish func(uintptr, **glib.Error) uintptr

// Finishes an asynchronous pixbuf creation operation started with
// gdk_pixbuf_new_from_stream_async().
func NewPixbufFromStreamFinish(AsyncResultVar gio.AsyncResult) (*Pixbuf, error) {
	var cls *Pixbuf
	var cerr *glib.Error

	cret := xNewPixbufFromStreamFinish(AsyncResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xNewPixbufFromXpmData func([]string) uintptr

// Creates a new pixbuf by parsing XPM data in memory.
//
// This data is commonly the result of including an XPM file into a
// program's C source.
func NewPixbufFromXpmData(DataVar []string) *Pixbuf {
	var cls *Pixbuf

	cret := xNewPixbufFromXpmData(DataVar)

	if cret == 0 {
		return nil
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xPixbufAddAlpha func(uintptr, bool, byte, byte, byte) uintptr

// Takes an existing pixbuf and adds an alpha channel to it.
//
// If the existing pixbuf already had an alpha channel, the channel
// values are copied from the original; otherwise, the alpha channel
// is initialized to 255 (full opacity).
//
// If `substitute_color` is `TRUE`, then the color specified by the
// (`r`, `g`, `b`) arguments will be assigned zero opacity. That is,
// if you pass `(255, 255, 255)` for the substitute color, all white
// pixels will become fully transparent.
//
// If `substitute_color` is `FALSE`, then the (`r`, `g`, `b`) arguments
// will be ignored.
func (x *Pixbuf) AddAlpha(SubstituteColorVar bool, RVar byte, GVar byte, BVar byte) *Pixbuf {
	var cls *Pixbuf

	cret := xPixbufAddAlpha(x.GoPointer(), SubstituteColorVar, RVar, GVar, BVar)

	if cret == 0 {
		return nil
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xPixbufApplyEmbeddedOrientation func(uintptr) uintptr

// Takes an existing pixbuf and checks for the presence of an
// associated "orientation" option.
//
// The orientation option may be provided by the JPEG loader (which
// reads the exif orientation tag) or the TIFF loader (which reads
// the TIFF orientation tag, and compensates it for the partial
// transforms performed by libtiff).
//
// If an orientation option/tag is present, the appropriate transform
// will be performed so that the pixbuf is oriented correctly.
func (x *Pixbuf) ApplyEmbeddedOrientation() *Pixbuf {
	var cls *Pixbuf

	cret := xPixbufApplyEmbeddedOrientation(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xPixbufComposite func(uintptr, uintptr, int, int, int, int, float64, float64, float64, float64, InterpType, int)

// Creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y.
//
// This gives an image in the coordinates of the destination pixbuf.
// The rectangle (@dest_x, @dest_y, @dest_width, @dest_height)
// is then alpha blended onto the corresponding rectangle of the
// original destination image.
//
// When the destination rectangle contains parts not in the source
// image, the data at the edges of the source image is replicated
// to infinity.
//
// ![](composite.png)
func (x *Pixbuf) Composite(DestVar *Pixbuf, DestXVar int, DestYVar int, DestWidthVar int, DestHeightVar int, OffsetXVar float64, OffsetYVar float64, ScaleXVar float64, ScaleYVar float64, InterpTypeVar InterpType, OverallAlphaVar int) {

	xPixbufComposite(x.GoPointer(), DestVar.GoPointer(), DestXVar, DestYVar, DestWidthVar, DestHeightVar, OffsetXVar, OffsetYVar, ScaleXVar, ScaleYVar, InterpTypeVar, OverallAlphaVar)

}

var xPixbufCompositeColor func(uintptr, uintptr, int, int, int, int, float64, float64, float64, float64, InterpType, int, int, int, int, uint32, uint32)

// Creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y,
// then alpha blends the rectangle (@dest_x ,@dest_y, @dest_width,
// @dest_height) of the resulting image with a checkboard of the
// colors @color1 and @color2 and renders it onto the destination
// image.
//
// If the source image has no alpha channel, and @overall_alpha is 255, a fast
// path is used which omits the alpha blending and just performs the scaling.
//
// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
// function suitable for many tasks.
func (x *Pixbuf) CompositeColor(DestVar *Pixbuf, DestXVar int, DestYVar int, DestWidthVar int, DestHeightVar int, OffsetXVar float64, OffsetYVar float64, ScaleXVar float64, ScaleYVar float64, InterpTypeVar InterpType, OverallAlphaVar int, CheckXVar int, CheckYVar int, CheckSizeVar int, Color1Var uint32, Color2Var uint32) {

	xPixbufCompositeColor(x.GoPointer(), DestVar.GoPointer(), DestXVar, DestYVar, DestWidthVar, DestHeightVar, OffsetXVar, OffsetYVar, ScaleXVar, ScaleYVar, InterpTypeVar, OverallAlphaVar, CheckXVar, CheckYVar, CheckSizeVar, Color1Var, Color2Var)

}

var xPixbufCompositeColorSimple func(uintptr, int, int, InterpType, int, int, uint32, uint32) uintptr

// Creates a new pixbuf by scaling `src` to `dest_width` x `dest_height`
// and alpha blending the result with a checkboard of colors `color1`
// and `color2`.
func (x *Pixbuf) CompositeColorSimple(DestWidthVar int, DestHeightVar int, InterpTypeVar InterpType, OverallAlphaVar int, CheckSizeVar int, Color1Var uint32, Color2Var uint32) *Pixbuf {
	var cls *Pixbuf

	cret := xPixbufCompositeColorSimple(x.GoPointer(), DestWidthVar, DestHeightVar, InterpTypeVar, OverallAlphaVar, CheckSizeVar, Color1Var, Color2Var)

	if cret == 0 {
		return nil
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xPixbufCopy func(uintptr) uintptr

// Creates a new `GdkPixbuf` with a copy of the information in the specified
// `pixbuf`.
//
// Note that this does not copy the options set on the original `GdkPixbuf`,
// use gdk_pixbuf_copy_options() for this.
func (x *Pixbuf) Copy() *Pixbuf {
	var cls *Pixbuf

	cret := xPixbufCopy(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xPixbufCopyArea func(uintptr, int, int, int, int, uintptr, int, int)

// Copies a rectangular area from `src_pixbuf` to `dest_pixbuf`.
//
// Conversion of pixbuf formats is done automatically.
//
// If the source rectangle overlaps the destination rectangle on the
// same pixbuf, it will be overwritten during the copy operation.
// Therefore, you can not use this function to scroll a pixbuf.
func (x *Pixbuf) CopyArea(SrcXVar int, SrcYVar int, WidthVar int, HeightVar int, DestPixbufVar *Pixbuf, DestXVar int, DestYVar int) {

	xPixbufCopyArea(x.GoPointer(), SrcXVar, SrcYVar, WidthVar, HeightVar, DestPixbufVar.GoPointer(), DestXVar, DestYVar)

}

var xPixbufCopyOptions func(uintptr, uintptr) bool

// Copies the key/value pair options attached to a `GdkPixbuf` to another
// `GdkPixbuf`.
//
// This is useful to keep original metadata after having manipulated
// a file. However be careful to remove metadata which you've already
// applied, such as the "orientation" option after rotating the image.
func (x *Pixbuf) CopyOptions(DestPixbufVar *Pixbuf) bool {

	cret := xPixbufCopyOptions(x.GoPointer(), DestPixbufVar.GoPointer())
	return cret
}

var xPixbufFill func(uintptr, uint32)

// Clears a pixbuf to the given RGBA value, converting the RGBA value into
// the pixbuf's pixel format.
//
// The alpha component will be ignored if the pixbuf doesn't have an alpha
// channel.
func (x *Pixbuf) Fill(PixelVar uint32) {

	xPixbufFill(x.GoPointer(), PixelVar)

}

var xPixbufFlip func(uintptr, bool) uintptr

// Flips a pixbuf horizontally or vertically and returns the
// result in a new pixbuf.
func (x *Pixbuf) Flip(HorizontalVar bool) *Pixbuf {
	var cls *Pixbuf

	cret := xPixbufFlip(x.GoPointer(), HorizontalVar)

	if cret == 0 {
		return nil
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xPixbufGetBitsPerSample func(uintptr) int

// Queries the number of bits per color sample in a pixbuf.
func (x *Pixbuf) GetBitsPerSample() int {

	cret := xPixbufGetBitsPerSample(x.GoPointer())
	return cret
}

var xPixbufGetByteLength func(uintptr) uint

// Returns the length of the pixel data, in bytes.
func (x *Pixbuf) GetByteLength() uint {

	cret := xPixbufGetByteLength(x.GoPointer())
	return cret
}

var xPixbufGetColorspace func(uintptr) Colorspace

// Queries the color space of a pixbuf.
func (x *Pixbuf) GetColorspace() Colorspace {

	cret := xPixbufGetColorspace(x.GoPointer())
	return cret
}

var xPixbufGetHasAlpha func(uintptr) bool

// Queries whether a pixbuf has an alpha channel (opacity information).
func (x *Pixbuf) GetHasAlpha() bool {

	cret := xPixbufGetHasAlpha(x.GoPointer())
	return cret
}

var xPixbufGetHeight func(uintptr) int

// Queries the height of a pixbuf.
func (x *Pixbuf) GetHeight() int {

	cret := xPixbufGetHeight(x.GoPointer())
	return cret
}

var xPixbufGetNChannels func(uintptr) int

// Queries the number of channels of a pixbuf.
func (x *Pixbuf) GetNChannels() int {

	cret := xPixbufGetNChannels(x.GoPointer())
	return cret
}

var xPixbufGetOption func(uintptr, string) string

// Looks up @key in the list of options that may have been attached to the
// @pixbuf when it was loaded, or that may have been attached by another
// function using gdk_pixbuf_set_option().
//
// For instance, the ANI loader provides "Title" and "Artist" options.
// The ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot
// options for cursor definitions. The PNG loader provides the tEXt ancillary
// chunk key/value pairs as options. Since 2.12, the TIFF and JPEG loaders
// return an "orientation" option string that corresponds to the embedded
// TIFF/Exif orientation tag (if present). Since 2.32, the TIFF loader sets
// the "multipage" option string to "yes" when a multi-page TIFF is loaded.
// Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
// contains image density information in dots per inch.
// Since 2.36.6, the JPEG loader sets the "comment" option with the comment
// EXIF tag.
func (x *Pixbuf) GetOption(KeyVar string) string {

	cret := xPixbufGetOption(x.GoPointer(), KeyVar)
	return cret
}

var xPixbufGetOptions func(uintptr) *glib.HashTable

// Returns a `GHashTable` with a list of all the options that may have been
// attached to the `pixbuf` when it was loaded, or that may have been
// attached by another function using [method@GdkPixbuf.Pixbuf.set_option].
func (x *Pixbuf) GetOptions() *glib.HashTable {

	cret := xPixbufGetOptions(x.GoPointer())
	return cret
}

var xPixbufGetPixels func(uintptr) uintptr

// Queries a pointer to the pixel data of a pixbuf.
//
// This function will cause an implicit copy of the pixbuf data if the
// pixbuf was created from read-only data.
//
// Please see the section on [image data](class.Pixbuf.html#image-data) for information
// about how the pixel data is stored in memory.
func (x *Pixbuf) GetPixels() uintptr {

	cret := xPixbufGetPixels(x.GoPointer())
	return cret
}

var xPixbufGetPixelsWithLength func(uintptr, uint) uintptr

// Queries a pointer to the pixel data of a pixbuf.
//
// This function will cause an implicit copy of the pixbuf data if the
// pixbuf was created from read-only data.
//
// Please see the section on [image data](class.Pixbuf.html#image-data) for information
// about how the pixel data is stored in memory.
func (x *Pixbuf) GetPixelsWithLength(LengthVar uint) uintptr {

	cret := xPixbufGetPixelsWithLength(x.GoPointer(), LengthVar)
	return cret
}

var xPixbufGetRowstride func(uintptr) int

// Queries the rowstride of a pixbuf, which is the number of bytes between
// the start of a row and the start of the next row.
func (x *Pixbuf) GetRowstride() int {

	cret := xPixbufGetRowstride(x.GoPointer())
	return cret
}

var xPixbufGetWidth func(uintptr) int

// Queries the width of a pixbuf.
func (x *Pixbuf) GetWidth() int {

	cret := xPixbufGetWidth(x.GoPointer())
	return cret
}

var xPixbufNewSubpixbuf func(uintptr, int, int, int, int) uintptr

// Creates a new pixbuf which represents a sub-region of `src_pixbuf`.
//
// The new pixbuf shares its pixels with the original pixbuf, so
// writing to one affects both.  The new pixbuf holds a reference to
// `src_pixbuf`, so `src_pixbuf` will not be finalized until the new
// pixbuf is finalized.
//
// Note that if `src_pixbuf` is read-only, this function will force it
// to be mutable.
func (x *Pixbuf) NewSubpixbuf(SrcXVar int, SrcYVar int, WidthVar int, HeightVar int) *Pixbuf {
	var cls *Pixbuf

	cret := xPixbufNewSubpixbuf(x.GoPointer(), SrcXVar, SrcYVar, WidthVar, HeightVar)

	if cret == 0 {
		return nil
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xPixbufReadPixelBytes func(uintptr) *glib.Bytes

// Provides a #GBytes buffer containing the raw pixel data; the data
// must not be modified.
//
// This function allows skipping the implicit copy that must be made
// if gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
func (x *Pixbuf) ReadPixelBytes() *glib.Bytes {

	cret := xPixbufReadPixelBytes(x.GoPointer())
	return cret
}

var xPixbufReadPixels func(uintptr) byte

// Provides a read-only pointer to the raw pixel data.
//
// This function allows skipping the implicit copy that must be made
// if gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
func (x *Pixbuf) ReadPixels() byte {

	cret := xPixbufReadPixels(x.GoPointer())
	return cret
}

var xPixbufRef func(uintptr) uintptr

// Adds a reference to a pixbuf.
func (x *Pixbuf) Ref() *Pixbuf {
	var cls *Pixbuf

	cret := xPixbufRef(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xPixbufRemoveOption func(uintptr, string) bool

// Removes the key/value pair option attached to a `GdkPixbuf`.
func (x *Pixbuf) RemoveOption(KeyVar string) bool {

	cret := xPixbufRemoveOption(x.GoPointer(), KeyVar)
	return cret
}

var xPixbufRotateSimple func(uintptr, PixbufRotation) uintptr

// Rotates a pixbuf by a multiple of 90 degrees, and returns the
// result in a new pixbuf.
//
// If `angle` is 0, this function will return a copy of `src`.
func (x *Pixbuf) RotateSimple(AngleVar PixbufRotation) *Pixbuf {
	var cls *Pixbuf

	cret := xPixbufRotateSimple(x.GoPointer(), AngleVar)

	if cret == 0 {
		return nil
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xPixbufSaturateAndPixelate func(uintptr, uintptr, float32, bool)

// Modifies saturation and optionally pixelates `src`, placing the result in
// `dest`.
//
// The `src` and `dest` pixbufs must have the same image format, size, and
// rowstride.
//
// The `src` and `dest` arguments may be the same pixbuf with no ill effects.
//
// If `saturation` is 1.0 then saturation is not changed. If it's less than 1.0,
// saturation is reduced (the image turns toward grayscale); if greater than
// 1.0, saturation is increased (the image gets more vivid colors).
//
// If `pixelate` is `TRUE`, then pixels are faded in a checkerboard pattern to
// create a pixelated image.
func (x *Pixbuf) SaturateAndPixelate(DestVar *Pixbuf, SaturationVar float32, PixelateVar bool) {

	xPixbufSaturateAndPixelate(x.GoPointer(), DestVar.GoPointer(), SaturationVar, PixelateVar)

}

var xPixbufSave func(uintptr, string, string, **glib.Error, ...interface{}) bool

// Saves pixbuf to a file in format @type. By default, "jpeg", "png", "ico"
// and "bmp" are possible file formats to save in, but more formats may be
// installed. The list of all writable formats can be determined in the
// following way:
//
// ```c
// void add_if_writable (GdkPixbufFormat *data, GSList **list)
//
//	{
//	  if (gdk_pixbuf_format_is_writable (data))
//	    *list = g_slist_prepend (*list, data);
//	}
//
// GSList *formats = gdk_pixbuf_get_formats ();
// GSList *writable_formats = NULL;
// g_slist_foreach (formats, add_if_writable, &amp;writable_formats);
// g_slist_free (formats);
// ```
//
// If `error` is set, `FALSE` will be returned. Possible errors include
// those in the `GDK_PIXBUF_ERROR` domain and those in the `G_FILE_ERROR`
// domain.
//
// The variable argument list should be `NULL`-terminated; if not empty,
// it should contain pairs of strings that modify the save
// parameters. For example:
//
// ```c
// gdk_pixbuf_save (pixbuf, handle, "jpeg", &amp;error, "quality", "100", NULL);
// ```
//
// Currently only few parameters exist.
//
// JPEG images can be saved with a "quality" parameter; its value should be
// in the range `[0, 100]`. JPEG and PNG density can be set by setting the
// "x-dpi" and "y-dpi" parameters to the appropriate values in dots per inch.
//
// Text chunks can be attached to PNG images by specifying parameters of
// the form "tEXt::key", where key is an ASCII string of length 1-79.
// The values are UTF-8 encoded strings. The PNG compression level can
// be specified using the "compression" parameter; it's value is in an
// integer in the range of `[0, 9]`.
//
// ICC color profiles can also be embedded into PNG, JPEG and TIFF images.
// The "icc-profile" value should be the complete ICC profile encoded
// into base64.
//
// ```c
// char *contents;
// gsize length;
//
// // icm_path is set elsewhere
// g_file_get_contents (icm_path, &amp;contents, &amp;length, NULL);
//
// char *contents_encode = g_base64_encode ((const guchar *) contents, length);
//
// gdk_pixbuf_save (pixbuf, handle, "png", &amp;error, "icc-profile", contents_encode, NULL);
// ```
//
// TIFF images recognize:
//
//  1. a "bits-per-sample" option (integer) which can be either 1 for saving
//     bi-level CCITTFAX4 images, or 8 for saving 8-bits per sample
//  2. a "compression" option (integer) which can be 1 for no compression,
//     2 for Huffman, 5 for LZW, 7 for JPEG and 8 for DEFLATE (see the libtiff
//     documentation and tiff.h for all supported codec values)
//  3. an "icc-profile" option (zero-terminated string) containing a base64
//     encoded ICC color profile.
//
// ICO images can be saved in depth 16, 24, or 32, by using the "depth"
// parameter. When the ICO saver is given "x_hot" and "y_hot" parameters,
// it produces a CUR instead of an ICO.
func (x *Pixbuf) Save(FilenameVar string, TypeVar string, ErrorVar **glib.Error, varArgs ...interface{}) bool {

	cret := xPixbufSave(x.GoPointer(), FilenameVar, TypeVar, ErrorVar, varArgs...)
	return cret
}

var xPixbufSaveToBuffer func(uintptr, uintptr, uint, string, **glib.Error, ...interface{}) bool

// Saves pixbuf to a new buffer in format `type`, which is currently "jpeg",
// "png", "tiff", "ico" or "bmp".
//
// This is a convenience function that uses `gdk_pixbuf_save_to_callback()`
// to do the real work.
//
// Note that the buffer is not `NUL`-terminated and may contain embedded `NUL`
// characters.
//
// If @error is set, `FALSE` will be returned and @buffer will be set to
// `NULL`. Possible errors include those in the `GDK_PIXBUF_ERROR`
// domain.
//
// See `gdk_pixbuf_save()` for more details.
func (x *Pixbuf) SaveToBuffer(BufferVar uintptr, BufferSizeVar uint, TypeVar string, ErrorVar **glib.Error, varArgs ...interface{}) bool {

	cret := xPixbufSaveToBuffer(x.GoPointer(), BufferVar, BufferSizeVar, TypeVar, ErrorVar, varArgs...)
	return cret
}

var xPixbufSaveToBufferv func(uintptr, uintptr, uint, string, []string, []string, **glib.Error) bool

// Vector version of `gdk_pixbuf_save_to_buffer()`.
//
// Saves pixbuf to a new buffer in format @type, which is currently "jpeg",
// "tiff", "png", "ico" or "bmp".
//
// See [method@GdkPixbuf.Pixbuf.save_to_buffer] for more details.
func (x *Pixbuf) SaveToBufferv(BufferVar uintptr, BufferSizeVar uint, TypeVar string, OptionKeysVar []string, OptionValuesVar []string) (bool, error) {
	var cerr *glib.Error

	cret := xPixbufSaveToBufferv(x.GoPointer(), BufferVar, BufferSizeVar, TypeVar, OptionKeysVar, OptionValuesVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPixbufSaveToCallback func(uintptr, uintptr, uintptr, string, **glib.Error, ...interface{}) bool

// Saves pixbuf in format `type` by feeding the produced data to a
// callback.
//
// This function can be used when you want to store the image to something
// other than a file, such as an in-memory buffer or a socket.
//
// If @error is set, `FALSE` will be returned. Possible errors
// include those in the `GDK_PIXBUF_ERROR` domain and whatever the save
// function generates.
//
// See [method@GdkPixbuf.Pixbuf.save] for more details.
func (x *Pixbuf) SaveToCallback(SaveFuncVar *PixbufSaveFunc, UserDataVar uintptr, TypeVar string, ErrorVar **glib.Error, varArgs ...interface{}) bool {

	cret := xPixbufSaveToCallback(x.GoPointer(), glib.NewCallback(SaveFuncVar), UserDataVar, TypeVar, ErrorVar, varArgs...)
	return cret
}

var xPixbufSaveToCallbackv func(uintptr, uintptr, uintptr, string, []string, []string, **glib.Error) bool

// Vector version of `gdk_pixbuf_save_to_callback()`.
//
// Saves pixbuf to a callback in format @type, which is currently "jpeg",
// "png", "tiff", "ico" or "bmp".
//
// If @error is set, `FALSE` will be returned.
//
// See [method@GdkPixbuf.Pixbuf.save_to_callback] for more details.
func (x *Pixbuf) SaveToCallbackv(SaveFuncVar *PixbufSaveFunc, UserDataVar uintptr, TypeVar string, OptionKeysVar []string, OptionValuesVar []string) (bool, error) {
	var cerr *glib.Error

	cret := xPixbufSaveToCallbackv(x.GoPointer(), glib.NewCallback(SaveFuncVar), UserDataVar, TypeVar, OptionKeysVar, OptionValuesVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPixbufSaveToStream func(uintptr, uintptr, string, uintptr, **glib.Error, ...interface{}) bool

// Saves `pixbuf` to an output stream.
//
// Supported file formats are currently "jpeg", "tiff", "png", "ico" or
// "bmp". See `gdk_pixbuf_save_to_buffer()` for more details.
//
// The `cancellable` can be used to abort the operation from another
// thread. If the operation was cancelled, the error `G_IO_ERROR_CANCELLED`
// will be returned. Other possible errors are in the `GDK_PIXBUF_ERROR`
// and `G_IO_ERROR` domains.
//
// The stream is not closed at the end of this call.
func (x *Pixbuf) SaveToStream(StreamVar *gio.OutputStream, TypeVar string, CancellableVar *gio.Cancellable, ErrorVar **glib.Error, varArgs ...interface{}) bool {

	cret := xPixbufSaveToStream(x.GoPointer(), StreamVar.GoPointer(), TypeVar, CancellableVar.GoPointer(), ErrorVar, varArgs...)
	return cret
}

var xPixbufSaveToStreamAsync func(uintptr, uintptr, string, uintptr, uintptr, uintptr, ...interface{})

// Saves `pixbuf` to an output stream asynchronously.
//
// For more details see gdk_pixbuf_save_to_stream(), which is the synchronous
// version of this function.
//
// When the operation is finished, `callback` will be called in the main thread.
//
// You can then call gdk_pixbuf_save_to_stream_finish() to get the result of
// the operation.
func (x *Pixbuf) SaveToStreamAsync(StreamVar *gio.OutputStream, TypeVar string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr, varArgs ...interface{}) {

	xPixbufSaveToStreamAsync(x.GoPointer(), StreamVar.GoPointer(), TypeVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar, varArgs...)

}

var xPixbufSaveToStreamv func(uintptr, uintptr, string, []string, []string, uintptr, **glib.Error) bool

// Saves `pixbuf` to an output stream.
//
// Supported file formats are currently "jpeg", "tiff", "png", "ico" or
// "bmp".
//
// See [method@GdkPixbuf.Pixbuf.save_to_stream] for more details.
func (x *Pixbuf) SaveToStreamv(StreamVar *gio.OutputStream, TypeVar string, OptionKeysVar []string, OptionValuesVar []string, CancellableVar *gio.Cancellable) (bool, error) {
	var cerr *glib.Error

	cret := xPixbufSaveToStreamv(x.GoPointer(), StreamVar.GoPointer(), TypeVar, OptionKeysVar, OptionValuesVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPixbufSaveToStreamvAsync func(uintptr, uintptr, string, uintptr, uintptr, uintptr, uintptr, uintptr)

// Saves `pixbuf` to an output stream asynchronously.
//
// For more details see gdk_pixbuf_save_to_streamv(), which is the synchronous
// version of this function.
//
// When the operation is finished, `callback` will be called in the main thread.
//
// You can then call gdk_pixbuf_save_to_stream_finish() to get the result of
// the operation.
func (x *Pixbuf) SaveToStreamvAsync(StreamVar *gio.OutputStream, TypeVar string, OptionKeysVar uintptr, OptionValuesVar uintptr, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xPixbufSaveToStreamvAsync(x.GoPointer(), StreamVar.GoPointer(), TypeVar, OptionKeysVar, OptionValuesVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xPixbufSavev func(uintptr, string, string, []string, []string, **glib.Error) bool

// Vector version of `gdk_pixbuf_save()`.
//
// Saves pixbuf to a file in `type`, which is currently "jpeg", "png", "tiff", "ico" or "bmp".
//
// If @error is set, `FALSE` will be returned.
//
// See [method@GdkPixbuf.Pixbuf.save] for more details.
func (x *Pixbuf) Savev(FilenameVar string, TypeVar string, OptionKeysVar []string, OptionValuesVar []string) (bool, error) {
	var cerr *glib.Error

	cret := xPixbufSavev(x.GoPointer(), FilenameVar, TypeVar, OptionKeysVar, OptionValuesVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPixbufScale func(uintptr, uintptr, int, int, int, int, float64, float64, float64, float64, InterpType)

// Creates a transformation of the source image @src by scaling by
// @scale_x and @scale_y then translating by @offset_x and @offset_y,
// then renders the rectangle (@dest_x, @dest_y, @dest_width,
// @dest_height) of the resulting image onto the destination image
// replacing the previous contents.
//
// Try to use gdk_pixbuf_scale_simple() first; this function is
// the industrial-strength power tool you can fall back to, if
// gdk_pixbuf_scale_simple() isn't powerful enough.
//
// If the source rectangle overlaps the destination rectangle on the
// same pixbuf, it will be overwritten during the scaling which
// results in rendering artifacts.
func (x *Pixbuf) Scale(DestVar *Pixbuf, DestXVar int, DestYVar int, DestWidthVar int, DestHeightVar int, OffsetXVar float64, OffsetYVar float64, ScaleXVar float64, ScaleYVar float64, InterpTypeVar InterpType) {

	xPixbufScale(x.GoPointer(), DestVar.GoPointer(), DestXVar, DestYVar, DestWidthVar, DestHeightVar, OffsetXVar, OffsetYVar, ScaleXVar, ScaleYVar, InterpTypeVar)

}

var xPixbufScaleSimple func(uintptr, int, int, InterpType) uintptr

// Create a new pixbuf containing a copy of `src` scaled to
// `dest_width` x `dest_height`.
//
// This function leaves `src` unaffected.
//
// The `interp_type` should be `GDK_INTERP_NEAREST` if you want maximum
// speed (but when scaling down `GDK_INTERP_NEAREST` is usually unusably
// ugly). The default `interp_type` should be `GDK_INTERP_BILINEAR` which
// offers reasonable quality and speed.
//
// You can scale a sub-portion of `src` by creating a sub-pixbuf
// pointing into `src`; see [method@GdkPixbuf.Pixbuf.new_subpixbuf].
//
// If `dest_width` and `dest_height` are equal to the width and height of
// `src`, this function will return an unscaled copy of `src`.
//
// For more complicated scaling/alpha blending see [method@GdkPixbuf.Pixbuf.scale]
// and [method@GdkPixbuf.Pixbuf.composite].
func (x *Pixbuf) ScaleSimple(DestWidthVar int, DestHeightVar int, InterpTypeVar InterpType) *Pixbuf {
	var cls *Pixbuf

	cret := xPixbufScaleSimple(x.GoPointer(), DestWidthVar, DestHeightVar, InterpTypeVar)

	if cret == 0 {
		return nil
	}
	cls = &Pixbuf{}
	cls.Ptr = cret
	return cls
}

var xPixbufSetOption func(uintptr, string, string) bool

// Attaches a key/value pair as an option to a `GdkPixbuf`.
//
// If `key` already exists in the list of options attached to the `pixbuf`,
// the new value is ignored and `FALSE` is returned.
func (x *Pixbuf) SetOption(KeyVar string, ValueVar string) bool {

	cret := xPixbufSetOption(x.GoPointer(), KeyVar, ValueVar)
	return cret
}

var xPixbufUnref func(uintptr)

// Removes a reference from a pixbuf.
func (x *Pixbuf) Unref() {

	xPixbufUnref(x.GoPointer())

}

func (c *Pixbuf) GoPointer() uintptr {
	return c.Ptr
}

func (c *Pixbuf) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Checks if two icons are equal.
func (x *Pixbuf) Equal(Icon2Var gio.Icon) bool {

	cret := gio.XGIconEqual(x.GoPointer(), Icon2Var.GoPointer())
	return cret
}

// Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
// back by calling g_icon_deserialize() on the returned value.
// As serialization will avoid using raw icon data when possible, it only
// makes sense to transfer the #GVariant between processes on the same machine,
// (as opposed to over the network), and within the same file system namespace.
func (x *Pixbuf) Serialize() *glib.Variant {

	cret := gio.XGIconSerialize(x.GoPointer())
	return cret
}

// Generates a textual representation of @icon that can be used for
// serialization such as when passing @icon to a different process or
// saving it to persistent storage. Use g_icon_new_for_string() to
// get @icon back from the returned string.
//
// The encoding of the returned string is proprietary to #GIcon except
// in the following two cases
//
//   - If @icon is a #GFileIcon, the returned string is a native path
//     (such as `/path/to/my icon.png`) without escaping
//     if the #GFile for @icon is a native file.  If the file is not
//     native, the returned string is the result of g_file_get_uri()
//     (such as `sftp://path/to/my%20icon.png`).
//
//   - If @icon is a #GThemedIcon with exactly one name and no fallbacks,
//     the encoding is simply the name (such as `network-server`).
func (x *Pixbuf) ToString() string {

	cret := gio.XGIconToString(x.GoPointer())
	return cret
}

// Loads a loadable icon. For the asynchronous version of this function,
// see g_loadable_icon_load_async().
func (x *Pixbuf) Load(SizeVar int, TypeVar string, CancellableVar *gio.Cancellable) (*gio.InputStream, error) {
	var cls *gio.InputStream
	var cerr *glib.Error

	cret := gio.XGLoadableIconLoad(x.GoPointer(), SizeVar, TypeVar, CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.InputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

// Loads an icon asynchronously. To finish this function, see
// g_loadable_icon_load_finish(). For the synchronous, blocking
// version of this function, see g_loadable_icon_load().
func (x *Pixbuf) LoadAsync(SizeVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	gio.XGLoadableIconLoadAsync(x.GoPointer(), SizeVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

// Finishes an asynchronous icon load started in g_loadable_icon_load_async().
func (x *Pixbuf) LoadFinish(ResVar gio.AsyncResult, TypeVar string) (*gio.InputStream, error) {
	var cls *gio.InputStream
	var cerr *glib.Error

	cret := gio.XGLoadableIconLoadFinish(x.GoPointer(), ResVar.GoPointer(), TypeVar, &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.InputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xPixbufCalculateRowstride func(Colorspace, bool, int, int, int) int

// Calculates the rowstride that an image created with those values would
// have.
//
// This function is useful for front-ends and backends that want to check
// image values without needing to create a `GdkPixbuf`.
func PixbufCalculateRowstride(ColorspaceVar Colorspace, HasAlphaVar bool, BitsPerSampleVar int, WidthVar int, HeightVar int) int {

	cret := xPixbufCalculateRowstride(ColorspaceVar, HasAlphaVar, BitsPerSampleVar, WidthVar, HeightVar)
	return cret
}

var xPixbufGetFileInfo func(string, int, int) *PixbufFormat

// Parses an image file far enough to determine its format and size.
func PixbufGetFileInfo(FilenameVar string, WidthVar int, HeightVar int) *PixbufFormat {

	cret := xPixbufGetFileInfo(FilenameVar, WidthVar, HeightVar)
	return cret
}

var xPixbufGetFileInfoAsync func(string, uintptr, uintptr, uintptr)

// Asynchronously parses an image file far enough to determine its
// format and size.
//
// For more details see gdk_pixbuf_get_file_info(), which is the synchronous
// version of this function.
//
// When the operation is finished, @callback will be called in the
// main thread. You can then call gdk_pixbuf_get_file_info_finish() to
// get the result of the operation.
func PixbufGetFileInfoAsync(FilenameVar string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xPixbufGetFileInfoAsync(FilenameVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xPixbufGetFileInfoFinish func(uintptr, int, int, **glib.Error) *PixbufFormat

// Finishes an asynchronous pixbuf parsing operation started with
// gdk_pixbuf_get_file_info_async().
func PixbufGetFileInfoFinish(AsyncResultVar gio.AsyncResult, WidthVar int, HeightVar int) (*PixbufFormat, error) {
	var cerr *glib.Error

	cret := xPixbufGetFileInfoFinish(AsyncResultVar.GoPointer(), WidthVar, HeightVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPixbufGetFormats func() *glib.SList

// Obtains the available information about the image formats supported
// by GdkPixbuf.
func PixbufGetFormats() *glib.SList {

	cret := xPixbufGetFormats()
	return cret
}

var xPixbufInitModules func(string, **glib.Error) bool

// Initalizes the gdk-pixbuf loader modules referenced by the `loaders.cache`
// file present inside that directory.
//
// This is to be used by applications that want to ship certain loaders
// in a different location from the system ones.
//
// This is needed when the OS or runtime ships a minimal number of loaders
// so as to reduce the potential attack surface of carefully crafted image
// files, especially for uncommon file types. Applications that require
// broader image file types coverage, such as image viewers, would be
// expected to ship the gdk-pixbuf modules in a separate location, bundled
// with the application in a separate directory from the OS or runtime-
// provided modules.
func PixbufInitModules(PathVar string) (bool, error) {
	var cerr *glib.Error

	cret := xPixbufInitModules(PathVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xPixbufNewFromStreamAsync func(uintptr, uintptr, uintptr, uintptr)

// Creates a new pixbuf by asynchronously loading an image from an input stream.
//
// For more details see gdk_pixbuf_new_from_stream(), which is the synchronous
// version of this function.
//
// When the operation is finished, @callback will be called in the main thread.
// You can then call gdk_pixbuf_new_from_stream_finish() to get the result of
// the operation.
func PixbufNewFromStreamAsync(StreamVar *gio.InputStream, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xPixbufNewFromStreamAsync(StreamVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xPixbufNewFromStreamAtScaleAsync func(uintptr, int, int, bool, uintptr, uintptr, uintptr)

// Creates a new pixbuf by asynchronously loading an image from an input stream.
//
// For more details see gdk_pixbuf_new_from_stream_at_scale(), which is the synchronous
// version of this function.
//
// When the operation is finished, @callback will be called in the main thread.
// You can then call gdk_pixbuf_new_from_stream_finish() to get the result of the operation.
func PixbufNewFromStreamAtScaleAsync(StreamVar *gio.InputStream, WidthVar int, HeightVar int, PreserveAspectRatioVar bool, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xPixbufNewFromStreamAtScaleAsync(StreamVar.GoPointer(), WidthVar, HeightVar, PreserveAspectRatioVar, CancellableVar.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar)

}

var xPixbufSaveToStreamFinish func(uintptr, **glib.Error) bool

// Finishes an asynchronous pixbuf save operation started with
// gdk_pixbuf_save_to_stream_async().
func PixbufSaveToStreamFinish(AsyncResultVar gio.AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xPixbufSaveToStreamFinish(AsyncResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GDKPIXBUF"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewPixbuf, lib, "gdk_pixbuf_new")
	core.PuregoSafeRegister(&xNewPixbufFromBytes, lib, "gdk_pixbuf_new_from_bytes")
	core.PuregoSafeRegister(&xNewPixbufFromData, lib, "gdk_pixbuf_new_from_data")
	core.PuregoSafeRegister(&xNewPixbufFromFile, lib, "gdk_pixbuf_new_from_file")
	core.PuregoSafeRegister(&xNewPixbufFromFileAtScale, lib, "gdk_pixbuf_new_from_file_at_scale")
	core.PuregoSafeRegister(&xNewPixbufFromFileAtSize, lib, "gdk_pixbuf_new_from_file_at_size")
	core.PuregoSafeRegister(&xNewPixbufFromInline, lib, "gdk_pixbuf_new_from_inline")
	core.PuregoSafeRegister(&xNewPixbufFromResource, lib, "gdk_pixbuf_new_from_resource")
	core.PuregoSafeRegister(&xNewPixbufFromResourceAtScale, lib, "gdk_pixbuf_new_from_resource_at_scale")
	core.PuregoSafeRegister(&xNewPixbufFromStream, lib, "gdk_pixbuf_new_from_stream")
	core.PuregoSafeRegister(&xNewPixbufFromStreamAtScale, lib, "gdk_pixbuf_new_from_stream_at_scale")
	core.PuregoSafeRegister(&xNewPixbufFromStreamFinish, lib, "gdk_pixbuf_new_from_stream_finish")
	core.PuregoSafeRegister(&xNewPixbufFromXpmData, lib, "gdk_pixbuf_new_from_xpm_data")

	core.PuregoSafeRegister(&xPixbufAddAlpha, lib, "gdk_pixbuf_add_alpha")
	core.PuregoSafeRegister(&xPixbufApplyEmbeddedOrientation, lib, "gdk_pixbuf_apply_embedded_orientation")
	core.PuregoSafeRegister(&xPixbufComposite, lib, "gdk_pixbuf_composite")
	core.PuregoSafeRegister(&xPixbufCompositeColor, lib, "gdk_pixbuf_composite_color")
	core.PuregoSafeRegister(&xPixbufCompositeColorSimple, lib, "gdk_pixbuf_composite_color_simple")
	core.PuregoSafeRegister(&xPixbufCopy, lib, "gdk_pixbuf_copy")
	core.PuregoSafeRegister(&xPixbufCopyArea, lib, "gdk_pixbuf_copy_area")
	core.PuregoSafeRegister(&xPixbufCopyOptions, lib, "gdk_pixbuf_copy_options")
	core.PuregoSafeRegister(&xPixbufFill, lib, "gdk_pixbuf_fill")
	core.PuregoSafeRegister(&xPixbufFlip, lib, "gdk_pixbuf_flip")
	core.PuregoSafeRegister(&xPixbufGetBitsPerSample, lib, "gdk_pixbuf_get_bits_per_sample")
	core.PuregoSafeRegister(&xPixbufGetByteLength, lib, "gdk_pixbuf_get_byte_length")
	core.PuregoSafeRegister(&xPixbufGetColorspace, lib, "gdk_pixbuf_get_colorspace")
	core.PuregoSafeRegister(&xPixbufGetHasAlpha, lib, "gdk_pixbuf_get_has_alpha")
	core.PuregoSafeRegister(&xPixbufGetHeight, lib, "gdk_pixbuf_get_height")
	core.PuregoSafeRegister(&xPixbufGetNChannels, lib, "gdk_pixbuf_get_n_channels")
	core.PuregoSafeRegister(&xPixbufGetOption, lib, "gdk_pixbuf_get_option")
	core.PuregoSafeRegister(&xPixbufGetOptions, lib, "gdk_pixbuf_get_options")
	core.PuregoSafeRegister(&xPixbufGetPixels, lib, "gdk_pixbuf_get_pixels")
	core.PuregoSafeRegister(&xPixbufGetPixelsWithLength, lib, "gdk_pixbuf_get_pixels_with_length")
	core.PuregoSafeRegister(&xPixbufGetRowstride, lib, "gdk_pixbuf_get_rowstride")
	core.PuregoSafeRegister(&xPixbufGetWidth, lib, "gdk_pixbuf_get_width")
	core.PuregoSafeRegister(&xPixbufNewSubpixbuf, lib, "gdk_pixbuf_new_subpixbuf")
	core.PuregoSafeRegister(&xPixbufReadPixelBytes, lib, "gdk_pixbuf_read_pixel_bytes")
	core.PuregoSafeRegister(&xPixbufReadPixels, lib, "gdk_pixbuf_read_pixels")
	core.PuregoSafeRegister(&xPixbufRef, lib, "gdk_pixbuf_ref")
	core.PuregoSafeRegister(&xPixbufRemoveOption, lib, "gdk_pixbuf_remove_option")
	core.PuregoSafeRegister(&xPixbufRotateSimple, lib, "gdk_pixbuf_rotate_simple")
	core.PuregoSafeRegister(&xPixbufSaturateAndPixelate, lib, "gdk_pixbuf_saturate_and_pixelate")
	core.PuregoSafeRegister(&xPixbufSave, lib, "gdk_pixbuf_save")
	core.PuregoSafeRegister(&xPixbufSaveToBuffer, lib, "gdk_pixbuf_save_to_buffer")
	core.PuregoSafeRegister(&xPixbufSaveToBufferv, lib, "gdk_pixbuf_save_to_bufferv")
	core.PuregoSafeRegister(&xPixbufSaveToCallback, lib, "gdk_pixbuf_save_to_callback")
	core.PuregoSafeRegister(&xPixbufSaveToCallbackv, lib, "gdk_pixbuf_save_to_callbackv")
	core.PuregoSafeRegister(&xPixbufSaveToStream, lib, "gdk_pixbuf_save_to_stream")
	core.PuregoSafeRegister(&xPixbufSaveToStreamAsync, lib, "gdk_pixbuf_save_to_stream_async")
	core.PuregoSafeRegister(&xPixbufSaveToStreamv, lib, "gdk_pixbuf_save_to_streamv")
	core.PuregoSafeRegister(&xPixbufSaveToStreamvAsync, lib, "gdk_pixbuf_save_to_streamv_async")
	core.PuregoSafeRegister(&xPixbufSavev, lib, "gdk_pixbuf_savev")
	core.PuregoSafeRegister(&xPixbufScale, lib, "gdk_pixbuf_scale")
	core.PuregoSafeRegister(&xPixbufScaleSimple, lib, "gdk_pixbuf_scale_simple")
	core.PuregoSafeRegister(&xPixbufSetOption, lib, "gdk_pixbuf_set_option")
	core.PuregoSafeRegister(&xPixbufUnref, lib, "gdk_pixbuf_unref")

	core.PuregoSafeRegister(&xPixbufCalculateRowstride, lib, "gdk_pixbuf_calculate_rowstride")
	core.PuregoSafeRegister(&xPixbufGetFileInfo, lib, "gdk_pixbuf_get_file_info")
	core.PuregoSafeRegister(&xPixbufGetFileInfoAsync, lib, "gdk_pixbuf_get_file_info_async")
	core.PuregoSafeRegister(&xPixbufGetFileInfoFinish, lib, "gdk_pixbuf_get_file_info_finish")
	core.PuregoSafeRegister(&xPixbufGetFormats, lib, "gdk_pixbuf_get_formats")
	core.PuregoSafeRegister(&xPixbufInitModules, lib, "gdk_pixbuf_init_modules")
	core.PuregoSafeRegister(&xPixbufNewFromStreamAsync, lib, "gdk_pixbuf_new_from_stream_async")
	core.PuregoSafeRegister(&xPixbufNewFromStreamAtScaleAsync, lib, "gdk_pixbuf_new_from_stream_at_scale_async")
	core.PuregoSafeRegister(&xPixbufSaveToStreamFinish, lib, "gdk_pixbuf_save_to_stream_finish")

}
