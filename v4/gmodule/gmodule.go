// Package gmodule was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gmodule

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// Specifies the type of the module initialization function.
// If a module contains a function named g_module_check_init() it is called
// automatically when the module is loaded. It is passed the #GModule structure
// and should return %NULL on success or a string describing the initialization
// error.
type ModuleCheckInit func(*Module) string

// Specifies the type of the module function called when it is unloaded.
// If a module contains a function named g_module_unload() it is called
// automatically when the module is unloaded.
// It is passed the #GModule structure.
type ModuleUnload func(*Module)

// The #GModule struct is an opaque data structure to represent a
// [dynamically-loaded module][glib-Dynamic-Loading-of-Modules].
// It should only be accessed via the following functions.
type Module struct {
}

func (x *Module) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xModuleClose func(uintptr) bool

// Closes a module.
func (x *Module) Close() bool {

	cret := xModuleClose(x.GoPointer())
	return cret
}

var xModuleMakeResident func(uintptr)

// Ensures that a module will never be unloaded.
// Any future g_module_close() calls on the module will be ignored.
func (x *Module) MakeResident() {

	xModuleMakeResident(x.GoPointer())

}

var xModuleName func(uintptr) string

// Returns the filename that the module was opened with.
//
// If @module refers to the application itself, "main" is returned.
func (x *Module) Name() string {

	cret := xModuleName(x.GoPointer())
	return cret
}

var xModuleSymbol func(uintptr, string, uintptr) bool

// Gets a symbol pointer from a module, such as one exported
// by %G_MODULE_EXPORT. Note that a valid symbol can be %NULL.
func (x *Module) Symbol(SymbolNameVar string, SymbolVar uintptr) bool {

	cret := xModuleSymbol(x.GoPointer(), SymbolNameVar, SymbolVar)
	return cret
}

// Flags passed to g_module_open().
// Note that these flags are not supported on all platforms.
type ModuleFlags int

const (

	// specifies that symbols are only resolved when
	//     needed. The default action is to bind all symbols when the module
	//     is loaded.
	GModuleBindLazyValue ModuleFlags = 1
	// specifies that symbols in the module should
	//     not be added to the global name space. The default action on most
	//     platforms is to place symbols in the module in the global name space,
	//     which may cause conflicts with existing symbols.
	GModuleBindLocalValue ModuleFlags = 2
	// mask for all flags.
	GModuleBindMaskValue ModuleFlags = 3
)

// Errors returned by g_module_open_full().
type ModuleError int

const (

	// there was an error loading or opening a module file
	GModuleErrorFailedValue ModuleError = 0
	// a module returned an error from its `g_module_check_init()` function
	GModuleErrorCheckFailedValue ModuleError = 1
)

var xModuleBuildPath func(string, string) string

// A portable way to build the filename of a module. The platform-specific
// prefix and suffix are added to the filename, if needed, and the result
// is added to the directory, using the correct separator character.
//
// The directory should specify the directory where the module can be found.
// It can be %NULL or an empty string to indicate that the module is in a
// standard platform-specific directory, though this is not recommended
// since the wrong module may be found.
//
// For example, calling g_module_build_path() on a Linux system with a
// @directory of `/lib` and a @module_name of "mylibrary" will return
// `/lib/libmylibrary.so`. On a Windows system, using `\Windows` as the
// directory it will return `\Windows\mylibrary.dll`.
func ModuleBuildPath(DirectoryVar string, ModuleNameVar string) string {

	cret := xModuleBuildPath(DirectoryVar, ModuleNameVar)
	return cret
}

var xNewModuleError func() string

// Gets a string describing the last module error.
func NewModuleError() string {

	cret := xNewModuleError()
	return cret
}

var xModuleSupported func() bool

// Checks if modules are supported on the current platform.
func ModuleSupported() bool {

	cret := xModuleSupported()
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GMODULE"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xModuleBuildPath, lib, "g_module_build_path")
	core.PuregoSafeRegister(&xNewModuleError, lib, "g_module_error")
	core.PuregoSafeRegister(&xModuleSupported, lib, "g_module_supported")

	core.PuregoSafeRegister(&xModuleClose, lib, "g_module_close")
	core.PuregoSafeRegister(&xModuleMakeResident, lib, "g_module_make_resident")
	core.PuregoSafeRegister(&xModuleName, lib, "g_module_name")
	core.PuregoSafeRegister(&xModuleSymbol, lib, "g_module_symbol")

}
