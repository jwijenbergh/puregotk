// Package gsk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gsk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/cairo"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/graphene"
)

type RendererClass struct {
}

func (x *RendererClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// `GskRenderer` is a class that renders a scene graph defined via a
// tree of [class@Gsk.RenderNode] instances.
//
// Typically you will use a `GskRenderer` instance to repeatedly call
// [method@Gsk.Renderer.render] to update the contents of its associated
// [class@Gdk.Surface].
//
// It is necessary to realize a `GskRenderer` instance using
// [method@Gsk.Renderer.realize] before calling [method@Gsk.Renderer.render],
// in order to create the appropriate windowing system resources needed
// to render the scene.
type Renderer struct {
	gobject.Object
}

func RendererNewFromInternalPtr(ptr uintptr) *Renderer {
	cls := &Renderer{}
	cls.Ptr = ptr
	return cls
}

var xNewRendererForSurface func(uintptr) uintptr

// Creates an appropriate `GskRenderer` instance for the given @surface.
//
// If the `GSK_RENDERER` environment variable is set, GSK will
// try that renderer first, before trying the backend-specific
// default. The ultimate fallback is the cairo renderer.
//
// The renderer will be realized before it is returned.
func NewRendererForSurface(SurfaceVar *gdk.Surface) *Renderer {
	var cls *Renderer

	cret := xNewRendererForSurface(SurfaceVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Renderer{}
	cls.Ptr = cret
	return cls
}

var xRendererGetSurface func(uintptr) uintptr

// Retrieves the `GdkSurface` set using gsk_enderer_realize().
//
// If the renderer has not been realized yet, %NULL will be returned.
func (x *Renderer) GetSurface() *gdk.Surface {
	var cls *gdk.Surface

	cret := xRendererGetSurface(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Surface{}
	cls.Ptr = cret
	return cls
}

var xRendererIsRealized func(uintptr) bool

// Checks whether the @renderer is realized or not.
func (x *Renderer) IsRealized() bool {

	cret := xRendererIsRealized(x.GoPointer())
	return cret
}

var xRendererRealize func(uintptr, uintptr, **glib.Error) bool

// Creates the resources needed by the @renderer to render the scene
// graph.
//
// Since GTK 4.6, the surface may be `NULL`, which allows using
// renderers without having to create a surface.
//
// Note that it is mandatory to call [method@Gsk.Renderer.unrealize] before
// destroying the renderer.
func (x *Renderer) Realize(SurfaceVar *gdk.Surface) (bool, error) {
	var cerr *glib.Error

	cret := xRendererRealize(x.GoPointer(), SurfaceVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xRendererRender func(uintptr, uintptr, *cairo.Region)

// Renders the scene graph, described by a tree of `GskRenderNode` instances
// to the renderer's surface,  ensuring that the given @region gets redrawn.
//
// If the renderer has no associated surface, this function does nothing.
//
// Renderers must ensure that changes of the contents given by the @root
// node as well as the area given by @region are redrawn. They are however
// free to not redraw any pixel outside of @region if they can guarantee that
// it didn't change.
//
// The @renderer will acquire a reference on the `GskRenderNode` tree while
// the rendering is in progress.
func (x *Renderer) Render(RootVar *RenderNode, RegionVar *cairo.Region) {

	xRendererRender(x.GoPointer(), RootVar.GoPointer(), RegionVar)

}

var xRendererRenderTexture func(uintptr, uintptr, *graphene.Rect) uintptr

// Renders the scene graph, described by a tree of `GskRenderNode` instances,
// to a `GdkTexture`.
//
// The @renderer will acquire a reference on the `GskRenderNode` tree while
// the rendering is in progress.
//
// If you want to apply any transformations to @root, you should put it into a
// transform node and pass that node instead.
func (x *Renderer) RenderTexture(RootVar *RenderNode, ViewportVar *graphene.Rect) *gdk.Texture {
	var cls *gdk.Texture

	cret := xRendererRenderTexture(x.GoPointer(), RootVar.GoPointer(), ViewportVar)

	if cret == 0 {
		return nil
	}
	cls = &gdk.Texture{}
	cls.Ptr = cret
	return cls
}

var xRendererUnrealize func(uintptr)

// Releases all the resources created by gsk_renderer_realize().
func (x *Renderer) Unrealize() {

	xRendererUnrealize(x.GoPointer())

}

func (c *Renderer) GoPointer() uintptr {
	return c.Ptr
}

func (c *Renderer) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GSK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewRendererForSurface, lib, "gsk_renderer_new_for_surface")

	core.PuregoSafeRegister(&xRendererGetSurface, lib, "gsk_renderer_get_surface")
	core.PuregoSafeRegister(&xRendererIsRealized, lib, "gsk_renderer_is_realized")
	core.PuregoSafeRegister(&xRendererRealize, lib, "gsk_renderer_realize")
	core.PuregoSafeRegister(&xRendererRender, lib, "gsk_renderer_render")
	core.PuregoSafeRegister(&xRendererRenderTexture, lib, "gsk_renderer_render_texture")
	core.PuregoSafeRegister(&xRendererUnrealize, lib, "gsk_renderer_unrealize")

}
