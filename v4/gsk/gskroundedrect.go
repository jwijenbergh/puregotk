// Package gsk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gsk

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/graphene"
)

// A rectangular region with rounded corners.
//
// Application code should normalize rectangles using
// [method@Gsk.RoundedRect.normalize]; this function will ensure that
// the bounds of the rectangle are normalized and ensure that the corner
// values are positive and the corners do not overlap.
//
// All functions taking a `GskRoundedRect` as an argument will internally
// operate on a normalized copy; all functions returning a `GskRoundedRect`
// will always return a normalized one.
//
// The algorithm used for normalizing corner sizes is described in
// [the CSS specification](https://drafts.csswg.org/css-backgrounds-3/#border-radius).
type RoundedRect struct {
	_ structs.HostLayout

	Bounds uintptr

	Corner [4]graphene.Size
}

func (x *RoundedRect) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xRoundedRectContainsPoint func(uintptr, *graphene.Point) bool

// Checks if the given @point is inside the rounded rectangle.
func (x *RoundedRect) ContainsPoint(PointVar *graphene.Point) bool {

	cret := xRoundedRectContainsPoint(x.GoPointer(), PointVar)
	return cret
}

var xRoundedRectContainsRect func(uintptr, *graphene.Rect) bool

// Checks if the given @rect is contained inside the rounded rectangle.
func (x *RoundedRect) ContainsRect(RectVar *graphene.Rect) bool {

	cret := xRoundedRectContainsRect(x.GoPointer(), RectVar)
	return cret
}

var xRoundedRectInit func(uintptr, *graphene.Rect, *graphene.Size, *graphene.Size, *graphene.Size, *graphene.Size) *RoundedRect

// Initializes the given `GskRoundedRect` with the given values.
//
// This function will implicitly normalize the `GskRoundedRect`
// before returning.
func (x *RoundedRect) Init(BoundsVar *graphene.Rect, TopLeftVar *graphene.Size, TopRightVar *graphene.Size, BottomRightVar *graphene.Size, BottomLeftVar *graphene.Size) *RoundedRect {

	cret := xRoundedRectInit(x.GoPointer(), BoundsVar, TopLeftVar, TopRightVar, BottomRightVar, BottomLeftVar)
	return cret
}

var xRoundedRectInitCopy func(uintptr, *RoundedRect) *RoundedRect

// Initializes @self using the given @src rectangle.
//
// This function will not normalize the `GskRoundedRect`,
// so make sure the source is normalized.
func (x *RoundedRect) InitCopy(SrcVar *RoundedRect) *RoundedRect {

	cret := xRoundedRectInitCopy(x.GoPointer(), SrcVar)
	return cret
}

var xRoundedRectInitFromRect func(uintptr, *graphene.Rect, float32) *RoundedRect

// Initializes @self to the given @bounds and sets the radius
// of all four corners to @radius.
func (x *RoundedRect) InitFromRect(BoundsVar *graphene.Rect, RadiusVar float32) *RoundedRect {

	cret := xRoundedRectInitFromRect(x.GoPointer(), BoundsVar, RadiusVar)
	return cret
}

var xRoundedRectIntersectsRect func(uintptr, *graphene.Rect) bool

// Checks if part of the given @rect is contained inside the rounded rectangle.
func (x *RoundedRect) IntersectsRect(RectVar *graphene.Rect) bool {

	cret := xRoundedRectIntersectsRect(x.GoPointer(), RectVar)
	return cret
}

var xRoundedRectIsRectilinear func(uintptr) bool

// Checks if all corners of @self are right angles and the
// rectangle covers all of its bounds.
//
// This information can be used to decide if [ctor@Gsk.ClipNode.new]
// or [ctor@Gsk.RoundedClipNode.new] should be called.
func (x *RoundedRect) IsRectilinear() bool {

	cret := xRoundedRectIsRectilinear(x.GoPointer())
	return cret
}

var xRoundedRectNormalize func(uintptr) *RoundedRect

// Normalizes the passed rectangle.
//
// This function will ensure that the bounds of the rectangle
// are normalized and ensure that the corner values are positive
// and the corners do not overlap.
func (x *RoundedRect) Normalize() *RoundedRect {

	cret := xRoundedRectNormalize(x.GoPointer())
	return cret
}

var xRoundedRectOffset func(uintptr, float32, float32) *RoundedRect

// Offsets the bound's origin by @dx and @dy.
//
// The size and corners of the rectangle are unchanged.
func (x *RoundedRect) Offset(DxVar float32, DyVar float32) *RoundedRect {

	cret := xRoundedRectOffset(x.GoPointer(), DxVar, DyVar)
	return cret
}

var xRoundedRectShrink func(uintptr, float32, float32, float32, float32) *RoundedRect

// Shrinks (or grows) the given rectangle by moving the 4 sides
// according to the offsets given.
//
// The corner radii will be changed in a way that tries to keep
// the center of the corner circle intact. This emulates CSS behavior.
//
// This function also works for growing rectangles if you pass
// negative values for the @top, @right, @bottom or @left.
func (x *RoundedRect) Shrink(TopVar float32, RightVar float32, BottomVar float32, LeftVar float32) *RoundedRect {

	cret := xRoundedRectShrink(x.GoPointer(), TopVar, RightVar, BottomVar, LeftVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GSK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xRoundedRectContainsPoint, lib, "gsk_rounded_rect_contains_point")
	core.PuregoSafeRegister(&xRoundedRectContainsRect, lib, "gsk_rounded_rect_contains_rect")
	core.PuregoSafeRegister(&xRoundedRectInit, lib, "gsk_rounded_rect_init")
	core.PuregoSafeRegister(&xRoundedRectInitCopy, lib, "gsk_rounded_rect_init_copy")
	core.PuregoSafeRegister(&xRoundedRectInitFromRect, lib, "gsk_rounded_rect_init_from_rect")
	core.PuregoSafeRegister(&xRoundedRectIntersectsRect, lib, "gsk_rounded_rect_intersects_rect")
	core.PuregoSafeRegister(&xRoundedRectIsRectilinear, lib, "gsk_rounded_rect_is_rectilinear")
	core.PuregoSafeRegister(&xRoundedRectNormalize, lib, "gsk_rounded_rect_normalize")
	core.PuregoSafeRegister(&xRoundedRectOffset, lib, "gsk_rounded_rect_offset")
	core.PuregoSafeRegister(&xRoundedRectShrink, lib, "gsk_rounded_rect_shrink")

}
