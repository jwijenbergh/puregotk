// Package gsk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gsk

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/cairo"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/graphene"
)

// Type of callback that is called when an error occurs
// during node deserialization.
type ParseErrorFunc func(*ParseLocation, *ParseLocation, *glib.Error, uintptr)

// A color stop in a gradient node.
type ColorStop struct {
	Offset float32

	Color uintptr
}

func (x *ColorStop) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A location in a parse buffer.
type ParseLocation struct {
	Bytes uint

	Chars uint

	Lines uint

	LineBytes uint

	LineChars uint
}

func (x *ParseLocation) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// The shadow parameters in a shadow node.
type Shadow struct {
	Color uintptr

	Dx float32

	Dy float32

	Radius float32
}

func (x *Shadow) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xValueDupRenderNode func(*gobject.Value) uintptr

// Retrieves the `GskRenderNode` stored inside the given `value`, and acquires
// a reference to it.
func ValueDupRenderNode(ValueVar *gobject.Value) *RenderNode {
	var cls *RenderNode

	cret := xValueDupRenderNode(ValueVar)

	if cret == 0 {
		return nil
	}
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xValueGetRenderNode func(*gobject.Value) uintptr

// Retrieves the `GskRenderNode` stored inside the given `value`.
func ValueGetRenderNode(ValueVar *gobject.Value) *RenderNode {
	var cls *RenderNode

	cret := xValueGetRenderNode(ValueVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xValueSetRenderNode func(*gobject.Value, uintptr)

// Stores the given `GskRenderNode` inside `value`.
//
// The [struct@GObject.Value] will acquire a reference to the `node`.
func ValueSetRenderNode(ValueVar *gobject.Value, NodeVar *RenderNode) {

	xValueSetRenderNode(ValueVar, NodeVar.GoPointer())

}

var xValueTakeRenderNode func(*gobject.Value, uintptr)

// Stores the given `GskRenderNode` inside `value`.
//
// This function transfers the ownership of the `node` to the `GValue`.
func ValueTakeRenderNode(ValueVar *gobject.Value, NodeVar *RenderNode) {

	xValueTakeRenderNode(ValueVar, NodeVar.GoPointer())

}

// `GskRenderNode` is the basic block in a scene graph to be
// rendered using [class@Gsk.Renderer].
//
// Each node has a parent, except the top-level node; each node may have
// children nodes.
//
// Each node has an associated drawing surface, which has the size of
// the rectangle set when creating it.
//
// Render nodes are meant to be transient; once they have been associated
// to a [class@Gsk.Renderer] it's safe to release any reference you have on
// them. All [class@Gsk.RenderNode]s are immutable, you can only specify their
// properties during construction.
type RenderNode struct {
	Ptr uintptr
}

func RenderNodeNewFromInternalPtr(ptr uintptr) *RenderNode {
	cls := &RenderNode{}
	cls.Ptr = ptr
	return cls
}

var xRenderNodeDraw func(uintptr, *cairo.Context)

// Draw the contents of @node to the given cairo context.
//
// Typically, you'll use this function to implement fallback rendering
// of `GskRenderNode`s on an intermediate Cairo context, instead of using
// the drawing context associated to a [class@Gdk.Surface]'s rendering buffer.
//
// For advanced nodes that cannot be supported using Cairo, in particular
// for nodes doing 3D operations, this function may fail.
func (x *RenderNode) Draw(CrVar *cairo.Context) {

	xRenderNodeDraw(x.GoPointer(), CrVar)

}

var xRenderNodeGetBounds func(uintptr, *graphene.Rect)

// Retrieves the boundaries of the @node.
//
// The node will not draw outside of its boundaries.
func (x *RenderNode) GetBounds(BoundsVar *graphene.Rect) {

	xRenderNodeGetBounds(x.GoPointer(), BoundsVar)

}

var xRenderNodeGetNodeType func(uintptr) RenderNodeType

// Returns the type of the @node.
func (x *RenderNode) GetNodeType() RenderNodeType {

	cret := xRenderNodeGetNodeType(x.GoPointer())
	return cret
}

var xRenderNodeRef func(uintptr) uintptr

// Acquires a reference on the given `GskRenderNode`.
func (x *RenderNode) Ref() *RenderNode {
	var cls *RenderNode

	cret := xRenderNodeRef(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xRenderNodeSerialize func(uintptr) *glib.Bytes

// Serializes the @node for later deserialization via
// gsk_render_node_deserialize(). No guarantees are made about the format
// used other than that the same version of GTK will be able to deserialize
// the result of a call to gsk_render_node_serialize() and
// gsk_render_node_deserialize() will correctly reject files it cannot open
// that were created with previous versions of GTK.
//
// The intended use of this functions is testing, benchmarking and debugging.
// The format is not meant as a permanent storage format.
func (x *RenderNode) Serialize() *glib.Bytes {

	cret := xRenderNodeSerialize(x.GoPointer())
	return cret
}

var xRenderNodeUnref func(uintptr)

// Releases a reference on the given `GskRenderNode`.
//
// If the reference was the last, the resources associated to the @node are
// freed.
func (x *RenderNode) Unref() {

	xRenderNodeUnref(x.GoPointer())

}

var xRenderNodeWriteToFile func(uintptr, string, **glib.Error) bool

// This function is equivalent to calling [method@Gsk.RenderNode.serialize]
// followed by [func@GLib.file_set_contents].
//
// See those two functions for details on the arguments.
//
// It is mostly intended for use inside a debugger to quickly dump a render
// node to a file for later inspection.
func (x *RenderNode) WriteToFile(FilenameVar string) (bool, error) {
	var cerr *glib.Error

	cret := xRenderNodeWriteToFile(x.GoPointer(), FilenameVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *RenderNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *RenderNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

var xRenderNodeDeserialize func(*glib.Bytes, uintptr, uintptr) uintptr

// Loads data previously created via [method@Gsk.RenderNode.serialize].
//
// For a discussion of the supported format, see that function.
func RenderNodeDeserialize(BytesVar *glib.Bytes, ErrorFuncVar *ParseErrorFunc, UserDataVar uintptr) *RenderNode {
	var cls *RenderNode

	cret := xRenderNodeDeserialize(BytesVar, glib.NewCallback(ErrorFuncVar), UserDataVar)

	if cret == 0 {
		return nil
	}
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GSK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xValueDupRenderNode, lib, "gsk_value_dup_render_node")
	core.PuregoSafeRegister(&xValueGetRenderNode, lib, "gsk_value_get_render_node")
	core.PuregoSafeRegister(&xValueSetRenderNode, lib, "gsk_value_set_render_node")
	core.PuregoSafeRegister(&xValueTakeRenderNode, lib, "gsk_value_take_render_node")

	core.PuregoSafeRegister(&xRenderNodeDraw, lib, "gsk_render_node_draw")
	core.PuregoSafeRegister(&xRenderNodeGetBounds, lib, "gsk_render_node_get_bounds")
	core.PuregoSafeRegister(&xRenderNodeGetNodeType, lib, "gsk_render_node_get_node_type")
	core.PuregoSafeRegister(&xRenderNodeRef, lib, "gsk_render_node_ref")
	core.PuregoSafeRegister(&xRenderNodeSerialize, lib, "gsk_render_node_serialize")
	core.PuregoSafeRegister(&xRenderNodeUnref, lib, "gsk_render_node_unref")
	core.PuregoSafeRegister(&xRenderNodeWriteToFile, lib, "gsk_render_node_write_to_file")

	core.PuregoSafeRegister(&xRenderNodeDeserialize, lib, "gsk_render_node_deserialize")

}
