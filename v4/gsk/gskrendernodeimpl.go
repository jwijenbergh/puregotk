// Package gsk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gsk

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/cairo"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/graphene"
	"github.com/jwijenbergh/puregotk/v4/pango"
)

// A render node applying a blending function between its two child nodes.
type BlendNode struct {
	RenderNode
}

var xBlendNodeGLibType func() types.GType

func BlendNodeGLibType() types.GType {
	return xBlendNodeGLibType()
}

func BlendNodeNewFromInternalPtr(ptr uintptr) *BlendNode {
	cls := &BlendNode{}
	cls.Ptr = ptr
	return cls
}

var xNewBlendNode func(uintptr, uintptr, BlendMode) uintptr

// Creates a `GskRenderNode` that will use @blend_mode to blend the @top
// node onto the @bottom node.
func NewBlendNode(BottomVar *RenderNode, TopVar *RenderNode, BlendModeVar BlendMode) *BlendNode {
	var cls *BlendNode

	cret := xNewBlendNode(BottomVar.GoPointer(), TopVar.GoPointer(), BlendModeVar)

	if cret == 0 {
		return nil
	}
	cls = &BlendNode{}
	cls.Ptr = cret
	return cls
}

var xBlendNodeGetBlendMode func(uintptr) BlendMode

// Retrieves the blend mode used by @node.
func (x *BlendNode) GetBlendMode() BlendMode {

	cret := xBlendNodeGetBlendMode(x.GoPointer())
	return cret
}

var xBlendNodeGetBottomChild func(uintptr) uintptr

// Retrieves the bottom `GskRenderNode` child of the @node.
func (x *BlendNode) GetBottomChild() *RenderNode {
	var cls *RenderNode

	cret := xBlendNodeGetBottomChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xBlendNodeGetTopChild func(uintptr) uintptr

// Retrieves the top `GskRenderNode` child of the @node.
func (x *BlendNode) GetTopChild() *RenderNode {
	var cls *RenderNode

	cret := xBlendNodeGetTopChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

func (c *BlendNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *BlendNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node applying a blur effect to its single child.
type BlurNode struct {
	RenderNode
}

var xBlurNodeGLibType func() types.GType

func BlurNodeGLibType() types.GType {
	return xBlurNodeGLibType()
}

func BlurNodeNewFromInternalPtr(ptr uintptr) *BlurNode {
	cls := &BlurNode{}
	cls.Ptr = ptr
	return cls
}

var xNewBlurNode func(uintptr, float32) uintptr

// Creates a render node that blurs the child.
func NewBlurNode(ChildVar *RenderNode, RadiusVar float32) *BlurNode {
	var cls *BlurNode

	cret := xNewBlurNode(ChildVar.GoPointer(), RadiusVar)

	if cret == 0 {
		return nil
	}
	cls = &BlurNode{}
	cls.Ptr = cret
	return cls
}

var xBlurNodeGetChild func(uintptr) uintptr

// Retrieves the child `GskRenderNode` of the blur @node.
func (x *BlurNode) GetChild() *RenderNode {
	var cls *RenderNode

	cret := xBlurNodeGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xBlurNodeGetRadius func(uintptr) float32

// Retrieves the blur radius of the @node.
func (x *BlurNode) GetRadius() float32 {

	cret := xBlurNodeGetRadius(x.GoPointer())
	return cret
}

func (c *BlurNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *BlurNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node for a border.
type BorderNode struct {
	RenderNode
}

var xBorderNodeGLibType func() types.GType

func BorderNodeGLibType() types.GType {
	return xBorderNodeGLibType()
}

func BorderNodeNewFromInternalPtr(ptr uintptr) *BorderNode {
	cls := &BorderNode{}
	cls.Ptr = ptr
	return cls
}

var xNewBorderNode func(*RoundedRect, [4]float32, [4]gdk.RGBA) uintptr

// Creates a `GskRenderNode` that will stroke a border rectangle inside the
// given @outline.
//
// The 4 sides of the border can have different widths and colors.
func NewBorderNode(OutlineVar *RoundedRect, BorderWidthVar [4]float32, BorderColorVar [4]gdk.RGBA) *BorderNode {
	var cls *BorderNode

	cret := xNewBorderNode(OutlineVar, BorderWidthVar, BorderColorVar)

	if cret == 0 {
		return nil
	}
	cls = &BorderNode{}
	cls.Ptr = cret
	return cls
}

var xBorderNodeGetColors func(uintptr) *gdk.RGBA

// Retrieves the colors of the border.
func (x *BorderNode) GetColors() *gdk.RGBA {

	cret := xBorderNodeGetColors(x.GoPointer())
	return cret
}

var xBorderNodeGetOutline func(uintptr) *RoundedRect

// Retrieves the outline of the border.
func (x *BorderNode) GetOutline() *RoundedRect {

	cret := xBorderNodeGetOutline(x.GoPointer())
	return cret
}

var xBorderNodeGetWidths func(uintptr) [4]float32

// Retrieves the stroke widths of the border.
func (x *BorderNode) GetWidths() [4]float32 {

	cret := xBorderNodeGetWidths(x.GoPointer())
	return cret
}

func (c *BorderNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *BorderNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node for a Cairo surface.
type CairoNode struct {
	RenderNode
}

var xCairoNodeGLibType func() types.GType

func CairoNodeGLibType() types.GType {
	return xCairoNodeGLibType()
}

func CairoNodeNewFromInternalPtr(ptr uintptr) *CairoNode {
	cls := &CairoNode{}
	cls.Ptr = ptr
	return cls
}

var xNewCairoNode func(*graphene.Rect) uintptr

// Creates a `GskRenderNode` that will render a cairo surface
// into the area given by @bounds.
//
// You can draw to the cairo surface using [method@Gsk.CairoNode.get_draw_context].
func NewCairoNode(BoundsVar *graphene.Rect) *CairoNode {
	var cls *CairoNode

	cret := xNewCairoNode(BoundsVar)

	if cret == 0 {
		return nil
	}
	cls = &CairoNode{}
	cls.Ptr = cret
	return cls
}

var xCairoNodeGetDrawContext func(uintptr) *cairo.Context

// Creates a Cairo context for drawing using the surface associated
// to the render node.
//
// If no surface exists yet, a surface will be created optimized for
// rendering to @renderer.
func (x *CairoNode) GetDrawContext() *cairo.Context {

	cret := xCairoNodeGetDrawContext(x.GoPointer())
	return cret
}

var xCairoNodeGetSurface func(uintptr) *cairo.Surface

// Retrieves the Cairo surface used by the render node.
func (x *CairoNode) GetSurface() *cairo.Surface {

	cret := xCairoNodeGetSurface(x.GoPointer())
	return cret
}

func (c *CairoNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *CairoNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node applying a rectangular clip to its single child node.
type ClipNode struct {
	RenderNode
}

var xClipNodeGLibType func() types.GType

func ClipNodeGLibType() types.GType {
	return xClipNodeGLibType()
}

func ClipNodeNewFromInternalPtr(ptr uintptr) *ClipNode {
	cls := &ClipNode{}
	cls.Ptr = ptr
	return cls
}

var xNewClipNode func(uintptr, *graphene.Rect) uintptr

// Creates a `GskRenderNode` that will clip the @child to the area
// given by @clip.
func NewClipNode(ChildVar *RenderNode, ClipVar *graphene.Rect) *ClipNode {
	var cls *ClipNode

	cret := xNewClipNode(ChildVar.GoPointer(), ClipVar)

	if cret == 0 {
		return nil
	}
	cls = &ClipNode{}
	cls.Ptr = cret
	return cls
}

var xClipNodeGetChild func(uintptr) uintptr

// Gets the child node that is getting clipped by the given @node.
func (x *ClipNode) GetChild() *RenderNode {
	var cls *RenderNode

	cret := xClipNodeGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xClipNodeGetClip func(uintptr) *graphene.Rect

// Retrieves the clip rectangle for @node.
func (x *ClipNode) GetClip() *graphene.Rect {

	cret := xClipNodeGetClip(x.GoPointer())
	return cret
}

func (c *ClipNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *ClipNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node controlling the color matrix of its single child node.
type ColorMatrixNode struct {
	RenderNode
}

var xColorMatrixNodeGLibType func() types.GType

func ColorMatrixNodeGLibType() types.GType {
	return xColorMatrixNodeGLibType()
}

func ColorMatrixNodeNewFromInternalPtr(ptr uintptr) *ColorMatrixNode {
	cls := &ColorMatrixNode{}
	cls.Ptr = ptr
	return cls
}

var xNewColorMatrixNode func(uintptr, *graphene.Matrix, *graphene.Vec4) uintptr

// Creates a `GskRenderNode` that will drawn the @child with
// @color_matrix.
//
// In particular, the node will transform the operation
//
//	pixel = color_matrix * pixel + color_offset
//
// for every pixel.
func NewColorMatrixNode(ChildVar *RenderNode, ColorMatrixVar *graphene.Matrix, ColorOffsetVar *graphene.Vec4) *ColorMatrixNode {
	var cls *ColorMatrixNode

	cret := xNewColorMatrixNode(ChildVar.GoPointer(), ColorMatrixVar, ColorOffsetVar)

	if cret == 0 {
		return nil
	}
	cls = &ColorMatrixNode{}
	cls.Ptr = cret
	return cls
}

var xColorMatrixNodeGetChild func(uintptr) uintptr

// Gets the child node that is getting its colors modified by the given @node.
func (x *ColorMatrixNode) GetChild() *RenderNode {
	var cls *RenderNode

	cret := xColorMatrixNodeGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xColorMatrixNodeGetColorMatrix func(uintptr) *graphene.Matrix

// Retrieves the color matrix used by the @node.
func (x *ColorMatrixNode) GetColorMatrix() *graphene.Matrix {

	cret := xColorMatrixNodeGetColorMatrix(x.GoPointer())
	return cret
}

var xColorMatrixNodeGetColorOffset func(uintptr) *graphene.Vec4

// Retrieves the color offset used by the @node.
func (x *ColorMatrixNode) GetColorOffset() *graphene.Vec4 {

	cret := xColorMatrixNodeGetColorOffset(x.GoPointer())
	return cret
}

func (c *ColorMatrixNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *ColorMatrixNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node for a solid color.
type ColorNode struct {
	RenderNode
}

var xColorNodeGLibType func() types.GType

func ColorNodeGLibType() types.GType {
	return xColorNodeGLibType()
}

func ColorNodeNewFromInternalPtr(ptr uintptr) *ColorNode {
	cls := &ColorNode{}
	cls.Ptr = ptr
	return cls
}

var xNewColorNode func(*gdk.RGBA, *graphene.Rect) uintptr

// Creates a `GskRenderNode` that will render the color specified by @rgba into
// the area given by @bounds.
func NewColorNode(RgbaVar *gdk.RGBA, BoundsVar *graphene.Rect) *ColorNode {
	var cls *ColorNode

	cret := xNewColorNode(RgbaVar, BoundsVar)

	if cret == 0 {
		return nil
	}
	cls = &ColorNode{}
	cls.Ptr = cret
	return cls
}

var xColorNodeGetColor func(uintptr) *gdk.RGBA

// Retrieves the color of the given @node.
func (x *ColorNode) GetColor() *gdk.RGBA {

	cret := xColorNodeGetColor(x.GoPointer())
	return cret
}

func (c *ColorNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *ColorNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node for a conic gradient.
type ConicGradientNode struct {
	RenderNode
}

var xConicGradientNodeGLibType func() types.GType

func ConicGradientNodeGLibType() types.GType {
	return xConicGradientNodeGLibType()
}

func ConicGradientNodeNewFromInternalPtr(ptr uintptr) *ConicGradientNode {
	cls := &ConicGradientNode{}
	cls.Ptr = ptr
	return cls
}

var xNewConicGradientNode func(*graphene.Rect, *graphene.Point, float32, []ColorStop, uint) uintptr

// Creates a `GskRenderNode` that draws a conic gradient.
//
// The conic gradient
// starts around @center in the direction of @rotation. A rotation of 0 means
// that the gradient points up. Color stops are then added clockwise.
func NewConicGradientNode(BoundsVar *graphene.Rect, CenterVar *graphene.Point, RotationVar float32, ColorStopsVar []ColorStop, NColorStopsVar uint) *ConicGradientNode {
	var cls *ConicGradientNode

	cret := xNewConicGradientNode(BoundsVar, CenterVar, RotationVar, ColorStopsVar, NColorStopsVar)

	if cret == 0 {
		return nil
	}
	cls = &ConicGradientNode{}
	cls.Ptr = cret
	return cls
}

var xConicGradientNodeGetAngle func(uintptr) float32

// Retrieves the angle for the gradient in radians, normalized in [0, 2 * PI].
//
// The angle is starting at the top and going clockwise, as expressed
// in the css specification:
//
//	angle = 90 - gsk_conic_gradient_node_get_rotation()
func (x *ConicGradientNode) GetAngle() float32 {

	cret := xConicGradientNodeGetAngle(x.GoPointer())
	return cret
}

var xConicGradientNodeGetCenter func(uintptr) *graphene.Point

// Retrieves the center pointer for the gradient.
func (x *ConicGradientNode) GetCenter() *graphene.Point {

	cret := xConicGradientNodeGetCenter(x.GoPointer())
	return cret
}

var xConicGradientNodeGetColorStops func(uintptr, uint) []ColorStop

// Retrieves the color stops in the gradient.
func (x *ConicGradientNode) GetColorStops(NStopsVar uint) []ColorStop {

	cret := xConicGradientNodeGetColorStops(x.GoPointer(), NStopsVar)
	return cret
}

var xConicGradientNodeGetNColorStops func(uintptr) uint

// Retrieves the number of color stops in the gradient.
func (x *ConicGradientNode) GetNColorStops() uint {

	cret := xConicGradientNodeGetNColorStops(x.GoPointer())
	return cret
}

var xConicGradientNodeGetRotation func(uintptr) float32

// Retrieves the rotation for the gradient in degrees.
func (x *ConicGradientNode) GetRotation() float32 {

	cret := xConicGradientNodeGetRotation(x.GoPointer())
	return cret
}

func (c *ConicGradientNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *ConicGradientNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node that can contain other render nodes.
type ContainerNode struct {
	RenderNode
}

var xContainerNodeGLibType func() types.GType

func ContainerNodeGLibType() types.GType {
	return xContainerNodeGLibType()
}

func ContainerNodeNewFromInternalPtr(ptr uintptr) *ContainerNode {
	cls := &ContainerNode{}
	cls.Ptr = ptr
	return cls
}

var xNewContainerNode func(uintptr, uint) uintptr

// Creates a new `GskRenderNode` instance for holding the given @children.
//
// The new node will acquire a reference to each of the children.
func NewContainerNode(ChildrenVar uintptr, NChildrenVar uint) *ContainerNode {
	var cls *ContainerNode

	cret := xNewContainerNode(ChildrenVar, NChildrenVar)

	if cret == 0 {
		return nil
	}
	cls = &ContainerNode{}
	cls.Ptr = cret
	return cls
}

var xContainerNodeGetChild func(uintptr, uint) uintptr

// Gets one of the children of @container.
func (x *ContainerNode) GetChild(IdxVar uint) *RenderNode {
	var cls *RenderNode

	cret := xContainerNodeGetChild(x.GoPointer(), IdxVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xContainerNodeGetNChildren func(uintptr) uint

// Retrieves the number of direct children of @node.
func (x *ContainerNode) GetNChildren() uint {

	cret := xContainerNodeGetNChildren(x.GoPointer())
	return cret
}

func (c *ContainerNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *ContainerNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node cross fading between two child nodes.
type CrossFadeNode struct {
	RenderNode
}

var xCrossFadeNodeGLibType func() types.GType

func CrossFadeNodeGLibType() types.GType {
	return xCrossFadeNodeGLibType()
}

func CrossFadeNodeNewFromInternalPtr(ptr uintptr) *CrossFadeNode {
	cls := &CrossFadeNode{}
	cls.Ptr = ptr
	return cls
}

var xNewCrossFadeNode func(uintptr, uintptr, float32) uintptr

// Creates a `GskRenderNode` that will do a cross-fade between @start and @end.
func NewCrossFadeNode(StartVar *RenderNode, EndVar *RenderNode, ProgressVar float32) *CrossFadeNode {
	var cls *CrossFadeNode

	cret := xNewCrossFadeNode(StartVar.GoPointer(), EndVar.GoPointer(), ProgressVar)

	if cret == 0 {
		return nil
	}
	cls = &CrossFadeNode{}
	cls.Ptr = cret
	return cls
}

var xCrossFadeNodeGetEndChild func(uintptr) uintptr

// Retrieves the child `GskRenderNode` at the end of the cross-fade.
func (x *CrossFadeNode) GetEndChild() *RenderNode {
	var cls *RenderNode

	cret := xCrossFadeNodeGetEndChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xCrossFadeNodeGetProgress func(uintptr) float32

// Retrieves the progress value of the cross fade.
func (x *CrossFadeNode) GetProgress() float32 {

	cret := xCrossFadeNodeGetProgress(x.GoPointer())
	return cret
}

var xCrossFadeNodeGetStartChild func(uintptr) uintptr

// Retrieves the child `GskRenderNode` at the beginning of the cross-fade.
func (x *CrossFadeNode) GetStartChild() *RenderNode {
	var cls *RenderNode

	cret := xCrossFadeNodeGetStartChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

func (c *CrossFadeNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *CrossFadeNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node that emits a debugging message when drawing its
// child node.
type DebugNode struct {
	RenderNode
}

var xDebugNodeGLibType func() types.GType

func DebugNodeGLibType() types.GType {
	return xDebugNodeGLibType()
}

func DebugNodeNewFromInternalPtr(ptr uintptr) *DebugNode {
	cls := &DebugNode{}
	cls.Ptr = ptr
	return cls
}

var xNewDebugNode func(uintptr, string) uintptr

// Creates a `GskRenderNode` that will add debug information about
// the given @child.
//
// Adding this node has no visual effect.
func NewDebugNode(ChildVar *RenderNode, MessageVar string) *DebugNode {
	var cls *DebugNode

	cret := xNewDebugNode(ChildVar.GoPointer(), MessageVar)

	if cret == 0 {
		return nil
	}
	cls = &DebugNode{}
	cls.Ptr = cret
	return cls
}

var xDebugNodeGetChild func(uintptr) uintptr

// Gets the child node that is getting drawn by the given @node.
func (x *DebugNode) GetChild() *RenderNode {
	var cls *RenderNode

	cret := xDebugNodeGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xDebugNodeGetMessage func(uintptr) string

// Gets the debug message that was set on this node
func (x *DebugNode) GetMessage() string {

	cret := xDebugNodeGetMessage(x.GoPointer())
	return cret
}

func (c *DebugNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *DebugNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node using a GL shader when drawing its children nodes.
type GLShaderNode struct {
	RenderNode
}

var xGLShaderNodeGLibType func() types.GType

func GLShaderNodeGLibType() types.GType {
	return xGLShaderNodeGLibType()
}

func GLShaderNodeNewFromInternalPtr(ptr uintptr) *GLShaderNode {
	cls := &GLShaderNode{}
	cls.Ptr = ptr
	return cls
}

var xNewGLShaderNode func(uintptr, *graphene.Rect, *glib.Bytes, uintptr, uint) uintptr

// Creates a `GskRenderNode` that will render the given @shader into the
// area given by @bounds.
//
// The @args is a block of data to use for uniform input, as per types and
// offsets defined by the @shader. Normally this is generated by
// [method@Gsk.GLShader.format_args] or [struct@Gsk.ShaderArgsBuilder].
//
// See [class@Gsk.GLShader] for details about how the shader should be written.
//
// All the children will be rendered into textures (if they aren't already
// `GskTextureNodes`, which will be used directly). These textures will be
// sent as input to the shader.
//
// If the renderer doesn't support GL shaders, or if there is any problem
// when compiling the shader, then the node will draw pink. You should use
// [method@Gsk.GLShader.compile] to ensure the @shader will work for the
// renderer before using it.
func NewGLShaderNode(ShaderVar *GLShader, BoundsVar *graphene.Rect, ArgsVar *glib.Bytes, ChildrenVar uintptr, NChildrenVar uint) *GLShaderNode {
	var cls *GLShaderNode

	cret := xNewGLShaderNode(ShaderVar.GoPointer(), BoundsVar, ArgsVar, ChildrenVar, NChildrenVar)

	if cret == 0 {
		return nil
	}
	cls = &GLShaderNode{}
	cls.Ptr = cret
	return cls
}

var xGLShaderNodeGetArgs func(uintptr) *glib.Bytes

// Gets args for the node.
func (x *GLShaderNode) GetArgs() *glib.Bytes {

	cret := xGLShaderNodeGetArgs(x.GoPointer())
	return cret
}

var xGLShaderNodeGetChild func(uintptr, uint) uintptr

// Gets one of the children.
func (x *GLShaderNode) GetChild(IdxVar uint) *RenderNode {
	var cls *RenderNode

	cret := xGLShaderNodeGetChild(x.GoPointer(), IdxVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xGLShaderNodeGetNChildren func(uintptr) uint

// Returns the number of children
func (x *GLShaderNode) GetNChildren() uint {

	cret := xGLShaderNodeGetNChildren(x.GoPointer())
	return cret
}

var xGLShaderNodeGetShader func(uintptr) uintptr

// Gets shader code for the node.
func (x *GLShaderNode) GetShader() *GLShader {
	var cls *GLShader

	cret := xGLShaderNodeGetShader(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &GLShader{}
	cls.Ptr = cret
	return cls
}

func (c *GLShaderNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *GLShaderNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node for an inset shadow.
type InsetShadowNode struct {
	RenderNode
}

var xInsetShadowNodeGLibType func() types.GType

func InsetShadowNodeGLibType() types.GType {
	return xInsetShadowNodeGLibType()
}

func InsetShadowNodeNewFromInternalPtr(ptr uintptr) *InsetShadowNode {
	cls := &InsetShadowNode{}
	cls.Ptr = ptr
	return cls
}

var xNewInsetShadowNode func(*RoundedRect, *gdk.RGBA, float32, float32, float32, float32) uintptr

// Creates a `GskRenderNode` that will render an inset shadow
// into the box given by @outline.
func NewInsetShadowNode(OutlineVar *RoundedRect, ColorVar *gdk.RGBA, DxVar float32, DyVar float32, SpreadVar float32, BlurRadiusVar float32) *InsetShadowNode {
	var cls *InsetShadowNode

	cret := xNewInsetShadowNode(OutlineVar, ColorVar, DxVar, DyVar, SpreadVar, BlurRadiusVar)

	if cret == 0 {
		return nil
	}
	cls = &InsetShadowNode{}
	cls.Ptr = cret
	return cls
}

var xInsetShadowNodeGetBlurRadius func(uintptr) float32

// Retrieves the blur radius to apply to the shadow.
func (x *InsetShadowNode) GetBlurRadius() float32 {

	cret := xInsetShadowNodeGetBlurRadius(x.GoPointer())
	return cret
}

var xInsetShadowNodeGetColor func(uintptr) *gdk.RGBA

// Retrieves the color of the inset shadow.
func (x *InsetShadowNode) GetColor() *gdk.RGBA {

	cret := xInsetShadowNodeGetColor(x.GoPointer())
	return cret
}

var xInsetShadowNodeGetDx func(uintptr) float32

// Retrieves the horizontal offset of the inset shadow.
func (x *InsetShadowNode) GetDx() float32 {

	cret := xInsetShadowNodeGetDx(x.GoPointer())
	return cret
}

var xInsetShadowNodeGetDy func(uintptr) float32

// Retrieves the vertical offset of the inset shadow.
func (x *InsetShadowNode) GetDy() float32 {

	cret := xInsetShadowNodeGetDy(x.GoPointer())
	return cret
}

var xInsetShadowNodeGetOutline func(uintptr) *RoundedRect

// Retrieves the outline rectangle of the inset shadow.
func (x *InsetShadowNode) GetOutline() *RoundedRect {

	cret := xInsetShadowNodeGetOutline(x.GoPointer())
	return cret
}

var xInsetShadowNodeGetSpread func(uintptr) float32

// Retrieves how much the shadow spreads inwards.
func (x *InsetShadowNode) GetSpread() float32 {

	cret := xInsetShadowNodeGetSpread(x.GoPointer())
	return cret
}

func (c *InsetShadowNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *InsetShadowNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node for a linear gradient.
type LinearGradientNode struct {
	RenderNode
}

var xLinearGradientNodeGLibType func() types.GType

func LinearGradientNodeGLibType() types.GType {
	return xLinearGradientNodeGLibType()
}

func LinearGradientNodeNewFromInternalPtr(ptr uintptr) *LinearGradientNode {
	cls := &LinearGradientNode{}
	cls.Ptr = ptr
	return cls
}

var xNewLinearGradientNode func(*graphene.Rect, *graphene.Point, *graphene.Point, []ColorStop, uint) uintptr

// Creates a `GskRenderNode` that will create a linear gradient from the given
// points and color stops, and render that into the area given by @bounds.
func NewLinearGradientNode(BoundsVar *graphene.Rect, StartVar *graphene.Point, EndVar *graphene.Point, ColorStopsVar []ColorStop, NColorStopsVar uint) *LinearGradientNode {
	var cls *LinearGradientNode

	cret := xNewLinearGradientNode(BoundsVar, StartVar, EndVar, ColorStopsVar, NColorStopsVar)

	if cret == 0 {
		return nil
	}
	cls = &LinearGradientNode{}
	cls.Ptr = cret
	return cls
}

var xLinearGradientNodeGetColorStops func(uintptr, uint) []ColorStop

// Retrieves the color stops in the gradient.
func (x *LinearGradientNode) GetColorStops(NStopsVar uint) []ColorStop {

	cret := xLinearGradientNodeGetColorStops(x.GoPointer(), NStopsVar)
	return cret
}

var xLinearGradientNodeGetEnd func(uintptr) *graphene.Point

// Retrieves the final point of the linear gradient.
func (x *LinearGradientNode) GetEnd() *graphene.Point {

	cret := xLinearGradientNodeGetEnd(x.GoPointer())
	return cret
}

var xLinearGradientNodeGetNColorStops func(uintptr) uint

// Retrieves the number of color stops in the gradient.
func (x *LinearGradientNode) GetNColorStops() uint {

	cret := xLinearGradientNodeGetNColorStops(x.GoPointer())
	return cret
}

var xLinearGradientNodeGetStart func(uintptr) *graphene.Point

// Retrieves the initial point of the linear gradient.
func (x *LinearGradientNode) GetStart() *graphene.Point {

	cret := xLinearGradientNodeGetStart(x.GoPointer())
	return cret
}

func (c *LinearGradientNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *LinearGradientNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node controlling the opacity of its single child node.
type OpacityNode struct {
	RenderNode
}

var xOpacityNodeGLibType func() types.GType

func OpacityNodeGLibType() types.GType {
	return xOpacityNodeGLibType()
}

func OpacityNodeNewFromInternalPtr(ptr uintptr) *OpacityNode {
	cls := &OpacityNode{}
	cls.Ptr = ptr
	return cls
}

var xNewOpacityNode func(uintptr, float32) uintptr

// Creates a `GskRenderNode` that will drawn the @child with reduced
// @opacity.
func NewOpacityNode(ChildVar *RenderNode, OpacityVar float32) *OpacityNode {
	var cls *OpacityNode

	cret := xNewOpacityNode(ChildVar.GoPointer(), OpacityVar)

	if cret == 0 {
		return nil
	}
	cls = &OpacityNode{}
	cls.Ptr = cret
	return cls
}

var xOpacityNodeGetChild func(uintptr) uintptr

// Gets the child node that is getting opacityed by the given @node.
func (x *OpacityNode) GetChild() *RenderNode {
	var cls *RenderNode

	cret := xOpacityNodeGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xOpacityNodeGetOpacity func(uintptr) float32

// Gets the transparency factor for an opacity node.
func (x *OpacityNode) GetOpacity() float32 {

	cret := xOpacityNodeGetOpacity(x.GoPointer())
	return cret
}

func (c *OpacityNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *OpacityNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node for an outset shadow.
type OutsetShadowNode struct {
	RenderNode
}

var xOutsetShadowNodeGLibType func() types.GType

func OutsetShadowNodeGLibType() types.GType {
	return xOutsetShadowNodeGLibType()
}

func OutsetShadowNodeNewFromInternalPtr(ptr uintptr) *OutsetShadowNode {
	cls := &OutsetShadowNode{}
	cls.Ptr = ptr
	return cls
}

var xNewOutsetShadowNode func(*RoundedRect, *gdk.RGBA, float32, float32, float32, float32) uintptr

// Creates a `GskRenderNode` that will render an outset shadow
// around the box given by @outline.
func NewOutsetShadowNode(OutlineVar *RoundedRect, ColorVar *gdk.RGBA, DxVar float32, DyVar float32, SpreadVar float32, BlurRadiusVar float32) *OutsetShadowNode {
	var cls *OutsetShadowNode

	cret := xNewOutsetShadowNode(OutlineVar, ColorVar, DxVar, DyVar, SpreadVar, BlurRadiusVar)

	if cret == 0 {
		return nil
	}
	cls = &OutsetShadowNode{}
	cls.Ptr = cret
	return cls
}

var xOutsetShadowNodeGetBlurRadius func(uintptr) float32

// Retrieves the blur radius of the shadow.
func (x *OutsetShadowNode) GetBlurRadius() float32 {

	cret := xOutsetShadowNodeGetBlurRadius(x.GoPointer())
	return cret
}

var xOutsetShadowNodeGetColor func(uintptr) *gdk.RGBA

// Retrieves the color of the outset shadow.
func (x *OutsetShadowNode) GetColor() *gdk.RGBA {

	cret := xOutsetShadowNodeGetColor(x.GoPointer())
	return cret
}

var xOutsetShadowNodeGetDx func(uintptr) float32

// Retrieves the horizontal offset of the outset shadow.
func (x *OutsetShadowNode) GetDx() float32 {

	cret := xOutsetShadowNodeGetDx(x.GoPointer())
	return cret
}

var xOutsetShadowNodeGetDy func(uintptr) float32

// Retrieves the vertical offset of the outset shadow.
func (x *OutsetShadowNode) GetDy() float32 {

	cret := xOutsetShadowNodeGetDy(x.GoPointer())
	return cret
}

var xOutsetShadowNodeGetOutline func(uintptr) *RoundedRect

// Retrieves the outline rectangle of the outset shadow.
func (x *OutsetShadowNode) GetOutline() *RoundedRect {

	cret := xOutsetShadowNodeGetOutline(x.GoPointer())
	return cret
}

var xOutsetShadowNodeGetSpread func(uintptr) float32

// Retrieves how much the shadow spreads outwards.
func (x *OutsetShadowNode) GetSpread() float32 {

	cret := xOutsetShadowNodeGetSpread(x.GoPointer())
	return cret
}

func (c *OutsetShadowNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *OutsetShadowNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node for a radial gradient.
type RadialGradientNode struct {
	RenderNode
}

var xRadialGradientNodeGLibType func() types.GType

func RadialGradientNodeGLibType() types.GType {
	return xRadialGradientNodeGLibType()
}

func RadialGradientNodeNewFromInternalPtr(ptr uintptr) *RadialGradientNode {
	cls := &RadialGradientNode{}
	cls.Ptr = ptr
	return cls
}

var xNewRadialGradientNode func(*graphene.Rect, *graphene.Point, float32, float32, float32, float32, []ColorStop, uint) uintptr

// Creates a `GskRenderNode` that draws a radial gradient.
//
// The radial gradient
// starts around @center. The size of the gradient is dictated by @hradius
// in horizontal orientation and by @vradius in vertial orientation.
func NewRadialGradientNode(BoundsVar *graphene.Rect, CenterVar *graphene.Point, HradiusVar float32, VradiusVar float32, StartVar float32, EndVar float32, ColorStopsVar []ColorStop, NColorStopsVar uint) *RadialGradientNode {
	var cls *RadialGradientNode

	cret := xNewRadialGradientNode(BoundsVar, CenterVar, HradiusVar, VradiusVar, StartVar, EndVar, ColorStopsVar, NColorStopsVar)

	if cret == 0 {
		return nil
	}
	cls = &RadialGradientNode{}
	cls.Ptr = cret
	return cls
}

var xRadialGradientNodeGetCenter func(uintptr) *graphene.Point

// Retrieves the center pointer for the gradient.
func (x *RadialGradientNode) GetCenter() *graphene.Point {

	cret := xRadialGradientNodeGetCenter(x.GoPointer())
	return cret
}

var xRadialGradientNodeGetColorStops func(uintptr, uint) []ColorStop

// Retrieves the color stops in the gradient.
func (x *RadialGradientNode) GetColorStops(NStopsVar uint) []ColorStop {

	cret := xRadialGradientNodeGetColorStops(x.GoPointer(), NStopsVar)
	return cret
}

var xRadialGradientNodeGetEnd func(uintptr) float32

// Retrieves the end value for the gradient.
func (x *RadialGradientNode) GetEnd() float32 {

	cret := xRadialGradientNodeGetEnd(x.GoPointer())
	return cret
}

var xRadialGradientNodeGetHradius func(uintptr) float32

// Retrieves the horizonal radius for the gradient.
func (x *RadialGradientNode) GetHradius() float32 {

	cret := xRadialGradientNodeGetHradius(x.GoPointer())
	return cret
}

var xRadialGradientNodeGetNColorStops func(uintptr) uint

// Retrieves the number of color stops in the gradient.
func (x *RadialGradientNode) GetNColorStops() uint {

	cret := xRadialGradientNodeGetNColorStops(x.GoPointer())
	return cret
}

var xRadialGradientNodeGetStart func(uintptr) float32

// Retrieves the start value for the gradient.
func (x *RadialGradientNode) GetStart() float32 {

	cret := xRadialGradientNodeGetStart(x.GoPointer())
	return cret
}

var xRadialGradientNodeGetVradius func(uintptr) float32

// Retrieves the vertical radius for the gradient.
func (x *RadialGradientNode) GetVradius() float32 {

	cret := xRadialGradientNodeGetVradius(x.GoPointer())
	return cret
}

func (c *RadialGradientNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *RadialGradientNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node repeating its single child node.
type RepeatNode struct {
	RenderNode
}

var xRepeatNodeGLibType func() types.GType

func RepeatNodeGLibType() types.GType {
	return xRepeatNodeGLibType()
}

func RepeatNodeNewFromInternalPtr(ptr uintptr) *RepeatNode {
	cls := &RepeatNode{}
	cls.Ptr = ptr
	return cls
}

var xNewRepeatNode func(*graphene.Rect, uintptr, *graphene.Rect) uintptr

// Creates a `GskRenderNode` that will repeat the drawing of @child across
// the given @bounds.
func NewRepeatNode(BoundsVar *graphene.Rect, ChildVar *RenderNode, ChildBoundsVar *graphene.Rect) *RepeatNode {
	var cls *RepeatNode

	cret := xNewRepeatNode(BoundsVar, ChildVar.GoPointer(), ChildBoundsVar)

	if cret == 0 {
		return nil
	}
	cls = &RepeatNode{}
	cls.Ptr = cret
	return cls
}

var xRepeatNodeGetChild func(uintptr) uintptr

// Retrieves the child of @node.
func (x *RepeatNode) GetChild() *RenderNode {
	var cls *RenderNode

	cret := xRepeatNodeGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xRepeatNodeGetChildBounds func(uintptr) *graphene.Rect

// Retrieves the bounding rectangle of the child of @node.
func (x *RepeatNode) GetChildBounds() *graphene.Rect {

	cret := xRepeatNodeGetChildBounds(x.GoPointer())
	return cret
}

func (c *RepeatNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *RepeatNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node for a repeating linear gradient.
type RepeatingLinearGradientNode struct {
	RenderNode
}

var xRepeatingLinearGradientNodeGLibType func() types.GType

func RepeatingLinearGradientNodeGLibType() types.GType {
	return xRepeatingLinearGradientNodeGLibType()
}

func RepeatingLinearGradientNodeNewFromInternalPtr(ptr uintptr) *RepeatingLinearGradientNode {
	cls := &RepeatingLinearGradientNode{}
	cls.Ptr = ptr
	return cls
}

var xNewRepeatingLinearGradientNode func(*graphene.Rect, *graphene.Point, *graphene.Point, []ColorStop, uint) uintptr

// Creates a `GskRenderNode` that will create a repeating linear gradient
// from the given points and color stops, and render that into the area
// given by @bounds.
func NewRepeatingLinearGradientNode(BoundsVar *graphene.Rect, StartVar *graphene.Point, EndVar *graphene.Point, ColorStopsVar []ColorStop, NColorStopsVar uint) *RepeatingLinearGradientNode {
	var cls *RepeatingLinearGradientNode

	cret := xNewRepeatingLinearGradientNode(BoundsVar, StartVar, EndVar, ColorStopsVar, NColorStopsVar)

	if cret == 0 {
		return nil
	}
	cls = &RepeatingLinearGradientNode{}
	cls.Ptr = cret
	return cls
}

func (c *RepeatingLinearGradientNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *RepeatingLinearGradientNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node for a repeating radial gradient.
type RepeatingRadialGradientNode struct {
	RenderNode
}

var xRepeatingRadialGradientNodeGLibType func() types.GType

func RepeatingRadialGradientNodeGLibType() types.GType {
	return xRepeatingRadialGradientNodeGLibType()
}

func RepeatingRadialGradientNodeNewFromInternalPtr(ptr uintptr) *RepeatingRadialGradientNode {
	cls := &RepeatingRadialGradientNode{}
	cls.Ptr = ptr
	return cls
}

var xNewRepeatingRadialGradientNode func(*graphene.Rect, *graphene.Point, float32, float32, float32, float32, []ColorStop, uint) uintptr

// Creates a `GskRenderNode` that draws a repeating radial gradient.
//
// The radial gradient starts around @center. The size of the gradient
// is dictated by @hradius in horizontal orientation and by @vradius
// in vertial orientation.
func NewRepeatingRadialGradientNode(BoundsVar *graphene.Rect, CenterVar *graphene.Point, HradiusVar float32, VradiusVar float32, StartVar float32, EndVar float32, ColorStopsVar []ColorStop, NColorStopsVar uint) *RepeatingRadialGradientNode {
	var cls *RepeatingRadialGradientNode

	cret := xNewRepeatingRadialGradientNode(BoundsVar, CenterVar, HradiusVar, VradiusVar, StartVar, EndVar, ColorStopsVar, NColorStopsVar)

	if cret == 0 {
		return nil
	}
	cls = &RepeatingRadialGradientNode{}
	cls.Ptr = cret
	return cls
}

func (c *RepeatingRadialGradientNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *RepeatingRadialGradientNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node applying a rounded rectangle clip to its single child.
type RoundedClipNode struct {
	RenderNode
}

var xRoundedClipNodeGLibType func() types.GType

func RoundedClipNodeGLibType() types.GType {
	return xRoundedClipNodeGLibType()
}

func RoundedClipNodeNewFromInternalPtr(ptr uintptr) *RoundedClipNode {
	cls := &RoundedClipNode{}
	cls.Ptr = ptr
	return cls
}

var xNewRoundedClipNode func(uintptr, *RoundedRect) uintptr

// Creates a `GskRenderNode` that will clip the @child to the area
// given by @clip.
func NewRoundedClipNode(ChildVar *RenderNode, ClipVar *RoundedRect) *RoundedClipNode {
	var cls *RoundedClipNode

	cret := xNewRoundedClipNode(ChildVar.GoPointer(), ClipVar)

	if cret == 0 {
		return nil
	}
	cls = &RoundedClipNode{}
	cls.Ptr = cret
	return cls
}

var xRoundedClipNodeGetChild func(uintptr) uintptr

// Gets the child node that is getting clipped by the given @node.
func (x *RoundedClipNode) GetChild() *RenderNode {
	var cls *RenderNode

	cret := xRoundedClipNodeGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xRoundedClipNodeGetClip func(uintptr) *RoundedRect

// Retrieves the rounded rectangle used to clip the contents of the @node.
func (x *RoundedClipNode) GetClip() *RoundedRect {

	cret := xRoundedClipNodeGetClip(x.GoPointer())
	return cret
}

func (c *RoundedClipNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *RoundedClipNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node drawing one or more shadows behind its single child node.
type ShadowNode struct {
	RenderNode
}

var xShadowNodeGLibType func() types.GType

func ShadowNodeGLibType() types.GType {
	return xShadowNodeGLibType()
}

func ShadowNodeNewFromInternalPtr(ptr uintptr) *ShadowNode {
	cls := &ShadowNode{}
	cls.Ptr = ptr
	return cls
}

var xNewShadowNode func(uintptr, []Shadow, uint) uintptr

// Creates a `GskRenderNode` that will draw a @child with the given
// @shadows below it.
func NewShadowNode(ChildVar *RenderNode, ShadowsVar []Shadow, NShadowsVar uint) *ShadowNode {
	var cls *ShadowNode

	cret := xNewShadowNode(ChildVar.GoPointer(), ShadowsVar, NShadowsVar)

	if cret == 0 {
		return nil
	}
	cls = &ShadowNode{}
	cls.Ptr = cret
	return cls
}

var xShadowNodeGetChild func(uintptr) uintptr

// Retrieves the child `GskRenderNode` of the shadow @node.
func (x *ShadowNode) GetChild() *RenderNode {
	var cls *RenderNode

	cret := xShadowNodeGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xShadowNodeGetNShadows func(uintptr) uint

// Retrieves the number of shadows in the @node.
func (x *ShadowNode) GetNShadows() uint {

	cret := xShadowNodeGetNShadows(x.GoPointer())
	return cret
}

var xShadowNodeGetShadow func(uintptr, uint) *Shadow

// Retrieves the shadow data at the given index @i.
func (x *ShadowNode) GetShadow(IVar uint) *Shadow {

	cret := xShadowNodeGetShadow(x.GoPointer(), IVar)
	return cret
}

func (c *ShadowNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *ShadowNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node drawing a set of glyphs.
type TextNode struct {
	RenderNode
}

var xTextNodeGLibType func() types.GType

func TextNodeGLibType() types.GType {
	return xTextNodeGLibType()
}

func TextNodeNewFromInternalPtr(ptr uintptr) *TextNode {
	cls := &TextNode{}
	cls.Ptr = ptr
	return cls
}

var xNewTextNode func(uintptr, *pango.GlyphString, *gdk.RGBA, *graphene.Point) uintptr

// Creates a render node that renders the given glyphs.
//
// Note that @color may not be used if the font contains
// color glyphs.
func NewTextNode(FontVar *pango.Font, GlyphsVar *pango.GlyphString, ColorVar *gdk.RGBA, OffsetVar *graphene.Point) *TextNode {
	var cls *TextNode

	cret := xNewTextNode(FontVar.GoPointer(), GlyphsVar, ColorVar, OffsetVar)

	if cret == 0 {
		return nil
	}
	cls = &TextNode{}
	cls.Ptr = cret
	return cls
}

var xTextNodeGetColor func(uintptr) *gdk.RGBA

// Retrieves the color used by the text @node.
func (x *TextNode) GetColor() *gdk.RGBA {

	cret := xTextNodeGetColor(x.GoPointer())
	return cret
}

var xTextNodeGetFont func(uintptr) uintptr

// Returns the font used by the text @node.
func (x *TextNode) GetFont() *pango.Font {
	var cls *pango.Font

	cret := xTextNodeGetFont(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &pango.Font{}
	cls.Ptr = cret
	return cls
}

var xTextNodeGetGlyphs func(uintptr, uint) []pango.GlyphInfo

// Retrieves the glyph information in the @node.
func (x *TextNode) GetGlyphs(NGlyphsVar uint) []pango.GlyphInfo {

	cret := xTextNodeGetGlyphs(x.GoPointer(), NGlyphsVar)
	return cret
}

var xTextNodeGetNumGlyphs func(uintptr) uint

// Retrieves the number of glyphs in the text node.
func (x *TextNode) GetNumGlyphs() uint {

	cret := xTextNodeGetNumGlyphs(x.GoPointer())
	return cret
}

var xTextNodeGetOffset func(uintptr) *graphene.Point

// Retrieves the offset applied to the text.
func (x *TextNode) GetOffset() *graphene.Point {

	cret := xTextNodeGetOffset(x.GoPointer())
	return cret
}

var xTextNodeHasColorGlyphs func(uintptr) bool

// Checks whether the text @node has color glyphs.
func (x *TextNode) HasColorGlyphs() bool {

	cret := xTextNodeHasColorGlyphs(x.GoPointer())
	return cret
}

func (c *TextNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *TextNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node for a `GdkTexture`.
type TextureNode struct {
	RenderNode
}

var xTextureNodeGLibType func() types.GType

func TextureNodeGLibType() types.GType {
	return xTextureNodeGLibType()
}

func TextureNodeNewFromInternalPtr(ptr uintptr) *TextureNode {
	cls := &TextureNode{}
	cls.Ptr = ptr
	return cls
}

var xNewTextureNode func(uintptr, *graphene.Rect) uintptr

// Creates a `GskRenderNode` that will render the given
// @texture into the area given by @bounds.
func NewTextureNode(TextureVar *gdk.Texture, BoundsVar *graphene.Rect) *TextureNode {
	var cls *TextureNode

	cret := xNewTextureNode(TextureVar.GoPointer(), BoundsVar)

	if cret == 0 {
		return nil
	}
	cls = &TextureNode{}
	cls.Ptr = cret
	return cls
}

var xTextureNodeGetTexture func(uintptr) uintptr

// Retrieves the `GdkTexture` used when creating this `GskRenderNode`.
func (x *TextureNode) GetTexture() *gdk.Texture {
	var cls *gdk.Texture

	cret := xTextureNodeGetTexture(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Texture{}
	cls.Ptr = cret
	return cls
}

func (c *TextureNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *TextureNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A render node applying a `GskTransform` to its single child node.
type TransformNode struct {
	RenderNode
}

var xTransformNodeGLibType func() types.GType

func TransformNodeGLibType() types.GType {
	return xTransformNodeGLibType()
}

func TransformNodeNewFromInternalPtr(ptr uintptr) *TransformNode {
	cls := &TransformNode{}
	cls.Ptr = ptr
	return cls
}

var xNewTransformNode func(uintptr, *Transform) uintptr

// Creates a `GskRenderNode` that will transform the given @child
// with the given @transform.
func NewTransformNode(ChildVar *RenderNode, TransformVar *Transform) *TransformNode {
	var cls *TransformNode

	cret := xNewTransformNode(ChildVar.GoPointer(), TransformVar)

	if cret == 0 {
		return nil
	}
	cls = &TransformNode{}
	cls.Ptr = cret
	return cls
}

var xTransformNodeGetChild func(uintptr) uintptr

// Gets the child node that is getting transformed by the given @node.
func (x *TransformNode) GetChild() *RenderNode {
	var cls *RenderNode

	cret := xTransformNodeGetChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &RenderNode{}
	cls.Ptr = cret
	return cls
}

var xTransformNodeGetTransform func(uintptr) *Transform

// Retrieves the `GskTransform` used by the @node.
func (x *TransformNode) GetTransform() *Transform {

	cret := xTransformNodeGetTransform(x.GoPointer())
	return cret
}

func (c *TransformNode) GoPointer() uintptr {
	return c.Ptr
}

func (c *TransformNode) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GSK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xBlendNodeGLibType, lib, "gsk_blend_node_get_type")

	core.PuregoSafeRegister(&xNewBlendNode, lib, "gsk_blend_node_new")

	core.PuregoSafeRegister(&xBlendNodeGetBlendMode, lib, "gsk_blend_node_get_blend_mode")
	core.PuregoSafeRegister(&xBlendNodeGetBottomChild, lib, "gsk_blend_node_get_bottom_child")
	core.PuregoSafeRegister(&xBlendNodeGetTopChild, lib, "gsk_blend_node_get_top_child")

	core.PuregoSafeRegister(&xBlurNodeGLibType, lib, "gsk_blur_node_get_type")

	core.PuregoSafeRegister(&xNewBlurNode, lib, "gsk_blur_node_new")

	core.PuregoSafeRegister(&xBlurNodeGetChild, lib, "gsk_blur_node_get_child")
	core.PuregoSafeRegister(&xBlurNodeGetRadius, lib, "gsk_blur_node_get_radius")

	core.PuregoSafeRegister(&xBorderNodeGLibType, lib, "gsk_border_node_get_type")

	core.PuregoSafeRegister(&xNewBorderNode, lib, "gsk_border_node_new")

	core.PuregoSafeRegister(&xBorderNodeGetColors, lib, "gsk_border_node_get_colors")
	core.PuregoSafeRegister(&xBorderNodeGetOutline, lib, "gsk_border_node_get_outline")
	core.PuregoSafeRegister(&xBorderNodeGetWidths, lib, "gsk_border_node_get_widths")

	core.PuregoSafeRegister(&xCairoNodeGLibType, lib, "gsk_cairo_node_get_type")

	core.PuregoSafeRegister(&xNewCairoNode, lib, "gsk_cairo_node_new")

	core.PuregoSafeRegister(&xCairoNodeGetDrawContext, lib, "gsk_cairo_node_get_draw_context")
	core.PuregoSafeRegister(&xCairoNodeGetSurface, lib, "gsk_cairo_node_get_surface")

	core.PuregoSafeRegister(&xClipNodeGLibType, lib, "gsk_clip_node_get_type")

	core.PuregoSafeRegister(&xNewClipNode, lib, "gsk_clip_node_new")

	core.PuregoSafeRegister(&xClipNodeGetChild, lib, "gsk_clip_node_get_child")
	core.PuregoSafeRegister(&xClipNodeGetClip, lib, "gsk_clip_node_get_clip")

	core.PuregoSafeRegister(&xColorMatrixNodeGLibType, lib, "gsk_color_matrix_node_get_type")

	core.PuregoSafeRegister(&xNewColorMatrixNode, lib, "gsk_color_matrix_node_new")

	core.PuregoSafeRegister(&xColorMatrixNodeGetChild, lib, "gsk_color_matrix_node_get_child")
	core.PuregoSafeRegister(&xColorMatrixNodeGetColorMatrix, lib, "gsk_color_matrix_node_get_color_matrix")
	core.PuregoSafeRegister(&xColorMatrixNodeGetColorOffset, lib, "gsk_color_matrix_node_get_color_offset")

	core.PuregoSafeRegister(&xColorNodeGLibType, lib, "gsk_color_node_get_type")

	core.PuregoSafeRegister(&xNewColorNode, lib, "gsk_color_node_new")

	core.PuregoSafeRegister(&xColorNodeGetColor, lib, "gsk_color_node_get_color")

	core.PuregoSafeRegister(&xConicGradientNodeGLibType, lib, "gsk_conic_gradient_node_get_type")

	core.PuregoSafeRegister(&xNewConicGradientNode, lib, "gsk_conic_gradient_node_new")

	core.PuregoSafeRegister(&xConicGradientNodeGetAngle, lib, "gsk_conic_gradient_node_get_angle")
	core.PuregoSafeRegister(&xConicGradientNodeGetCenter, lib, "gsk_conic_gradient_node_get_center")
	core.PuregoSafeRegister(&xConicGradientNodeGetColorStops, lib, "gsk_conic_gradient_node_get_color_stops")
	core.PuregoSafeRegister(&xConicGradientNodeGetNColorStops, lib, "gsk_conic_gradient_node_get_n_color_stops")
	core.PuregoSafeRegister(&xConicGradientNodeGetRotation, lib, "gsk_conic_gradient_node_get_rotation")

	core.PuregoSafeRegister(&xContainerNodeGLibType, lib, "gsk_container_node_get_type")

	core.PuregoSafeRegister(&xNewContainerNode, lib, "gsk_container_node_new")

	core.PuregoSafeRegister(&xContainerNodeGetChild, lib, "gsk_container_node_get_child")
	core.PuregoSafeRegister(&xContainerNodeGetNChildren, lib, "gsk_container_node_get_n_children")

	core.PuregoSafeRegister(&xCrossFadeNodeGLibType, lib, "gsk_cross_fade_node_get_type")

	core.PuregoSafeRegister(&xNewCrossFadeNode, lib, "gsk_cross_fade_node_new")

	core.PuregoSafeRegister(&xCrossFadeNodeGetEndChild, lib, "gsk_cross_fade_node_get_end_child")
	core.PuregoSafeRegister(&xCrossFadeNodeGetProgress, lib, "gsk_cross_fade_node_get_progress")
	core.PuregoSafeRegister(&xCrossFadeNodeGetStartChild, lib, "gsk_cross_fade_node_get_start_child")

	core.PuregoSafeRegister(&xDebugNodeGLibType, lib, "gsk_debug_node_get_type")

	core.PuregoSafeRegister(&xNewDebugNode, lib, "gsk_debug_node_new")

	core.PuregoSafeRegister(&xDebugNodeGetChild, lib, "gsk_debug_node_get_child")
	core.PuregoSafeRegister(&xDebugNodeGetMessage, lib, "gsk_debug_node_get_message")

	core.PuregoSafeRegister(&xGLShaderNodeGLibType, lib, "gsk_gl_shader_node_get_type")

	core.PuregoSafeRegister(&xNewGLShaderNode, lib, "gsk_gl_shader_node_new")

	core.PuregoSafeRegister(&xGLShaderNodeGetArgs, lib, "gsk_gl_shader_node_get_args")
	core.PuregoSafeRegister(&xGLShaderNodeGetChild, lib, "gsk_gl_shader_node_get_child")
	core.PuregoSafeRegister(&xGLShaderNodeGetNChildren, lib, "gsk_gl_shader_node_get_n_children")
	core.PuregoSafeRegister(&xGLShaderNodeGetShader, lib, "gsk_gl_shader_node_get_shader")

	core.PuregoSafeRegister(&xInsetShadowNodeGLibType, lib, "gsk_inset_shadow_node_get_type")

	core.PuregoSafeRegister(&xNewInsetShadowNode, lib, "gsk_inset_shadow_node_new")

	core.PuregoSafeRegister(&xInsetShadowNodeGetBlurRadius, lib, "gsk_inset_shadow_node_get_blur_radius")
	core.PuregoSafeRegister(&xInsetShadowNodeGetColor, lib, "gsk_inset_shadow_node_get_color")
	core.PuregoSafeRegister(&xInsetShadowNodeGetDx, lib, "gsk_inset_shadow_node_get_dx")
	core.PuregoSafeRegister(&xInsetShadowNodeGetDy, lib, "gsk_inset_shadow_node_get_dy")
	core.PuregoSafeRegister(&xInsetShadowNodeGetOutline, lib, "gsk_inset_shadow_node_get_outline")
	core.PuregoSafeRegister(&xInsetShadowNodeGetSpread, lib, "gsk_inset_shadow_node_get_spread")

	core.PuregoSafeRegister(&xLinearGradientNodeGLibType, lib, "gsk_linear_gradient_node_get_type")

	core.PuregoSafeRegister(&xNewLinearGradientNode, lib, "gsk_linear_gradient_node_new")

	core.PuregoSafeRegister(&xLinearGradientNodeGetColorStops, lib, "gsk_linear_gradient_node_get_color_stops")
	core.PuregoSafeRegister(&xLinearGradientNodeGetEnd, lib, "gsk_linear_gradient_node_get_end")
	core.PuregoSafeRegister(&xLinearGradientNodeGetNColorStops, lib, "gsk_linear_gradient_node_get_n_color_stops")
	core.PuregoSafeRegister(&xLinearGradientNodeGetStart, lib, "gsk_linear_gradient_node_get_start")

	core.PuregoSafeRegister(&xOpacityNodeGLibType, lib, "gsk_opacity_node_get_type")

	core.PuregoSafeRegister(&xNewOpacityNode, lib, "gsk_opacity_node_new")

	core.PuregoSafeRegister(&xOpacityNodeGetChild, lib, "gsk_opacity_node_get_child")
	core.PuregoSafeRegister(&xOpacityNodeGetOpacity, lib, "gsk_opacity_node_get_opacity")

	core.PuregoSafeRegister(&xOutsetShadowNodeGLibType, lib, "gsk_outset_shadow_node_get_type")

	core.PuregoSafeRegister(&xNewOutsetShadowNode, lib, "gsk_outset_shadow_node_new")

	core.PuregoSafeRegister(&xOutsetShadowNodeGetBlurRadius, lib, "gsk_outset_shadow_node_get_blur_radius")
	core.PuregoSafeRegister(&xOutsetShadowNodeGetColor, lib, "gsk_outset_shadow_node_get_color")
	core.PuregoSafeRegister(&xOutsetShadowNodeGetDx, lib, "gsk_outset_shadow_node_get_dx")
	core.PuregoSafeRegister(&xOutsetShadowNodeGetDy, lib, "gsk_outset_shadow_node_get_dy")
	core.PuregoSafeRegister(&xOutsetShadowNodeGetOutline, lib, "gsk_outset_shadow_node_get_outline")
	core.PuregoSafeRegister(&xOutsetShadowNodeGetSpread, lib, "gsk_outset_shadow_node_get_spread")

	core.PuregoSafeRegister(&xRadialGradientNodeGLibType, lib, "gsk_radial_gradient_node_get_type")

	core.PuregoSafeRegister(&xNewRadialGradientNode, lib, "gsk_radial_gradient_node_new")

	core.PuregoSafeRegister(&xRadialGradientNodeGetCenter, lib, "gsk_radial_gradient_node_get_center")
	core.PuregoSafeRegister(&xRadialGradientNodeGetColorStops, lib, "gsk_radial_gradient_node_get_color_stops")
	core.PuregoSafeRegister(&xRadialGradientNodeGetEnd, lib, "gsk_radial_gradient_node_get_end")
	core.PuregoSafeRegister(&xRadialGradientNodeGetHradius, lib, "gsk_radial_gradient_node_get_hradius")
	core.PuregoSafeRegister(&xRadialGradientNodeGetNColorStops, lib, "gsk_radial_gradient_node_get_n_color_stops")
	core.PuregoSafeRegister(&xRadialGradientNodeGetStart, lib, "gsk_radial_gradient_node_get_start")
	core.PuregoSafeRegister(&xRadialGradientNodeGetVradius, lib, "gsk_radial_gradient_node_get_vradius")

	core.PuregoSafeRegister(&xRepeatNodeGLibType, lib, "gsk_repeat_node_get_type")

	core.PuregoSafeRegister(&xNewRepeatNode, lib, "gsk_repeat_node_new")

	core.PuregoSafeRegister(&xRepeatNodeGetChild, lib, "gsk_repeat_node_get_child")
	core.PuregoSafeRegister(&xRepeatNodeGetChildBounds, lib, "gsk_repeat_node_get_child_bounds")

	core.PuregoSafeRegister(&xRepeatingLinearGradientNodeGLibType, lib, "gsk_repeating_linear_gradient_node_get_type")

	core.PuregoSafeRegister(&xNewRepeatingLinearGradientNode, lib, "gsk_repeating_linear_gradient_node_new")

	core.PuregoSafeRegister(&xRepeatingRadialGradientNodeGLibType, lib, "gsk_repeating_radial_gradient_node_get_type")

	core.PuregoSafeRegister(&xNewRepeatingRadialGradientNode, lib, "gsk_repeating_radial_gradient_node_new")

	core.PuregoSafeRegister(&xRoundedClipNodeGLibType, lib, "gsk_rounded_clip_node_get_type")

	core.PuregoSafeRegister(&xNewRoundedClipNode, lib, "gsk_rounded_clip_node_new")

	core.PuregoSafeRegister(&xRoundedClipNodeGetChild, lib, "gsk_rounded_clip_node_get_child")
	core.PuregoSafeRegister(&xRoundedClipNodeGetClip, lib, "gsk_rounded_clip_node_get_clip")

	core.PuregoSafeRegister(&xShadowNodeGLibType, lib, "gsk_shadow_node_get_type")

	core.PuregoSafeRegister(&xNewShadowNode, lib, "gsk_shadow_node_new")

	core.PuregoSafeRegister(&xShadowNodeGetChild, lib, "gsk_shadow_node_get_child")
	core.PuregoSafeRegister(&xShadowNodeGetNShadows, lib, "gsk_shadow_node_get_n_shadows")
	core.PuregoSafeRegister(&xShadowNodeGetShadow, lib, "gsk_shadow_node_get_shadow")

	core.PuregoSafeRegister(&xTextNodeGLibType, lib, "gsk_text_node_get_type")

	core.PuregoSafeRegister(&xNewTextNode, lib, "gsk_text_node_new")

	core.PuregoSafeRegister(&xTextNodeGetColor, lib, "gsk_text_node_get_color")
	core.PuregoSafeRegister(&xTextNodeGetFont, lib, "gsk_text_node_get_font")
	core.PuregoSafeRegister(&xTextNodeGetGlyphs, lib, "gsk_text_node_get_glyphs")
	core.PuregoSafeRegister(&xTextNodeGetNumGlyphs, lib, "gsk_text_node_get_num_glyphs")
	core.PuregoSafeRegister(&xTextNodeGetOffset, lib, "gsk_text_node_get_offset")
	core.PuregoSafeRegister(&xTextNodeHasColorGlyphs, lib, "gsk_text_node_has_color_glyphs")

	core.PuregoSafeRegister(&xTextureNodeGLibType, lib, "gsk_texture_node_get_type")

	core.PuregoSafeRegister(&xNewTextureNode, lib, "gsk_texture_node_new")

	core.PuregoSafeRegister(&xTextureNodeGetTexture, lib, "gsk_texture_node_get_texture")

	core.PuregoSafeRegister(&xTransformNodeGLibType, lib, "gsk_transform_node_get_type")

	core.PuregoSafeRegister(&xNewTransformNode, lib, "gsk_transform_node_new")

	core.PuregoSafeRegister(&xTransformNodeGetChild, lib, "gsk_transform_node_get_child")
	core.PuregoSafeRegister(&xTransformNodeGetTransform, lib, "gsk_transform_node_get_transform")

}
